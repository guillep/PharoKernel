Class	name: #SubscriptionRegistry;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#subscriptions #monitor );	classVariables: #();	package: #'Announcements-Core'.Class SubscriptionRegistry >> reset[	"subscriber -> subscriptions"subscriptions := IdentitySet new]Class SubscriptionRegistry >> numberOfSubscriptions[^ subscriptions size]Class SubscriptionRegistry >> deliver: anAnnouncement to: subs[^ self deliver: anAnnouncement to: subs startingAt: 1]Class SubscriptionRegistry >> protected: aBlock[^ monitor critical: [ aBlock value ]]Class SubscriptionRegistry >> add: subscription[^ self protected: [ subscriptions add: subscription ]]Class SubscriptionRegistry >> deliver: anAnnouncement[| interestedSubscriptions |"using a copy, so subscribers can unsubscribe from announcer "subscriptions isEmpty	ifTrue: [ ^ self ].self protected: [ interestedSubscriptions := self subscriptionsHandling: anAnnouncement ].self deliver: anAnnouncement to: interestedSubscriptions]Class SubscriptionRegistry >> removeSubscriber: subscriber[^ self protected: [ subscriptions removeAllSuchThat: [ :subscription | subscription subscriber == subscriber ] ]]Class SubscriptionRegistry >> subscriptionsOf: aSubscriber do: aBlock[| copy |self protected: [ copy := subscriptions copy ].copy	do: [ :subscription | 		subscription subscriber == aSubscriber			ifTrue: [ aBlock value: subscription ] ]]Class SubscriptionRegistry >> initialize[monitor := Semaphore forMutualExclusion.self reset]Class SubscriptionRegistry >> deliver: anAnnouncement to: subs startingAt: startIndex[startIndex to: subs size do: [ :index | 	| subscription |	subscription := subs at: index.	[ subscription deliver: anAnnouncement ]		ifCurtailed: [ self deliver: anAnnouncement to: subs startingAt: index + 1 ]	"Ensure delivery to remaining announcements" ]]Class SubscriptionRegistry >> remove: subscription[^ self protected: [ subscriptions remove: subscription ifAbsent: nil ]]Class SubscriptionRegistry >> replace: subscription with: newOne[	" Note that it will signal an error if subscription is not there "self	protected: [ 		subscriptions remove: subscription.		subscriptions add: newOne ].^ newOne]Class SubscriptionRegistry >> subscriptionsHandling: anAnnouncement[^ Array	streamContents: [ :s | 		subscriptions			do: [ :each | 				(each handles: anAnnouncement class)					ifTrue: [ s nextPut: each ] ] ]]Metaclass	name: #SubscriptionRegistry;	instanceVariables: #().