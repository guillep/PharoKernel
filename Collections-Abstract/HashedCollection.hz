Class	name: #HashedCollection;	superclass: #ClassCollection;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#tally #array );	classVariables: #();	package: #'Collections-Abstract'.Class HashedCollection >> fixCollisionsFrom: start[	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."self subclassResponsibility]Class HashedCollection >> fullCheck[	"Keep array at least 1/4 free for decent hash behavior"array size - tally < (array size // 4 max: 1)	ifTrue: [ self grow ]]Class HashedCollection >> atNewIndex: index put: anObject[array at: index put: anObject.tally := tally + 1.self fullCheck]Class HashedCollection >> rehash[self growTo: self capacity]Class HashedCollection >> removeAll[	"remove all elements from this collection.	Preserve the capacity"self initialize: self capacity]Class HashedCollection >> errorNoFreeSpace[self error: 'There is no free space in this collection!']Class HashedCollection >> capacity[	"Answer the current capacity of the receiver."^ array size]Class HashedCollection >> grow[	"Grow the elements array and reinsert the old elements"| oldElements |oldElements := array.array := Array new: (HashTableSizes atLeast: oldElements size * 2).tally := 0.oldElements	do: [ :each | 		each == nil			ifFalse: [ self noCheckAdd: each ] ]]Class HashedCollection >> noCheckNoGrowFillFrom: anArray[	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."self subclassResponsibility]Class HashedCollection >> scanFor: anObject[	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."self subclassResponsibility]Class HashedCollection >> growTo: anInteger[	"Grow the elements array and reinsert the old elements"| oldElements |oldElements := array.array := Array new: anInteger.self noCheckNoGrowFillFrom: oldElements]Class HashedCollection >> growSize[	"Answer what my next higher table size should be"^ HashTableSizes atLeast: self capacity * 3 // 2 + 2]Class HashedCollection >> someElement[	"Deprecated. Use anyOne."^ self anyOne]Class HashedCollection >> hasContentsInExplorer[^ self notEmpty]Class HashedCollection >> compact[	"Reduce the size of array so that the load factor will be ~75%."| newCapacity |newCapacity := HashTableSizes atLeast: tally * 4 // 3.self growTo: newCapacity]Class HashedCollection >> findElementOrNil: anObject[	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."| index |index := self scanFor: anObject.index > 0	ifTrue: [ ^ index ].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."self error: 'There is no free space in this set!']Class HashedCollection >> size[^ tally]Class HashedCollection >> array[^ array]Class HashedCollection >> doWithIndex: aBlock2[	"Support Set enumeration with a counter, even though not ordered"| index |index := 0.self do: [ :item | aBlock2 value: item value: (index := index + 1) ]]Class HashedCollection >> initialize: n[	"Initialize array to an array size of n"array := Array new: n.tally := 0]Class HashedCollection >> copyEmpty[	"Answer an empty copy of this collection"	"Note: this code could be moved to super"^ self species new]Class HashedCollection >> add: newObject withOccurrences: anInteger[	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."anInteger < 1	ifTrue: [ ^ newObject ].	"I can only store an object once."^ self add: newObject]Class HashedCollection >> scanForEmptySlotFor: aKey[	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."| index start |index := start := aKey hash \\ array size + 1.[ (array at: index) ifNil: [ ^ index ].(index := index \\ array size + 1) = start ] whileFalse.self errorNoFreeSpace]Metaclass	name: #HashedCollection;	instanceVariables: #().Metaclass HashedCollection >> cleanUp: aggressive[	"Rehash all instances when cleaning aggressively"aggressive	ifTrue: [ self compactAll ]]Metaclass HashedCollection >> rehashAllInstances[	"Do not use #allInstancesDo: because rehash may create new instances."self allInstances do: [ :each | each rehash ]]Metaclass HashedCollection >> new[^ self basicNew initialize: 5]Metaclass HashedCollection >> newFrom: aCollection[	"Answer an instance of me containing the same elements as aCollection."^ self subclassResponsibility]Metaclass HashedCollection >> new: nElements[	"Create a Set large enough to hold nElements without growing"^ self basicNew initialize: (self sizeFor: nElements)]Metaclass HashedCollection >> sizeFor: nElements[	"Large enough size to hold nElements with some slop (see fullCheck)"nElements < 4	ifTrue: [ ^ 5 ].^ HashTableSizes atLeast: (nElements + 1) * 4 // 3]Metaclass HashedCollection >> rehashAll[	"HashedCollection rehashAll"self allSubclassesDo: #rehashAllInstances]Metaclass HashedCollection >> compactAll[	"HashedCollection rehashAll"self allSubclassesDo: #compactAllInstances]Metaclass HashedCollection >> compactAllInstances[	"Do not use #allInstancesDo: because rehash may create new instances."self allInstances do: [ :each | each compact ]]