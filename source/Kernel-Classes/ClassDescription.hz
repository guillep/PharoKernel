ClassDescription
	superclass: #Behavior;
	traitComposition: #TClassAndTraitDescription - {#removeSelector:};
	instanceVariables: #(#instanceVariables #organization );
	package: #'Kernel-Classes'.

ClassDescription >> acceptsLoggingOfCompilation
[
	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself.
	weird name is so that it will come lexically before #compile, so that a clean build can make it through."

	^ true
]

ClassDescription >> addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor
[
	| priorMethodOrNil oldProtocol newProtocol |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [ nil ].
	self addSelectorSilently: selector withMethod: compiledMethod.
	oldProtocol := self organization categoryOfElement: selector.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ self organization classify: selector under: category ].
	newProtocol := self organization categoryOfElement: selector.
	priorMethodOrNil isNil
		ifTrue: [ SystemAnnouncer uniqueInstance
				methodAdded: compiledMethod
				selector: selector
				inProtocol: category
				class: self
				requestor: requestor ]
		ifFalse: [ "If protocol changed and someone is from different package, I need to throw a method recategorized"
			newProtocol = oldProtocol
				ifFalse: [ | oldPackage newPackage |
					"Check for repackage"
					newPackage := RPackage organizer packageForProtocol: newProtocol inClass: self.
					oldPackage := RPackage organizer packageForProtocol: oldProtocol inClass: self.
					newPackage = oldPackage
						ifFalse: [ SystemAnnouncer uniqueInstance methodRepackaged: compiledMethod from: oldPackage to: newPackage ].	"Announce recategorization"
					SystemAnnouncer uniqueInstance
						selector: selector
						recategorizedFrom: oldProtocol
						to: newProtocol
						inClass: self ].
			SystemAnnouncer uniqueInstance
				methodChangedFrom: priorMethodOrNil
				to: compiledMethod
				selector: selector
				inClass: self
				oldProtocol: oldProtocol
				newProtocol: newProtocol
				requestor: requestor ]
]

ClassDescription >> addAuthorsTo: result
[
	"private method that  to store the result in the argument."

	self methodsDo: [ :each | result add: each author ]
]

ClassDescription >> addInstVarNamed: aString
[
	"Add the argument, aString, as one of the receiver's instance variables."

	self subclassResponsibility
]

ClassDescription >> allInstVarNamesEverywhere
[
	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"

	| aList |
	aList := OrderedCollection new.
	self allSuperclasses , self withAllSubclasses asOrderedCollection do: [ :cls | aList addAll: cls instVarNames ].
	^ aList asSet	"BorderedMorph allInstVarNamesEverywhere"
]

ClassDescription >> allMethodCategoriesIntegratedThrough: mostGenericClass
[
	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"

	| otherClassCategories thisClassCategories lowercaseSortBlock combinedClassCategories |
	otherClassCategories := OrderedCollection new.
	lowercaseSortBlock := [ :a :b | a asLowercase <= b asLowercase ].
	(self allSuperclassesIncluding: mostGenericClass)
		do: [ :aClass | otherClassCategories addAll: aClass organization categories ].
	otherClassCategories remove: 'no messages' ifAbsent: [  ].
	thisClassCategories := self organization categories sorted: lowercaseSortBlock.
	^ thisClassCategories
		,
			((otherClassCategories asSet removeAllSuchThat: [ :each | thisClassCategories includes: each ])
				sorted: lowercaseSortBlock)
]

ClassDescription >> allMethodsInCategory: aName
[
	"Answer a list of all the methods of the receiver and all its 
	superclasses that are in the category named aName"

	| aColl |
	aColl := OrderedCollection new.
	self withAllSuperclasses
		do: [ :aClass | aColl
				addAll:
					(aName = ClassOrganizer allCategory
						ifTrue: [ aClass organization allMethodSelectors ]
						ifFalse: [ aClass organization listAtCategoryNamed: aName ]) ].
	^ aColl asSet asArray sort
]

ClassDescription >> allSharedPools
[
	"Answer an ordered collection  of the shared pools the receiver shares, including those defined  in the superclasses of the receiver."

	^ OrderedCollection new
]

ClassDescription >> authors
[
	"Returns a bag representing the author frequency based on the latest version of the methods of the receiver."

	"self new authorsgather: Date"

	| br result selectors |
	result := Bag new.
	self addAuthorsTo: result.
	self class addAuthorsTo: result.
	^ result
]

ClassDescription >> checkForInstVarsOK: instVarString
[
	"Return true if instVarString does no include any names used in a subclass"

	| instVarArray |
	instVarArray := instVarString subStrings: ' '.
	self allSubclasses
		do: [ :cl | cl instVarNames
				do: [ :n | (instVarArray includes: n)
						ifTrue: [ self error: n , ' is already used in ' , cl name.
							^ false ] ] ].
	^ true
]

ClassDescription >> classCommentBlank
[
	| existingComment stream |
	existingComment := self theNonMetaClass organization classComment.
	existingComment isEmpty
		ifFalse: [ ^ existingComment ].
	stream := (String new: 100) writeStream.
	stream
		nextPutAll: 'A';
		nextPutAll: (self name first isVowel
						ifTrue: [ 'n ' ]
						ifFalse: [ ' ' ]);
		nextPutAll: self name;
		nextPutAll: ' is xxxxxxxxx.';
		cr;
		cr;
		nextPutAll: 'Instance Variables'.
	self instVarNames asSortedCollection
		do: [ :each | stream
				cr;
				tab;
				nextPutAll: each;
				nextPut: $:;
				tab;
				tab;
				nextPutAll: '<Object>' ].
	stream cr.
	self instVarNames asSortedCollection
		do: [ :each | stream
				cr;
				nextPutAll: each;
				cr;
				tab;
				nextPutAll: '- xxxxx';
				cr ].
	^ stream contents
]

ClassDescription >> classSide
[
	^ self theMetaClass
]

ClassDescription >> classThatDefinesClassVariable: classVarName
[
	"Answer the class that defines the given class variable"

	(self classPool includesKey: classVarName asSymbol)
		ifTrue: [ ^ self ].
	^ self superclass ifNotNil: [ self superclass classThatDefinesClassVariable: classVarName ]
]

ClassDescription >> classThatDefinesInstanceVariable: instVarName
[
	(self instVarNames notNil and: [ self instVarNames includes: instVarName asString ])
		ifTrue: [ ^ self ].
	^ self superclass ifNotNil: [ self superclass classThatDefinesInstanceVariable: instVarName ]
]

ClassDescription >> classVariablesString
[
	"Answer a string of my class variable names separated by spaces."

	^ String
		streamContents: [ :stream | self classVarNames do: [ :each | stream nextPutAll: each ] separatedBy: [ stream space ] ]
]

ClassDescription >> classVersion
[
	"Default.  Any class may return a later version to inform readers that use ReferenceStream. 
	This method allows you to distinguish between class versions when the shape of the class 
	hasn't changed (when there's no change in the instVar names).
	In the conversion methods you usually can tell by the inst var names 
	what old version you have. In a few cases, though, the same inst var 
	names were kept but their interpretation changed (like in the layoutFrame).
	By changing the class version when you keep the same instVars you can 
	warn older and newer images that they have to convert."

	^ 0
]

ClassDescription >> classesThatImplementAllOf: selectorSet
[
	"Return an array of any classes that implement all the messages in selectorSet."

	| found remaining |
	found := OrderedCollection new.
	selectorSet do: [ :sel | (self methodDict includesKey: sel)
				ifTrue: [ found add: sel ] ].
	found isEmpty
		ifTrue: [ ^ self subclasses
				inject: Array new
				into: [ :subsThatDo :sub | subsThatDo , (sub classesThatImplementAllOf: selectorSet) ] ]
		ifFalse: [ remaining := selectorSet copyWithoutAll: found.
			remaining isEmpty
				ifTrue: [ ^ Array with: self ].
			^ self subclasses
				inject: Array new
				into: [ :subsThatDo :sub | subsThatDo , (sub classesThatImplementAllOf: remaining) ] ]
]

ClassDescription >> commentInventory
[
	"Answer a string with a count of the classes with and without comments 
	for all the classes in the package of which this class is a member."

	"Morph commentInventory"

	^ self environment organization commentInventory: (self category copyUpTo: $-) , '*'
]

ClassDescription >> compile: text classified: category notifying: requestor
[
	| stamp |
	stamp := self acceptsLoggingOfCompilation
		ifTrue: [ Author changeStamp ]
		ifFalse: [ nil ].
	^ self
		compile: text
		classified: category
		withStamp: stamp
		notifying: requestor
]

ClassDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor
[
	^ self
		compile: text
		classified: category
		withStamp: changeStamp
		notifying: requestor
		logSource: self acceptsLoggingOfCompilation
]

ClassDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
	| methodAndNode |
	methodAndNode := self
		compile: text asString
		classified: category
		notifying: requestor
		trailer: self defaultMethodTrailer
		ifFail: [ ^ nil ].
	logSource
		ifTrue: [ self
				logMethodSource: methodAndNode node sourceCode
				forMethodWithNode: methodAndNode
				inCategory: category
				withStamp: changeStamp
				notifying: requestor ].
	self
		addAndClassifySelector: methodAndNode selector
		withMethod: methodAndNode method
		inProtocol: category
		notifying: requestor.
	self instanceSide noteCompilationOf: methodAndNode selector meta: self isClassSide.
	^ methodAndNode selector
]

ClassDescription >> definition
[
	"Answer a String that defines the receiver."

	| aStream |
	aStream := (String new: 800) writeStream.
	superclass == nil
		ifTrue: [ aStream nextPutAll: 'ProtoObject' ]
		ifFalse: [ aStream nextPutAll: superclass name ].
	aStream
		nextPutAll: self kindOfSubclass;
		store: self name.
	self hasTraitComposition
		ifTrue: [ aStream
				cr;
				tab;
				nextPutAll: 'uses: ';
				nextPutAll: self traitCompositionString ].
	aStream
		cr;
		tab;
		nextPutAll: 'instanceVariableNames: ';
		store: self instanceVariablesString.
	aStream
		cr;
		tab;
		nextPutAll: 'classVariableNames: ';
		store: self classVariablesString.
	aStream
		cr;
		tab;
		nextPutAll: 'poolDictionaries: ';
		store: self sharedPoolsString.
	aStream
		cr;
		tab;
		nextPutAll: 'category: ';
		store: self category asString.
	superclass
		ifNil: [ aStream
				nextPutAll: '.';
				cr.
			aStream nextPutAll: self name.
			aStream
				space;
				nextPutAll: 'superclass: nil' ].
	^ aStream contents
]

ClassDescription >> fileOutCategory: catName
[
	| internalStream |
	internalStream := (String new: 1000) writeStream.
	internalStream
		header;
		timeStamp.
	self
		fileOutCategory: catName
		on: internalStream
		moveSource: false
		toFile: 0.
	internalStream trailer.
	^ FileStream writeSourceCodeFrom: internalStream baseName: self name , '-' , catName isSt: true
]

ClassDescription >> fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the messages of this class that have been 
	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.changes file, and should only write a preamble for every method."

	| org |
	(org := self organization) categories
		do: [ :cat | | sels |
			sels := (org listAtCategoryNamed: cat) select: [ :sel | aSet includes: sel ].
			sels
				do: [ :sel | self
						printMethodChunk: sel
						withPreamble: true
						on: aFileStream
						moveSource: moveSource
						toFile: fileIndex ] ]
]

ClassDescription >> fileOutChangedMessagesHistorically: aSet on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File all historical description of the messages of this class that have been 
	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.changes file, and should only write a preamble for every method."

	| org |
	(org := self organization) categories
		do: [ :cat | | sels |
			sels := (org listAtCategoryNamed: cat) select: [ :sel | aSet includes: sel ].
			sels
				do: [ :sel | self
						printMethodChunkHistorically: sel
						on: aFileStream
						moveSource: moveSource
						toFile: fileIndex ] ]
]

ClassDescription >> fileOutMethod: selector
[
	"Write source code of a single method on a file.  Make up a name for the file."

	| internalStream |
	selector == #Comment
		ifTrue: [ ^ self inform: 'Sorry, cannot file out class comment in isolation.' ].
	(self includesSelector: selector)
		ifFalse: [ ^ self error: 'Selector ' , selector asString , ' not found' ].
	internalStream := (String new: 1000) writeStream.
	internalStream
		header;
		timeStamp.
	self
		printMethodChunk: selector
		withPreamble: true
		on: internalStream
		moveSource: false
		toFile: 0.
	FileStream
		writeSourceCodeFrom: internalStream
		baseName: self name , '-' , (selector copyReplaceAll: ':' with: '')
		isSt: true
]

ClassDescription >> forceNewFrom: anArray
[
	"Create a new instance of the class and fill
    its instance variables up with the array."

	| object max |
	object := self new.
	max := self instSize.
	anArray doWithIndex: [ :each :index | index > max
				ifFalse: [ object instVarAt: index put: each ] ].
	^ object
]

ClassDescription >> hasInstVarNamed: aString
[
	"Return true whether the receiver defines an instance variable named aString."

	^ self instVarNames includes: aString
]

ClassDescription >> hasSharedPools
[
	"Only a class may have shared pools"

	^ false
]

ClassDescription >> instVarIndexFor: instVarName
[
	"Answer the index of the named instance variable."

	| index |
	index := instanceVariables == nil
		ifTrue: [ 0 ]
		ifFalse: [ instanceVariables indexOf: instVarName ].
	index = 0
		ifTrue: [ ^ superclass == nil
				ifTrue: [ 0 ]
				ifFalse: [ superclass instVarIndexFor: instVarName ] ].
	^ superclass == nil
		ifTrue: [ index ]
		ifFalse: [ index + superclass instSize ]
]

ClassDescription >> instVarIndexFor: instVarName ifAbsent: aBlock
[
	"Answer the index of the named instance variable."

	| index |
	index := instanceVariables == nil
		ifTrue: [ 0 ]
		ifFalse: [ instanceVariables indexOf: instVarName ifAbsent: [ 0 ] ].
	index = 0
		ifTrue: [ ^ superclass == nil
				ifTrue: [ aBlock value ]
				ifFalse: [ superclass instVarIndexFor: instVarName ifAbsent: aBlock ] ].
	^ superclass == nil
		ifTrue: [ index ]
		ifFalse: [ index + superclass instSize ]
]

ClassDescription >> instVarMappingFrom: oldClass
[
	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."

	| oldInstVarNames |
	oldInstVarNames := oldClass allInstVarNames.
	^ self allInstVarNames collect: [ :instVarName | oldInstVarNames indexOf: instVarName ]
]

ClassDescription >> instVarNameForIndex: index
[
	"Answer the named instance variable with index index or nil if none."

	| superInstSize |
	index > self instSize
		ifTrue: [ ^ nil ].
	superInstSize := superclass isNil
		ifTrue: [ 0 ]
		ifFalse: [ superclass instSize ].
	index > superInstSize
		ifTrue: [ ^ instanceVariables at: index - superInstSize ].
	superclass isNil
		ifTrue: [ ^ nil ].
	^ superclass instVarNameForIndex: index	"(Object allSubclasses select:		[:cls| cls instSize > cls superclass instSize and: [cls subclasses isEmpty and: [cls superclass instSize > 0]]]) collect:			[:cls| (1 to: cls instSize) collect: [:i| cls instVarNameForIndex: i]]"
]

ClassDescription >> instVarNames
[
	"Answer an Array of the receiver's instance variable names."

	instanceVariables == nil
		ifTrue: [ ^ #() ]
		ifFalse: [ ^ instanceVariables ]
]

ClassDescription >> instVarNamesAndOffsetsDo: aBinaryBlock
[
	"This is part of the interface between the compiler and a class's instance or field names.
	 The class should enumerate aBinaryBlock with the instance variable name strings and
	 their integer offsets.  The order is important. Names evaluated later will override the
	 same names occurring earlier."

	| superInstSize |
	(superInstSize := superclass notNil
		ifTrue: [ superclass instSize ]
		ifFalse: [ 0 ]) > 0
		ifTrue: [ superclass instVarNamesAndOffsetsDo: aBinaryBlock ].
	1 to: self instSize - superInstSize do: [ :i | aBinaryBlock value: (instanceVariables at: i) value: i + superInstSize ]
]

ClassDescription >> instanceSide
[
	^ self theNonMetaClass
]

ClassDescription >> instanceVariablesString
[
	"Answer a string of my instance variable names separated by spaces."

	^ String
		streamContents: [ :stream | self instVarNames do: [ :each | stream nextPutAll: each ] separatedBy: [ stream space ] ]
]

ClassDescription >> isAbstractClass
[
	self deprecated: 'Use hasAbstractMethods' on: '16 December 2012' in: #Pharo2.
	0.
	self subclassResponsibility
]

ClassDescription >> linesOfCode
[
	"An approximate measure of lines of code.
	Includes comments, but excludes blank lines."

	| lines |
	lines := self localMethods inject: 0 into: [ :sum :each | sum + each linesOfCode ].
	^ self isMeta
		ifTrue: [ lines ]
		ifFalse: [ lines + self class linesOfCode ]
]

ClassDescription >> logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor
[
	aCompiledMethodWithNode method
		putSource: aText
		fromParseNode: aCompiledMethodWithNode node
		class: self
		category: category
		withStamp: changeStamp
		inFile: 2
		priorMethod: (self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [  ])
]

ClassDescription >> methodsInCategory: aName
[
	"Answer a list of the methods of the receiver that are in category named aName"

	| aColl |
	aColl := Set
		withAll:
			(aName = ClassOrganizer allCategory
				ifTrue: [ self organization allMethodSelectors ]
				ifFalse: [ self organization listAtCategoryNamed: aName ]).
	^ aColl asArray sort
]

ClassDescription >> moveChangesWithVersionsTo: newFile
[
	"Used in the process of condensing changes, this message requests that 
	the source code of all methods of the receiver that have been changed 
	should be moved to newFile."

	| changes |
	changes := self selectors select: [ :sel | (self methodDict at: sel) fileIndex > 1 ].
	self
		fileOutChangedMessagesHistorically: changes
		on: newFile
		moveSource: true
		toFile: 2
]

ClassDescription >> moveInstVarNamed: instVarName to: anotherClass after: prevInstVarName
[
	"Move the given instance variable to another class."

	self == anotherClass
		ifFalse: [ 
			self
				notify:
					'Warning:' asText allBold , ' moving ' , instVarName printString , ' from ' , self name , ' to ' , anotherClass name
						,
							' will not be recorded in the change set correctly.Proceed to do it anyways.' ].
	^ ClassBuilder new
		moveInstVarNamed: instVarName
		from: self
		to: anotherClass
		after: prevInstVarName
]

ClassDescription >> newInstanceFrom: oldInstance variable: variable size: instSize map: map
[
	"Create a new instance of the receiver based on the given old instance.
	The supplied map contains a mapping of the old instVar names into
	the receiver's instVars"

	| new |
	variable
		ifTrue: [ new := self basicNew: oldInstance basicSize ]
		ifFalse: [ new := self basicNew ].
	1 to: instSize do: [ :offset | (map at: offset) > 0
			ifTrue: [ new instVarAt: offset put: (oldInstance instVarAt: (map at: offset)) ] ].
	variable
		ifTrue: [ 1 to: oldInstance basicSize do: [ :offset | new basicAt: offset put: (oldInstance basicAt: offset) ] ].
	^ new
]

ClassDescription >> noteChangesFrom: oldMethodDict
[
	"create notifications about the changes made to the method dictionary"

	"additions have already been notified in #addTraitSelector:withMethod:"

	" deal with removal / updates relative to the old method dictionary"

	oldMethodDict
		keysAndValuesDo: [ :selector :oldMethod | self methodDict
				at: selector
				ifPresent: [ :currentMethod | currentMethod == oldMethod
						ifFalse: [ self noteMethodChanged: oldMethod to: currentMethod ] ]
				ifAbsent: [ self noteMethodRemoved: oldMethod ] ]
]

ClassDescription >> noteChangesFrom: oldMethodDict with: changedSelectors
[
	"create notifications about the changes made to the method dictionary"

	self haltIf: changedSelectors isEmpty not.	"oldMethodDict keys \ methodDict keys"
	changedSelectors
		do: [ :selector | " deal with removal / updates relative to the old method dictionary"
			oldMethodDict
				at: selector
				ifPresent: [ :oldMethod | methodDict
						at: selector
						ifPresent: [ :newMethod | self noteMethodChanged: oldMethod to: newMethod ]
						ifAbsent: [ self noteMethodRemoved: oldMethod ] ]
				ifAbsent: [ self noteMethodAdded: (methodDict at: selector) ] ]
]

ClassDescription >> noteMethodAdded: aMethod
[
	SystemAnnouncer uniqueInstance methodAdded: aMethod
]

ClassDescription >> noteMethodChanged: oldMethod to: newMethod
[
	SystemAnnouncer uniqueInstance methodChangedFrom: oldMethod to: newMethod
]

ClassDescription >> noteMethodRemoved: oldMethod
[
	SystemAnnouncer uniqueInstance methodRemoved: oldMethod
]

ClassDescription >> noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition
[
	aCollection
		do: [ :each | | oldCategory newCategory |
			oldCategory := self organization categoryOfElement: each.
			newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.
			self noteRecategorizedSelector: each from: oldCategory to: newCategory ]
]

ClassDescription >> notifyOfRecategorizedSelector: element from: oldCategory to: newCategory
[
	SystemAnnouncer uniqueInstance
		selector: element
		recategorizedFrom: oldCategory
		to: newCategory
		inClass: self
]

ClassDescription >> numberOfMethods
[
	"count all methods that are local (not comming from a trait)"

	| num |
	num := self localMethods size.
	^ self isMeta
		ifTrue: [ num ]
		ifFalse: [ num + self class numberOfMethods ]
]

ClassDescription >> obsolete
[
	"Make the receiver obsolete."

	superclass removeSubclass: self.
	self organization: nil.
	super obsolete
]

ClassDescription >> organization
[
	"Answer the instance of ClassOrganizer that represents the organization 
	of the messages of the receiver."

	organization ifNil: [ self organization: (ClassOrganizer defaultList: self selectors asArray sort) ].	"Making sure that subject is set correctly. It should not be necessary."
	organization ifNotNil: [ organization setSubject: self ].
	^ organization
]

ClassDescription >> organization: aClassOrg
[
	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."

	aClassOrg ifNotNil: [ aClassOrg setSubject: self ].
	organization := aClassOrg
]

ClassDescription >> printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod
[
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

	"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream
		cr;
		nextPut: $!.
	aFileStream
		nextChunkPut:
			(String
				streamContents: [ :strm | strm
						nextPutAll: self name;
						nextPutAll: ' methodsFor: ';
						print: category asString.
					(changeStamp ~~ nil and: [ changeStamp size > 0 or: [ priorMethod ~~ nil ] ])
						ifTrue: [ strm
								nextPutAll: ' stamp: ';
								print: changeStamp ].
					priorMethod ~~ nil
						ifTrue: [ strm
								nextPutAll: ' prior: ';
								print: priorMethod sourcePointer ] ])
]

ClassDescription >> printMethodChunkHistorically: selector on: outStream moveSource: moveSource toFile: fileIndex
[
	"Copy all source codes historically for the method associated with selector onto the 
	fileStream.  If moveSource true, then also set the source code pointer of the method."

	| preamble method sourceFile endPos category changeList newPos |
	category := self organization categoryOfElement: selector.
	preamble := self name , ' methodsFor: ' , category asString printString.
	method := self methodDict at: selector.
	((method fileIndex = 0 or: [ (SourceFiles at: method fileIndex) == nil ]) or: [ method filePosition = 0 ])
		ifTrue: [ outStream
				cr;
				nextPut: $!;
				nextChunkPut: preamble;
				cr.
			outStream nextChunkPut: method decompileString.
			outStream
				nextChunkPut: ' ';
				cr ]
		ifFalse: [ changeList := ChangeSet
				scanVersionsOf: method
				class: self
				meta: self isMeta
				category: category
				selector: selector.
			newPos := nil.
			sourceFile := SourceFiles at: method fileIndex.
			changeList
				reverseDo: [ :chgRec | | prior |
					chgRec fileIndex = fileIndex
						ifTrue: [ outStream copyPreamble: preamble from: sourceFile at: chgRec position.
							(prior := chgRec prior)
								ifNotNil: [ outStream position: outStream position - 2.
									outStream
										nextPutAll:
											' prior: '
												,
													(prior first = method fileIndex
														ifFalse: [ prior third ]
														ifTrue: [ SourceFiles sourcePointerFromFileIndex: method fileIndex andPosition: newPos ]) printString.
									outStream
										nextPut: $!;
										cr ].	"Copy the method chunk"
							newPos := outStream position.
							outStream copyMethodChunkFrom: sourceFile at: chgRec position.
							sourceFile skipSeparators.	"The following chunk may have ]style["
							sourceFile peek == $]
								ifTrue: [ outStream
										cr;
										copyMethodChunkFrom: sourceFile ].
							outStream
								nextChunkPut: ' ';
								cr ] ].
			moveSource
				ifTrue: [ endPos := outStream position.
					method setSourcePosition: newPos inFile: fileIndex ] ].
	^ outStream
]

ClassDescription >> printSubclassesOn: aStream level: level
[
	"As part of the algorithm for printing a description of the receiver, print the
	subclass on the file stream, aStream, indenting level times."

	| subclassNames |
	aStream crtab: level.
	aStream nextPutAll: self name.
	aStream
		space;
		print: self instVarNames.
	self == Class
		ifTrue: [ aStream
				crtab: level + 1;
				nextPutAll: '[ ... all the Metaclasses ... ]'.
			^ self ].
	subclassNames := self subclasses asSortedCollection: [ :c1 :c2 | c1 name <= c2 name ].	"Print subclasses in alphabetical order"
	subclassNames do: [ :subclass | subclass printSubclassesOn: aStream level: level + 1 ]
]

ClassDescription >> printWithClosureAnalysisOn: aStream
[
	aStream nextPutAll: self name
]

ClassDescription >> putClassCommentToCondensedChangesFile: aFileStream
[
	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."

	| header aStamp aCommentRemoteStr |
	self isMeta
		ifTrue: [ ^ self ].	"bulletproofing only"
	((aCommentRemoteStr := self organization commentRemoteStr) isNil or: [ aCommentRemoteStr sourceFileNumber = 1 ])
		ifTrue: [ ^ self ].
	aFileStream
		cr;
		nextPut: $!.
	header := String
		streamContents: [ :strm | strm
				nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
			(aStamp := self organization commentStamp ifNil: [ '<historical>' ]) storeOn: strm.
			strm nextPutAll: ' prior: 0' ].
	aFileStream nextChunkPut: header.
	aFileStream cr.
	self organization
		classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream)
		stamp: aStamp
]

ClassDescription >> reformatMethodAt: selector
[
	| newCodeString method |
	newCodeString := self prettyPrinterClass format: (self sourceCodeAt: selector) in: self notifying: nil.
	method := self compiledMethodAt: selector.
	method
		putSource: newCodeString
		fromParseNode: nil
		class: self
		category: (self organization categoryOfElement: selector)
		inFile: 2
		priorMethod: method
]

ClassDescription >> removeInstVarNamed: aString
[
	"Remove the argument, aString, as one of the receiver's instance 
	variables. Create an error notification if the argument is not found."

	self subclassResponsibility
]

ClassDescription >> removeSelector: selector
[
	"Remove the message whose selector is given from the method
    dictionary of the receiver, if it is there. Answer nil otherwise."

	| priorMethod priorProtocol origin |
	priorMethod := self compiledMethodAt: selector ifAbsent: [ ^ nil ].
	origin := priorMethod origin.
	priorProtocol := self whichCategoryIncludesSelector: selector.
	super removeSelector: selector.
	SystemAnnouncer uniqueInstance
		suspendAllWhile: [ self updateOrganizationSelector: selector oldCategory: priorProtocol newCategory: nil ].
	SystemAnnouncer uniqueInstance
		methodRemoved: priorMethod
		selector: selector
		inProtocol: priorProtocol
		class: self
		origin: origin
]

ClassDescription >> renameInstVar: oldName to: newName
[
	(self
		confirm:
			'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?')
		ifFalse: [ self halt ].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"
	^ self renameSilentlyInstVar: oldName to: newName
]

ClassDescription >> renameSilentlyInstVar: old to: new
[
	| i oldName newName |
	oldName := old asString.
	newName := new asString.
	(i := self instVarNames indexOf: oldName) = 0
		ifTrue: [ self error: oldName , ' is not defined in ' , self name ].
	self allSuperclasses , self withAllSubclasses asOrderedCollection
		do: [ :cls | (cls instVarNames includes: newName)
				ifTrue: [ self error: newName , ' is already used in ' , cls name ] ].
	self instVarNames replaceFrom: i to: i with: (Array with: newName).
	self replaceSilently: oldName to: newName	"replace in text body of all methods"
]

ClassDescription >> replaceSilently: old to: new
[
	"text-replace any part of a method.  Used for class and pool variables.  Don't touch the header.  Not guaranteed to work if name appears in odd circumstances"

	| oldName newName |
	oldName := old asString.
	newName := new asString.
	self withAllSubclasses
		do: [ :cls | | sels |
			sels := cls selectors copyWithoutAll: #(#DoIt #DoItIn:).
			sels
				do: [ :sel | | oldCode newCode parser header body |
					oldCode := cls sourceCodeAt: sel.	"Don't make changes in the method header"
					(parser := cls parserClass new) parseSelector: oldCode.
					header := oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).
					body := header size > oldCode size
						ifTrue: [ '' ]
						ifFalse: [ oldCode copyFrom: header size + 1 to: oldCode size ].
					newCode := header , (body copyReplaceTokens: oldName with: newName).
					newCode ~= oldCode
						ifTrue: [ cls compile: newCode classified: (cls organization categoryOfElement: sel) notifying: nil ] ].
			cls isMeta
				ifFalse: [ | oldCode newCode |
					oldCode := cls comment.
					newCode := oldCode copyReplaceTokens: oldName with: newName.
					newCode ~= oldCode
						ifTrue: [ cls comment: newCode ] ] ]
]

ClassDescription >> setInstVarNames: instVarArray
[
	"Private - for class initialization only"

	| required |
	required := self instSize.
	superclass notNil
		ifTrue: [ required := required - superclass instSize ].
	instVarArray size = required
		ifFalse: [ ^ self error: required printString , ' instvar names are required' ].
	instVarArray isEmpty
		ifTrue: [ instanceVariables := nil ]
		ifFalse: [ instanceVariables := instVarArray asArray ]
]

ClassDescription >> sharedPoolOfVarNamed: aString
[
	"Only classes may have shared pools"

	^ nil
]

ClassDescription >> sharedPoolsString
[
	"Answer a string of my shared pool names separated by spaces."

	^ String
		streamContents: [ :stream | self sharedPools
				do: [ :each | stream nextPutAll: (self environment keyAtIdentityValue: each ifAbsent: [ 'private' ]) ]
				separatedBy: [ stream space ] ]
]

ClassDescription >> subclasses
[
	^ Array new
]

ClassDescription >> subclassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."

	^ self subclasses do: aBlock
]

ClassDescription >> superclass: aClass methodDictionary: mDict format: fmt
[
	"Basic initialization of the receiver"

	super superclass: aClass methodDictionary: mDict format: fmt.
	instanceVariables := nil.
	self organization: nil
]

ClassDescription >> theMetaClass
[
	"Sent to a class or metaclass, always return the metaclass"

	^ self class
]

ClassDescription >> theNonMetaClass
[
	"Sent to a class or metaclass, always return the class"

	^ self
]

ClassDescription >> uncategorizedMethods
[
	^ self methodsInCategory: ClassOrganizer default
]

ClassDescription >> updateInstances: oldInstances from: oldClass isMeta: isMeta
[
	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary. Return the array of old instances (none of which should be pointed to legally by anyone but the array)."

	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."

	| map variable instSize newInstances |
	oldInstances isEmpty
		ifTrue: [ ^ #() ].	"no instances to convert"
	isMeta
		ifTrue: [ oldInstances size = 1
				ifFalse: [ ^ self error: 'Metaclasses can only have one instance' ].
			self soleInstance class == self
				ifTrue: [ ^ self error: 'Metaclasses can only have one instance' ] ].
	map := self instVarMappingFrom: oldClass.
	variable := self isVariable.
	instSize := self instSize.
	newInstances := Array new: oldInstances size.
	1 to: oldInstances size do: [ :i | newInstances
			at: i
			put: (self
					newInstanceFrom: (oldInstances at: i)
					variable: variable
					size: instSize
					map: map) ].	"Now perform a bulk mutation of old instances into new ones"
	oldInstances elementsExchangeIdentityWith: newInstances.
	^ newInstances	"which are now old"
]

ClassDescription >> updateInstancesFrom: oldClass
[
	"Recreate any existing instances of the argument, oldClass, as instances of 
	the receiver, which is a newly changed class. Permute variables as 
	necessary. Return the array of old instances (none of which should be
	pointed to legally by anyone but the array)."

	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:"

	| oldInstances |
	oldInstances := oldClass allInstances asArray.
	oldInstances := self updateInstances: oldInstances from: oldClass isMeta: self isMeta.
	^ oldInstances	"	| crashingBlock class |	class := Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar := value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock := (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"
]

ClassDescription >> updateOrganizationDescription: aTraitMethodDescription oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil changedCategories: changedCategories
[
	| sel effectiveCategory currentCategory |
	sel := aTraitMethodDescription selector.
	(self includesLocalSelector: sel)
		ifTrue: [ ^ self ].
	currentCategory := self organization categoryOfElement: sel.
	effectiveCategory := aTraitMethodDescription effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.
	effectiveCategory
		ifNil: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
			^ self organization removeElement: sel ].
	((currentCategory isNil or: [ currentCategory == ClassOrganizer ambiguous or: [ currentCategory == oldCategoryOrNil ] ])
		and: [ currentCategory ~~ effectiveCategory ])
		ifTrue: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
			self organization classify: sel under: effectiveCategory suppressIfDefault: false ]
]

ClassDescription >> updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil
[
	| changedCategories composition |
	changedCategories := IdentitySet new.
	composition := self hasTraitComposition
		ifTrue: [ self traitComposition ]
		ifFalse: [ TraitComposition new ].
	(composition methodDescriptionsForSelector: aSymbol)
		do: [ :each | self
				updateOrganizationDescription: each
				oldCategory: oldCategoryOrNil
				newCategory: newCategoryOrNil
				changedCategories: changedCategories ].
	^ changedCategories
]

ClassDescription >> usesLocalPoolVarNamed: aString
[
	^ false
]

ClassDescription >> usesPoolVarNamed: aString
[
	"Only classes may use a pool variable named: aString"

	^ false
]

ClassDescription >> version
[
	"Allows polymorphism with TraitDescription>>version"

	^ self classVersion
]

ClassDescription >> wantsChangeSetLogging
[
	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism."

	^ true
]

