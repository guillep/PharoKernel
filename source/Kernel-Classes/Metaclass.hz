Metaclass
	superclass: #ClassDescription;
	traitComposition: TApplyingOnClassSide;
	instanceVariables: #(#thisClass #traitComposition #localSelectors );
	package: #'Kernel-Classes'.

Metaclass >> acceptsLoggingOfCompilation
[
	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself."

	^ thisClass acceptsLoggingOfCompilation
]

Metaclass >> addInstVarNamed: aString
[
	"Add the argument, aString, as one of the receiver's instance variables."

	| fullString |
	fullString := String
		streamContents: [ :strm | self instVarNames do: [ :aString2 | strm
						nextPutAll: aString2;
						space ].
			strm nextPutAll: aString ].
	self instanceVariableNames: fullString
]

Metaclass >> addObsoleteSubclass: aClass
[
	"Do nothing."

	
]

Metaclass >> addSubclass: aClass
[
	"Do nothing."

	
]

Metaclass >> adoptInstance: oldInstance from: oldMetaClass
[
	"Recreate any existing instances of the argument, oldClass, as instances of 
	the receiver, which is a newly changed class. Permute variables as 
	necessary."

	thisClass class == self
		ifTrue: [ ^ self error: 'Metaclasses have only one instance' ].
	oldMetaClass isMeta
		ifFalse: [ ^ self error: 'Argument must be Metaclass' ].
	oldInstance class == oldMetaClass
		ifFalse: [ ^ self error: 'Not the class of argument' ].
	^ thisClass := self
		newInstanceFrom: oldInstance
		variable: self isVariable
		size: self instSize
		map: (self instVarMappingFrom: oldMetaClass)
]

Metaclass >> basicLocalSelectors
[
	"Direct accessor for the instance variable localSelectors.
	Since localSelectors is lazily initialized, this may 
	return nil, which means that all selectors are local."

	^ localSelectors
]

Metaclass >> basicLocalSelectors: aSetOrNil
[
	localSelectors := aSetOrNil
]

Metaclass >> binding
[
	"return an association that can be used as the binding
	 To share it between methods, reuse an existing one if possible"

	^ self methodDict ifEmpty: [ nil -> self ] ifNotEmpty: [ :dict | dict anyOne methodClassAssociation ]
]

Metaclass >> bindingOf: varName
[
	^ thisClass classBindingOf: varName
]

Metaclass >> canZapMethodDictionary
[
	"Return true if it is safe to zap the method dictionary on #obsolete"

	thisClass == nil
		ifTrue: [ ^ true ]
		ifFalse: [ ^ thisClass canZapMethodDictionary ]
]

Metaclass >> classPool
[
	"Answer the dictionary of class variables."

	^ thisClass classPool
]

Metaclass >> classVarNames
[
	"Answer a set of the names of the class variables defined in the receiver's instance."

	thisClass ifNil: [ ^ Set new ].
	^ thisClass classVarNames
]

Metaclass >> definition
[
	"Refer to the comment in ClassDescription|definition."

	^ String
		streamContents: [ :strm | strm print: self.
			(self hasTraitComposition and: [ self traitComposition notEmpty ])
				ifTrue: [ strm
						crtab;
						nextPutAll: 'uses: ';
						print: self traitComposition ].
			strm
				crtab;
				nextPutAll: 'instanceVariableNames: ';
				store: self instanceVariablesString ]
]

Metaclass >> environment
[
	^ thisClass environment
]

Metaclass >> fileOutInitializerOn: aStream
[
	(self methodDict includesKey: #initialize)
		ifTrue: [ aStream cr.
			aStream nextChunkPut: thisClass name , ' initialize' ]
]

Metaclass >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex
[
	^ self
		fileOutOn: aFileStream
		moveSource: moveSource
		toFile: fileIndex
		initializing: true
]

Metaclass >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool
[
	super fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex.
	(aBool and: [ moveSource not and: [ self methodDict includesKey: #initialize ] ])
		ifTrue: [ aFileStream cr.
			aFileStream cr.
			aFileStream nextChunkPut: thisClass name , ' initialize'.
			aFileStream cr ]
]

Metaclass >> hasTraitComposition
[
	^ traitComposition notNil and: [ traitComposition notEmpty ]
]

Metaclass >> instanceVariableNames: instVarString
[
	"Declare additional named variables for my instance."

	^ ClassBuilder new class: self instanceVariableNames: instVarString
]

Metaclass >> isAbstractClass
[
	self deprecated: 'Use hasAbstractMethods' on: '16 December 2012' in: #Pharo2.
	0.
	^ self theNonMetaClass isAbstractClass
]

Metaclass >> isAnonymous
[
	^ thisClass isAnonymous
]

Metaclass >> isMeta
[
	^ true
]

Metaclass >> isObsolete
[
	"Return true if the receiver is obsolete"

	^ thisClass == nil or: [ thisClass class ~~ self or: [ thisClass isObsolete ]	"or I am not the class of thisClass" ]	"Either no thisClass"	"or my instance is obsolete"
]

Metaclass >> isSelfEvaluating
[
	^ self isObsolete not
]

Metaclass >> name
[
	"Answer a String that is the name of the receiver, either 'Metaclass' or 
	the name of the receiver's class followed by ' class'."

	thisClass == nil
		ifTrue: [ ^ 'a Metaclass' ]
		ifFalse: [ ^ thisClass name , ' class' ]
]

Metaclass >> new
[
	"The receiver can only have one instance. Create it or complain that
	one already exists."

	thisClass class ~~ self
		ifTrue: [ ^ thisClass := self basicNew ]
		ifFalse: [ self error: 'A Metaclass should only have one instance!' ]
]

Metaclass >> nonTrivial
[
	"Answer whether the receiver has any methods or instance variables."

	^ self instVarNames notEmpty or: [ self hasMethods or: [ self hasTraitComposition ] ]
]

Metaclass >> obsoleteSubclasses
[
	"Answer the receiver's subclasses."

	thisClass == nil
		ifTrue: [ ^ #() ].
	^ thisClass obsoleteSubclasses
		select: [ :aSubclass | aSubclass isMeta not ]
		thenCollect: [ :aSubclass | aSubclass class ]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"
]

Metaclass >> possibleVariablesFor: misspelled continuedFrom: oldResults
[
	^ thisClass possibleVariablesFor: misspelled continuedFrom: oldResults
]

Metaclass >> postCopy
[
	"Don't share the reference to the sole instance."

	super postCopy.
	thisClass := nil
]

Metaclass >> removeInstVarNamed: aString
[
	"Remove the argument, aString, as one of the receiver's instance variables."

	| newArray newString |
	(self instVarNames includes: aString)
		ifFalse: [ self error: aString , ' is not one of my instance variables' ].
	newArray := self instVarNames copyWithout: aString.
	newString := ''.
	newArray do: [ :aString2 | newString := aString2 , ' ' , newString ].
	self instanceVariableNames: newString
]

Metaclass >> removeObsoleteSubclass: aClass
[
	"Do nothing."

	
]

Metaclass >> removeSubclass: aClass
[
	"Do nothing."

	
]

Metaclass >> soleInstance
[
	"The receiver has only one instance. Answer it."

	^ thisClass
]

Metaclass >> subclasses
[
	"Answer the receiver's subclasses."

	thisClass == nil
		ifTrue: [ ^ #() ].
	^ thisClass subclasses select: [ :aSubclass | aSubclass isMeta not ] thenCollect: [ :aSubclass | aSubclass class ]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"
]

Metaclass >> subclassesDo: aBlock
[
	"Evaluate aBlock for each of the receiver's immediate subclasses."

	thisClass
		subclassesDo: [ :aSubclass | 
			"The following test is for Class class which has to exclude		the Metaclasses being subclasses of Class."
			aSubclass isMeta
				ifFalse: [ aBlock value: aSubclass class ] ]
]

Metaclass >> theMetaClass
[
	"Sent to a class or metaclass, always return the metaclass"

	^ self
]

Metaclass >> theNonMetaClass
[
	"Sent to a class or metaclass, always return the class"

	^ thisClass
]

Metaclass >> traitComposition
[
	traitComposition ifNil: [ traitComposition := TraitComposition new ].
	^ traitComposition
]

Metaclass >> traitComposition: aTraitComposition
[
	traitComposition := aTraitComposition
]

Metaclass >> uses: aTraitCompositionOrArray instanceVariableNames: instVarString
[
	| newComposition newMetaClass copyOfOldMetaClass |
	copyOfOldMetaClass := self copy.
	newMetaClass := self instanceVariableNames: instVarString.
	newComposition := aTraitCompositionOrArray asTraitComposition.
	newMetaClass assertConsistantCompositionsForNew: newComposition.
	newMetaClass setTraitComposition: newComposition.
	SystemAnnouncer uniqueInstance classDefinitionChangedFrom: copyOfOldMetaClass to: newMetaClass
]

Metaclass >> veryDeepCopyWith: deepCopier
[
	"Return self.  Must be created, not copied.  Do not record me."

	
]

Metaclass >> wantsChangeSetLogging
[
	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.The metaclass follows the rule of the class itself."

	^ thisClass wantsChangeSetLogging
]

Metaclass >> wantsRecompilationProgressReported
[
	"The metaclass follows the rule of the class itself."

	^ thisClass wantsRecompilationProgressReported
]

