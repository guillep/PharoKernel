ClassOrganizer
	superclass: #BasicClassOrganizer;
	package: #'Kernel-Classes'.

ClassOrganizer >> addCategory: catString before: nextCategory
[
	| oldCategories |
	oldCategories := self categories copy.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super addCategory: catString before: nextCategory ].
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories
]

ClassOrganizer >> categoriesSorted
[
	^ self categories
]

ClassOrganizer >> changeFromCategorySpecs: categorySpecs
[
	| oldDict oldCategories |
	oldDict := self elementCategoryDict.
	oldCategories := self categories copy.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super changeFromCategorySpecs: categorySpecs ].
	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories
]

ClassOrganizer >> classify: element under: heading suppressIfDefault: aBoolean
[
	| oldCat newCat |
	oldCat := self categoryOfElement: element.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super classify: element under: heading suppressIfDefault: aBoolean ].
	newCat := self categoryOfElement: element.
	self notifyOfChangedSelector: element from: oldCat to: newCat
]

ClassOrganizer >> notifyOfChangedCategoriesFrom: oldCollectionOrNil to: newCollectionOrNil
[
	(self hasSubject and: [ oldCollectionOrNil ~= newCollectionOrNil ])
		ifTrue: [ SystemAnnouncer uniqueInstance classReorganized: self subject ]
]

ClassOrganizer >> notifyOfChangedCategoryFrom: oldNameOrNil to: newNameOrNil
[
	(self hasSubject and: [ oldNameOrNil ~= newNameOrNil ])
		ifTrue: [ SystemAnnouncer uniqueInstance classReorganized: self subject ]
]

ClassOrganizer >> notifyOfChangedSelector: element from: oldCategory to: newCategory
[
	(self hasSubject and: [ oldCategory ~= newCategory ])
		ifTrue: [ self subject notifyOfRecategorizedSelector: element from: oldCategory to: newCategory ]
]

ClassOrganizer >> notifyOfChangedSelectorsOldDict: oldDictionaryOrNil newDict: newDictionaryOrNil
[
	(oldDictionaryOrNil isNil and: [ newDictionaryOrNil isNil ])
		ifTrue: [ ^ self ].
	oldDictionaryOrNil isNil
		ifTrue: [ newDictionaryOrNil keysAndValuesDo: [ :el :cat | self notifyOfChangedSelector: el from: nil to: cat ].
			^ self ].
	newDictionaryOrNil isNil
		ifTrue: [ oldDictionaryOrNil keysAndValuesDo: [ :el :cat | self notifyOfChangedSelector: el from: cat to: nil ].
			^ self ].
	oldDictionaryOrNil
		keysAndValuesDo: [ :el :cat | | newCat |
			newCat := newDictionaryOrNil at: el.
			self notifyOfChangedSelector: el from: cat to: newCat ]
]

ClassOrganizer >> ownCategories
[
	"get all categories that are not obtained from traits. Order is random"

	| traitsCategories |
	traitsCategories := self subject traits
		inject: Set new
		into: [ :set :trait | set addAll: trait organization categories.
			set ].
	^ (self categories copyWithoutAll: traitsCategories) asArray
]

ClassOrganizer >> removeCategory: cat
[
	| oldCategories |
	oldCategories := self categories copy.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super removeCategory: cat ].
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories
]

ClassOrganizer >> removeElement: element
[
	| oldCat |
	oldCat := self categoryOfElement: element.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super removeElement: element ].
	self notifyOfChangedSelector: element from: oldCat to: (self categoryOfElement: element)
]

ClassOrganizer >> removeEmptyCategories
[
	| oldCategories |
	oldCategories := self categories copy.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super removeEmptyCategories ].
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories
]

ClassOrganizer >> renameCategory: oldCatString toBe: newCatString
[
	| oldCat newCat oldElementsBefore oldElementsAfter |
	oldCat := oldCatString asSymbol.
	newCat := newCatString asSymbol.
	oldElementsBefore := self listAtCategoryNamed: oldCat.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super renameCategory: oldCatString toBe: newCatString ].
	oldElementsAfter := (self listAtCategoryNamed: oldCat) asSet.
	oldElementsBefore
		do: [ :each | (oldElementsAfter includes: each)
				ifFalse: [ self notifyOfChangedSelector: each from: oldCat to: newCat ] ].
	self notifyOfChangedCategoryFrom: oldCat to: newCat
]

ClassOrganizer >> setDefaultList: aSortedCollection
[
	| oldDict oldCategories |
	oldDict := self elementCategoryDict.
	oldCategories := self categories copy.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super setDefaultList: aSortedCollection ].
	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories
]

ClassOrganizer >> sortCategories
[
	| oldCategories |
	oldCategories := self categories copy.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ super sortCategories ].
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories
]

ClassOrganizer class >> cleanUp: aggressive
[
	"Remove empty method categories when cleaning aggressively"

	aggressive
		ifTrue: [ Smalltalk removeEmptyMessageCategories ]
]

