Class
	name: #Class;
	superclass: #ClassClassDescription;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#subclasses #name #classPool #sharedPools #environment #category #traitComposition #localSelectors );
	classVariables: #();
	package: #'Kernel-Classes'.

Class Class >> addClassVarNamed: aString
[
	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."
| symbol oldState |oldState := self copy.aString first canBeGlobalVarInitial	ifFalse: [ ^ self error: aString , ' class variable name should be capitalized; proceed to include anyway.' ].symbol := aString asSymbol.self withAllSubclasses	do: [ :subclass | 		(subclass bindingOf: symbol)			ifNotNil: [ ^ self error: aString , ' is already used as a variable name in class ' , subclass name ] ].classPool == nil	ifTrue: [ classPool := Dictionary new ].(classPool includesKey: symbol)	ifFalse: [ 		"Pick up any refs in Undeclared"		classPool declare: symbol from: Undeclared.		SystemAnnouncer uniqueInstance classDefinitionChangedFrom: oldState to: self ]
]

Class Class >> addInstVarNamed: aString
[
	"Add the argument, aString, as one of the receiver's instance variables."
^ ClassBuilder new	name: self name	inEnvironment: self environment	subclassOf: self superclass	type: self typeOfClass	instanceVariableNames: self instanceVariablesString , ' ' , aString	classVariableNames: self classVariablesString	poolDictionaries: self sharedPoolsString	category: self category
]

Class Class >> addSharedPool: aSharedPool
[
	"Add the argument, aSharedPool, as one of the receiver's shared pools. 	Create an error if the shared pool is already one of the pools.	This method will work with shared pools that are plain Dictionaries or thenewer SharedPool subclasses"
(self sharedPools includes: aSharedPool)	ifTrue: [ ^ self error: 'This is already in my shared pool list' ].sharedPools == nil	ifTrue: [ sharedPools := OrderedCollection with: aSharedPool ]	ifFalse: [ sharedPools add: aSharedPool ]
]

Class Class >> addSubclass: aSubclass
[
	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."
aSubclass superclass ~~ self	ifTrue: [ ^ self error: aSubclass name , ' is not my subclass' ].subclasses == nil	ifTrue: [ 		subclasses := Array with: aSubclass.		^ self ].subclasses	do: [ :cl | 		cl == aSubclass			ifTrue: [ ^ self ] ].	"Already my subclass"subclasses := subclasses copyWith: aSubclass
]

Class Class >> allClassVarNames
[
	"Answer a Set of the names of the receiver's class variables, including those	defined in the superclasses of the receiver."
| aSet |self superclass == nil	ifTrue: [ ^ self classVarNames asSet ]	ifFalse: [ 		aSet := self superclass allClassVarNames.		aSet addAll: self classVarNames.		^ aSet ]	"This is the keys so it is a new Set."
]

Class Class >> allSharedPools
[
	"Answer an ordered collection of the pools the receiver shares, including those defined  in the superclasses of the receiver."
| aSet |^ self superclass == nil	ifTrue: [ self sharedPools copy ]	ifFalse: [ 		aSet := self superclass allSharedPools.		aSet addAll: self sharedPools.		aSet ]
]

Class Class >> applyChangesOfNewTraitCompositionReplacing: oldComposition
[
	"See Trait>>applyChangesOfNewTraitCompositionReplacing:"
| changedSelectors |changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.self classSide noteNewBaseTraitCompositionApplied: self traitComposition.^ changedSelectors
]

Class Class >> basicCategory
[
^ category
]

Class Class >> basicCategory: aSymbol
[
category := aSymbol
]

Class Class >> basicLocalSelectors
[
	"Direct accessor for the instance variable localSelectors.	Since localSelectors is lazily initialized, this may 	return nil, which means that all selectors are local."
^ localSelectors
]

Class Class >> basicLocalSelectors: aSetOrNil
[
localSelectors := aSetOrNil
]

Class Class >> binding
[
	"Answer a binding for the receiver, sharing if possible"
| binding |binding := self environment associationAt: name ifAbsent: [ nil -> self ].^ binding value == self	ifTrue: [ binding ]	ifFalse: [ nil -> self ]
]

Class Class >> bindingOf: varName
[
	"Answer the binding of some variable resolved in the scope of the receiver, or nil	if variable with such name is not defined"
	"The lookup recurses up to superclasses looking inside their class and shared pools,	but not the environment, since two classes, even if they have ancestry relationship,	could use different environments.	That's why we doing an environment lookup only as a last step of symbol lookup 	and taking only the environment of receiver only, not any of it's superclass(es) "
| aSymbol binding |aSymbol := varName asSymbol.^ (self innerBindingOf: aSymbol) ifNil: [ self environment bindingOf: aSymbol ]
]

Class Class >> canFindWithoutEnvironment: varName
[
	"This method is used for analysis of system structure -- see senders."
	"Look up varName, in the context of the receiver. Return true if it can be found without using the declared environment."
	"First look in classVar dictionary."
(self classPool bindingOf: varName) ifNotNil: [ ^ true ].	"Next look in shared pools."self sharedPools do: [ :pool | (pool bindingOf: varName) ifNotNil: [ ^ true ] ].	"Finally look higher up the superclass chain and fail at the end."superclass == nil	ifTrue: [ ^ false ]	ifFalse: [ ^ (superclass bindingOf: varName) notNil ]
]

Class Class >> category
[
	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"
| result |self basicCategory	ifNotNil: [ :symbol | 		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^ symbol ] ].self basicCategory: (result := self environment organization categoryOfElement: self name).^ result
]

Class Class >> category: aString
[
	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."
| oldCategory |oldCategory := self basicCategory.aString isString	ifTrue: [ 		self basicCategory: aString asSymbol.		self environment organization classify: self name under: self basicCategory ]	ifFalse: [ self errorCategoryName ].SystemAnnouncer uniqueInstance class: self recategorizedFrom: oldCategory to: self basicCategory
]

Class Class >> classPool
[
	"Answer the dictionary of class variables."
classPool == nil	ifTrue: [ ^ Dictionary new ]	ifFalse: [ ^ classPool ]
]

Class Class >> classPool: aDictionary
[
classPool := aDictionary
]

Class Class >> classPoolFrom: aClass
[
	"share the classPool with aClass."
classPool := aClass classPool
]

Class Class >> classVarNamed: name
[
	"Answer the content of the Class Variable"
^ self classPool at: name asSymbol ifAbsent: [ self error: 'no such lass var' ]
]

Class Class >> classVarNamed: name put: anObject
[
	"Store anObject in the class variable."
| symbol |symbol := name asSymbol.(self classPool includesKey: symbol)	ifFalse: [ ^ self error: 'no such lass var' ].self classPool at: symbol put: anObject
]

Class Class >> classVarNames
[
	"Answer a collection of the names of the class variables defined in the receiver."
^ self classPool keys asArray sort
]

Class Class >> compileAll
[
super compileAll.self class compileAll
]

Class Class >> compileAllFrom: oldClass
[
	"Recompile all the methods in the receiver's method dictionary (not the	subclasses). Also recompile the methods in the metaclass."
super compileAllFrom: oldClass.self class compileAllFrom: oldClass class
]

Class Class >> copy
[
	"Answer a copy of the receiver without a list of subclasses.	 This copy is used by the ClassBuilder when mutating classes on redefinition.	 (SystemNavigation new browseAllCallsOn: #copy localTo: ClassBuilder)"
| newClass |newClass := self class copy new	superclass: superclass	methodDict: self methodDict copy	format: format	name: name	organization: self organization copy	instVarNames: instanceVariables copy	classPool: classPool copy	sharedPools: sharedPools copy.Class instSize + 1 to: self class instSize do: [ :offset | newClass instVarAt: offset put: (self instVarAt: offset) ].^ newClass
]

Class Class >> declare: varString
[
	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."
| newVars conflicts |newVars := (varString subStrings: ' ') collect: [ :x | x asSymbol ].conflicts := false.classPool	ifNotNil: [ (classPool keys reject: [ :x | newVars includes: x ]) do: [ :var | self removeClassVarNamed: var ] ].(newVars reject: [ :var | self classPool includesKey: var ])	do: [ :var | 		"adding"		"check if new vars defined elsewhere"		(self innerBindingOf: var)			ifNotNil: [ 				DuplicatedVariableError new					variable: var;					signal: var , ' is defined elsewhere'.				conflicts := true ] ].newVars notEmpty	ifTrue: [ 		classPool := self classPool.	"in case it was nil"		newVars do: [ :var | classPool declare: var from: Undeclared ] ].^ conflicts
]

Class Class >> duplicateClassWithNewName: aSymbol
[
| copysName class newDefinition |copysName := aSymbol asSymbol.copysName = self name	ifTrue: [ ^ self ].(Smalltalk globals includesKey: copysName)	ifTrue: [ ^ self error: copysName , ' already exists' ].newDefinition := self definition copyReplaceAll: '#' , self name asString with: '#' , copysName asString.class := self class evaluatorClass evaluate: newDefinition logged: true.class class instanceVariableNames: self class instanceVariablesString.class copyAllCategoriesFrom: self.class class copyAllCategoriesFrom: self class.^ class
]

Class Class >> ensureClassPool
[
classPool ifNil: [ classPool := Dictionary new ]
]

Class Class >> environment
[
environment == nil	ifTrue: [ ^ super environment ].^ environment
]

Class Class >> environment: anEnvironment
[
environment := anEnvironment
]

Class Class >> externalName
[
	"Answer a name by which the receiver can be known."
^ name
]

Class Class >> fileOut
[
	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."
| internalStream |internalStream := (String new: 100) writeStream.internalStream	header;	timeStamp.self hasSharedPools	ifTrue: [ 		self shouldFileOutPools			ifTrue: [ self fileOutSharedPoolsOn: internalStream ] ].self fileOutOn: internalStream moveSource: false toFile: 0.internalStream trailer.FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true
]

Class Class >> fileOutInitializerOn: aStream
[
^ self class fileOutInitializerOn: aStream
]

Class Class >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."
^ self	fileOutOn: aFileStream	moveSource: moveSource	toFile: fileIndex	initializing: true
]

Class Class >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool
[
	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."
self crTrace: self name.super fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex.self class nonTrivial	ifTrue: [ 		aFileStream			cr;			nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!';			cr;			cr.		self class			fileOutOn: aFileStream			moveSource: moveSource			toFile: fileIndex			initializing: aBool ]
]

Class Class >> fileOutPool: aPool onFileStream: aFileStream
[
| aPoolName |(aPool isKindOf: SharedPool class)	ifTrue: [ ^ self notify: 'we do not fileout SharedPool type shared pools for now' ].aPoolName := self environment keyAtIdentityValue: aPool.self crTrace: aPoolName.aFileStream	nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!';	cr.aFileStream	nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!';	cr.aPool keys asSortedCollection	do: [ :aKey | 		| aValue |		aValue := aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''' , ' put:  '.		(aValue isKindOf: Number)			ifTrue: [ aValue printOn: aFileStream ]			ifFalse: [ 				aFileStream nextPutAll: '('.				aValue printOn: aFileStream.				aFileStream nextPutAll: ')' ].		aFileStream			nextPutAll: '!';			cr ].aFileStream cr
]

Class Class >> fileOutSharedPoolsOn: aFileStream
[
	"file out the shared pools of this class after prompting the user about each pool"
| poolsToFileOut |poolsToFileOut := self sharedPools	select: [ :aPool | self shouldFileOutPool: (self environment keyAtIdentityValue: aPool) ].poolsToFileOut do: [ :aPool | self fileOutPool: aPool onFileStream: aFileStream ]
]

Class Class >> hasClassVarNamed: aString
[
	"Return whether the receiver has a class variables (shared variables among its class and subclasses) named: aString"
^ self classVarNames includes: aString
]

Class Class >> hasMethods
[
	"Answer a Boolean according to whether any methods are defined for the 	receiver (includes whether there are methods defined in the receiver's 	metaclass)."
^ super hasMethods or: [ self class hasMethods ]
]

Class Class >> hasSharedPools
[
	"Returns whether the receiver uses shared pools directly (Does not take into account that it may inherit shared pool uses."
^ self sharedPools notEmpty
]

Class Class >> hasTraitComposition
[
^ traitComposition notNil and: [ traitComposition notEmpty ]
]

Class Class >> innerBindingOf: aSymbol
[
	"Answer the binding of some variable resolved in the scope of the receiver, or one of its superclass	but do not look up binding in receiver's environment.	Use #bindingOf: for looking up the variable binding in a full scope, including receiver's environment"
| binding |"First look in classVar dictionary."binding := self classPool bindingOf: aSymbol.binding ifNotNil: [ ^ binding ].	"Next look in shared pools."self sharedPools	do: [ :pool | 		| aBinding |		aBinding := pool bindingOf: aSymbol.		aBinding ifNotNil: [ ^ aBinding ] ].superclass ifNotNil: [ ^ superclass innerBindingOf: aSymbol ].^ nil
]

Class Class >> isAbstractClass
[
^ (self allMethods anySatisfy: [ :cm | cm sendsSelector: #subclassResponsibility ])	or: [ self class allMethods anySatisfy: [ :cm | cm sendsSelector: #subclassResponsibility ] ]
]

Class Class >> isObsolete
[
	"Return true if the receiver is obsolete."
^ (self environment at: name ifAbsent: [ nil ]) ~~ self
]

Class Class >> isSelfEvaluating
[
^ self isObsolete not
]

Class Class >> name
[
	"Answer the name of the receiver."
name == nil	ifTrue: [ ^ super name ]	ifFalse: [ ^ name ]
]

Class Class >> newSubclass
[
| i className |i := 1.[ className := (self name , i printString) asSymbol.self environment includesKey: className ] whileTrue: [ i := i + 1 ].^ self	subclass: className	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Unclassified'	"Point newSubclass new"
]

Class Class >> obsolete
[
	"Change the receiver and all of its subclasses to an obsolete class."
self == Object	ifTrue: [ ^ self error: 'Object is NOT obsolete' ].self setName: 'AnObsolete' , self name.Object class instSize + 1 to: self class instSize do: [ :i | self instVarAt: i put: nil ].	"Store nil over class instVars."self classPool: nil.self sharedPools: nil.self class obsolete.super obsolete
]

Class Class >> possibleVariablesFor: misspelled continuedFrom: oldResults
[
| results |results := misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.self sharedPools do: [ :pool | results := misspelled correctAgainstDictionary: pool continuedFrom: results ].superclass == nil	ifTrue: [ ^ misspelled correctAgainstDictionary: self environment continuedFrom: results ]	ifFalse: [ ^ superclass possibleVariablesFor: misspelled continuedFrom: results ]
]

Class Class >> reformatAll
[
	"Reformat all methods in this class.	Leaves old code accessible to version browsing"
super reformatAll.	"me..."self class reformatAll	"...and my metaclass"
]

Class Class >> removeClassVarNamed: aString
[
	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."
| aSymbol |aSymbol := aString asSymbol.(classPool includesKey: aSymbol)	ifFalse: [ ^ self error: aString , ' is not a class variable' ].self withAllSubclasses	do: [ :subclass | 		(Array with: subclass with: subclass class)			do: [ :classOrMeta | 				(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol)) isEmpty					ifFalse: [ 						InMidstOfFileinNotification signal							ifTrue: [ 								self crTrace: self name , ' (' , aString , ' is Undeclared) '.								^ Undeclared declare: aSymbol from: classPool ].						(self							confirm:								(aString , ' is still used in code of class ' , classOrMeta name , '.\Is it okay to move it to Undeclared?') withCRs)							ifTrue: [ ^ Undeclared declare: aSymbol from: classPool ]							ifFalse: [ ^ self ] ] ] ].classPool removeKey: aSymbol.classPool isEmpty	ifTrue: [ classPool := nil ]
]

Class Class >> removeFromChanges
[
	"References to the receiver, a class, and its metaclass should no longer be included in the system ChangeSet."
ChangeSet current removeClassAndMetaClassChanges: self
]

Class Class >> removeFromSystem
[
	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."
self removeFromSystem: true
]

Class Class >> removeFromSystem: logged
[
	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."
	"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."
	"tell class to deactivate and unload itself-- two separate events in the module system"
self unload.self superclass	ifNotNil: [ 		"If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self ].self environment forgetClass: self logged: logged.self obsolete
]

Class Class >> removeFromSystemUnlogged
[
	"Forget the receiver from the Smalltalk global dictionary. Any existing instances will refer to an obsolete version of the receiver.  Do not log the removal either to the current change set nor to the system changes log"
^ self removeFromSystem: false
]

Class Class >> removeInstVarNamed: aString
[
	"Remove the argument, aString, as one of the receiver's instance variables."
| newInstVarString |(self instVarNames includes: aString)	ifFalse: [ self error: aString , ' is not one of my instance variables' ].newInstVarString := ''.(self instVarNames copyWithout: aString) do: [ :varName | newInstVarString := newInstVarString , ' ' , varName ].^ ClassBuilder new	name: self name	inEnvironment: self environment	subclassOf: self superclass	type: self typeOfClass	instanceVariableNames: newInstVarString	classVariableNames: self classVariablesString	poolDictionaries: self sharedPoolsString	category: self category
]

Class Class >> removeSharedPool: aDictionary
[
	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."
| satisfiedSet workingSet aSubclass |(self sharedPools includes: aDictionary)	ifFalse: [ ^ self error: 'the dictionary is not in my pool' ].	"first see if it is declared in a superclass in which case we can remove it."(self selectSuperclasses: [ :class | class sharedPools includes: aDictionary ]) isEmpty	ifFalse: [ 		sharedPools remove: aDictionary.		sharedPools isEmpty			ifTrue: [ sharedPools := nil ].		^ self ].	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."workingSet := self subclasses asOrderedCollection.satisfiedSet := Set new.[ workingSet isEmpty ]	whileFalse: [ 		aSubclass := workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: [ 				satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses ] ].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."satisfiedSet add: self.satisfiedSet	do: [ :sub | 		aDictionary			associationsDo: [ :aGlobal | 				(sub whichSelectorsReferTo: aGlobal) isEmpty					ifFalse: [ ^ self error: aGlobal key , ' is still used in code of class ' , sub name ] ] ].sharedPools remove: aDictionary.sharedPools isEmpty	ifTrue: [ sharedPools := nil ]
]

Class Class >> removeSubclass: aSubclass
[
	"If the argument, aSubclass, is one of the receiver's subclasses, remove it."
subclasses == nil	ifFalse: [ 		subclasses := subclasses copyWithout: aSubclass.		subclasses isEmpty			ifTrue: [ subclasses := nil ] ]
]

Class Class >> rename: aString
[
	"The new name of the receiver is the argument, aString."
| oldName newName |(newName := aString asSymbol) = (oldName := self name)	ifTrue: [ ^ self ].(self environment includesKey: newName)	ifTrue: [ ^ self error: newName , ' already exists' ].name := newName.self environment renameClass: self from: oldName.(Undeclared includesKey: newName)	ifTrue: [ 		self			inform:				'There are references to, ' , aString printString					,						'from Undeclared. Check them after this change.' ]
]

Class Class >> setName: aSymbol
[
	"Private - set the name of the class"
name := aSymbol
]

Class Class >> sharedPoolOfVarNamed: aString
[
	"Returns the SharedPool or nil from which the pool variable named aString is coming from."
^ self sharedPools	detect: [ :each | each usesClassVarNamed: aString ]	ifNone: [ 		superclass == nil			ifTrue: [ nil ]			ifFalse: [ superclass sharedPoolOfVarNamed: aString ] ]
]

Class Class >> sharedPools
[
	"Answer an orderedCollection  of the shared pools declared in the receiver."
sharedPools == nil	ifTrue: [ ^ OrderedCollection new ]	ifFalse: [ ^ sharedPools ]
]

Class Class >> sharedPools: aCollection
[
sharedPools := aCollection
]

Class Class >> sharing: poolString
[
	"Set up sharedPools. Answer whether recompilation is advisable."
| oldPools |oldPools := self sharedPools.sharedPools := OrderedCollection new.(poolString subStrings: ' ')	do: [ :poolName | 		sharedPools			add:				(self environment					at: poolName asSymbol					ifAbsent: [ 						(self confirm: 'The pool dictionary ' , poolName , ' does not exist.' , '\Do you want it automatically created?' withCRs)							ifTrue: [ self environment at: poolName asSymbol put: Dictionary new ]							ifFalse: [ ^ self error: poolName , ' does not exist' ] ]) ].sharedPools isEmpty	ifTrue: [ sharedPools := nil ].oldPools	do: [ :pool | 		| found |		found := self sharedPools anySatisfy: [ :p | p == pool ].		found			ifFalse: [ ^ true	"A pool got deleted" ] ].^ false
]

Class Class >> shouldFileOutPool: aPoolName
[
	"respond with true if the user wants to file out aPoolName"
^ self confirm: 'FileOut the sharedPool ' , aPoolName , '?'
]

Class Class >> shouldFileOutPools
[
	"respond with true if the user wants to file out the shared pools"
^ self confirm: 'FileOut selected sharedPools?'
]

Class Class >> spaceUsed
[
	"Object spaceUsed"
^ super spaceUsed + self class spaceUsed
]

Class Class >> subclass: t
[
^ self	subclass: t	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Unclassified'
]

Class Class >> subclass: t instanceVariableNames: ins
[
^ self	subclass: t	instanceVariableNames: ins	classVariableNames: ''	poolDictionaries: ''	category: 'Unclassified'
]

Class Class >> subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."
| class |class := ClassBuilder new	superclass: self	subclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat.class ifNotNil: [ class setTraitComposition: {} asTraitComposition ].^ class
]

Class Class >> subclass: t uses: aTraitComposition
[
| cls |cls := self	subclass: t	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Unclassified'.cls setTraitComposition: aTraitComposition asTraitComposition.^ cls
]

Class Class >> subclass: t uses: aTraitCompositionOrArray instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
| newClass copyOfOldClass |copyOfOldClass := self copy.newClass := self	subclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat.newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.SystemAnnouncer uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.^ newClass
]

Class Class >> subclasses
[
	"Answer a Set containing the receiver's subclasses."
^ subclasses == nil	ifTrue: [ #() ]	ifFalse: [ subclasses copy ]
]

Class Class >> subclassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."
subclasses == nil	ifFalse: [ subclasses do: aBlock ]
]

Class Class >> superclass: sup methodDict: md format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet
[
	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."
superclass := sup.methodDict := md.format := ft.name := nm.instanceVariables := nilOrArray.classPool := pool.sharedPools := poolSet.self organization: org
]

Class Class >> superclass: aClass methodDictionary: mDict format: fmt
[
	"Basic initialization of the receiver"
super superclass: aClass methodDictionary: mDict format: fmt.subclasses := nil	"Important for moving down the subclasses field into Class"
]

Class Class >> traitComposition
[
traitComposition ifNil: [ traitComposition := TraitComposition new ].^ traitComposition
]

Class Class >> traitComposition: aTraitComposition
[
traitComposition := aTraitComposition
]

Class Class >> unload
[
	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."

]

Class Class >> usesClassVarNamed: aString
[
	"Return whether the receiver or its superclasses have a class variable named: aString"
^ self allClassVarNames includes: aString
]

Class Class >> usesLocalPoolVarNamed: aString
[
	"Return whether the receiver uses a pool variable named: aString which is defined locally"
self hasSharedPools	ifTrue: [ 		self sharedPools			do: [ :each | 				(each usesClassVarNamed: aString)					ifTrue: [ ^ true ] ] ]	ifFalse: [ ^ false ].^ false
]

Class Class >> usesPoolVarNamed: aString
[
	"Return whether the receiver has a pool variable named: aString, taking into account superclasses too"
self allSharedPools	do: [ :each | 		(each usesClassVarNamed: aString)			ifTrue: [ ^ true ] ].^ false
]

Class Class >> variableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."
^ ClassBuilder new	superclass: self	variableByteSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat
]

Class Class >> variableByteSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."
| newClass copyOfOldClass |copyOfOldClass := self copy.newClass := self	variableByteSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat.newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.SystemAnnouncer uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.^ newClass
]

Class Class >> variableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."
^ ClassBuilder new	superclass: self	variableSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat
]

Class Class >> variableSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."
| newClass copyOfOldClass |copyOfOldClass := self copy.newClass := self	variableSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat.newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.SystemAnnouncer uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.^ newClass
]

Class Class >> variableWordSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."
^ ClassBuilder new	superclass: self	variableWordSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat
]

Class Class >> variableWordSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."
| newClass copyOfOldClass |copyOfOldClass := self copy.newClass := self	variableWordSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat.newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.SystemAnnouncer uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.^ newClass
]

Class Class >> weakSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a subclass of an existing class (the receiver) in which the subclass is to have weak indexable pointer variables."
^ ClassBuilder new	superclass: self	weakSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat
]

Class Class >> weakSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat
[
	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."
| newClass copyOfOldClass |copyOfOldClass := self copy.newClass := self	weakSubclass: t	instanceVariableNames: f	classVariableNames: d	poolDictionaries: s	category: cat.newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.SystemAnnouncer uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.^ newClass
]

Class Class >> withClassVersion: aVersion
[
aVersion = self classVersion	ifTrue: [ ^ self ].^ self error: 'Invalid class version'
]

Metaclass
	name: #Class;
	instanceVariables: #().

Metaclass Class >> allSuperclassesFor: aClass cache: cache
[
^ cache at: aClass ifAbsentPut: [ aClass allSuperclasses asArray ]
]

Metaclass Class >> doesNotIncludeInstanceOrSuperclassesFor: aClass in: unprocessedClasses cache: cache
[
| soleInstance |soleInstance := aClass soleInstance.^ (unprocessedClasses includes: soleInstance) not	and: [ self hasNoSuperclassesOf: soleInstance in: unprocessedClasses cache: cache ]
]

Metaclass Class >> fileOutPool: aString
[
	"file out the global pool named aString"
| internalStream |internalStream := (String new: 1000) writeStream.self new fileOutPool: (self environment at: aString asSymbol) onFileStream: internalStream.FileStream writeSourceCodeFrom: internalStream baseName: aString isSt: true
]

Metaclass Class >> hasNoDependenciesFor: aClass in: unprocessedClasses cache: cache
[
^ (self hasNoSuperclassesOf: aClass in: unprocessedClasses cache: cache)	and: [ aClass isMeta not or: [ self hasNoDependenciesForMetaclass: aClass in: unprocessedClasses cache: cache ] ]
]

Metaclass Class >> hasNoDependenciesForMetaclass: aClass in: unprocessedClasses cache: cache
[
| soleInstance |soleInstance := aClass soleInstance.^ (unprocessedClasses includes: soleInstance) not	and: [ self hasNoSuperclassesOf: soleInstance in: unprocessedClasses cache: cache ]
]

Metaclass Class >> hasNoSuperclassesOf: aClass in: unprocessedClasses cache: cache
[
^ (unprocessedClasses includesAnyOf: (self allSuperclassesFor: aClass cache: cache)) not
]

Metaclass Class >> rootsOfTheWorld
[
	"return all classes that have a nil superclass"
^ (Smalltalk globals select: [ :each | each isBehavior and: [ each superclass isNil ] ]) asOrderedCollection
]

Metaclass Class >> superclassOrder: classes
[
	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in. Do it in sets instead of ordered collections."
| all unprocessedClasses cache |unprocessedClasses := classes asSet.cache := Dictionary new.all := OrderedCollection new: unprocessedClasses size.unprocessedClasses size	timesRepeat: [ 		| nextClass |		nextClass := unprocessedClasses			detect: [ :aClass | self hasNoDependenciesFor: aClass in: unprocessedClasses cache: cache ].		all add: nextClass.		unprocessedClasses remove: nextClass ].^ all
]

Metaclass Class >> template: aSystemCategoryName
[
	"Answer an expression that can be edited and evaluated in order to define a new class."
^ self templateForSubclassOf: Object name category: aSystemCategoryName
]

Metaclass Class >> templateForSubclassOf: priorClassName category: systemCategoryName
[
	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"
^ priorClassName asString	,		' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString , ''''
]

