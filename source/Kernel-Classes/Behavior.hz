Behavior
	traitComposition: #TPureBehavior;
	instanceVariables: #(#superclass #methodDict #format #layout );
	classVariables: #(#ObsoleteSubclasses );
	package: #'Kernel-Classes'.

Behavior >> >> selector
[
	"Answer the compiled method associated with the argument, selector (a 
	Symbol), a message selector in the receiver's method dictionary. If the 
	selector is not in the dictionary, create an error notification."

	^ self compiledMethodAt: selector
]

Behavior >> addExclusionOf: aSymbol to: aTrait
[
	self setTraitComposition: (self traitComposition copyWithExclusionOf: aSymbol to: aTrait)
]

Behavior >> addObsoleteSubclass: aClass
[
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"

	| obs |
	obs := ObsoleteSubclasses at: self ifAbsent: [ WeakArray new ].
	(obs includes: aClass)
		ifTrue: [ ^ self ].
	obs := obs copyWithout: nil.
	obs := obs copyWith: aClass.
	ObsoleteSubclasses at: self put: obs
]

Behavior >> addSelector: selector withMethod: compiledMethod
[
	^ self addSelector: selector withMethod: compiledMethod notifying: nil
]

Behavior >> addSelector: selector withMethod: compiledMethod notifying: requestor
[
	^ self addSelectorSilently: selector withMethod: compiledMethod
]

Behavior >> addSelectorSilently: selector withMethod: compiledMethod
[
	self methodDictAddSelectorSilently: selector withMethod: compiledMethod.
	self registerLocalSelector: selector
]

Behavior >> addToComposition: aTrait
[
	self setTraitComposition: (self traitComposition copyTraitExpression
				add: aTrait;
				yourself)
]

Behavior >> addTraitSelector: aSymbol withMethod: aCompiledMethod
[
	"Add aMethod with selector aSymbol to my
	methodDict. aMethod must not be defined locally."

	| source methodAndNode |
	[ (self includesLocalSelector: aSymbol) not ] assert.
	self ensureLocalSelectors.
	source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.
	methodAndNode := self
		compile: source
		classified: aCompiledMethod category
		notifying: nil
		trailer: self defaultMethodTrailer
		ifFail: [ ^ nil ].
	methodAndNode method
		putSource: source
		fromParseNode: methodAndNode node
		inFile: 2
		withPreamble: [ :f | f
				cr;
				nextPut: $!;
				nextChunkPut: 'Trait method';
				cr ].
	methodAndNode method properties at: #traitSource put: aCompiledMethod.
	self basicAddSelector: aSymbol withMethod: methodAndNode method
]

Behavior >> adoptInstance: anInstance
[
	"Change the class of anInstance to me.
	Primitive (found in Cog and new VMs)  follows the same rules as primitiveChangeClassTo:, but returns the 	class rather than the modified instance"

	<primitive: 160 error: #ec>
	anInstance primitiveChangeClassTo: self basicNew.
	^ self
]

Behavior >> allClassVarNames
[
	"Answer a Set of the names of the receiver's and the receiver's ancestor's 
	class variables."

	^ superclass allClassVarNames
]

Behavior >> allInstVarNames
[
	"Answer an Array of the names of the receiver's instance variables. The 
	Array ordering is the order in which the variables are stored and 
	accessed by the interpreter."

	| vars |
	superclass == nil
		ifTrue: [ vars := self instVarNames copy ]
		ifFalse: [ vars := superclass allInstVarNames , self instVarNames ].	"Guarantee a copy is answered."
	^ vars
]

Behavior >> allInstances
[
	"Answer a collection of all current instances of the receiver."

	| all inst next |
	all := OrderedCollection new.
	inst := self someInstance.
	[ inst == nil ]
		whileFalse: [ next := inst nextInstance.
			inst == all
				ifFalse: [ all add: inst ].
			inst := next ].
	^ all asArray
]

Behavior >> allInstancesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the current instances of the 
	receiver.
	
	Because aBlock might change the class of inst (for example, using become:),
	it is essential to compute next before aBlock value: inst."

	| inst next |
	inst := self someInstance.
	[ inst == nil ] whileFalse: [ next := inst nextInstance.
			aBlock value: inst.
			inst := next ]
]

Behavior >> allLocalCallsOn: aSymbol
[
	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."

	^ SystemNavigation new allLocalCallsOn: aSymbol ofClass: self theNonMetaClass
]

Behavior >> allMethods
[
	"Return the collection of compiled method I and my superclasses are defining"

	"asArray is used to not bump into a bug when comparing compiled methods."

	^ self allSelectors asArray collect: [ :s | self lookupSelector: s ]
]

Behavior >> allSelectors
[
	"Answer all selectors understood by instances of the receiver"

	^ self allSelectorsBelow: nil
]

Behavior >> allSelectorsAbove
[
	^ self allSelectorsAboveUntil: ProtoObject
]

Behavior >> allSelectorsAboveUntil: aRootClass
[
	| coll |
	coll := IdentitySet new.
	(self allSuperclassesIncluding: aRootClass) do: [ :aClass | aClass selectorsDo: [ :sel | coll add: sel ] ].
	^ coll
]

Behavior >> allSelectorsBelow: topClass
[
	| coll |
	coll := IdentitySet new.
	self
		withAllSuperclassesDo: [ :aClass | aClass = topClass
				ifTrue: [ ^ coll ]
				ifFalse: [ aClass selectorsDo: [ :sel | coll add: sel ] ] ].
	^ coll
]

Behavior >> allSelectorsWithout: behaviors
[
	"Returns all the selectors of the receiver and its superclasses, except the ones define in behaviors"

	| selectors |
	selectors := IdentitySet new.
	self withAllSuperclassesDo: [ :class | (behaviors includes: class)
				ifFalse: [ selectors addAll: class selectors ] ].
	^ selectors asOrderedCollection
]

Behavior >> allSharedPools
[
	"Answer an ordered collection of the shared pools that the receiver and the receiver's ancestors share."

	^ superclass allSharedPools
]

Behavior >> allSubInstances
[
	"Answer a list of all current instances of the receiver and all of its subclasses."

	| aCollection |
	aCollection := OrderedCollection new.
	self allSubInstancesDo: [ :x | x == aCollection
				ifFalse: [ aCollection add: x ] ].
	^ aCollection
]

Behavior >> allSubInstancesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the current instances of the 
	receiver and all its subclasses."

	self allInstancesDo: aBlock.
	self allSubclassesDo: [ :sub | sub allInstancesDo: aBlock ]
]

Behavior >> allSubclasses
[
	"Answer an orderedCollection of the receiver's and the receiver's descendent's subclasses. "

	| scan scanTop |
	scan := OrderedCollection withAll: self subclasses.
	scanTop := 1.
	[ scanTop > scan size ] whileFalse: [ scan addAll: (scan at: scanTop) subclasses.
			scanTop := scanTop + 1 ].
	^ scan
]

Behavior >> allSubclassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the receiver's subclasses."

	self subclassesDo: [ :cl | aBlock value: cl.
			cl allSubclassesDo: aBlock ]
]

Behavior >> allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level
[
	"Walk the tree of subclasses, giving the class and its level"

	| subclassNames |
	classAndLevelBlock value: self value: level.
	self == Class
		ifTrue: [ ^ self ].	"Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"
	subclassNames := SortedCollection new.
	self subclassesDo: [ :subC | subclassNames add: subC name ].
	subclassNames
		do: [ :name | (self environment at: name) allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level + 1 ]
]

Behavior >> allSuperclasses
[
	"Answer an OrderedCollection of the receiver's and the receiver's  
	ancestor's superclasses. The first element is the receiver's immediate  
	superclass, followed by its superclass; the last element is Object."

	| temp |
	^ superclass == nil
		ifTrue: [ OrderedCollection new ]
		ifFalse: [ temp := superclass allSuperclasses.
			temp addFirst: superclass.
			temp ]
]

Behavior >> allSuperclassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the receiver's superclasses."

	superclass == nil
		ifFalse: [ aBlock value: superclass.
			superclass allSuperclassesDo: aBlock ]
]

Behavior >> allSuperclassesIncluding: aClass
[
	"Answer an OrderedCollection of the receiver's and the receiver's  ancestor's superclasses
	up to aClass included. If aClass is not part of the receiver's superclass, returns up to the root."

	| temp |
	self class == ProtoObject class
		ifTrue: [ ^ OrderedCollection new ].
	^ superclass == aClass
		ifTrue: [ OrderedCollection with: aClass ]
		ifFalse: [ temp := superclass allSuperclassesIncluding: aClass.
			temp addFirst: superclass.
			temp ]
]

Behavior >> allUnreferencedInstanceVariables
[
	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"

	^ self allInstVarNames
		reject: [ :ivn | | definingClass |
			definingClass := self classThatDefinesInstanceVariable: ivn.
			definingClass withAllSubclasses anySatisfy: [ :class | (class whichSelectorsAccess: ivn asSymbol) notEmpty ] ]
]

Behavior >> allowsSubInstVars
[
	"Classes that allow instances to change classes among its subclasses will want to override this and return false, so inst vars are not accidentally added to its subclasses."

	^ true
]

Behavior >> applyChangesOfNewTraitCompositionReplacing: oldComposition
[
	| changedSelectors |
	changedSelectors := self traitComposition changedSelectorsComparedTo: oldComposition.
	changedSelectors isEmpty
		ifFalse: [ self noteChangedSelectors: changedSelectors ].
	self traitComposition isEmpty
		ifTrue: [ self purgeLocalSelectors ].
	^ changedSelectors
]

Behavior >> basicAddSelector: selector withMethod: compiledMethod
[
	"Add the message selector with the corresponding compiled method to the 
	receiver's method dictionary.
	Do this without sending system change notifications"

	| oldMethodOrNil |
	oldMethodOrNil := self lookupSelector: selector.
	self methodDict at: selector put: compiledMethod.
	compiledMethod methodClass: self.
	compiledMethod selector: selector.	"Now flush Pharo's method cache, either by selector or by method"
	oldMethodOrNil ifNotNil: [ oldMethodOrNil flushCache ].
	selector flushCache
]

Behavior >> basicLocalSelectors
[
	"Direct accessor for the instance variable localSelectors.
	Because of hardcoded ivar indexes of Behavior and Class in the VM, Class and
	Metaclass declare the needed ivar and override this method as an accessor. 
	By returning nil instead of declaring this method as a subclass responsibility,
	Behavior can be instantiated for creating anonymous classes."

	^ nil
]

Behavior >> basicLocalSelectors: aSetOrNil
[
	self subclassResponsibility
]

Behavior >> basicNew
[
	"Primitive. Answer an instance of the receiver (which is a class) with no 
	indexable variables. Fail if the class is indexable. Essential. See Object 
	documentation whatIsAPrimitive."

	<primitive: 70>
	self isVariable
		ifTrue: [ ^ self basicNew: 0 ].	"space must be low"
	OutOfMemory signal.
	^ self basicNew	"retry if user proceeds"
]

Behavior >> basicNew: sizeRequested
[
	"Primitive. Answer an instance of this class with the number
	of indexable variables specified by the argument, sizeRequested.
	Fail if this class is not indexable or if the argument is not a
	positive Integer, or if there is not enough memory available. 
	Essential. See Object documentation whatIsAPrimitive."

	<primitive: 71>
	self isVariable
		ifFalse: [ self error: self printString , ' cannot have variable sized instances' ].
	(sizeRequested isInteger and: [ sizeRequested >= 0 ])
		ifTrue: [ "arg okay; space must be low."
			OutOfMemory signal.
			^ self basicNew: sizeRequested	"retry if user proceeds" ].
	self primitiveFailed
]

Behavior >> basicRemoveSelector: selector
[
	"Assuming that the argument, selector (a Symbol), is a message selector 
	in my method dictionary, remove it and its method."

	| oldMethod |
	oldMethod := self methodDict at: selector ifAbsent: [ ^ self ].
	self methodDict removeKey: selector.	"Now flush Pharo's method cache, either by selector or by method"
	oldMethod flushCache.
	selector flushCache
]

Behavior >> becomeCompact
[
	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Pharo, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."

	| cct index |
	self isWeak
		ifTrue: [ ^ Halt halt: 'You must not make a weak class compact' ].
	cct := Smalltalk compactClassesArray.
	(self isCompact or: [ cct includes: self ])
		ifTrue: [ ^ self halt: self name , 'is already compact' ].
	index := cct indexOf: nil ifAbsent: [ ^ self halt: 'compact class table is full' ].	"Install this class in the compact class table"
	cct at: index put: self.	"Update instspec so future instances will be compact"
	format := format + (index bitShift: 11).	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.	"Purge any old instances"
	Smalltalk garbageCollect
]

Behavior >> becomeCompactSimplyAt: index
[
	"Make me compact, but don't update the instances.  For importing segments."

	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Pharo, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."

	| cct |
	self isWeak
		ifTrue: [ ^ Halt halt: 'You must not make a weak class compact' ].
	cct := Smalltalk compactClassesArray.
	(self isCompact or: [ cct includes: self ])
		ifTrue: [ ^ self halt: self name , 'is already compact' ].
	(cct at: index) ifNotNil: [ ^ self halt: 'compact table slot already in use' ].	"Install this class in the compact class table"
	cct at: index put: self.	"Update instspec so future instances will be compact"
	format := format + (index bitShift: 11)	"Caller must convert the instances"
]

Behavior >> becomeUncompact
[
	| cct index |
	cct := Smalltalk compactClassesArray.
	(index := self indexIfCompact) = 0
		ifTrue: [ ^ self ].
	(cct includes: self)
		ifFalse: [ ^ self halt	"inconsistent state" ].
	self checkCanBeUncompact.	"Update instspec so future instances will not be compact"
	format := format - (index bitShift: 11).	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.	"Make sure there are no compact ones left around"
	Smalltalk garbageCollect.	"Remove this class from the compact class table"
	cct at: index put: nil
]

Behavior >> binding
[
	^ nil -> self
]

Behavior >> bindingOf: varName
[
	"Answer the binding of some variable resolved in the scope of the receiver"

	^ superclass bindingOf: varName
]

Behavior >> canPerform: selector
[
	"Answer whether the receiver can safely perform to the message whose selector 
	is the argument: it is not an abstract or cancelled method"

	^ self classAndMethodFor: selector do: [ :c :m | m isProvided ] ifAbsent: [ false ]
]

Behavior >> canUnderstand: selector
[
	"Answer whether the receiver can respond to the message whose selector 
	is the argument. The selector can be in the method dictionary of the 
	receiver's class or any of its superclasses."

	(self includesSelector: selector)
		ifTrue: [ ^ true ].
	superclass == nil
		ifTrue: [ ^ false ].
	^ superclass canUnderstand: selector
]

Behavior >> changeRecordsAt: selector
[
	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."

	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"

	^ ChangeSet
		scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [ ^ nil ])
		class: self
		meta: self isMeta
		category: (self whichCategoryIncludesSelector: selector)
		selector: selector
]

Behavior >> checkCanBeUncompact
[
	"Certain classes cannot be uncompacted in CogVM. Â If you download VMMaker and see the VM code, these are as defined by StackInterpreter>>#checkAssumedCompactClasses and the ones that can't be uncompacted are the following: "

	({Array.
	LargeNegativeInteger.
	LargePositiveInteger.
	Float.
	MethodContext} includes: self)
		ifTrue: [ self error: 'Class ' , self name , ' cannot be uncompact. ' ]
]

Behavior >> classAndMethodFor: aSymbol do: binaryBlock ifAbsent: absentBlock
[
	"Looks up the selector aSymbol in the class chain. If it is found, binaryBlock is evaluated
	with the class that defines the selector and the associated method. Otherwise
	absentBlock is evaluated."

	self
		withAllSuperclassesDo: [ :class | | method |
			method := class compiledMethodAt: aSymbol ifAbsent: [ nil ].
			method ifNotNil: [ ^ binaryBlock value: class value: method ] ].
	^ absentBlock value
]

Behavior >> classBindingOf: varName
[
	"Answer the binding of some variable resolved in the scope of the receiver's class"

	^ self bindingOf: varName
]

Behavior >> classDepth
[
	superclass ifNil: [ ^ 1 ].
	^ superclass classDepth + 1
]

Behavior >> classVarNames
[
	"Answer a collection of the receiver's class variable names."

	^ #()
]

Behavior >> classesComposedWithMe
[
	^ {self}
]

Behavior >> cleanUp
[
	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. Subclasses may override #cleanUp: to provide different levels of cleanliness"

	
]

Behavior >> cleanUp: aggressive
[
	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. The argument should be used to indicate how aggressive the cleanup should be. Some subclasses may act differently depending on its value - for example, ChangeSet will only delete all unused and reinitialize the current change set if we're asking it to be aggressive."

	^ self cleanUp
]

Behavior >> commentsAt: selector
[
	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."

	^ self commentsIn: (self sourceCodeAt: selector) asString	"Behavior commentsAt: #commentsAt:"
]

Behavior >> commentsIn: sourceString
[
	| commentStart nextQuotePos someComments aPos |
	('*"*' match: sourceString)
		ifFalse: [ ^ #() ].
	someComments := OrderedCollection new.
	sourceString size = 0
		ifTrue: [ ^ someComments ].
	aPos := 1.
	nextQuotePos := 0.
	[ commentStart := sourceString findString: '"' startingAt: aPos.
	nextQuotePos := self nextQuotePosIn: sourceString startingFrom: commentStart.
	commentStart ~= 0 and: [ nextQuotePos > commentStart ] ]
		whileTrue: [ commentStart ~= nextQuotePos
				ifTrue: [ someComments add: ((sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"') ].
			aPos := nextQuotePos + 1 ].
	^ someComments
]

Behavior >> compile: code
[
	"Compile the argument, code, as source code in the context of the 
	receiver. Create an error notification if the code can not be compiled. 
	The argument is either a string or an object that converts to a string or a 
	PositionableStream on an object that converts to a string."

	^ self compile: code notifying: nil
]

Behavior >> compile: code classified: category notifying: requestor trailer: bytes ifFail: failBlock
[
	"Compile code without logging the source in the changes file"

	| methodNode |
	methodNode := self compilerClass new
		compile: code
		in: self
		classified: category
		notifying: requestor
		ifFail: failBlock.
	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: bytes
]

Behavior >> compile: code notifying: requestor
[
	"Compile the argument, code, as source code in the context of the 
	receiver and insEtall the result in the receiver's method dictionary. The 
	second argument, requestor, is to be notified if an error occurs. The 
	argument code is either a string or an object that converts to a string or 
	a PositionableStream. This method also saves the source code."

	| methodAndNode |
	methodAndNode := self
		compile: code
		classified: nil
		notifying: requestor
		trailer: self defaultMethodTrailer
		ifFail: [ ^ nil ].	"a Text"
	methodAndNode method
		putSource: code
		fromParseNode: methodAndNode node
		inFile: 2
		withPreamble: [ :f | f
				cr;
				nextPut: $!;
				nextChunkPut: 'Behavior method';
				cr ].
	self addSelector: methodAndNode selector withMethod: methodAndNode method notifying: requestor.
	^ methodAndNode selector
]

Behavior >> compileAll
[
	^ self compileAllFrom: self
]

Behavior >> compileAllFrom: oldClass
[
	"Compile all the methods in the receiver's method dictionary.
	This validates sourceCode and variable references and forces
	all methods to use the current bytecode set"

	| binding |
	oldClass selectorsDo: [ :sel | self recompile: sel from: oldClass ].	"Ensure that we share a common binding after recompilation. This is so that ClassBuilder reshapes avoid creating new bindings for every method when recompiling a large class hierarchy."
	binding := self binding.
	self methodsDo: [ :m | m methodClassAssociation == binding
				ifFalse: [ m methodClassAssociation: binding ] ]
]

Behavior >> compiledMethodAt: selector
[
	"Answer the compiled method associated with the argument, selector (a 
	Symbol), a message selector in the receiver's method dictionary. If the 
	selector is not in the dictionary, create an error notification."

	^ self methodDict at: selector
]

Behavior >> compiledMethodAt: selector ifAbsent: aBlock
[
	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"

	^ self methodDict at: selector ifAbsent: [ aBlock value ]
]

Behavior >> compilerClass
[
	"Answer a compiler class appropriate for source methods of this class."

	^ Smalltalk compilerClass
]

Behavior >> compress
[
	"Compact the method dictionary of the receiver."

	self methodDict rehash
]

Behavior >> copiedFromSuperclass: method
[
	"Returns the methods that the receiver copied with its ancestors"

	self
		allSuperclassesDo: [ :cls | (cls includesSelector: method selector)
				ifTrue: [ (cls >> method selector) sourceCode = method sourceCode
						ifTrue: [ ^ {(cls >> method selector)} ]
						ifFalse: [ ^ #() ] ] ].
	^ #()
]

Behavior >> copiedMethodsFromSuperclass
[
	"Returns the methods that the receiver copied with its ancestors"

	| methods |
	methods := OrderedCollection new.
	self methodDict valuesDo: [ :method | methods addAll: (self copiedFromSuperclass: method) ].
	^ methods
]

Behavior >> copiesFromSuperclass: method
[
	"Checks whether the receiver copied the argument,  method, from its superclasses"

	self
		allSuperclassesDo: [ :cls | (cls includesSelector: method selector)
				ifTrue: [ ^ (cls >> method selector) sourceCode = method sourceCode ] ].
	^ false
]

Behavior >> copiesMethodsFromSuperclass
[
	"Checks whether the receiver copied some method from its superclass"

	self methodDict valuesDo: [ :method | (self copiesFromSuperclass: method)
				ifTrue: [ ^ true ] ].
	^ false
]

Behavior >> copyOfMethodDictionary
[
	"Return a copy of the receiver's method dictionary"

	^ self methodDict copy
]

Behavior >> decompile: selector
[
	"Find the compiled code associated with the argument, selector, as a 
	message selector in the receiver's method dictionary and decompile it. 
	Answer the resulting source code as a string. Create an error notification 
	if the selector is not in the receiver's method dictionary."

	^ self decompilerClass new decompile: selector in: self
]

Behavior >> decompilerClass
[
	"Answer a decompiler class appropriate for compiled methods of this class."

	^ self compilerClass decompilerClass
]

Behavior >> deepCopy
[
	"Classes should only be shallowCopied or made anew."

	^ self shallowCopy
]

Behavior >> defaultMethodTrailer
[
	^ CompiledMethodTrailer empty
]

Behavior >> deregisterLocalSelector: aSymbol
[
	self basicLocalSelectors notNil
		ifTrue: [ self basicLocalSelectors remove: aSymbol ifAbsent: [  ] ]
]

Behavior >> emptyMethodDictionary
[
	^ MethodDictionary new
]

Behavior >> ensureLocalSelectors
[
	"Ensures that the instance variable localSelectors is effectively used to maintain
	the set of local selectors.
	This method must be called before any non-local selectors are added to the
	method dictionary!"

	self basicLocalSelectors isNil
		ifTrue: [ self basicLocalSelectors: self selectors asSet ]
]

Behavior >> environment
[
	"Return the environment in which the receiver is visible"

	^ Smalltalk globals
]

Behavior >> evaluatorClass
[
	"Answer an evaluator class appropriate for evaluating expressions in the 
	context of this class."

	^ self compilerClass
]

Behavior >> firstCommentAt: selector
[
	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."

	| someComments |
	someComments := self commentsAt: selector.
	^ someComments isEmpty
		ifTrue: [ '' ]
		ifFalse: [ someComments first ]	"Behavior firstCommentAt: #firstCommentAt:"
]

Behavior >> firstPrecodeCommentFor: selector
[
	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"

	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"

	| parser source tree |
	(#(#Comment #Definition #Hierarchy) includes: selector)
		ifTrue: [ "Not really a selector"
			^ nil ].
	source := self sourceCodeAt: selector asSymbol ifAbsent: [ ^ nil ].
	parser := self parserClass new.
	tree := parser
		parse: source readStream
		class: self
		noPattern: false
		context: nil
		notifying: nil
		ifFail: [ ^ nil ].
	^ (tree comment ifNil: [ ^ nil ]) first
]

Behavior >> flattenDown: aTrait
[
	| selectors |
	[ self hasTraitComposition and: [ self traitComposition allTraits includes: aTrait ] ] assert.
	selectors := (self traitComposition transformationOfTrait: aTrait) selectors.
	self basicLocalSelectors: self basicLocalSelectors , selectors.
	self removeFromComposition: aTrait
]

Behavior >> flattenDownAllTraits
[
	self traitComposition allTraits do: [ :each | self flattenDown: each ].
	[ self traitComposition isEmpty ] assert.
	self traitComposition: nil
]

Behavior >> flushCache
[
	"Tell the interpreter to remove the contents of its method lookup cache, if it has 
	one.  Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 89>
	self primitiveFailed
]

Behavior >> formalHeaderPartsFor: aSelector
[
	"popeye"

	"olive oil"

	"RELAX!  The warning you may have just seen about possibly having a bad source file does not apply here, because this method *intends* to have its source code start with a comment.
	This method returns a collection giving the parts in the formal declaration for aSelector.  This parse is in support of schemes in which adjutant properties of a method can be declared via special comments secreted in the formal header
	The result will have
     	3 elements for a simple, argumentless selector.
		5 elements for a single-argument selector
		9 elements for a two-argument selector
		13 elements for a three-argument, selector
		etc...

	The syntactic elements are:

		1		comment preceding initial selector fragment

		2		first selector fragment
		3		comment following first selector fragment  (nil if selector has no arguments)

        ----------------------  (ends here for, e.g., #copy)

		4		first formal argument
		5		comment following first formal argument (nil if selector has only one argument)

        ----------------------  (ends here for, e.g., #copyFrom:)

		6		second keyword
		7		comment following second keyword
		8		second formal argument
		9		comment following second formal argument (nil if selector has only two arguments)

         ----------------------  (ends here for, e.g., #copyFrom:to:)

	Any nil element signifies an absent comment.
	NOTE: The comment following the final formal argument is *not* successfully retrieved by this method in its current form, though it can be obtained, if needed, by other means (e.g. calling #firstPrecodeCommentFor:).  Thus, the *final* element in the structure returned by this method is always going to be nil."

	^ Scanner new scanMessageParts: (self methodHeaderFor: aSelector)	"	Behavior class formalHeaderPartsFor: #formalHeaderPartsFor:"
]

Behavior >> formalParametersAt: aSelector
[
	"Return the names of the arguments used in this method."

	| source |
	source := self sourceCodeAt: aSelector ifAbsent: [ ^ #() ].	"for now"
	^ self parserClass new parseParameterNames: source
]

Behavior >> format
[
	"Answer an Integer that encodes the kinds and numbers of variables of 
	instances of the receiver."

	^ format
]

Behavior >> hasAbstractMethods
[
	"Tells whether the receiver locally defines an abstract method, i.e., a method sending subclassResponsibility"

	^ self methods anySatisfy: [ :cm | cm sendsSelector: #subclassResponsibility ]
]

Behavior >> hasMethods
[
	"Answer whether the receiver has any methods in its method dictionary."

	^ self methodDict notEmpty
]

Behavior >> hasTraitComposition
[
	self subclassResponsibility
]

Behavior >> includesBehavior: aClass
[
	^ self == aClass or: [ self inheritsFrom: aClass ]
]

Behavior >> includesLocalSelector: aSymbol
[
	^ self basicLocalSelectors isNil
		ifTrue: [ self includesSelector: aSymbol ]
		ifFalse: [ self localSelectors includes: aSymbol ]
]

Behavior >> includesSelector: aSymbol
[
	"Answer whether the message whose selector is the argument is in the 
	method dictionary of the receiver's class."

	^ self methodDict includesKey: aSymbol
]

Behavior >> includesSharedPoolNamed: aSharedPoolString
[
	"Answer whether the receiver uses the shared pool named aSharedPoolString"

	^ self sharedPools anySatisfy: [ :each | each name = aSharedPoolString ]
]

Behavior >> indexIfCompact
[
	"If these 5 bits are non-zero, then instances of this class
	will be compact.  It is crucial that there be an entry in
	Smalltalk compactClassesArray for any class so optimized.
	See the msgs becomeCompact and becomeUncompact."

	^ (format bitShift: -11) bitAnd: 16r1F	"Array indexIfCompactVerify if the compactClassesArray and indexIfCompact are coherenSmalltalk compactClassesArray doWithIndex: 	[:c :i | c == nil ifFalse:		[c indexIfCompact = i ifFalse: [self halt]]]"
]

Behavior >> inheritsFrom: aClass
[
	"Answer whether the argument, aClass, is on the receiver's superclass 
	chain."

	| aSuperclass |
	aSuperclass := superclass.
	[ aSuperclass == nil ]
		whileFalse: [ aSuperclass == aClass
				ifTrue: [ ^ true ].
			aSuperclass := aSuperclass superclass ].
	^ false
]

Behavior >> initialize
[
	"moved here from the class side's #new"

	super initialize.
	superclass := Object.	"no longer sending any messages, some of them crash the VM"
	methodDict := self emptyMethodDictionary.
	format := Object format
]

Behavior >> instSize
[
	"Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver."

	self flag: #instSizeChange.	"Smalltalk browseAllCallsOn: #instSizeChange"	"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ ((format bitShift: -1) bitAnd: 16rFF) - 1	Note also that every other method in this category will require	2 bits more of right shift after the change."
	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1
]

Behavior >> instSpec
[
	^ (format bitShift: -7) bitAnd: 16rF
]

Behavior >> instVarNames
[
	"Answer an Array of the instance variable names. Behaviors must make 
	up fake local instance variable names because Behaviors have instance 
	variables for the purpose of compiling methods, but these are not named 
	instance variables."

	| mySize superSize |
	mySize := self instSize.
	superSize := superclass == nil
		ifTrue: [ 0 ]
		ifFalse: [ superclass instSize ].
	mySize = superSize
		ifTrue: [ ^ #() ].
	^ (superSize + 1 to: mySize) collect: [ :i | 'inst' , i printString ]
]

Behavior >> instVarNamesAndOffsetsDo: aBinaryBlock
[
	"This is part of the interface between the compiler and a class's instance or field names.
	 The class should enumerate aBinaryBlock with the instance variable name strings and
	 their integer offsets.  The order is important. Names evaluated later will override the
	 same names occurring earlier."

	"Nothing to do here; ClassDescription introduces named instance variables"

	^ self
]

Behavior >> instanceCount
[
	"Answer the number of instances of the receiver that are currently in 
	use."

	| count |
	count := 0.
	self allInstancesDo: [ :x | count := count + 1 ].
	^ count
]

Behavior >> instancesSizeInMemory
[
	"Answers the number of bytes consumed by all its instances including their object header"

	| bytes |
	bytes := 0.
	self allInstancesDo: [ :each | bytes := bytes + each sizeInMemory ].
	^ bytes
]

Behavior >> isAliasSelector: aSymbol
[
	"Return true if the selector aSymbol is an alias defined
	in my or in another composition somewhere deeper in 
	the tree of traits compositions."

	^ (self includesLocalSelector: aSymbol) not
		and: [ self hasTraitComposition and: [ self traitComposition isAliasSelector: aSymbol ] ]
]

Behavior >> isAnonymous
[
	^ true
]

Behavior >> isBehavior
[
	"Return true if the receiver is a behavior"

	^ true
]

Behavior >> isBits
[
	"Answer whether the receiver contains just bits (not pointers)."

	^ self instSpec >= 6
]

Behavior >> isBytes
[
	"Answer whether the receiver has 8-bit instance variables."

	^ self instSpec >= 8
]

Behavior >> isCompact
[
	^ self indexIfCompact ~= 0
]

Behavior >> isComposedBy: aTrait
[
	"Answers if this object includes trait aTrait into its composition"

	aTrait isTrait
		ifFalse: [ self error: aTrait name , ' is not a Trait' ].
	^ self hasTraitComposition
		ifTrue: [ self traitComposition includesTrait: aTrait ]
		ifFalse: [ false ]
]

Behavior >> isDisabledSelector: selector
[
	^ self classAndMethodFor: selector do: [ :c :m | m isDisabled ] ifAbsent: [ false ]
]

Behavior >> isFixed
[
	"Answer whether the receiver does not have a variable (indexable) part."

	^ self isVariable not
]

Behavior >> isLocalAliasSelector: aSymbol
[
	"Return true if the selector aSymbol is an alias defined
	in my trait composition."

	^ (self includesLocalSelector: aSymbol) not
		and: [ self hasTraitComposition and: [ self traitComposition isLocalAliasSelector: aSymbol ] ]
]

Behavior >> isMeta
[
	^ false
]

Behavior >> isObsolete
[
	"Return true if the receiver is obsolete."

	^ self instanceCount = 0
]

Behavior >> isPointers
[
	"Answer whether the receiver contains just pointers (not bits)."

	^ self isBits not
]

Behavior >> isVariable
[
	"Answer whether the receiver has indexable variables."

	^ self instSpec >= 2
]

Behavior >> isWeak
[
	"Answer whether the receiver has contains weak references."

	^ self instSpec = 4
]

Behavior >> isWords
[
	"Answer true if the receiver is made of 32-bit instance variables."

	^ self isBytes not
]

Behavior >> kindOfSubclass
[
	"Answer a String that is the keyword that describes the receiver's kind 
	of subclass, either a regular subclass, a variableSubclass, a  
	variableByteSubclass, a variableWordSubclass, or a weakSubclass."

	self isWeak
		ifTrue: [ ^ ' weakSubclass: ' ].
	^ self isVariable
		ifTrue: [ self isBits
				ifTrue: [ self isBytes
						ifTrue: [ ' variableByteSubclass: ' ]
						ifFalse: [ ' variableWordSubclass: ' ] ]
				ifFalse: [ ' variableSubclass: ' ] ]
		ifFalse: [ ' subclass: ' ]
]

Behavior >> literalScannedAs: scannedLiteral notifying: requestor
[
	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).
	If scannedLiteral is not an association, answer it.
	Else, if it is of the form:
		nil->#NameOfMetaclass
	answer nil->theMetaclass, if any has that name, else report an error.
	Else, if it is of the form:
		#NameOfGlobalVariable->anythiEng
	answer the global, class, or pool association with that nameE, if any, else
	add it to Undeclared a answer the new Association."

	| key value |
	scannedLiteral isVariableBinding
		ifFalse: [ ^ scannedLiteral ].
	key := scannedLiteral key.
	value := scannedLiteral value.
	key isNil
		ifTrue: [ "###<metaclass soleInstance name>"
			(self bindingOf: value)
				ifNotNil: [ :assoc | (assoc value isKindOf: Behavior)
						ifTrue: [ ^ nil -> assoc value class ] ].
			requestor notify: 'No such metaclass'.
			^ false ].
	key isSymbol
		ifTrue: [ "##<global var name>"
			(self bindingOf: key) ifNotNil: [ :assoc | ^ assoc ].
			Undeclared at: key put: nil.
			^ Undeclared bindingOf: key ].
	requestor notify: '## must be followed by a non-local variable name'.
	^ false	"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"
]

Behavior >> localSelectors
[
	"Return a set of selectors defined locally.
	The instance variable is lazily initialized. If it is nil then there
	are no non-local selectors"

	^ self basicLocalSelectors isNil
		ifTrue: [ self selectors asSet ]
		ifFalse: [ self basicLocalSelectors ]
]

Behavior >> longPrintOn: aStream
[
	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  But, not useful for a class with a method dictionary."

	aStream
		nextPutAll: '<<too complex to show>>';
		cr
]

Behavior >> lookupSelector: selector
[
	"Look up the given selector in my methodDictionary.
	Return the corresponding method if found.
	Otherwise chase the superclass chain and try again.
	Return nil if no method is found."

	| lookupClass |
	lookupClass := self.
	[ lookupClass == nil ]
		whileFalse: [ (lookupClass includesSelector: selector)
				ifTrue: [ ^ lookupClass compiledMethodAt: selector ].
			lookupClass := lookupClass superclass ].
	^ nil
]

Behavior >> methodDict
[
	"The method dictionary of a class can be nil when we want to use the #cannotInterpret: hook. Indeed when a class dictionary is nil, the VM sends the message cannotInterpret: to the receiver but starting the look up in the superclass of the class whose method dictionary was nil.
	 Now the system relies that when the message methodDict is sent to a class a method dictionary is returned. In order to prevent the complaints of tools and IDE unaware of this feature, we fool them by providing an empty MethodDictionary. This will hopefully work in most cases, but the tools will loose the ability to modify the behaviour of this behavior. The user of #cannotInterpret: should be aware of this."

	methodDict == nil
		ifTrue: [ ^ MethodDictionary new ].
	^ methodDict
]

Behavior >> methodDict: aDictionary
[
	methodDict := aDictionary
]

Behavior >> methodDictAddSelectorSilently: selector withMethod: compiledMethod
[
	self basicAddSelector: selector withMethod: compiledMethod
]

Behavior >> methodDictionary
[
	"Convenience"

	^ self methodDict
]

Behavior >> methodDictionary: aDictionary
[
	self methodDict: aDictionary
]

Behavior >> methodHeaderFor: selector
[
	"Answer the string corresponding to the method header for the given selector"

	| sourceString parser |
	sourceString := self ultimateSourceCodeAt: selector ifAbsent: [ self standardMethodHeaderFor: selector ].
	(parser := self parserClass new) parseSelector: sourceString.
	^ sourceString asString copyFrom: 1 to: (parser endOfLastToken min: sourceString size)	"Behavior methodHeaderFor: #methodHeaderFor: "
]

Behavior >> methodsDo: aBlock
[
	"Evaluate aBlock for all the compiled methods in my method dictionary."

	^ self methodDict valuesDo: aBlock
]

Behavior >> name
[
	"Answer a String that is the name of the receiver."

	^ 'a subclass of ' , superclass name
]

Behavior >> new
[
	"Answer a new initialized instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."

	^ self basicNew initialize
]

Behavior >> new: sizeRequested
[
	"Answer an initialized instance of this class with the number of indexable
	variables specified by the argument, sizeRequested."

	^ (self basicNew: sizeRequested) initialize
]

Behavior >> nextQuotePosIn: sourceString startingFrom: commentStart
[
	| pos nextQuotePos |
	pos := commentStart + 1.
	[ (nextQuotePos := sourceString findString: '"' startingAt: pos) == (sourceString findString: '""' startingAt: pos)
		and: [ nextQuotePos ~= 0 ] ]
		whileTrue: [ pos := nextQuotePos + 2 ].
	^ nextQuotePos
]

Behavior >> nonObsoleteClass
[
	"Attempt to find and return the current version of this obsolete class"

	| obsName |
	obsName := self name.
	[ obsName beginsWith: 'AnObsolete' ] whileTrue: [ obsName := obsName copyFrom: 'AnObsolete' size + 1 to: obsName size ].
	^ self environment at: obsName asSymbol
]

Behavior >> noteChangedSelectors: aCollection
[
	"Start update of my methodDict (after changes to traits in traitComposition
	or after a local method was removed from my methodDict). The argument 
	is a collection of method selectors that may have been changed. Most of the time
	aCollection only holds one selector. But when there are aliases involved 
	there may be several method changes that have to be propagated to users."

	| affectedSelectors |
	affectedSelectors := IdentitySet new.
	aCollection do: [ :selector | affectedSelectors addAll: (self updateMethodDictionarySelector: selector) ].
	self notifyUsersOfChangedSelectors: affectedSelectors.
	^ affectedSelectors
]

Behavior >> notifyUsersOfChangedSelector: aSelector
[
	self notifyUsersOfChangedSelectors: (Array with: aSelector)
]

Behavior >> numberOfInstanceVariables
[
	^ self instVarNames size
]

Behavior >> obsolete
[
	"Invalidate and recycle local methods,
	e.g., zap the method dictionary if can be done safely."

	self canZapMethodDictionary
		ifTrue: [ self methodDict: self emptyMethodDictionary ].
	self hasTraitComposition
		ifTrue: [ self traitComposition traits do: [ :each | each removeUser: self ] ]
]

Behavior >> obsoleteSubclasses
[
	"Return all the weakly remembered obsolete subclasses of the receiver"

	| obs |
	obs := ObsoleteSubclasses at: self ifAbsent: [ ^ #() ].
	^ obs copyWithout: nil
]

Behavior >> originalName
[
	^ self isObsolete
		ifTrue: [ (self name copyFrom: 'AnObsolete' size + 1 to: self name size) asSymbol ]
		ifFalse: [ self name asSymbol ]
]

Behavior >> parserClass
[
	"Answer a parser class to use for parsing method headers."

	^ self compilerClass parserClass
]

Behavior >> postCopy
[
	super postCopy.
	self methodDictionary: self copyOfMethodDictionary
]

Behavior >> precodeCommentOrInheritedCommentFor: selector
[
	"Answer a string representing the first comment in the method associated 
	with selector, considering however only comments that occur before the 
	beginning of the actual code. If the version recorded in the receiver is 
	uncommented, look up the inheritance chain. Return nil if none found."

	| aSuper aComment |
	^ (aComment := self firstPrecodeCommentFor: selector) isEmptyOrNil
		ifTrue: [ (self == Behavior or: [ superclass == nil or: [ (aSuper := superclass whichClassIncludesSelector: selector) == nil ] ])
				ifFalse: [ aSuper precodeCommentOrInheritedCommentFor: selector ] ]
		ifFalse: [ aComment ]
]

Behavior >> prettyPrinterClass
[
	^ self compilerClass
]

Behavior >> printHierarchy
[
	"Answer a description containing the names and instance variable names 
	of all of the subclasses and superclasses of the receiver."

	| aStream index |
	index := 0.
	aStream := (String new: 16) writeStream.
	self allSuperclasses
		reverseDo: [ :aClass | aStream crtab: index.
			index := index + 1.
			aStream nextPutAll: aClass name.
			aStream space.
			aStream print: aClass instVarNames ].
	aStream cr.
	self printSubclassesOn: aStream level: index.
	^ aStream contents
]

Behavior >> printOn: aStream
[
	"Refer to the comment in Object|printOn:."

	aStream nextPutAll: 'a descendent of '.
	superclass printOn: aStream
]

Behavior >> printWithClosureAnalysisOn: aStream
[
	"Refer to the comment in Object|printOn:."

	aStream nextPutAll: 'a descendent of '.
	superclass printWithClosureAnalysisOn: aStream
]

Behavior >> purgeLocalSelectors
[
	self basicLocalSelectors: nil
]

Behavior >> recompile: selector
[
	"Compile the method associated with selector in the receiver's method dictionary."

	^ self recompile: selector from: self
]

Behavior >> recompile: selector from: oldClass
[
	"Compile the method associated with selector in the receiver's method dictionary."

	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"

	| method trailer methodNode |
	method := oldClass compiledMethodAt: selector.
	trailer := method trailer.
	methodNode := self compilerClass new
		compile: (oldClass sourceCodeAt: selector)
		in: self
		notifying: nil
		ifFail: [ ^ self ].	"Assume OK after proceed from SyntaxError"
	selector == methodNode selector
		ifFalse: [ self error: 'selector changed!' ].
	self basicAddSelector: selector withMethod: (methodNode generate: trailer)
]

Behavior >> recompileChanges
[
	"Compile all the methods that are in the changes file.
	This validates sourceCode and variable references and forces
	methods to use the current bytecode set"

	self selectorsAndMethodsDo: [ :sel :meth | meth fileIndex > 1
				ifTrue: [ self recompile: sel from: self ] ]
]

Behavior >> registerLocalSelector: aSymbol
[
	self basicLocalSelectors notNil
		ifTrue: [ self basicLocalSelectors add: aSymbol ]
]

Behavior >> removeAlias: aSymbol of: aTrait
[
	self setTraitComposition: (self traitComposition copyWithoutAlias: aSymbol of: aTrait)
]

Behavior >> removeAllObsoleteSubclasses
[
	"Remove all the obsolete subclasses of the receiver"

	ObsoleteSubclasses removeKey: self ifAbsent: [  ]
]

Behavior >> removeFromComposition: aTrait
[
	self setTraitComposition: (self traitComposition copyTraitExpression removeFromComposition: aTrait)
]

Behavior >> removeObsoleteSubclass: aClass
[
	"Remove aClass from the weakly remembered obsolete subclasses"

	| obs |
	obs := ObsoleteSubclasses at: self ifAbsent: [ ^ self ].
	(obs includes: aClass)
		ifFalse: [ ^ self ].
	obs := obs copyWithout: aClass.
	obs := obs copyWithout: nil.
	ObsoleteSubclasses at: self put: obs
]

Behavior >> removeSelector: aSelector
[
	"Assuming that the argument, selector (a Symbol), is a message selector 
	in my method dictionary, remove it and its method.
	
	If the method to remove will be replaced by a method from my trait composition,
	the current method does not have to be removed because we mark it as non-local.
	If it is not identical to the actual method from the trait it will be replaced automatically
	by #noteChangedSelectors:.
	
	This is useful to avoid bootstrapping problems when moving methods to a trait
	(e.g., from TPureBehavior to TMethodDictionaryBehavior). Manual moving (implementing
	the method in the trait and then remove it from the class) does not work if the methods
	themselves are used for this process (such as compiledMethodAt:, includesLocalSelector: or
	addTraitSelector:withMethod:)"

	| changeFromLocalToTraitMethod |
	changeFromLocalToTraitMethod := (self includesLocalSelector: aSelector)
		and: [ self hasTraitComposition and: [ self traitComposition includesMethod: aSelector ] ].
	changeFromLocalToTraitMethod
		ifFalse: [ self basicRemoveSelector: aSelector ]
		ifTrue: [ self ensureLocalSelectors ].
	self deregisterLocalSelector: aSelector.
	self noteChangedSelectors: (Array with: aSelector)
]

Behavior >> removeSelectorSilently: selector
[
	"Remove selector without sending system change notifications"

	^ SystemAnnouncer uniqueInstance suspendAllWhile: [ self removeSelector: selector ]
]

Behavior >> removeTraitSelector: aSymbol
[
	[ (self includesLocalSelector: aSymbol) not ] assert.
	self basicRemoveSelector: aSymbol
]

Behavior >> selectSubclasses: aBlock
[
	"Evaluate the argument, aBlock, with each of the receiver's (next level) 
	subclasses as its argument. Collect into a Set only those subclasses for 
	which aBlock evaluates to true. In addition, evaluate aBlock for the 
	subclasses of each of these successful subclasses and collect into the set 
	those for which aBlock evaluates true. Answer the resulting set."

	| aSet |
	aSet := Set new.
	self allSubclasses do: [ :aSubclass | (aBlock value: aSubclass)
				ifTrue: [ aSet add: aSubclass ] ].
	^ aSet
]

Behavior >> selectSuperclasses: aBlock
[
	"Evaluate the argument, aBlock, with the receiver's superclasses as the 
	argument. Collect into an OrderedCollection only those superclasses for 
	which aBlock evaluates to true. In addition, evaluate aBlock for the 
	superclasses of each of these successful superclasses and collect into the 
	OrderedCollection ones for which aBlock evaluates to true. Answer the 
	resulting OrderedCollection."

	| aSet |
	aSet := Set new.
	self allSuperclasses do: [ :aSuperclass | (aBlock value: aSuperclass)
				ifTrue: [ aSet add: aSuperclass ] ].
	^ aSet
]

Behavior >> selectors
[
	"Answer a Set of all the message selectors specified in the receiver's 
	method dictionary."

	^ self methodDict keys
]

Behavior >> selectorsAndMethodsDo: selectorAndMethodBlock
[
	"Evaluate selectorAndMethodBlock with two arguments for each selector/method pair in my method dictionary."

	^ self methodDict keysAndValuesDo: selectorAndMethodBlock
]

Behavior >> selectorsDo: selectorBlock
[
	"Evaluate selectorBlock for all the message selectors in my method dictionary."

	^ self methodDict keysDo: selectorBlock
]

Behavior >> selectorsWithArgs: numberOfArgs
[
	"Return all selectors defined in this class that take this number of arguments"

	^ self selectors select: [ :selector | selector numArgs = numberOfArgs ]
]

Behavior >> setFormat: aFormatInstanceDescription
[
	"only use this method with extreme care since it modifies the format of the class 
     ie a description of the number of instance variables and whether the class is
     compact, variable sized"

	format := aFormatInstanceDescription
]

Behavior >> setTraitComposition: aTraitComposition
[
	| oldComposition |
	(self hasTraitComposition not and: [ aTraitComposition isEmpty ])
		ifTrue: [ ^ self ].
	aTraitComposition assertValidUser: self.
	oldComposition := self traitComposition.
	self traitComposition: aTraitComposition.
	self applyChangesOfNewTraitCompositionReplacing: oldComposition.
	oldComposition traits do: [ :each | each removeUser: self ].
	aTraitComposition traits do: [ :each | each addUser: self ]
]

Behavior >> setTraitCompositionFrom: aTraitExpression
[
	^ self setTraitComposition: aTraitExpression asTraitComposition
]

Behavior >> sharedPools
[
	"Answer an ordered collection of  the shared pools that the receiver shares"

	^ OrderedCollection new
]

Behavior >> shouldNotBeRedefined
[
	"Return true if the receiver should not be redefined.
	The assumption is that compact classes,
	classes in Smalltalk specialObjects and 
	Behaviors should not be redefined"

	^ (Smalltalk compactClassesArray includes: self)
		or: [ (Smalltalk specialObjectsArray includes: self) or: [ self isKindOf: self ] ]
]

Behavior >> shutDown
[
	"This message is sent on system shutdown to registered classes"

	
]

Behavior >> shutDown: quitting
[
	"This message is sent on system shutdown to registered classes"

	^ self shutDown
]

Behavior >> someInstance
[
	"Primitive. Answer the first instance in the enumeration of all instances 
	of the receiver. Fails if there are none. Essential. See Object 
	documentation whatIsAPrimitive."

	<primitive: 77>
	^ nil
]

Behavior >> sourceCodeAt: selector
[
	^ (self methodDict at: selector) sourceCode
]

Behavior >> sourceCodeAt: selector ifAbsent: aBlock
[
	^ (self methodDict at: selector ifAbsent: [ ^ aBlock value ]) sourceCode
]

Behavior >> sourceCodeTemplate
[
	"Answer an expression to be edited and evaluated in order to define 
	methods in this class or trait."

	^ 'message selector and argument names	"comment stating purpose of message"	| temporary variable names |	statements'
]

Behavior >> sourceMatchesBytecodeAt: selector
[
	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false
	otherwise. Implemented to detect an error where Monticello did not recompile sources when the class
	shape changed"

	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a
	method which turned a selector and class into a CompiledMethod, without  installing it into the 
	methodDictionary"

	| method trailer methodNode |
	method := self compiledMethodAt: selector.
	trailer := method trailer.
	methodNode := self compilerClass new
		compile: (self sourceCodeAt: selector)
		in: self
		notifying: nil
		ifFail: [ ^ false ].	"Assume OK after proceed from SyntaxError"
	selector == methodNode selector
		ifFalse: [ self error: 'selector changed!!' ].
	^ (methodNode generate: trailer) = method
]

Behavior >> spaceUsed
[
	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."

	| space |
	space := 0.
	self
		methodsDo: [ :method | space := space + 16.	"dict and org'n space"
			space := space + (method size + 6).	"hdr + avg pad"
			method
				literalsDo: [ :lit | (lit isMemberOf: Array)
						ifTrue: [ space := space + ((lit size + 1) * 4) ].
					(lit isMemberOf: Float)
						ifTrue: [ space := space + 12 ].
					(lit isMemberOf: ByteString)
						ifTrue: [ space := space + (lit size + 6) ].
					(lit isMemberOf: LargeNegativeInteger)
						ifTrue: [ space := space + ((lit size + 1) * 4) ].
					(lit isMemberOf: LargePositiveInteger)
						ifTrue: [ space := space + ((lit size + 1) * 4) ] ] ].
	^ space
]

Behavior >> standardMethodHeaderFor: aSelector
[
	| args |
	args := (1 to: aSelector numArgs) collect: [ :i | 'arg' , i printString ].
	args size = 0
		ifTrue: [ ^ aSelector asString ].
	args size = 1
		ifTrue: [ ^ aSelector , ' arg1' ].
	^ String
		streamContents: [ :s | (aSelector findTokens: ':')
				with: args
				do: [ :tok :arg | s
						nextPutAll: tok;
						nextPutAll: ': ';
						nextPutAll: arg;
						nextPutAll: ' ' ] ]
]

Behavior >> startUp
[
	"This message is sent to registered classes when the system is coming up."

	
]

Behavior >> startUp: resuming
[
	"This message is sent to registered classes when the system is coming up."

	^ self startUp
]

Behavior >> storeLiteral: aCodeLiteral on: aStream
[
	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName
	 or ###MetaclassSoleInstanceName format if appropriate"

	| key value |
	aCodeLiteral isVariableBinding
		ifFalse: [ aCodeLiteral storeOn: aStream.
			^ self ].
	key := aCodeLiteral key.
	(key isNil and: [ (value := aCodeLiteral value) isMemberOf: Metaclass ])
		ifTrue: [ aStream
				nextPutAll: '###';
				nextPutAll: value soleInstance name.
			^ self ].
	(key isSymbol and: [ (self bindingOf: key) notNil ])
		ifTrue: [ aStream
				nextPutAll: '##';
				nextPutAll: key.
			^ self ].
	aCodeLiteral storeOn: aStream
]

Behavior >> subclassDefinerClass
[
	"Answer an evaluator class appropriate for evaluating definitions of new 
	subclasses of this class."

	^ self compilerClass
]

Behavior >> subclassInstVarNames
[
	"Answer a Set of the names of the receiver's subclasses' instance 
	variables."

	| vars |
	vars := Set new.
	self allSubclasses do: [ :aSubclass | vars addAll: aSubclass instVarNames ].
	^ vars
]

Behavior >> subclasses
[
	"slow implementation since Behavior does not keep trace of subclasses"

	^ self class allInstances select: [ :each | each superclass = self ]
]

Behavior >> subclassesDo: aBlock
[
	self subclasses do: aBlock
]

Behavior >> superclass
[
	"Answer the receiver's superclass, a Class."

	^ superclass
]

Behavior >> superclass: aClass
[
	"Change the receiver's superclass to be aClass."

	"Note: Do not use 'aClass isKindOf: Behavior' here
		in case we recompile from Behavior itself."

	(aClass == nil or: [ aClass isBehavior ])
		ifTrue: [ superclass := aClass.
			Object flushCache ]
		ifFalse: [ self error: 'superclass must be a class-describing object' ]
]

Behavior >> superclass: aClass methodDictionary: mDict format: fmt
[
	"Basic initialization of the receiver.
	Must only be sent to a new instance; else we would need Object flushCache."

	superclass := aClass.
	format := fmt.
	methodDict := mDict.
	self traitComposition: nil
]

Behavior >> supermostPrecodeCommentFor: selector
[
	"Answer a string representing the precode comment in the most distant 
	superclass's implementation of the selector. Return nil if none found."

	| aSuper superComment |
	(self == Behavior or: [ superclass == nil or: [ (aSuper := superclass whichClassIncludesSelector: selector) == nil ] ])
		ifFalse: [ "There is a super implementor"
			superComment := aSuper supermostPrecodeCommentFor: selector ].
	^ superComment ifNil: [ self firstPrecodeCommentFor: selector	"ActorState supermostPrecodeCommentFor: #printOn:" ]
]

Behavior >> thoroughHasSelectorReferringTo: literal special: specialFlag byte: specialByte
[
	"Answer true if any of my methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	self
		methodsDo: [ :method | ((method hasLiteralThorough: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])
				ifTrue: [ ^ true ] ].
	^ false
]

Behavior >> thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte
[
	"Answer a set of selectors whose methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	| selectors |
	selectors := IdentitySet new.
	self
		selectorsAndMethodsDo: [ :sel :method | ((method refersToLiteral: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])
				ifTrue: [ selectors add: sel ] ].
	^ selectors
]

Behavior >> traitComposition
[
	self subclassResponsibility
]

Behavior >> traitComposition: aTraitComposition
[
	self subclassResponsibility
]

Behavior >> traitCompositionIncludes: aTrait
[
	^ self == aTrait or: [ self hasTraitComposition and: [ self traitComposition allTraits includes: aTrait ] ]
]

Behavior >> traitCompositionString
[
	^ self hasTraitComposition
		ifTrue: [ self traitComposition asString ]
		ifFalse: [ '{}' ]
]

Behavior >> traitOrClassOfSelector: aSymbol
[
	"Return the trait or the class which originally defines the method aSymbol
	or return self if locally defined or if it is a conflict marker method.
	This is primarly used by Debugger to determin the behavior in which a recompiled
	method should be put. If a conflict method is recompiled it should be put into
	the class, thus return self. Also see TraitComposition>>traitProvidingSelector:"

	((self includesLocalSelector: aSymbol) or: [ self hasTraitComposition not ])
		ifTrue: [ ^ self ].
	^ (self traitComposition traitProvidingSelector: aSymbol) ifNil: [ self ]
]

Behavior >> traitTransformations
[
	^ self traitComposition transformations
]

Behavior >> traits
[
	"Returns a collection of all traits used by the receiver"

	^ self traitComposition traits
]

Behavior >> traitsProvidingSelector: aSymbol
[
	| result |
	result := OrderedCollection new.
	self hasTraitComposition
		ifFalse: [ ^ result ].
	(self traitComposition methodDescriptionsForSelector: aSymbol)
		do: [ :methodDescription | methodDescription selector = aSymbol
				ifTrue: [ result addAll: (methodDescription locatedMethods collect: [ :each | each methodClass ]) ] ].
	^ result
]

Behavior >> typeOfClass
[
	"Answer a symbol uniquely describing the type of the receiver"

	self instSpec = CompiledMethod instSpec
		ifTrue: [ ^ #compiledMethod ].	"Very special!"
	self isBytes
		ifTrue: [ ^ #bytes ].
	(self isWords and: [ self isPointers not ])
		ifTrue: [ ^ #words ].
	self isWeak
		ifTrue: [ ^ #weak ].
	self isVariable
		ifTrue: [ ^ #variable ].
	^ #normal
]

Behavior >> ultimateSourceCodeAt: selector ifAbsent: aBlock
[
	"Return the source code at selector, deferring to superclass if necessary"

	^ self
		sourceCodeAt: selector
		ifAbsent: [ superclass ifNil: [ aBlock value ] ifNotNil: [ superclass ultimateSourceCodeAt: selector ifAbsent: aBlock ] ]
]

Behavior >> unreferencedInstanceVariables
[
	"Return a list of the instance variables defined in the receiver which are not referenced in the receiver or any of its subclasses."

	^ self instVarNames
		reject: [ :ivn | self withAllSubclasses anySatisfy: [ :class | (class whichSelectorsAccess: ivn) notEmpty ] ]
]

Behavior >> updateMethodDictionarySelector: aSymbol
[
	"A method with selector aSymbol in myself or my traitComposition has been changed.
	Do the appropriate update to my methodDict (remove or update method) and
	return all affected selectors of me so that my useres get notified."

	| modifiedSelectors descriptions oldProtocol |
	modifiedSelectors := IdentitySet new.
	descriptions := self traitComposition methodDescriptionsForSelector: aSymbol.
	descriptions
		do: [ :methodDescription | | effectiveMethod selector |
			selector := methodDescription selector.
			(self includesLocalSelector: selector)
				ifFalse: [ methodDescription isEmpty
						ifTrue: [ self removeTraitSelector: selector.
							modifiedSelectors add: selector ]
						ifFalse: [ effectiveMethod := methodDescription effectiveMethod.
							self addTraitSelector: selector withMethod: effectiveMethod.	"If the method was not categorized yet, we categorize it "
							oldProtocol := self organization categoryOfElement: selector.
							(oldProtocol isNil or: [ oldProtocol = ClassOrganizer default ])
								ifTrue: [ self organization classify: selector under: methodDescription effectiveMethodCategory ].
							modifiedSelectors add: selector ] ] ].
	^ modifiedSelectors
]

Behavior >> variablesAndOffsetsDo: aBinaryBlock
[
	"This is the interface between the compiler and a class's instance or field names.  The
	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed
	 by the instance variable name strings and their integer offsets (1-relative).  The order is
	 important; names evaluated later will override the same names occurring earlier."

	"Only need to do instance variables here.  CProtoObject introduces field definitions."

	self instVarNamesAndOffsetsDo: aBinaryBlock
]

Behavior >> whichClassDefinesClassVar: aString
[
	Symbol
		hasInterned: aString
		ifTrue: [ :aSymbol | ^ self whichSuperclassSatisfies: [ :aClass | aClass classVarNames anySatisfy: [ :each | each = aSymbol ] ] ].
	^ #()
]

Behavior >> whichClassDefinesInstVar: aString
[
	^ self whichSuperclassSatisfies: [ :aClass | aClass instVarNames includes: aString ]
]

Behavior >> whichClassIncludesSelector: aSymbol
[
	"Answer the class on the receiver's superclass chain where the 
	argument, aSymbol (a message selector), will be found. Answer nil if none found."

	"Rectangle whichClassIncludesSelector: #inspect."

	(self includesSelector: aSymbol)
		ifTrue: [ ^ self ].
	superclass == nil
		ifTrue: [ ^ nil ].
	^ superclass whichClassIncludesSelector: aSymbol
]

Behavior >> whichSelectorsAccess: instVarName
[
	"Answer a set of selectors whose methods access the argument, 
	instVarName, as a named instance variable."

	| instVarIndex |
	instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^ IdentitySet new ].
	^ self selectors
		select: [ :sel | ((self methodDict at: sel) readsField: instVarIndex) or: [ (self methodDict at: sel) writesField: instVarIndex ] ]	"Point whichSelectorsAccess: 'x'."
]

Behavior >> whichSelectorsAssign: instVarName
[
	"Answer a Set of selectors whose methods store into the argument, 
	instVarName, as a named instance variable."

	^ self whichSelectorsStoreInto: instVarName
]

Behavior >> whichSelectorsRead: instVarName
[
	"Answer a Set of selectors whose methods access the argument, 
	instVarName, as a named instance variable."

	^ self whichSelectorsAccess: instVarName
]

Behavior >> whichSelectorsReferTo: literal
[
	"Answer a Set of selectors whose methods access the argument as a
literal."

	| special byte |
	special := Smalltalk hasSpecialSelector: literal ifTrueSetByte: [ :b | byte := b ].
	^ self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."
]

Behavior >> whichSelectorsReferTo: literal special: specialFlag byte: specialByte
[
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |
	who := IdentitySet new.
	self
		selectorsAndMethodsDo: [ :sel :method | ((method hasLiteral: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])
				ifTrue: [ (literal isVariableBinding not or: [ method literals allButLast includes: literal ])
						ifTrue: [ who add: sel ] ] ].
	^ who
]

Behavior >> whichSelectorsStoreInto: instVarName
[
	"Answer a Set of selectors whose methods access the argument, 
	instVarName, as a named instance variable."

	| instVarIndex |
	instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^ IdentitySet new ].
	^ self selectors select: [ :sel | (self methodDict at: sel) writesField: instVarIndex ]	"Point whichSelectorsStoreInto: 'x'."
]

Behavior >> whichSuperclassSatisfies: aBlock
[
	(aBlock value: self)
		ifTrue: [ ^ self ].
	^ superclass isNil
		ifTrue: [ nil ]
		ifFalse: [ superclass whichSuperclassSatisfies: aBlock ]
]

Behavior >> withAllSubAndSuperclassesDo: aBlock
[
	self withAllSubclassesDo: aBlock.
	self allSuperclassesDo: aBlock
]

Behavior >> withAllSubclasses
[
	"Answer a Set of the receiver, the receiver's descendent's, and the  
	receiver's descendent's subclasses."

	^ self allSubclasses
		add: self;
		yourself
]

Behavior >> withAllSubclassesDo: aBlock
[
	"Evaluate the argument, aBlock, for the receiver and each of its 
	subclasses."

	aBlock value: self.
	self allSubclassesDo: aBlock
]

Behavior >> withAllSuperAndSubclassesDo: aBlock
[
	self allSuperclassesDo: aBlock.
	aBlock value: self.
	self allSubclassesDo: aBlock
]

Behavior >> withAllSuperclasses
[
	"Answer an OrderedCollection of the receiver and the receiver's 
	superclasses. The first element is the receiver, 
	followed by its superclass; the last element is Object."

	| temp |
	temp := self allSuperclasses.
	temp addFirst: self.
	^ temp
]

Behavior >> withAllSuperclassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the receiver's superclasses."

	aBlock value: self.
	superclass == nil
		ifFalse: [ superclass withAllSuperclassesDo: aBlock ]
]

Behavior >> zapAllMethods
[
	"Remove all methods in this class which is assumed to be obsolete"

	methodDict := self emptyMethodDictionary.
	self class isMeta
		ifTrue: [ self class zapAllMethods ]
]

Behavior class >> canZapMethodDictionary
[
	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."

	^ false
]

Behavior class >> cleanUp
[
	"Flush the obsolete subclasses."

	self flushObsoleteSubclasses
]

Behavior class >> flushObsoleteSubclasses
[
	"Behavior flushObsoleteSubclasses"

	ObsoleteSubclasses finalizeValues
]

Behavior class >> initialize
[
	"Behavior initialize"

	"Never called for real"

	ObsoleteSubclasses
		ifNil: [ self initializeObsoleteSubclasses ]
		ifNotNil: [ | newDict |
			newDict := WeakKeyToCollectionDictionary newFrom: ObsoleteSubclasses.
			newDict rehash.
			ObsoleteSubclasses := newDict ]
]

Behavior class >> initializeObsoleteSubclasses
[
	ObsoleteSubclasses := WeakKeyToCollectionDictionary new
]

