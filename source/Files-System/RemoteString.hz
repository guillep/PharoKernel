RemoteString
	instanceVariables: #(#sourceFileNumber #filePositionHi );
	package: #'Files-System'.

RemoteString >> checkSum: aString
[
	"Construct a checksum of the string.  A three byte number represented as Base64 characters."

	| sum shift bytes |
	sum := aString size.
	shift := 0.
	aString
		do: [ :char | (shift := shift + 7) > 16
				ifTrue: [ shift := shift - 17 ].	"shift by 7 to keep a change of adjacent chars from xoring to same value"
			sum := sum bitXor: (char asInteger bitShift: shift) ].
	bytes := ByteArray new: 3.
	sum := sum + 16r10000000000.
	1 to: 3 do: [ :ind | bytes at: ind put: (sum digitAt: ind) ].
	^ bytes base64Encoded
]

RemoteString >> fileNumber: fileNumber position: position
[
	sourceFileNumber := fileNumber.
	filePositionHi := position
]

RemoteString >> fileStream
[
	"Answer the file stream with position set at the beginning of my string.
	Answer a read only copy to avoid syntax errors when accessed via
	multiple processes."

	| theFile |
	(sourceFileNumber == nil or: [ (SourceFiles at: sourceFileNumber) == nil ])
		ifTrue: [ ^ nil ].
	theFile := (SourceFiles at: sourceFileNumber) flush readOnlyCopy.
	filePositionHi > theFile size
		ifTrue: [ self error: 'RemoteString past end of file' ].
	theFile position: filePositionHi.
	^ theFile
]

RemoteString >> last
[
	^ self string ifNotNil: [ :s | s last ]
]

RemoteString >> position
[
	"Answer the location of the string on a file."

	^ filePositionHi
]

RemoteString >> setSourcePointer: aSourcePointer
[
	sourceFileNumber := SourceFiles fileIndexFromSourcePointer: aSourcePointer.
	filePositionHi := SourceFiles filePositionFromSourcePointer: aSourcePointer
]

RemoteString >> sourceFileNumber
[
	"Answer the index of the file on which the string is stored."

	^ sourceFileNumber
]

RemoteString >> sourcePointer
[
	sourceFileNumber ifNil: [ ^ 0 ].
	^ SourceFiles sourcePointerFromFileIndex: sourceFileNumber andPosition: filePositionHi
]

RemoteString >> string
[
	"Answer the receiver's string if remote files are enabled.
	Use a read only copy to avoid syntax errors when accessed via
	multiple processes."

	| theFile |
	(sourceFileNumber == nil or: [ (SourceFiles at: sourceFileNumber) == nil ])
		ifTrue: [ ^ '' ].
	theFile := (SourceFiles at: sourceFileNumber) flush readOnlyCopy.
	^ [ filePositionHi > theFile size
		ifTrue: [ self error: 'RemoteString past end of file' ].
	theFile position: filePositionHi.
	theFile nextChunk ]
		ensure: [ theFile close ]
]

RemoteString >> string: aString onFileNumber: fileNumber
[
	"Store this as my string if source files exist."

	| theFile |
	(SourceFiles at: fileNumber) == nil
		ifFalse: [ theFile := SourceFiles at: fileNumber.
			theFile
				setToEnd;
				cr.
			self string: aString onFileNumber: fileNumber toFile: theFile ]
]

RemoteString >> string: aString onFileNumber: fileNumber toFile: aFileStream
[
	"Store this as the receiver's string if source files exist."

	| position |
	position := aFileStream position.
	self fileNumber: fileNumber position: position.
	aFileStream nextChunkPut: aString.
	^ self
]

RemoteString >> text
[
	"Answer the receiver's string asText if remote files are enabled.
	Use a read only copy to avoid syntax errors when accessed via
	multiple processes."

	"| theFile |
	self haltOnce.
	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].
	theFile := (SourceFiles at: sourceFileNumber) readOnlyCopy.
	^[theFile position: filePositionHi.
	theFile position > theFile size ifTrue: [
		self error: 'RemoteString past end of file' ].
	theFile nextChunkText string ] ensure: [theFile close]"

	"Code saved should only be ascii and we do not want to have the encoding at the end of the chunk
	this is why we extract the string and convert instead of invoking nextChunkText"

	^ self string asText
]

RemoteString class >> newFileNumber: sourceIndex position: anInteger
[
	"Answer an instance of me fora file indexed by sourceIndex, at the 
	position anInteger. Assume that the string is already stored on the file 
	and the instance will be used to access it."

	^ self new fileNumber: sourceIndex position: anInteger
]

RemoteString class >> newString: aString onFileNumber: sourceIndex
[
	"Answer an instance of me for string, aString, on file indexed by 
	sourceIndex. Put the string on the file and create the remote reference."

	^ self new string: aString onFileNumber: sourceIndex
]

RemoteString class >> newString: aString onFileNumber: sourceIndex toFile: aFileStream
[
	"Answer an instance of me for string, aString, on file indexed by 
	sourceIndex. Put the string on the file, aFileStream, and create the 
	remote reference. Assume that the index corresponds properly to 
	aFileStream."

	^ self new string: aString onFileNumber: sourceIndex toFile: aFileStream
]

