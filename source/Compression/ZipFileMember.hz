ZipFileMember
	superclass: #ZipArchiveMember;
	instanceVariables: #(#externalFileName #stream #localHeaderRelativeOffset #dataOffset );
	package: #Compression.

ZipFileMember >> canonicalizeFileName
[
	"For security reasons, make all paths relative and remove any ../ portions"

	[ fileName beginsWith: '/' ] whileTrue: [ fileName := fileName allButFirst ].
	fileName := fileName copyReplaceAll: '../' with: ''
]

ZipFileMember >> close
[
	stream ifNotNil: [ stream close ]
]

ZipFileMember >> copyDataTo: aStream
[
	self copyRawDataTo: aStream
]

ZipFileMember >> initialize
[
	super initialize.
	crc32 := 0.
	localHeaderRelativeOffset := 0.
	dataOffset := 0
]

ZipFileMember >> localHeaderRelativeOffset
[
	^ localHeaderRelativeOffset
]

ZipFileMember >> looksLikeDirectory
[
	^ fileName last = $/ and: [ uncompressedSize = 0 ]
]

ZipFileMember >> readCentralDirectoryFileHeaderFrom: aStream
[
	"Assumes aStream positioned after signature"

	| fileNameLength extraFieldLength fileCommentLength |
	self versionMadeBy: (aStream nextLittleEndianNumber: 1).
	fileAttributeFormat := aStream nextLittleEndianNumber: 1.
	self versionNeededToExtract: (aStream nextLittleEndianNumber: 2).
	self bitFlag: (aStream nextLittleEndianNumber: 2).
	compressionMethod := aStream nextLittleEndianNumber: 2.
	lastModFileDateTime := self unzipTimestamp: (aStream nextLittleEndianNumber: 4).
	crc32 := aStream nextLittleEndianNumber: 4.
	compressedSize := aStream nextLittleEndianNumber: 4.
	uncompressedSize := aStream nextLittleEndianNumber: 4.
	fileNameLength := aStream nextLittleEndianNumber: 2.
	extraFieldLength := aStream nextLittleEndianNumber: 2.
	fileCommentLength := aStream nextLittleEndianNumber: 2.
	aStream nextLittleEndianNumber: 2.	"disk number start"
	internalFileAttributes := aStream nextLittleEndianNumber: 2.
	externalFileAttributes := aStream nextLittleEndianNumber: 4.
	localHeaderRelativeOffset := aStream nextLittleEndianNumber: 4.
	fileName := (aStream next: fileNameLength) asString.
	cdExtraField := (aStream next: extraFieldLength) asByteArray asString.
	fileComment := (aStream next: fileCommentLength) asString convertFromSystemString.
	self desiredCompressionMethod: compressionMethod
]

ZipFileMember >> readFrom: aStream
[
	"assumes aStream positioned after CD header; leaves stream positioned after my CD entry"

	self readCentralDirectoryFileHeaderFrom: aStream.
	self readLocalDirectoryFileHeaderFrom: aStream.
	self endRead.
	self canonicalizeFileName
]

ZipFileMember >> readLocalDirectoryFileHeaderFrom: aStream
[
	"Positions stream as necessary. Will return stream to its original position"

	| fileNameLength extraFieldLength xcrc32 xcompressedSize xuncompressedSize sig oldPos |
	oldPos := aStream position.
	aStream position: localHeaderRelativeOffset.
	sig := aStream next: 4.
	sig = LocalFileHeaderSignature asByteArray
		ifFalse: [ aStream position: oldPos.
			^ self error: 'bad LH signature at ' , localHeaderRelativeOffset printStringHex ].
	versionNeededToExtract := aStream nextLittleEndianNumber: 2.
	self bitFlag: (aStream nextLittleEndianNumber: 2).
	compressionMethod := aStream nextLittleEndianNumber: 2.
	lastModFileDateTime := self unzipTimestamp: (aStream nextLittleEndianNumber: 4).
	xcrc32 := aStream nextLittleEndianNumber: 4.
	xcompressedSize := aStream nextLittleEndianNumber: 4.
	xuncompressedSize := aStream nextLittleEndianNumber: 4.
	fileNameLength := aStream nextLittleEndianNumber: 2.
	extraFieldLength := aStream nextLittleEndianNumber: 2.
	fileName := (aStream next: fileNameLength) asString.
	localExtraField := (aStream next: extraFieldLength) asByteArray.
	dataOffset := aStream position.	"Don't trash these fields if we already got them from the central directory"
	self hasDataDescriptor
		ifFalse: [ crc32 := xcrc32.
			compressedSize := xcompressedSize.
			uncompressedSize := xuncompressedSize ].
	aStream position: oldPos
]

ZipFileMember >> readRawChunk: n
[
	^ stream next: n
]

ZipFileMember >> rewindData
[
	super rewindData.
	(stream isNil or: [ stream closed ])
		ifTrue: [ self error: 'stream missing or closed' ].
	stream position: localHeaderRelativeOffset + 4.
	self skipLocalDirectoryFileHeaderFrom: stream
]

ZipFileMember >> skipLocalDirectoryFileHeaderFrom: aStream
[
	"Assumes that stream is positioned after signature."

	| extraFieldLength fileNameLength |
	aStream next: 22.
	fileNameLength := aStream nextLittleEndianNumber: 2.
	extraFieldLength := aStream nextLittleEndianNumber: 2.
	aStream next: fileNameLength.
	aStream next: extraFieldLength.
	dataOffset := aStream position
]

ZipFileMember >> stream: aStream externalFileName: aFileName
[
	stream := aStream.
	externalFileName := aFileName
]

ZipFileMember >> uncompressDataTo: aStream
[
	| decoder buffer crcErrorMessage |
	decoder := ZipReadStream on: stream.
	decoder expectedCrc: self crc32.
	buffer := ByteArray new: (32768 min: readDataRemaining).
	crcErrorMessage := nil.
	[ [ readDataRemaining > 0 ]
		whileTrue: [ | chunkSize |
			chunkSize := 32768 min: readDataRemaining.
			buffer := decoder next: chunkSize into: buffer startingAt: 1.
			aStream next: chunkSize putAll: buffer startingAt: 1.
			readDataRemaining := readDataRemaining - chunkSize ] ]
		on: CRCError
		do: [ :ex | crcErrorMessage := ex messageText.
			ex proceed ].
	crcErrorMessage ifNotNil: [ self isCorrupt: true.
			CRCError signal: crcErrorMessage ]
]

ZipFileMember >> uncompressDataTo: aStream from: start to: finish
[
	| decoder buffer chunkSize |
	decoder := FastInflateStream on: stream.
	readDataRemaining := readDataRemaining min: finish - start + 1.
	buffer := ByteArray new: (32768 min: readDataRemaining).
	decoder next: start - 1.
	[ readDataRemaining > 0 ]
		whileTrue: [ chunkSize := 32768 min: readDataRemaining.
			buffer := decoder next: chunkSize into: buffer startingAt: 1.
			aStream next: chunkSize putAll: buffer startingAt: 1.
			readDataRemaining := readDataRemaining - chunkSize ]
]

ZipFileMember >> unzipTimestamp: dosTimestampInteger
[
	^ [ DateAndTime fromDosTimestamp: dosTimestampInteger ]
		on: Error
		do: [ "Assume we're dealing with the old, incorrect Squeak format"
			DateAndTime fromSeconds: 2492992800 + dosTimestampInteger ]
]

ZipFileMember >> usesFileNamed: aFileName
[
	"Do I require aFileName? That is, do I care if it's clobbered?"

	^ externalFileName asFileReference = aFileName asFileReference
]

ZipFileMember class >> newFrom: stream named: fileName
[
	^ self new stream: stream externalFileName: fileName
]

