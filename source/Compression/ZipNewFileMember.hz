ZipNewFileMember
	superclass: #ZipArchiveMember;
	instanceVariables: #(#externalFileName #stream );
	package: #Compression.

ZipNewFileMember >> close
[
	stream ifNotNil: [ stream close ]
]

ZipNewFileMember >> from: aFileName
[
	| entry |
	"Now get the size, attributes, and timestamps, and see if the file exists"
	stream := StandardFileStream readOnlyFileNamed: aFileName.
	self localFileName: (externalFileName := stream name).
	entry := stream directoryEntry.
	compressedSize := uncompressedSize := entry size.
	desiredCompressionMethod := compressedSize > 0
		ifTrue: [ CompressionDeflated ]
		ifFalse: [ CompressionStored ].
	self
		flag:
			'When we replace Files with FileSystem, the following line won''t have to jump throught hoops (FS returns aDateAndTime)'.
	self modifiedAt: entry modificationTime
]

ZipNewFileMember >> initialize
[
	super initialize.
	externalFileName := ''.
	compressionMethod := CompressionStored.
	self mapPermissionsFromUnix: DefaultFilePermissions
]

ZipNewFileMember >> readRawChunk: n
[
	^ stream next: n
]

ZipNewFileMember >> rewindData
[
	super rewindData.
	readDataRemaining := stream size.
	stream position: 0
]

ZipNewFileMember >> usesFileNamed: aFileName
[
	"Do I require aFileName? That is, do I care if it's clobbered?"

	^ externalFileName asFileReference = aFileName asFileReference
]

ZipNewFileMember class >> newNamed: aFileName
[
	^ self new from: aFileName
]

