ZipEncoderNode
	instanceVariables: #(#value #frequency #height #bitLength #code #parent #left #right );
	package: #Compression.

ZipEncoderNode >> bitLength
[
	^ bitLength ifNil: [ 0 ]
]

ZipEncoderNode >> code
[
	^ code ifNil: [ 0 ]
]

ZipEncoderNode >> code: aCode
[
	[ aCode >= 0 and: [ (1 bitShift: bitLength) > aCode ] ] assert.
	code := aCode
]

ZipEncoderNode >> computeHeight
[
	^ self isLeaf
		ifTrue: [ height := 0 ]
		ifFalse: [ height := (left computeHeight max: right computeHeight) + 1 ]
]

ZipEncoderNode >> encodeBitLength: blCounts from: aTree
[
	| index |
	"Note: If bitLength is not nil then the tree must be broken"
	bitLength isNil
		ifFalse: [ self error: 'Huffman tree is broken' ].
	parent ifNil: [ bitLength := 0 ] ifNotNil: [ bitLength := parent bitLength + 1 ].
	self isLeaf
		ifTrue: [ index := bitLength + 1.
			blCounts at: index put: (blCounts at: index) + 1 ]
		ifFalse: [ left encodeBitLength: blCounts from: aTree.
			right encodeBitLength: blCounts from: aTree ]
]

ZipEncoderNode >> frequency
[
	^ frequency
]

ZipEncoderNode >> frequency: aNumber
[
	frequency := aNumber
]

ZipEncoderNode >> height
[
	^ height
]

ZipEncoderNode >> isLeaf
[
	^ left isNil
]

ZipEncoderNode >> leafNodes
[
	self isLeaf
		ifTrue: [ ^ Array with: self ]
		ifFalse: [ ^ left leafNodes , right leafNodes ]
]

ZipEncoderNode >> left
[
	^ left
]

ZipEncoderNode >> left: aNode
[
	aNode parent: self.
	left := aNode
]

ZipEncoderNode >> parent
[
	^ parent
]

ZipEncoderNode >> parent: aNode
[
	parent := aNode
]

ZipEncoderNode >> printOn: aStream
[
	super printOn: aStream.
	aStream
		nextPut: $(;
		nextPutAll: 'value = ';
		print: value;
		nextPutAll: ', freq = ';
		print: frequency;
		nextPutAll: ', bitLength = ';
		print: bitLength;
		nextPutAll: ', code = ';
		print: code;
		nextPutAll: ', height = ';
		print: height;
		nextPut: $)
]

ZipEncoderNode >> right
[
	^ right
]

ZipEncoderNode >> right: aNode
[
	aNode parent: self.
	right := aNode
]

ZipEncoderNode >> rotateToHeight: maxHeight
[
	"Rotate the tree to achieve maxHeight depth"

	| newParent |
	height < 4
		ifTrue: [ ^ self ].
	self left: (left rotateToHeight: maxHeight - 1).
	self right: (right rotateToHeight: maxHeight - 1).
	height := (left height max: right height) + 1.
	height <= maxHeight
		ifTrue: [ ^ self ].
	(left height - right height) abs <= 2
		ifTrue: [ ^ self ].
	left height < right height
		ifTrue: [ right right height >= right left height
				ifTrue: [ newParent := right.
					self right: newParent left.
					newParent left: self ]
				ifFalse: [ newParent := right left.
					right left: newParent right.
					newParent right: right.
					self right: newParent left.
					newParent left: self ] ]
		ifFalse: [ left left height >= left right height
				ifTrue: [ newParent := left.
					self left: newParent right.
					newParent right: self ]
				ifFalse: [ newParent := left right.
					left right: newParent left.
					newParent left: left.
					self left: newParent right.
					newParent right: self ] ].
	parent computeHeight.
	^ parent
]

ZipEncoderNode >> setBitLengthTo: bl
[
	bitLength := bl
]

ZipEncoderNode >> setValue: v frequency: f height: h
[
	value := v.
	frequency := f.
	height := h
]

ZipEncoderNode >> value
[
	^ value
]

ZipEncoderNode class >> value: v frequency: f height: h
[
	^ self new setValue: v frequency: f height: h
]

