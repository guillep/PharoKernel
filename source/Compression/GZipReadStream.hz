GZipReadStream
	superclass: #FastInflateStream;
	sharedPools: #(#GZipConstants );
	package: #Compression.

GZipReadStream >> on: aCollection from: firstIndex to: lastIndex
[
	"Check the header of the GZIP stream."

	| method magic flags length |
	super on: aCollection from: firstIndex to: lastIndex.
	crc := 16rFFFFFFFF.
	magic := self nextBits: 16.
	magic = GZipMagic
		ifFalse: [ ^ self error: 'Not a GZipped stream' ].
	method := self nextBits: 8.
	method = GZipDeflated
		ifFalse: [ ^ self error: 'Bad compression method' ].
	flags := self nextBits: 8.
	(flags anyMask: GZipEncryptFlag)
		ifTrue: [ ^ self error: 'Cannot decompress encrypted stream' ].
	(flags anyMask: GZipReservedFlags)
		ifTrue: [ ^ self error: 'Cannot decompress stream with unknown flags' ].	"Ignore stamp, extra flags, OS type"
	self
		nextBits: 16;
		nextBits: 16.	"stamp"
	self nextBits: 8.	"extra flags"
	self nextBits: 8.	"OS type"
	(flags anyMask: GZipContinueFlag)
		ifTrue: [ self nextBits: 16 ].	"Number of multi-part archive - ignored"
	(flags anyMask: GZipExtraField)
		ifTrue: [ length := self nextBits: 16.
			1 to: length do: [ :i | self nextBits: 8 ] ].	"Extra fields - ignored"
	(flags anyMask: GZipNameFlag)
		ifTrue: [ [ (self nextBits: 8) = 0 ] whileFalse ].	"Original file name - ignored"
	(flags anyMask: GZipCommentFlag)
		ifTrue: [ [ (self nextBits: 8) = 0 ] whileFalse ]	"Comment - ignored"
]

GZipReadStream >> updateCrc: oldCrc from: start to: stop in: aCollection
[
	"Answer an updated CRC for the range of bytes in aCollection"

	^ ZipWriteStream
		updateCrc: oldCrc
		from: start
		to: stop
		in: aCollection
]

GZipReadStream >> verifyCrc
[
	| stored |
	stored := 0.
	0 to: 24 by: 8 do: [ :i | sourcePos >= sourceLimit
			ifTrue: [ ^ self crcError: 'No checksum (proceed to ignore)' ].
		stored := stored + (self nextByte bitShift: i) ].
	stored := stored bitXor: 16rFFFFFFFF.
	stored = crc
		ifFalse: [ ^ self crcError: 'Wrong checksum (proceed to ignore)' ].
	^ stored
]

GZipReadStream class >> fileIn: fullFileName
[
	"FileIn the contents of a gzipped file"

	| zipped unzipped |
	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).
	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.
	unzipped reset.
	unzipped fileIn
]

GZipReadStream class >> fileIntoNewChangeSet: fullFileName
[
	"FileIn the contents of a gzipped file"

	| zipped unzipped csClass |
	csClass := Smalltalk globals at: #ChangeSet ifAbsent: [ ^ self ].
	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).
	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.
	unzipped reset.
	csClass newChangesFromStream: unzipped named: fullFileName asFileReference basename
]

GZipReadStream class >> saveContents: fullFileName
[
	"Save the contents of a gzipped file"

	| zipped buffer unzipped newName |
	newName := fullFileName copyUpToLast: FileSystem disk extensionDelimiter.
	unzipped := FileStream newFileNamed: newName.
	unzipped binary.
	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).
	buffer := ByteArray new: 50000.
	'Extracting ' , fullFileName
		displayProgressFrom: 0
		to: zipped sourceStream size
		during: [ :bar | [ zipped atEnd ]
				whileFalse: [ bar current: zipped sourceStream position.
					unzipped nextPutAll: (zipped nextInto: buffer) ].
			zipped close.
			unzipped close ].
	^ newName
]

GZipReadStream class >> uncompressedFileName: fullName
[
	^ ((fullName endsWith: '.gz')
		and: [ 
			self
				confirm:
					('{1}appears to be a compressed file.Do you want to uncompress it?' translated format: {fullName}) ])
		ifFalse: [ fullName ]
		ifTrue: [ self saveContents: fullName ]
]

GZipReadStream class >> unload
[
	Smalltalk tools fileList unregisterFileReader: self
]

GZipReadStream class >> unzip: fullFileName
[
	"Unzip the contents of a gzipped file specified by its full file name to the current working directory"

	^ self unzip: fullFileName to: FileSystem disk workingDirectory
]

GZipReadStream class >> unzip: fullFileName to: pathString
[
	"Unzip the contents of the file specified by the full path name fullFileName to the location given by pathString."

	| zipped buffer unzipped newName |
	newName := fullFileName copyUpToLast: FileSystem disk extensionDelimiter.
	pathString asFileReference ensureCreateDirectory.
	unzipped := FileStream newFileNamed: (pathString asFileReference / newName) fullName.
	unzipped ifNil: [ self error: pathString , ' looks incorrect' ].
	[ unzipped binary.
	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).
	buffer := ByteArray new: 50000.
	[ zipped atEnd ] whileFalse: [ unzipped nextPutAll: (zipped nextInto: buffer) ] ]
		ensure: [ zipped close.
			unzipped close ].
	^ newName
]

GZipReadStream class >> viewContents: fullFileName
[
	"Open the decompressed contents of the .gz file with the given name.  This method is only required for the registering-file-list of Squeak 3.3a and beyond, but does no harm in an earlier system"

	(FileStream readOnlyFileNamed: fullFileName) ifNotNil: [ :aStream | aStream viewGZipContents ]
]

