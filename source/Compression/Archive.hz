Archive
	instanceVariables: #(#members );
	package: #Compression.

Archive >> addDirectory: aFileName
[
	^ self addDirectory: aFileName as: aFileName
]

Archive >> addDirectory: aFileName as: anotherFileName
[
	| newMember |
	newMember := self memberClass newFromDirectory: aFileName.
	self addMember: newMember.
	newMember localFileName: anotherFileName.
	^ newMember
]

Archive >> addFile: aFileName
[
	^ self addFile: aFileName as: aFileName
]

Archive >> addFile: aFileName as: anotherFileName
[
	| newMember |
	newMember := self memberClass newFromFile: aFileName.
	newMember localFileName: anotherFileName.
	self addMember: newMember.
	^ newMember
]

Archive >> addMember: aMember
[
	^ members addLast: aMember
]

Archive >> addString: aString as: aFileName
[
	| newMember |
	newMember := self memberClass newFromString: aString named: aFileName.
	self addMember: newMember.
	newMember localFileName: aFileName.
	^ newMember
]

Archive >> addTree: aFileNameOrDirectory match: aBlock
[
	| nameSize |
	nameSize := aFileNameOrDirectory isString
		ifTrue: [ aFileNameOrDirectory size ]
		ifFalse: [ aFileNameOrDirectory fullName size ].
	^ self addTree: aFileNameOrDirectory removingFirstCharacters: nameSize + 1 match: aBlock
]

Archive >> addTree: aFileNameOrDirectory removingFirstCharacters: n
[
	^ self addTree: aFileNameOrDirectory removingFirstCharacters: n match: [ :e | true ]
]

Archive >> addTree: aFileNameOrDirectory removingFirstCharacters: n match: aBlock
[
	| dir relativePath matches |
	dir := aFileNameOrDirectory asFileReference.
	relativePath := (dir fullName allButFirst: n) asFileReference.
	matches := dir entries select: [ :entry | aBlock value: entry ].
	matches
		do: [ :e | | newMember |
			newMember := e isDirectory
				ifTrue: [ self memberClass newFromDirectory: e fullName ]
				ifFalse: [ self memberClass newFromFile: e fullName ].
			newMember localFileName: (relativePath / e name) fullName.
			self addMember: newMember.
			e isDirectory
				ifTrue: [ self addTree: e fullName removingFirstCharacters: n match: aBlock ] ]
]

Archive >> canWriteToFileNamed: aFileName
[
	"Catch attempts to overwrite existing zip file"

	^ (members anySatisfy: [ :ea | ea usesFileNamed: aFileName ]) not
]

Archive >> contentsOf: aMemberOrName
[
	| member |
	member := self member: aMemberOrName.
	member ifNil: [ ^ nil ].
	^ member contents
]

Archive >> extractMember: aMemberOrName
[
	| member |
	member := self member: aMemberOrName.
	member ifNil: [ ^ nil ].
	member extractToFileNamed: member localFileName inDirectory: FileSystem workingDirectory
]

Archive >> extractMember: aMemberOrName toFileNamed: aFileName
[
	| member |
	member := self member: aMemberOrName.
	member ifNil: [ ^ nil ].
	member extractToFileNamed: aFileName
]

Archive >> extractMemberWithoutPath: aMemberOrName
[
	self extractMemberWithoutPath: aMemberOrName inDirectory: FileSystem workingDirectory
]

Archive >> extractMemberWithoutPath: aMemberOrName inDirectory: dir
[
	| member |
	member := self member: aMemberOrName.
	member ifNil: [ ^ nil ].
	member extractToFileNamed: member asFileReference basename inDirectory: dir
]

Archive >> initialize
[
	super initialize.
	members := OrderedCollection new
]

Archive >> member: aMemberOrName
[
	^ (members includes: aMemberOrName)
		ifTrue: [ aMemberOrName ]
		ifFalse: [ self memberNamed: aMemberOrName ]
]

Archive >> memberClass
[
	self subclassResponsibility
]

Archive >> memberNamed: aString
[
	"Return the first member whose zip name or local file name matches aString, or nil"

	^ members detect: [ :ea | ea fileName = aString or: [ ea localFileName = aString ] ] ifNone: [  ]
]

Archive >> memberNames
[
	^ members collect: [ :ea | ea fileName ]
]

Archive >> members
[
	^ members
]

Archive >> membersMatching: aString
[
	^ members select: [ :ea | (aString match: ea fileName) or: [ aString match: ea localFileName ] ]
]

Archive >> numberOfMembers
[
	^ members size
]

Archive >> removeMember: aMemberOrName
[
	| member |
	member := self member: aMemberOrName.
	member ifNotNil: [ members remove: member ].
	^ member
]

Archive >> replaceMember: aMemberOrName with: newMember
[
	| member |
	member := self member: aMemberOrName.
	member ifNotNil: [ members replaceAll: member with: newMember ].
	^ member
]

Archive >> setContentsOf: aMemberOrName to: aString
[
	| newMember oldMember |
	oldMember := self member: aMemberOrName.
	newMember := (self memberClass newFromString: aString named: oldMember fileName) copyFrom: oldMember.
	self replaceMember: oldMember with: newMember
]

Archive >> writeTo: aStream
[
	self subclassResponsibility
]

Archive >> writeToFileNamed: aFileName
[
	"Catch attempts to overwrite existing zip file"

	(self canWriteToFileNamed: aFileName)
		ifFalse: [ ^ self error: aFileName , ' is needed by one or more members in this archive' ].
	StandardFileStream forceNewFileNamed: aFileName do: [ :stream | self writeTo: stream ]
]

