ZipStore
	superclass: #MemoryStore;
	instanceVariables: #(#reference );
	package: #'FileSystem-Zip'.

ZipStore >> close
[
	| archive fs stream |
	archive := ZipArchive new.
	fs := FileSystem store: self.
	fs root allChildren
		do: [ :each | each isFile
				ifTrue: [ each readStreamDo: [ :output | archive addString: output contents as: each path printString ] ] ].
	archive
		writeTo: (stream := WriteStream on: ByteArray new);
		close.
	self reference writeStreamDo: [ :output | output nextPutAll: stream contents ]
]

ZipStore >> initializeWithReference: aReference
[
	self initialize.
	reference := aReference
]

ZipStore >> open
[
	| archive output |
	self reference exists
		ifFalse: [ ^ self ].
	archive := ZipArchive new.
	self reference
		readStreamDo: [ :input | archive readFrom: input contents readStream.
			archive members
				do: [ :member | | path |
					path := self pathFromMember: member.
					member isDirectory
						ifTrue: [ self ensureCreateDirectory: path ]
						ifFalse: [ self ensureCreateDirectory: path parent.
							self createFile: path.
							self
								replaceFile: path
								in: [ :bytes | output := bytes writeStream.
									member rewindData.
									member copyRawDataTo: output.
									output contents ] ] ] ].
	^ self
]

ZipStore >> pathFromMember: anArchiveMember
[
	| path |
	path := Path root resolve: anArchiveMember fileName.
	^ path basename isEmpty
		ifTrue: [ path parent ]
		ifFalse: [ path ]
]

ZipStore >> reference
[
	^ reference
]

ZipStore class >> reference: aReference
[
	^ self basicNew initializeWithReference: aReference yourself
]

ence: aReference
[reference: aReference
	^ self basicNew initializeWithReference: aReference yourself
]

