TextConverter
	instanceVariables: #(#latin1Map #latin1Encodings );
	sharedPools: #(#EventSensorConstants );
	package: #'Multilingual-TextConversion'.

TextConverter class
	instanceVariables: #(#latin1Map #latin1Encodings ).

TextConverter >> convertFromSystemString: aString
convertFromSystemString: aString
	| readStream writeStream |
	readStream := aString readStream.
	writeStream := String new writeStream.
	[ readStream atEnd ] whileFalse: [ writeStream nextPut: (self nextFromStream: readStream) ].
	^ writeStream contents

TextConverter >> convertToSystemString: aString
convertToSystemString: aString
	| writeStream |
	writeStream := String new writeStream.
	self nextPutAll: aString toStream: writeStream.
	self emitSequenceToResetStateIfNeededOn: writeStream.
	^ writeStream contents

TextConverter >> emitSequenceToResetStateIfNeededOn: aStream
emitSequenceToResetStateIfNeededOn: aStream
	

TextConverter >> initialize
initialize
	latin1Map := self class latin1Map.
	latin1Encodings := self class latin1Encodings

TextConverter >> installLineEndConvention: lineEndStringOrNil
installLineEndConvention: lineEndStringOrNil
	lineEndStringOrNil
		ifNotNil: [ latin1Encodings := latin1Encodings copy.
			latin1Encodings at: Character cr asciiValue + 1 put: (self convertFromSystemString: lineEndStringOrNil).
			latin1Map := ByteString nonAsciiMap copy.
			latin1Map at: Character cr asciiValue + 1 put: 1 ]

TextConverter >> next: anInteger putAll: aString startingAt: startIndex toStream: aStream
next: anInteger putAll: aString startingAt: startIndex toStream: aStream
	"Handle fast conversion if ByteString"

	| lastIndex nextIndex |
	aString class == ByteString
		ifFalse: [ startIndex to: startIndex + anInteger - 1 do: [ :index | self nextPut: (aString at: index) toStream: aStream ].
			^ aString ].
	aStream isBinary
		ifTrue: [ aStream basicNext: anInteger putAll: aString startingAt: startIndex.
			^ aString ].
	^ self
		next: anInteger
		putByteString: aString
		startingAt: startIndex
		toStream: aStream

TextConverter >> next: anAmount putByteString: aString startingAt: startIndex toStream: aStream
next: anAmount putByteString: aString startingAt: startIndex toStream: aStream
	"This is a reasonable default which speeds up conversion of encodings which have a partial match with latin1 encoding (for instance ascii supersets)"

	| lastIndex nextIndex |
	lastIndex := startIndex.
	[ nextIndex := ByteString findFirstInString: aString inSet: latin1Map startingAt: lastIndex.
	nextIndex = 0 or: [ nextIndex >= (startIndex + anAmount) ] ]
		whileFalse: [ aStream next: nextIndex - lastIndex putAll: aString startingAt: lastIndex.
			aStream basicNextPutAll: (latin1Encodings at: (aString byteAt: nextIndex) + 1).
			lastIndex := nextIndex + 1 ].
	aStream basicNext: anAmount - lastIndex + startIndex putAll: aString startingAt: lastIndex

TextConverter >> nextFromStream: aStream
nextFromStream: aStream
	self subclassResponsibility

TextConverter >> nextPut: aCharacter toStream: aStream
nextPut: aCharacter toStream: aStream
	self subclassResponsibility

TextConverter >> nextPutAll: aString toStream: aStream
nextPutAll: aString toStream: aStream
	"Handle fast conversion if ByteString"

	| lastIndex nextIndex |
	aString class == ByteString
		ifFalse: [ aString do: [ :char | self nextPut: char toStream: aStream ].
			^ self ].
	aStream isBinary
		ifTrue: [ aStream basicNextPutAll: aString.
			^ self ].
	self nextPutByteString: aString toStream: aStream.
	^ self

TextConverter >> nextPutByteString: aString toStream: aStream
nextPutByteString: aString toStream: aStream
	"This is a reasonable default which speeds up conversion of encodings which have a partial match with latin1 encoding (for instance ascii supersets)"

	| lastIndex nextIndex |
	lastIndex := 1.
	[ nextIndex := ByteString findFirstInString: aString inSet: latin1Map startingAt: lastIndex.
	nextIndex = 0 ]
		whileFalse: [ aStream next: nextIndex - lastIndex putAll: aString startingAt: lastIndex.
			aStream basicNextPutAll: (latin1Encodings at: (aString byteAt: nextIndex) + 1).
			lastIndex := nextIndex + 1 ].
	aStream basicNext: aString size - lastIndex + 1 putAll: aString startingAt: lastIndex

TextConverter >> restoreStateOf: aStream with: aConverterState
restoreStateOf: aStream with: aConverterState
	aStream position: aConverterState

TextConverter >> saveStateOf: aStream
saveStateOf: aStream
	^ aStream position

TextConverter class >> allEncodingNames
allEncodingNames
	"TextConverter allEncodingNames"

	| encodingNames |
	encodingNames := Set new.
	self allSubclasses
		do: [ :each | | names |
			names := each encodingNames.
			names notEmpty
				ifTrue: [ encodingNames add: names first asSymbol ] ].
	^ encodingNames

TextConverter class >> default
default
	^ UTF8TextConverter new

TextConverter class >> defaultConverterClassForEncoding: encodingName
defaultConverterClassForEncoding: encodingName
	"TextConverter defaultConverterClassForEncoding: 'shift-jis'"

	^ self allSubclasses detect: [ :class | class encodingNames includes: encodingName ] ifNone: [  ]

TextConverter class >> defaultSystemConverter
defaultSystemConverter
	^ LanguageEnvironment defaultSystemConverter

TextConverter class >> encodingNames
encodingNames
	^ #() copy

TextConverter class >> initializeLatin1MapAndEncodings
initializeLatin1MapAndEncodings
	"Initialize the latin1Map and latin1Encodings.
	These variables ensure that conversions from latin1 ByteString is reasonably fast"

	| latin1 utf8 |
	latin1Map := ByteArray new: 256.
	latin1Encodings := Array new: 256.
	0 to: 255 do: [ :i | utf8 := (String new: 8) writeStream.
		latin1 := String with: (Character value: i).
		self new nextPut: latin1 first toStream: utf8.
		utf8 := utf8 contents.
		latin1 = utf8
			ifTrue: [ latin1Map at: i + 1 put: 0	"no translation needed" ]
			ifFalse: [ latin1Map at: i + 1 put: 1.	"translation needed"
				latin1Encodings at: i + 1 put: utf8 ] ]

TextConverter class >> latin1Encodings
latin1Encodings
	"Answer an Array mapping latin1 characters to conversion string"

	^ latin1Encodings ifNil: [ self initializeLatin1MapAndEncodings.
			latin1Encodings ]

TextConverter class >> latin1Map
latin1Map
	"Answer a ByteArray map telling if latin1 characters needs conversion or not"

	^ latin1Map ifNil: [ self initializeLatin1MapAndEncodings.
			latin1Map ]

TextConverter class >> newForEncoding: aString
newForEncoding: aString
	| encoding |
	aString ifNil: [ ^ Latin1TextConverter new ].
	encoding := aString asLowercase.
	^ self allSubclasses
		detect: [ :each | each encodingNames includes: encoding ]
		ifFound: [ :class | class new ]
		ifNone: [ nil ]

