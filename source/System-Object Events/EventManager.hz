Class
	name: #EventManager;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#actionMap );
	classVariables: #(#ActionMaps );
	package: #'System-Object Events'.

Class EventManager >> actionMap
[
^ actionMap == nil	ifTrue: [ self createActionMap ]	ifFalse: [ actionMap ]
]

Class EventManager >> addDependent: anObject
[
	"Make the given object one of the receiver's dependents."
self when: self changedEventSelector send: self updateEventSelector to: anObject.^ anObject
]

Class EventManager >> breakDependents
[
	"Remove all of the receiver's dependents."
self removeActionsForEvent: self changedEventSelector
]

Class EventManager >> changed: aParameter
[
	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."
self triggerEvent: self changedEventSelector with: aParameter
]

Class EventManager >> changedEventSelector
[
^ #changed:
]

Class EventManager >> dependents
[
^ (self actionSequenceForEvent: self changedEventSelector) asSet collect: [ :each | each receiver ]
]

Class EventManager >> postCopy
[
super postCopy.self release
]

Class EventManager >> releaseActionMap
[
actionMap := nil
]

Class EventManager >> removeDependent: anObject
[
	"Remove the given object as one of the receiver's dependents."
self removeActionsWithReceiver: anObject forEvent: self changedEventSelector.^ anObject
]

Class EventManager >> updateEventSelector
[
^ #update:
]

Class EventManager >> updateableActionMap
[
actionMap == nil	ifTrue: [ actionMap := self createActionMap ].^ actionMap
]

Metaclass
	name: #EventManager;
	instanceVariables: #().

Metaclass EventManager >> actionMapFor: anObject
[
^ self actionMaps at: anObject ifAbsent: [ self createActionMap ]
]

Metaclass EventManager >> actionMaps
[
^ ActionMaps ifNil: [ ActionMaps := WeakIdentityKeyDictionary new ]
]

Metaclass EventManager >> cleanUp: aggressive
[
	"Dump all ActionMaps but only when we're aggressively cleaning"
aggressive	ifTrue: [ ActionMaps := nil ]
]

Metaclass EventManager >> flushEvents
[
	"Object flushEvents"
self actionMaps	keysAndValuesDo: [ :rcvr :evtDict | 		rcvr			ifNotNil: [ 				"make sure we don't modify evtDict while enumerating"				evtDict keys					do: [ :evtName | 						| msgSet |						msgSet := evtDict at: evtName ifAbsent: [ nil ].						msgSet == nil							ifTrue: [ rcvr removeActionsForEvent: evtName ] ] ] ].EventManager actionMaps finalizeValues
]

Metaclass EventManager >> releaseActionMapFor: anObject
[
self actionMaps removeKey: anObject ifAbsent: [  ]
]

Metaclass EventManager >> updateableActionMapFor: anObject
[
^ self actionMaps at: anObject ifAbsentPut: [ self createActionMap ]
]

