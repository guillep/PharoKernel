DummyUIManager
	superclass: #UIManager;
	classVariables: #(#ProgressBarEnabled );
	package: #UIManager.

DummyUIManager >> checkForNewDisplaySize
[checkForNewDisplaySize
	Display extent = DisplayScreen actualScreenSize
		ifTrue: [ ^ self ].
	DisplayScreen startUp
]

DummyUIManager >> chooseDirectory: label from: dir
[chooseDirectory: label from: dir
	^ nil
]

DummyUIManager >> chooseFrom: aList lines: linesArray title: aString
[chooseFrom: aList lines: linesArray title: aString
	^ aList first
]

DummyUIManager >> chooseFrom: labelList values: valueList lines: linesArray title: aString
[chooseFrom: labelList values: valueList lines: linesArray title: aString
	^ valueList first
]

DummyUIManager >> confirm: queryString
[confirm: queryString
	(ProvideAnswerNotification signal: queryString) ifNotNil: [ :answer | ^ answer ].
	self error: 'No user response possible'
]

DummyUIManager >> confirm: aString orCancel: cancelBlock
[confirm: aString orCancel: cancelBlock
	(ProvideAnswerNotification signal: aString)
		ifNotNil: [ :answer | ^ answer == #cancel
				ifTrue: [ cancelBlock value ]
				ifFalse: [ answer ] ].
	self error: 'No user response possible'
]

DummyUIManager >> edit: aText label: labelString accept: anAction
[edit: aText label: labelString accept: anAction
	^ nil
]

DummyUIManager >> fileDoesNotExistsDefaultAction: anException
[fileDoesNotExistsDefaultAction: anException
	
]

DummyUIManager >> fileExistsDefaultAction: anException
[fileExistsDefaultAction: anException
	
]

DummyUIManager >> fontFromUser: priorFont
[fontFromUser: priorFont
	self error: 'No user response possible'
]

DummyUIManager >> inform: aString
[inform: aString
	"Nothing to be done here"

	
]

DummyUIManager >> informUserDuring: aBlock
[informUserDuring: aBlock
	aBlock value: DummySystemProgressItem new
]

DummyUIManager >> lowSpaceWatcherDefaultAction
[lowSpaceWatcherDefaultAction
	Transcript
		show: '*** LOW SPACE ***';
		cr
]

DummyUIManager >> multiLineRequest: queryString initialAnswer: defaultAnswer answerHeight: answerHeight
[multiLineRequest: queryString initialAnswer: defaultAnswer answerHeight: answerHeight
	
]

DummyUIManager >> newDisplayDepthNoRestore: pixelSize
[newDisplayDepthNoRestore: pixelSize
	"Change depths.  Check if there is enough space!  , di"

	| area need |
	pixelSize = Display depth
		ifTrue: [ ^ self	"no change" ].
	pixelSize abs < Display depth
		ifFalse: [ "Make sure there is enough space"
			area := Display boundingBox area.	"pixels"
			need := area * (pixelSize abs - Display depth) // 8 + Smalltalk lowSpaceThreshold.	"new bytes needed"
			(Smalltalk garbageCollectMost <= need and: [ Smalltalk garbageCollect <= need ])
				ifTrue: [ self error: 'Insufficient free space' ] ].
	Display setExtent: Display extent depth: pixelSize.
	DisplayScreen startUp
]

DummyUIManager >> progressBarEnabled
[progressBarEnabled
	^ ProgressBarEnabled ifNil: [ ProgressBarEnabled := true ]
]

DummyUIManager >> progressBarEnabled: aBoolean
[progressBarEnabled: aBoolean
	ProgressBarEnabled := aBoolean
]

DummyUIManager >> request: queryString initialAnswer: defaultAnswer
[request: queryString initialAnswer: defaultAnswer
	^ self
		request: queryString
		initialAnswer: defaultAnswer
		title: 'Provide the following information'
		entryCompletion: nil
]

DummyUIManager >> request: aStringOrText initialAnswer: defaultAnswer entryCompletion: anEntryCompletion
[request: aStringOrText initialAnswer: defaultAnswer entryCompletion: anEntryCompletion
	^ self
		request: aStringOrText
		initialAnswer: defaultAnswer
		title: 'Information Required' translated
		entryCompletion: anEntryCompletion
]

DummyUIManager >> request: aStringOrText initialAnswer: defaultAnswer title: aTitle entryCompletion: anEntryCompletion
[request: aStringOrText initialAnswer: defaultAnswer title: aTitle entryCompletion: anEntryCompletion
	(ProvideAnswerNotification signal: aStringOrText)
		ifNotNil: [ :answer | ^ answer == #default
				ifTrue: [ defaultAnswer ]
				ifFalse: [ answer ] ].
	self error: 'No user response possible'
]

DummyUIManager >> requestPassword: queryString
[requestPassword: queryString
	^ self request: queryString initialAnswer: ''
]

DummyUIManager >> restoreDisplay
[restoreDisplay
	
]

DummyUIManager >> restoreDisplayAfter: aBlock
[restoreDisplayAfter: aBlock
	aBlock value.
	Sensor waitButton
]

DummyUIManager >> syntaxErrorNotificationDefaultAction: anException
[syntaxErrorNotificationDefaultAction: anException
	Transcript
		show: '*** SYNTAX ERROR ***';
		cr.
	Transcript
		show: anException;
		cr.
	Transcript
		show: (thisContext stack first: (20 min: thisContext stack size));
		cr.
	anException return
]

DummyUIManager >> unhandledErrorDefaultAction: anException
[unhandledErrorDefaultAction: anException
	Transcript
		show: '*** EXCEPTION ***';
		cr.
	Transcript
		show: anException;
		cr.
	Transcript
		show: (thisContext stack first: (20 min: thisContext stack size));
		cr.
	anException isResumable
		ifTrue: [ anException resume ]
]

DummyUIManager >> warningDefaultAction: anException
[warningDefaultAction: anException
	^ self unhandledErrorDefaultAction: anException
]

