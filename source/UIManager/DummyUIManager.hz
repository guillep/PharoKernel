Class
	name: #DummyUIManager;
	superclass: #ClassUIManager;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #();
	classVariables: #(#ProgressBarEnabled );
	package: #UIManager.

Class DummyUIManager >> checkForNewDisplaySize
[
Display extent = DisplayScreen actualScreenSize	ifTrue: [ ^ self ].DisplayScreen startUp
]

Class DummyUIManager >> chooseDirectory: label from: dir
[
^ nil
]

Class DummyUIManager >> chooseFrom: aList lines: linesArray title: aString
[
^ aList first
]

Class DummyUIManager >> chooseFrom: labelList values: valueList lines: linesArray title: aString
[
^ valueList first
]

Class DummyUIManager >> confirm: queryString
[
(ProvideAnswerNotification signal: queryString) ifNotNil: [ :answer | ^ answer ].self error: 'No user response possible'
]

Class DummyUIManager >> confirm: aString orCancel: cancelBlock
[
(ProvideAnswerNotification signal: aString)	ifNotNil: [ :answer | 		^ answer == #cancel			ifTrue: [ cancelBlock value ]			ifFalse: [ answer ] ].self error: 'No user response possible'
]

Class DummyUIManager >> displayProgress: titleString at: aPoint from: minVal to: maxVal during: workBlock
[
^ ProgressBarEnabled	ifFalse: [ nil ]	ifTrue: [ 		ProgressInitiationException			display: titleString			at: aPoint			from: minVal			to: maxVal			during: workBlock ]
]

Class DummyUIManager >> displayProgress: titleString from: minVal to: maxVal during: workBlock
[
^ ProgressBarEnabled	ifFalse: [ nil ]	ifTrue: [ 		ProgressInitiationException			display: titleString			at: Display center			from: minVal			to: maxVal			during: workBlock ]
]

Class DummyUIManager >> edit: aText label: labelString accept: anAction
[
^ nil
]

Class DummyUIManager >> fileDoesNotExistsDefaultAction: anException
[

]

Class DummyUIManager >> fileExistsDefaultAction: anException
[

]

Class DummyUIManager >> fontFromUser: priorFont
[
self error: 'No user response possible'
]

Class DummyUIManager >> inform: aString
[

]

Class DummyUIManager >> informUserDuring: aBlock
[
aBlock value: DummySystemProgressItem new
]

Class DummyUIManager >> lowSpaceWatcherDefaultAction
[
Transcript	show: '*** LOW SPACE ***';	cr
]

Class DummyUIManager >> multiLineRequest: queryString initialAnswer: defaultAnswer answerHeight: answerHeight
[

]

Class DummyUIManager >> newDisplayDepthNoRestore: pixelSize
[
	"Change depths.  Check if there is enough space!  , di"
| area need |pixelSize = Display depth	ifTrue: [ ^ self	"no change" ].pixelSize abs < Display depth	ifFalse: [ 		"Make sure there is enough space"		area := Display boundingBox area.	"pixels"		need := area * (pixelSize abs - Display depth) // 8 + Smalltalk lowSpaceThreshold.	"new bytes needed"		(Smalltalk garbageCollectMost <= need and: [ Smalltalk garbageCollect <= need ])			ifTrue: [ self error: 'Insufficient free space' ] ].Display setExtent: Display extent depth: pixelSize.DisplayScreen startUp
]

Class DummyUIManager >> progressBarEnabled
[
^ ProgressBarEnabled ifNil: [ ProgressBarEnabled := true ]
]

Class DummyUIManager >> progressBarEnabled: aBoolean
[
ProgressBarEnabled := aBoolean
]

Class DummyUIManager >> progressInitiationExceptionDefaultAction: anException
[
| result |result := anException workBlock value: DummySystemProgressItem new.anException resume: result
]

Class DummyUIManager >> request: queryString initialAnswer: defaultAnswer
[
^ defaultAnswer
]

Class DummyUIManager >> request: queryString initialAnswer: defaultAnswer entryCompletion: anEntryCompletion
[
^ defaultAnswer
]

Class DummyUIManager >> request: aStringOrText initialAnswer: defaultAnswer title: aTitle entryCompletion: anEntryCompletion
[
^ defaultAnswer
]

Class DummyUIManager >> requestPassword: queryString
[
^ self request: queryString initialAnswer: ''
]

Class DummyUIManager >> restoreDisplay
[

]

Class DummyUIManager >> restoreDisplayAfter: aBlock
[
aBlock value.Sensor waitButton
]

Class DummyUIManager >> syntaxErrorNotificationDefaultAction: anException
[
Transcript	show: '*** SYNTAX ERROR ***';	cr.Transcript	show: anException;	cr.Transcript	show: (thisContext stack first: (20 min: thisContext stack size));	cr.anException return
]

Class DummyUIManager >> unhandledErrorDefaultAction: anException
[
Transcript	show: '*** EXCEPTION ***';	cr.Transcript	show: anException;	cr.Transcript	show: (thisContext stack first: (20 min: thisContext stack size));	cr.anException isResumable	ifTrue: [ anException resume ]
]

Class DummyUIManager >> warningDefaultAction: anException
[
^ self unhandledErrorDefaultAction: anException
]

Metaclass
	name: #DummyUIManager;
	instanceVariables: #().

