NonInteractiveUIManager
	superclass: #CommandLineUIManager;
	package: #UIManager.

NonInteractiveUIManager >> chooseDirectory: label from: dir
[
	"Let the user choose a directory"

	^ self
		nonInteractiveWarning:
			(String
				streamContents: [ :s | s
						nextPutAll: 'Interactive Directory Choice Request: ';
						nextPutAll: '[ ';
						nextPutAll: label asString;
						nextPutAll: ' ] from ';
						print: dir ])
]

NonInteractiveUIManager >> chooseFileMatching: patterns label: labelString
[
	"Let the user choose a file matching the given patterns"

	^ self chooseFullFileNameMatching: patterns label: labelString
]

NonInteractiveUIManager >> chooseFrom: aList lines: linesArray title: aString
[
	"Choose an item from the given list. Answer the index of the selected item."

	^ self
		chooseOrRequestFrom: aList
		values: aList
		lines: linesArray
		title: aString
]

NonInteractiveUIManager >> chooseFrom: labelList values: valueList lines: linesArray title: aString
[
	"Choose an item from the given list. Answer the selected item."

	^ self
		chooseOrRequestFrom: labelList
		values: valueList
		lines: linesArray
		title: aString
]

NonInteractiveUIManager >> chooseFullFileNameMatching: patterns label: labelString
[
	"Let the user choose a file matching the given patterns"

	^ self
		nonInteractiveWarning:
			(String
				streamContents: [ :s | s
						nextPutAll: 'Interactive File Choice Request: ';
						nextPutAll: '[ ';
						nextPutAll: labelString asString;
						nextPutAll: ' ] ';
						print: patterns ])
]

NonInteractiveUIManager >> chooseOrRequestFrom: labelList values: valueList lines: linesArray title: aString
[
	^ self
		nonInteractiveWarning:
			(String
				streamContents: [ :s | s
						nextPutAll: 'Choice Request: ';
						nextPutAll: aString;
						cr.
					labelList
						with: valueList
						do: [ :label :value | s
								tab;
								nextPutAll: label asString;
								nextPutAll: ':';
								tab;
								print: value;
								cr ] ])
]

NonInteractiveUIManager >> confirm: queryString
[
	(ProvideAnswerNotification signal: queryString) ifNotNil: [ :answer | ^ answer ].
	^ self nonInteractiveWarning: 'Confirming: ' , queryString
]

NonInteractiveUIManager >> confirm: queryString label: titleString
[
	^ self nonInteractiveRequest: queryString title: titleString
]

NonInteractiveUIManager >> confirm: aString orCancel: cancelBlock
[
	^ self nonInteractiveRequest: aString
]

NonInteractiveUIManager >> confirm: queryString trueChoice: trueChoice falseChoice: falseChoice
[
	^ self nonInteractiveRequest: queryString
]

NonInteractiveUIManager >> confirm: queryString trueChoice: trueChoice falseChoice: falseChoice cancelChoice: cancelChoice default: aSymbol
[
	^ self nonInteractiveRequest: queryString
]

NonInteractiveUIManager >> edit: aText label: labelString accept: anAction
[
	"Open an editor on the given string/text"

	^ self
		nonInteractiveWarning:
			(String
				streamContents: [ :s | s nextPutAll: 'Editing Text: '.
					labelString ifNotNil: [ s
								nextPutAll: '[ ';
								nextPutAll: labelString;
								nextPutAll: ' ] ' ].
					s
						cr;
						nextPutAll: aText ])
]

NonInteractiveUIManager >> fileDoesNotExistsDefaultAction: anException
[
	^ self nonInteractive: anException
]

NonInteractiveUIManager >> fileExistsDefaultAction: anException
[
	^ self nonInteractive: anException
]

NonInteractiveUIManager >> fontFromUser: priorFont
[
	^ self nonInteractiveWarning: 'Font Choose Request'
]

NonInteractiveUIManager >> lowSpaceWatcherDefaultAction: preemptedProcess
[
	| ctx |
	"yeah.. space is low.. quit!! :)"
	ctx := preemptedProcess ifNotNil: [ preemptedProcess suspendedContext ].
	ctx ifNil: [ ctx := thisContext sender ].
	self quitFrom: ctx withMessage: 'Low space signal received.'.
	self error	"what else we can do? "
]

NonInteractiveUIManager >> multiLineRequest: queryString initialAnswer: defaultAnswer answerHeight: answerHeight
[
	^ self nonInteractiveRequest: queryString
]

NonInteractiveUIManager >> nonInteractive
[
	^ ErrorNonInteractive signal
]

NonInteractiveUIManager >> nonInteractive: anException
[
	^ ErrorNonInteractive signalForException: anException
]

NonInteractiveUIManager >> nonInteractiveManager
[
	" Answer an instance of non-interactive manager, which will be used when image runs headless.
	  We put it here, so subclasses can override it. 
	
	We already non-interactive. Just answer self
	"

	^ self
]

NonInteractiveUIManager >> nonInteractiveRequest: aStringOrText
[
	^ self nonInteractiveRequest: aStringOrText title: nil
]

NonInteractiveUIManager >> nonInteractiveRequest: aStringOrText title: aTitle
[
	^ self
		nonInteractiveWarning:
			(String
				streamContents: [ :s | s nextPutAll: 'Interactive Request: '.
					aTitle ifNotNil: [ s
								nextPutAll: '[ ';
								nextPutAll: aTitle asString;
								nextPutAll: ' ] ' ].
					s nextPutAll: aStringOrText asString ])
]

NonInteractiveUIManager >> nonInteractiveWarning: aWarnMessage
[
	^ ErrorNonInteractive signal: aWarnMessage
]

NonInteractiveUIManager >> onDebug: process context: context title: title full: bool
[
	^ self nonInteractiveWarning: 'Opening Debugger'
]

NonInteractiveUIManager >> onSnapshot: resuming
[
	"The resuming argument is true when image boots from disk,
	and false, if user just did an image snapshot."

	resuming
		ifTrue: [ Smalltalk isHeadless
				ifFalse: [ "restore old, or nil, so it will be set in #default "
					uiManager beDefault.
					UIManager default onSnapshot: resuming.
					^ self ].
			Smalltalk isInteractive
				ifTrue: [ "use a headless but interactive manager"
					^ self headlessManager onSnapshot: resuming ] ].	" this flag set to true only if we are saving a snapshot before quitting "
	doNotQuitOnRestart
		ifTrue: [ Smalltalk snapshot: false andQuit: true ]
]

NonInteractiveUIManager >> request: queryString initialAnswer: defaultAnswer
[
	^ self
		request: queryString
		initialAnswer: defaultAnswer
		title: nil
		entryCompletion: nil
]

NonInteractiveUIManager >> request: queryString initialAnswer: defaultAnswer centerAt: aPoint
[
	"Create an instance of me whose question is queryString with the given initial answer. Answer the string the user accepts. Answer the empty string if the user cancels."

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		title: nil
		entryCompletion: nil
]

NonInteractiveUIManager >> request: queryString initialAnswer: defaultAnswer entryCompletion: anEntryCompletion
[
	^ self
		request: queryString
		initialAnswer: defaultAnswer
		title: nil
		entryCompletion: anEntryCompletion
]

NonInteractiveUIManager >> request: aStringOrText initialAnswer: defaultAnswer title: aTitle
[
	^ self
		request: aStringOrText
		initialAnswer: defaultAnswer
		title: aTitle
		entryCompletion: nil
]

NonInteractiveUIManager >> request: aStringOrText initialAnswer: defaultAnswer title: aTitle entryCompletion: anEntryCompletion
[
	(ProvideAnswerNotification signal: aStringOrText)
		ifNotNil: [ :answer | ^ answer = #default
				ifTrue: [ defaultAnswer ]
				ifFalse: [ answer ] ].
	^ self nonInteractiveRequest: aStringOrText title: aTitle
]

NonInteractiveUIManager >> requestPassword: queryString
[
	^ self nonInteractiveWarning: 'Requesting Password'
]

NonInteractiveUIManager >> syntaxErrorNotificationDefaultAction: aSyntaxErrorNotification
[
	"display and log the syntax error"

	super syntaxErrorNotificationDefaultAction: aSyntaxErrorNotification.	"in noninteractive mode simply quit"
	^ self exitFailure
]

the user cancels."

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		title: nil
		entryCompletion: nil
]

NonInteractiveUIManager >> request: queryString initialAnswer: defaultAnswer entryCompletion: anEntryCompletion
[request: queryString initialAnswer: defaultAnswer entryCompletion: anEntryCompletion
	^ self
		request: queryString
		initialAnswer: defaultAnswer
		title: nil
		entryCompletion: anEntryCompletion
]

NonInteractiveUIManager >> request: aStringOrText initialAnswer: defaultAnswer title: aTitle
[request: aStringOrText initialAnswer: defaultAnswer title: aTitle
	^ self
		request: aStringOrText
		initialAnswer: defaultAnswer
		title: aTitle
		entryCompletion: nil
]

NonInteractiveUIManager >> request: aStringOrText initialAnswer: defaultAnswer title: aTitle entryCompletion: anEntryCompletion
[request: aStringOrText initialAnswer: defaultAnswer title: aTitle entryCompletion: anEntryCompletion
	(ProvideAnswerNotification signal: aStringOrText)
		ifNotNil: [ :answer | ^ answer = #default
				ifTrue: [ defaultAnswer ]
				ifFalse: [ answer ] ].
	^ self nonInteractiveRequest: aStringOrText title: aTitle
]

NonInteractiveUIManager >> requestPassword: queryString
[requestPassword: queryString
	^ self nonInteractiveWarning: 'Requesting Password'
]

NonInteractiveUIManager >> syntaxErrorNotificationDefaultAction: aSyntaxErrorNotification
[syntaxErrorNotificationDefaultAction: aSyntaxErrorNotification
	"display and log the syntax error"

	super syntaxErrorNotificationDefaultAction: aSyntaxErrorNotification.	"in noninteractive mode simply quit"
	^ self exitFailure
]

