RxMatcher
	instanceVariables: #(#matcher #ignoreCase #startOptimizer #stream #markerPositions #markerCount #lastResult );
	classVariables: #(#Cr #Lf );
	package: #'Regex-Core'.

RxMatcher >> allocateMarker
allocateMarker
	"Answer an integer to use as an index of the next marker."

	markerCount := markerCount + 1.
	^ markerCount

RxMatcher >> atBeginningOfLine
atBeginningOfLine
	^ self position = 0 or: [ self lastChar = Cr ]

RxMatcher >> atBeginningOfWord
atBeginningOfWord
	^ (self isWordChar: self lastChar) not and: [ self isWordChar: stream peek ]

RxMatcher >> atEnd
atEnd
	^ stream atEnd

RxMatcher >> atEndOfLine
atEndOfLine
	^ self atEnd or: [ stream peek = Cr ]

RxMatcher >> atEndOfWord
atEndOfWord
	^ (self isWordChar: self lastChar) and: [ (self isWordChar: stream peek) not ]

RxMatcher >> atWordBoundary
atWordBoundary
	^ (self isWordChar: self lastChar) xor: (self isWordChar: stream peek)

RxMatcher >> buildFrom: aSyntaxTreeRoot
buildFrom: aSyntaxTreeRoot
	"Private - Entry point of matcher build process."

	markerCount := 0.	"must go before #dispatchTo: !"
	matcher := aSyntaxTreeRoot dispatchTo: self.
	matcher terminateWith: RxmTerminator new

RxMatcher >> copy: aString replacingMatchesWith: replacementString
copy: aString replacingMatchesWith: replacementString
	"Copy <aString>, except for the matches. Replace each match with <aString>."

	| answer |
	answer := (String new: 40) writeStream.
	self copyStream: aString readStream to: answer replacingMatchesWith: replacementString.
	^ answer contents

RxMatcher >> copy: aString translatingMatchesUsing: aBlock
copy: aString translatingMatchesUsing: aBlock
	"Copy <aString>, except for the matches. For each match, evaluate <aBlock> passing the matched substring as the argument.  Expect the block to answer a String, and replace the match with the answer."

	| answer |
	answer := (String new: 40) writeStream.
	self copyStream: aString readStream to: answer translatingMatchesUsing: aBlock.
	^ answer contents

RxMatcher >> copyStream: aStream to: writeStream replacingMatchesWith: aString
copyStream: aStream to: writeStream replacingMatchesWith: aString
	"Copy the contents of <aStream> on the <writeStream>, except for the matches. Replace each match with <aString>."

	| searchStart matchStart matchEnd |
	stream := aStream.
	markerPositions := nil.
	[ searchStart := aStream position.
	self proceedSearchingStream: aStream ]
		whileTrue: [ 
			matchStart := (self subBeginning: 1) first.
			matchEnd := (self subEnd: 1) first.
			aStream position: searchStart.
			searchStart to: matchStart - 1 do: [ :ignoredPos | writeStream nextPut: aStream next ].
			writeStream nextPutAll: aString.
			aStream position: matchEnd.	"Be extra careful about successful matches which consume no input.		After those, make sure to advance or finish if already at end."
			matchEnd = searchStart
				ifTrue: [ aStream atEnd
						ifTrue: [ ^ self	"rest after end of whileTrue: block is a no-op if atEnd" ]
						ifFalse: [ writeStream nextPut: aStream next ] ] ].
	aStream position: searchStart.
	[ aStream atEnd ] whileFalse: [ writeStream nextPut: aStream next ]

RxMatcher >> copyStream: aStream to: writeStream translatingMatchesUsing: aBlock
copyStream: aStream to: writeStream translatingMatchesUsing: aBlock
	"Copy the contents of <aStream> on the <writeStream>, except for the matches. For each match, evaluate <aBlock> passing the matched substring as the argument.  Expect the block to answer a String, and write the answer to <writeStream> in place of the match."

	| searchStart matchStart matchEnd match |
	stream := aStream.
	markerPositions := nil.
	[ searchStart := aStream position.
	self proceedSearchingStream: aStream ]
		whileTrue: [ 
			matchStart := (self subBeginning: 1) first.
			matchEnd := (self subEnd: 1) first.
			aStream position: searchStart.
			searchStart to: matchStart - 1 do: [ :ignoredPos | writeStream nextPut: aStream next ].
			match := (String new: matchEnd - matchStart + 1) writeStream.
			matchStart to: matchEnd - 1 do: [ :ignoredPos | match nextPut: aStream next ].
			writeStream nextPutAll: (aBlock value: match contents).	"Be extra careful about successful matches which consume no input.		After those, make sure to advance or finish if already at end."
			matchEnd = searchStart
				ifTrue: [ aStream atEnd
						ifTrue: [ ^ self	"rest after end of whileTrue: block is a no-op if atEnd" ]
						ifFalse: [ writeStream nextPut: aStream next ] ] ].
	aStream position: searchStart.
	[ aStream atEnd ] whileFalse: [ writeStream nextPut: aStream next ]

RxMatcher >> currentState
currentState
	"Answer an opaque object that can later be used to restore the
	matcher's state (for backtracking)."

	| origPosition origLastChar |
	origPosition := stream position.
	^ [ stream position: origPosition ]

RxMatcher >> hookBranchOf: regexNode onto: endMarker
hookBranchOf: regexNode onto: endMarker
	"Private - Recurse down the chain of regexes starting at
	regexNode, compiling their branches and hooking their tails 
	to the endMarker node."

	| rest |
	rest := regexNode regex isNil
		ifTrue: [ nil ]
		ifFalse: [ self hookBranchOf: regexNode regex onto: endMarker ].
	^ RxmBranch new
		next: ((regexNode branch dispatchTo: self)
						pointTailTo: endMarker;
						yourself);
		alternative: rest;
		yourself

RxMatcher >> initialize: syntaxTreeRoot ignoreCase: aBoolean
initialize: syntaxTreeRoot ignoreCase: aBoolean
	"Compile thyself for the regex with the specified syntax tree.
	See comment and `building' protocol in this class and 
	#dispatchTo: methods in syntax tree components for details 
	on double-dispatch building. 
	The argument is supposedly a RxsRegex."

	ignoreCase := aBoolean.
	self buildFrom: syntaxTreeRoot.
	startOptimizer := RxMatchOptimizer new initialize: syntaxTreeRoot ignoreCase: aBoolean

RxMatcher >> isWordChar: aCharacterOrNil
isWordChar: aCharacterOrNil
	"Answer whether the argument is a word constituent character:
	alphanumeric or _."

	^ aCharacterOrNil ~~ nil and: [ aCharacterOrNil isAlphaNumeric ]

RxMatcher >> lastChar
lastChar
	^ stream position = 0
		ifFalse: [ stream
				skip: -1;
				next ]

RxMatcher >> lastResult
lastResult
	^ lastResult

RxMatcher >> makeOptional: aMatcher
makeOptional: aMatcher
	"Private - Wrap this matcher so that the result would match 0 or 1
	occurrences of the matcher."

	| dummy branch |
	dummy := RxmLink new.
	branch := RxmBranch new beLoopback
		next: aMatcher;
		alternative: dummy.
	aMatcher pointTailTo: dummy.
	^ branch

RxMatcher >> makePlus: aMatcher
makePlus: aMatcher
	"Private - Wrap this matcher so that the result would match 1 and more
	occurrences of the matcher."

	| loopback |
	loopback := RxmBranch new beLoopback next: aMatcher.
	aMatcher pointTailTo: loopback.
	^ aMatcher

RxMatcher >> makeQuantified: anRxmLink min: min max: max
makeQuantified: anRxmLink min: min max: max
	"Perform recursive poor-man's transformation of the {<min>,<max>} quantifiers."

	| aMatcher |
	"<atom>{,<max>}       ==>  (<atom>{1,<max>})?"
	min = 0
		ifTrue: [ ^ self makeOptional: (self makeQuantified: anRxmLink min: 1 max: max) ].	"<atom>{<min>,}       ==>  <atom>{<min>-1, <min>-1}<atom>+"
	max ifNil: [ ^ (self makeQuantified: anRxmLink min: 1 max: min - 1) pointTailTo: (self makePlus: anRxmLink copy) ].	"<atom>{<max>,<max>}  ==>  <atom><atom> ... <atom>"
	min = max
		ifTrue: [ aMatcher := anRxmLink copy.
			min - 1 timesRepeat: [ aMatcher pointTailTo: anRxmLink copy ].
			^ aMatcher ].	"<atom>{<min>,<max>}  ==>  <atom>{<min>,<min>}(<atom>{1,<max>-1})?"
	aMatcher := self makeOptional: anRxmLink copy.
	max - min - 1 timesRepeat: [ aMatcher := self makeOptional: (anRxmLink copy pointTailTo: aMatcher) ].
	^ (self makeQuantified: anRxmLink min: min max: min) pointTailTo: aMatcher

RxMatcher >> makeStar: aMatcher
makeStar: aMatcher
	"Private - Wrap this matcher so that the result would match 0 and more
	occurrences of the matcher."

	| dummy detour loopback |
	dummy := RxmLink new.
	detour := RxmBranch new
		next: aMatcher;
		alternative: dummy.
	loopback := RxmBranch new beLoopback
		next: aMatcher;
		alternative: dummy.
	aMatcher pointTailTo: loopback.
	^ detour

RxMatcher >> markerPositionAt: anIndex add: position
markerPositionAt: anIndex add: position
	"Remember position of another instance of the given marker."

	(markerPositions at: anIndex) addFirst: position

RxMatcher >> matches: aString
matches: aString
	"Match against a string. Return true if the complete String matches.
	If you want to search for occurences anywhere in the String see #search:"

	^ self matchesStream: aString readStream

RxMatcher >> matchesIn: aString
matchesIn: aString
	"Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of all matches (substrings)."

	| result |
	result := OrderedCollection new.
	self matchesOnStream: aString readStream do: [ :match | result add: match ].
	^ result

RxMatcher >> matchesIn: aString collect: aBlock
matchesIn: aString collect: aBlock
	"Search aString repeatedly for the matches of the receiver.  Evaluate aBlock for each match passing the matched substring as the argument, collect evaluation results in an OrderedCollection, and return in. The following example shows how to use this message to split a string into words."

	"'\w+' asRegex matchesIn: 'Now is the Time' collect: [:each | each asLowercase]"

	| result |
	result := OrderedCollection new.
	self matchesOnStream: aString readStream do: [ :match | result add: (aBlock value: match) ].
	^ result

RxMatcher >> matchesIn: aString do: aBlock
matchesIn: aString do: aBlock
	"Search aString repeatedly for the matches of the receiver.
	Evaluate aBlock for each match passing the matched substring
	as the argument."

	self matchesOnStream: aString readStream do: aBlock

RxMatcher >> matchesOnStream: aStream
matchesOnStream: aStream
	| result |
	result := OrderedCollection new.
	self matchesOnStream: aStream do: [ :match | result add: match ].
	^ result

RxMatcher >> matchesOnStream: aStream collect: aBlock
matchesOnStream: aStream collect: aBlock
	| result |
	result := OrderedCollection new.
	self matchesOnStream: aStream do: [ :match | result add: (aBlock value: match) ].
	^ result

RxMatcher >> matchesOnStream: aStream do: aBlock
matchesOnStream: aStream do: aBlock
	"Be extra careful about successful matches which consume no input.
	After those, make sure to advance or finish if already at end."

	| position subexpression |
	[ position := aStream position.
	self searchStream: aStream ]
		whileTrue: [ subexpression := self subexpression: 1.
			aBlock value: subexpression.
			subexpression size = 0
				ifTrue: [ aStream atEnd
						ifTrue: [ ^ self ]
						ifFalse: [ aStream next ] ] ]

RxMatcher >> matchesPrefix: aString
matchesPrefix: aString
	"Match against a string. Return true if a prefix matches.
	If you want to match 
		- the full string use #matches:
		- anywhere in the string use #search:"

	^ self matchesStreamPrefix: aString readStream

RxMatcher >> matchesStream: theStream
matchesStream: theStream
	"Match thyself against a positionable stream."

	^ (self matchesStreamPrefix: theStream) and: [ stream atEnd ]

RxMatcher >> matchesStreamPrefix: theStream
matchesStreamPrefix: theStream
	"Match thyself against a positionable stream."

	stream := theStream.
	markerPositions := nil.
	^ self tryMatch

RxMatcher >> matchingRangesIn: aString
matchingRangesIn: aString
	"Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."

	| result |
	result := OrderedCollection new.
	self matchesIn: aString do: [ :match | result add: (self position - match size + 1 to: self position) ].
	^ result

RxMatcher >> next
next
	^ stream next

RxMatcher >> notAtWordBoundary
notAtWordBoundary
	^ self atWordBoundary not

RxMatcher >> position
position
	^ stream position

RxMatcher >> proceedSearchingStream: aStream
proceedSearchingStream: aStream
	| position |
	position := aStream position.
	[ aStream atEnd ]
		whileFalse: [ self tryMatch
				ifTrue: [ ^ true ].
			aStream
				position: position;
				next.
			position := aStream position ].	"Try match at the very stream end too!"
	self tryMatch
		ifTrue: [ ^ true ].
	^ false

RxMatcher >> restoreState: aBlock
restoreState: aBlock
	aBlock value

RxMatcher >> search: aString
search: aString
	"Search anywhere in the String for occurrence of something matching myself.
	If you want to match the full String see #matches:
	Answer a Boolean indicating success."

	^ self searchStream: aString readStream

RxMatcher >> searchStream: aStream
searchStream: aStream
	"Search the stream for occurrence of something matching myself.
	After the search has occurred, stop positioned after the end of the
	matched substring. Answer a Boolean indicating success."

	| position |
	stream := aStream.
	position := aStream position.
	markerPositions := nil.
	[ aStream atEnd ]
		whileFalse: [ self tryMatch
				ifTrue: [ ^ true ].
			aStream
				position: position;
				next.
			position := aStream position ].	"Try match at the very stream end too!"
	self tryMatch
		ifTrue: [ ^ true ].
	^ false

RxMatcher >> subBeginning: subIndex
subBeginning: subIndex
	^ markerPositions at: subIndex * 2 - 1

RxMatcher >> subEnd: subIndex
subEnd: subIndex
	^ markerPositions at: subIndex * 2

RxMatcher >> subexpression: subIndex
subexpression: subIndex
	"Answer a string that matched the subexpression at the given index.
	If there are multiple matches, answer the last one.
	If there are no matches, answer nil. 
	(NB: it used to answer an empty string but I think nil makes more sense)."

	| matches |
	matches := self subexpressions: subIndex.
	^ matches isEmpty
		ifTrue: [ nil ]
		ifFalse: [ matches last ]

RxMatcher >> subexpressionCount
subexpressionCount
	^ markerCount // 2

RxMatcher >> subexpressions: subIndex
subexpressions: subIndex
	"Answer an array of all matches of the subexpression at the given index.
	The answer is always an array; it is empty if there are no matches."

	| originalPosition startPositions stopPositions reply |
	originalPosition := stream position.
	startPositions := self subBeginning: subIndex.
	stopPositions := self subEnd: subIndex.
	(startPositions isEmpty or: [ stopPositions isEmpty ])
		ifTrue: [ ^ Array new ].
	reply := OrderedCollection new.
	startPositions
		with: stopPositions
		do: [ :start :stop | stream position: start.
			reply add: (stream next: stop - start) ].
	stream position: originalPosition.
	^ reply asArray

RxMatcher >> supportsSubexpressions
supportsSubexpressions
	^ true

RxMatcher >> syntaxAny
syntaxAny
	"Double dispatch from the syntax tree. 
	Create a matcher for any non-null character."

	^ RxmPredicate new predicate: [ :char | char asInteger ~= 0 ]

RxMatcher >> syntaxBeginningOfLine
syntaxBeginningOfLine
	"Double dispatch from the syntax tree. 
	Create a matcher for beginning-of-line condition."

	^ RxmSpecial new beBeginningOfLine

RxMatcher >> syntaxBeginningOfWord
syntaxBeginningOfWord
	"Double dispatch from the syntax tree. 
	Create a matcher for beginning-of-word condition."

	^ RxmSpecial new beBeginningOfWord

RxMatcher >> syntaxBranch: branchNode
syntaxBranch: branchNode
	"Double dispatch from the syntax tree. 
	Branch node is a link in a chain of concatenated pieces.
	First build the matcher for the rest of the chain, then make 
	it for the current piece and hook the rest to it."

	| result next rest |
	branchNode branch isNil
		ifTrue: [ ^ branchNode piece dispatchTo: self ].	"Optimization: glue a sequence of individual characters into a single string to match."
	branchNode piece isAtomic
		ifTrue: [ result := (String new: 40) writeStream.
			next := branchNode tryMergingInto: result.
			result := result contents.
			result size > 1
				ifTrue: [ "worth merging"
					rest := next notNil
						ifTrue: [ next dispatchTo: self ]
						ifFalse: [ nil ].
					^ (RxmSubstring new substring: result ignoreCase: ignoreCase)
						pointTailTo: rest;
						yourself ] ].	"No optimization possible or worth it, just concatenate all. "
	^ (branchNode piece dispatchTo: self)
		pointTailTo: (branchNode branch dispatchTo: self);
		yourself

RxMatcher >> syntaxCharSet: charSetNode
syntaxCharSet: charSetNode
	"Double dispatch from the syntax tree. 
	A character set is a few characters, and we either match any of them,
	or match any that is not one of them."

	^ RxmPredicate with: (charSetNode predicateIgnoringCase: ignoreCase)

RxMatcher >> syntaxCharacter: charNode
syntaxCharacter: charNode
	"Double dispatch from the syntax tree. 
	We get here when no merging characters into strings was possible."

	| wanted |
	wanted := charNode character.
	^ RxmPredicate new
		predicate: (ignoreCase
				ifTrue: [ [ :char | char sameAs: wanted ] ]
				ifFalse: [ [ :char | char = wanted ] ])

RxMatcher >> syntaxEndOfLine
syntaxEndOfLine
	"Double dispatch from the syntax tree. 
	Create a matcher for end-of-line condition."

	^ RxmSpecial new beEndOfLine

RxMatcher >> syntaxEndOfWord
syntaxEndOfWord
	"Double dispatch from the syntax tree. 
	Create a matcher for end-of-word condition."

	^ RxmSpecial new beEndOfWord

RxMatcher >> syntaxEpsilon
syntaxEpsilon
	"Double dispatch from the syntax tree. Match empty string. This is unlikely
	to happen in sane expressions, so we'll live without special epsilon-nodes."

	^ RxmSubstring new substring: String new ignoreCase: ignoreCase

RxMatcher >> syntaxLookaround: lookaroundNode
syntaxLookaround: lookaroundNode
	"Double dispatch from the syntax tree. 
	Special link can handle lookarounds (look ahead, positive and negative)."

	| piece |
	piece := lookaroundNode piece dispatchTo: self.
	^ RxmLookahaed with: piece

RxMatcher >> syntaxMessagePredicate: messagePredicateNode
syntaxMessagePredicate: messagePredicateNode
	"Double dispatch from the syntax tree. 
	Special link can handle predicates."

	^ messagePredicateNode negated
		ifTrue: [ RxmPredicate new bePerformNot: messagePredicateNode selector ]
		ifFalse: [ RxmPredicate new bePerform: messagePredicateNode selector ]

RxMatcher >> syntaxNonWordBoundary
syntaxNonWordBoundary
	"Double dispatch from the syntax tree. 
	Create a matcher for the word boundary condition."

	^ RxmSpecial new beNotWordBoundary

RxMatcher >> syntaxPiece: pieceNode
syntaxPiece: pieceNode
	"Double dispatch from the syntax tree. 
	Piece is an atom repeated a few times. Take care of a special
	case when the atom is repeated just once."

	| atom |
	atom := pieceNode atom dispatchTo: self.
	^ pieceNode isSingular
		ifTrue: [ atom ]
		ifFalse: [ pieceNode isStar
				ifTrue: [ self makeStar: atom ]
				ifFalse: [ pieceNode isPlus
						ifTrue: [ self makePlus: atom ]
						ifFalse: [ pieceNode isOptional
								ifTrue: [ self makeOptional: atom ]
								ifFalse: [ self makeQuantified: atom min: pieceNode min max: pieceNode max ] ] ] ]

RxMatcher >> syntaxPredicate: predicateNode
syntaxPredicate: predicateNode
	"Double dispatch from the syntax tree. 
	A character set is a few characters, and we either match any of them,
	or match any that is not one of them."

	^ RxmPredicate with: predicateNode predicate

RxMatcher >> syntaxRegex: regexNode
syntaxRegex: regexNode
	"Double dispatch from the syntax tree. 
	Regex node is a chain of branches to be tried. Should compile this 
	into a bundle of parallel branches, between two marker nodes."

	| startIndex endIndex endNode alternatives |
	startIndex := self allocateMarker.
	endIndex := self allocateMarker.
	endNode := RxmMarker new index: endIndex.
	alternatives := self hookBranchOf: regexNode onto: endNode.
	^ (RxmMarker new index: startIndex)
		pointTailTo: alternatives;
		yourself

RxMatcher >> syntaxWordBoundary
syntaxWordBoundary
	"Double dispatch from the syntax tree. 
	Create a matcher for the word boundary condition."

	^ RxmSpecial new beWordBoundary

RxMatcher >> tryMatch
tryMatch
	"Match thyself against the current stream."

	| oldMarkerPositions |
	oldMarkerPositions := markerPositions.
	markerPositions := Array new: markerCount.
	1 to: markerCount do: [ :i | markerPositions at: i put: OrderedCollection new ].
	lastResult := startOptimizer isNil
		ifTrue: [ matcher matchAgainst: self ]
		ifFalse: [ (startOptimizer canStartMatch: stream peek in: self) and: [ matcher matchAgainst: self ] ].	"check for duplicates"
	(lastResult not or: [ oldMarkerPositions isNil or: [ oldMarkerPositions size ~= markerPositions size ] ])
		ifTrue: [ ^ lastResult ].
	oldMarkerPositions
		with: markerPositions
		do: [ :oldPos :newPos | oldPos size = newPos size
				ifFalse: [ ^ lastResult ].
			oldPos with: newPos do: [ :old :new | old = new
						ifFalse: [ ^ lastResult ] ] ].	"this is a duplicate"
	^ lastResult := false

RxMatcher class >> for: aRegex
for: aRegex
	"Create and answer a matcher that will match a regular expression
	specified by the syntax tree of which `aRegex' is a root."

	^ self for: aRegex ignoreCase: false

RxMatcher class >> for: aRegex ignoreCase: aBoolean
for: aRegex ignoreCase: aBoolean
	"Create and answer a matcher that will match a regular expression
	specified by the syntax tree of which `aRegex' is a root."

	^ self new initialize: aRegex ignoreCase: aBoolean

RxMatcher class >> forString: aString
forString: aString
	"Create and answer a matcher that will match the regular expression
	`aString'."

	^ self for: (RxParser new parse: aString)

RxMatcher class >> forString: aString ignoreCase: aBoolean
forString: aString ignoreCase: aBoolean
	"Create and answer a matcher that will match the regular expression
	`aString'."

	^ self for: (RxParser new parse: aString) ignoreCase: aBoolean

RxMatcher class >> initialize
initialize
	"RxMatcher initialize"

	Cr := Character cr.
	Lf := Character lf

