RxsCharSet
	superclass: #RxsNode;
	instanceVariables: #(#negated #elements );
	package: #'Regex-Core'.

RxsCharSet >> dispatchTo: aMatcher
[
	"Inform the matcher of the kind of the node, and it
	will do whatever it has to."

	^ aMatcher syntaxCharSet: self
]

RxsCharSet >> enumerablePartPredicateIgnoringCase: aBoolean
[
	| enumeration |
	enumeration := self optimalSetIgnoringCase: aBoolean.
	^ negated
		ifTrue: [ [ :char | (enumeration includes: char) not ] ]
		ifFalse: [ [ :char | enumeration includes: char ] ]
]

RxsCharSet >> enumerableSetIgnoringCase: aBoolean
[
	"Answer a collection of characters that make up the portion of me
	that can be enumerated."

	| set |
	set := Set new.
	elements do: [ :each | each isEnumerable
				ifTrue: [ each enumerateTo: set ignoringCase: aBoolean ] ].
	^ set
]

RxsCharSet >> hasPredicates
[
	^ elements contains: [ :some | some isEnumerable not ]
]

RxsCharSet >> initializeElements: aCollection negated: aBoolean
[
	"See class comment for instance variables description."

	elements := aCollection.
	negated := aBoolean
]

RxsCharSet >> isEnumerable
[
	elements detect: [ :some | some isEnumerable not ] ifNone: [ ^ true ].
	^ false
]

RxsCharSet >> isNegated
[
	^ negated
]

RxsCharSet >> optimalSetIgnoringCase: aBoolean
[
	"Assuming the client with search the `set' using #includes:,
	answer a collection with the contents of `set', of the class
	that will provide the fastest lookup. Strings are faster than
	Sets for short strings."

	| set |
	set := self enumerableSetIgnoringCase: aBoolean.
	^ set size < 10
		ifTrue: [ set asArray ]
		ifFalse: [ set ]
]

RxsCharSet >> predicateIgnoringCase: aBoolean
[
	| predicate enumerable |
	enumerable := self enumerablePartPredicateIgnoringCase: aBoolean.
	^ self hasPredicates
		ifFalse: [ enumerable ]
		ifTrue: [ predicate := self predicatePartPredicate.
			negated
				ifTrue: [ [ :char | (enumerable value: char) and: [ predicate value: char ] ] ]
				ifFalse: [ [ :char | (enumerable value: char) or: [ predicate value: char ] ] ] ]
]

RxsCharSet >> predicatePartPredicate
[
	"Answer a predicate that tests all of my elements that cannot be
	enumerated."

	| predicates |
	predicates := elements reject: [ :some | some isEnumerable ].
	predicates isEmpty
		ifTrue: [ ^ [ :char | negated ] ].
	predicates size = 1
		ifTrue: [ ^ negated
				ifTrue: [ predicates first predicateNegation ]
				ifFalse: [ predicates first predicate ] ].
	predicates := predicates collect: [ :each | each predicate ].
	^ negated
		ifFalse: [ [ :char | predicates contains: [ :some | some value: char ] ] ]
		ifTrue: [ [ :char | (predicates contains: [ :some | some value: char ]) not ] ]
]

RxsCharSet >> predicates
[
	^ (elements reject: [ :some | some isEnumerable ]) collect: [ :each | each predicate ]
]

