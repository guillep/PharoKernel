RxsPredicate
	superclass: #RxsNode;
	instanceVariables: #(#predicate #negation );
	classVariables: #(#EscapedLetterSelectors #NamedClassSelectors );
	package: #'Regex-Core'.

RxsPredicate >> beAlphaNumeric
beAlphaNumeric
	predicate := [ :char | char isAlphaNumeric ].
	negation := [ :char | char isAlphaNumeric not ]

RxsPredicate >> beAlphabetic
beAlphabetic
	predicate := [ :char | char isLetter ].
	negation := [ :char | char isLetter not ]

RxsPredicate >> beBackslash
beBackslash
	predicate := [ :char | char == $\ ].
	negation := [ :char | char ~~ $\ ]

RxsPredicate >> beControl
beControl
	predicate := [ :char | char asInteger < 32 ].
	negation := [ :char | char asInteger >= 32 ]

RxsPredicate >> beDigit
beDigit
	predicate := [ :char | char isDigit ].
	negation := [ :char | char isDigit not ]

RxsPredicate >> beGraphics
beGraphics
	self
		beControl;
		negate

RxsPredicate >> beHexDigit
beHexDigit
	| hexLetters |
	hexLetters := 'abcdefABCDEF'.
	predicate := [ :char | char isDigit or: [ hexLetters includes: char ] ].
	negation := [ :char | char isDigit not and: [ (hexLetters includes: char) not ] ]

RxsPredicate >> beLowercase
beLowercase
	predicate := [ :char | char isLowercase ].
	negation := [ :char | char isLowercase not ]

RxsPredicate >> beNotDigit
beNotDigit
	self
		beDigit;
		negate

RxsPredicate >> beNotSpace
beNotSpace
	self
		beSpace;
		negate

RxsPredicate >> beNotWordConstituent
beNotWordConstituent
	self
		beWordConstituent;
		negate

RxsPredicate >> bePrintable
bePrintable
	self
		beControl;
		negate

RxsPredicate >> bePunctuation
bePunctuation
	| punctuationChars |
	punctuationChars := #($. $, $! $? $; $: $" $' $- $( $) $`).
	predicate := [ :char | punctuationChars includes: char ].
	negation := [ :char | (punctuationChars includes: char) not ]

RxsPredicate >> beSpace
beSpace
	predicate := [ :char | char isSeparator ].
	negation := [ :char | char isSeparator not ]

RxsPredicate >> beUppercase
beUppercase
	predicate := [ :char | char isUppercase ].
	negation := [ :char | char isUppercase not ]

RxsPredicate >> beWordConstituent
beWordConstituent
	predicate := [ :char | char isAlphaNumeric or: [ char == $_ ] ].
	negation := [ :char | char isAlphaNumeric not and: [ char ~~ $_ ] ]

RxsPredicate >> dispatchTo: anObject
dispatchTo: anObject
	^ anObject syntaxPredicate: self

RxsPredicate >> isEnumerable
isEnumerable
	^ false

RxsPredicate >> negate
negate
	| tmp |
	tmp := predicate.
	predicate := negation.
	negation := tmp

RxsPredicate >> negated
negated
	^ self copy negate

RxsPredicate >> predicate
predicate
	^ predicate

RxsPredicate >> predicateNegation
predicateNegation
	^ negation

RxsPredicate >> value: aCharacter
value: aCharacter
	^ predicate value: aCharacter

RxsPredicate class >> forEscapedLetter: aCharacter
forEscapedLetter: aCharacter
	^ self new
		perform: (EscapedLetterSelectors at: aCharacter ifAbsent: [ RxParser signalSyntaxException: 'bad backslash escape' ])

RxsPredicate class >> forNamedClass: aString
forNamedClass: aString
	^ self new
		perform: (NamedClassSelectors at: aString ifAbsent: [ RxParser signalSyntaxException: 'bad character class name' ])

RxsPredicate class >> initialize
initialize
	"self initialize"

	self
		initializeNamedClassSelectors;
		initializeEscapedLetterSelectors

RxsPredicate class >> initializeEscapedLetterSelectors
initializeEscapedLetterSelectors
	"self initializeEscapedLetterSelectors"

	(EscapedLetterSelectors := Dictionary new)
		at: $w put: #beWordConstituent;
		at: $W put: #beNotWordConstituent;
		at: $d put: #beDigit;
		at: $D put: #beNotDigit;
		at: $s put: #beSpace;
		at: $S put: #beNotSpace;
		at: $\ put: #beBackslash

RxsPredicate class >> initializeNamedClassSelectors
initializeNamedClassSelectors
	"self initializeNamedClassSelectors"

	(NamedClassSelectors := Dictionary new)
		at: 'alnum' put: #beAlphaNumeric;
		at: 'alpha' put: #beAlphabetic;
		at: 'cntrl' put: #beControl;
		at: 'digit' put: #beDigit;
		at: 'graph' put: #beGraphics;
		at: 'lower' put: #beLowercase;
		at: 'print' put: #bePrintable;
		at: 'punct' put: #bePunctuation;
		at: 'space' put: #beSpace;
		at: 'upper' put: #beUppercase;
		at: 'xdigit' put: #beHexDigit

