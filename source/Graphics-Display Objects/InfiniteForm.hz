InfiniteForm
	superclass: #DisplayObject;
	instanceVariables: #(#patternForm );
	package: #'Graphics-Display Objects'.

InfiniteForm >> addFillStyleMenuItems: aMenu hand: aHand from: aMorph
[
	"Add the items for changing the current fill style of the receiver"

	"prevents a walkback when control menu is built for morph with me as color"

	^ self
]

InfiniteForm >> asColor
[
	^ patternForm dominantColor
]

InfiniteForm >> asForm
[
	^ patternForm
]

InfiniteForm >> bitPatternForDepth: suspectedDepth
[
	^ patternForm
]

InfiniteForm >> colorForInsets
[
	^ Color transparent
]

InfiniteForm >> computeBoundingBox
[
	"Refer to the comment in DisplayObject|computeBoundingBox."

	^ 0 @ 0 corner: SmallInteger maxVal @ SmallInteger maxVal
]

InfiniteForm >> direction
[
	^ patternForm width @ 0
]

InfiniteForm >> displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm
[
	"This is the real display message, but it doesn't get used until the new
	display protocol is installed."

	| targetBox patternBox bb |
	patternForm isForm
		ifFalse: [ ^ aDisplayMedium fill: clipRectangle rule: ruleInteger fillColor: patternForm ].	"Do it iteratively"
	targetBox := aDisplayMedium boundingBox intersect: clipRectangle ifNone: [ ^ self ].
	patternBox := patternForm boundingBox.
	bb := BitBlt
		destForm: aDisplayMedium
		sourceForm: patternForm
		fillColor: aForm
		combinationRule: ruleInteger
		destOrigin: 0 @ 0
		sourceOrigin: 0 @ 0
		extent: patternBox extent
		clipRect: clipRectangle.
	bb colorMap: (patternForm colormapIfNeededFor: aDisplayMedium).
	(targetBox left truncateTo: patternBox width) to: targetBox right - 1 by: patternBox width do: [ :x | (targetBox top truncateTo: patternBox height) to: targetBox bottom - 1 by: patternBox height do: [ :y | bb
				destOrigin: x @ y;
				copyBits ] ]
]

InfiniteForm >> displayOnPort: aPort at: offset
[
	| targetBox patternBox savedMap top left |
	self flag: #bob.	"this *may* not get called at the moment. I have been trying to figure out the right way for this to work and am using #displayOnPort:offsetBy: as my current offering - Bob"
	patternForm isForm
		ifFalse: [ "patternForm is a Pattern or Color; just use it as a mask for BitBlt"
			^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over ].	"do it iteratively"
	targetBox := aPort clipRect.
	patternBox := patternForm boundingBox.
	savedMap := aPort colorMap.
	aPort
		sourceForm: patternForm;
		fillColor: nil;
		combinationRule: Form paint;
		sourceRect: (0 @ 0 extent: patternBox extent);
		colorMap: (patternForm colormapIfNeededFor: aPort destForm).
	top := targetBox top truncateTo: patternBox height.	"- (offset y \\ patternBox height)"
	left := targetBox left truncateTo: patternBox width.	"- (offset x \\ patternBox width)"
	left to: targetBox right - 1 by: patternBox width do: [ :x | top to: targetBox bottom - 1 by: patternBox height do: [ :y | aPort
				destOrigin: x @ y;
				copyBits ] ].
	aPort colorMap: savedMap
]

InfiniteForm >> displayOnPort: aPort offsetBy: offset
[
	| targetBox patternBox savedMap top left |
	"this version tries to get the form aligned where the user wants it and not just aligned with the cliprect"
	patternForm isForm
		ifFalse: [ "patternForm is a Pattern or Color; just use it as a mask for BitBlt"
			^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over ].	"do it iteratively"
	targetBox := aPort clipRect.
	patternBox := patternForm boundingBox.
	savedMap := aPort colorMap.
	aPort
		sourceForm: patternForm;
		fillColor: nil;
		combinationRule: Form paint;
		sourceRect: (0 @ 0 extent: patternBox extent);
		colorMap: (patternForm colormapIfNeededFor: aPort destForm).
	top := (targetBox top truncateTo: patternBox height) + offset y.
	left := (targetBox left truncateTo: patternBox width) + offset x.
	left to: targetBox right - 1 by: patternBox width do: [ :x | top to: targetBox bottom - 1 by: patternBox height do: [ :y | aPort
				destOrigin: x @ y;
				copyBits ] ].
	aPort colorMap: savedMap
]

InfiniteForm >> dominantColor
[
	^ patternForm dominantColor
]

InfiniteForm >> form
[
	"Bitmap fills respond to #form"

	^ patternForm
]

InfiniteForm >> form: aForm
[
	patternForm := aForm
]

InfiniteForm >> isBitmapFill
[
	^ true
]

InfiniteForm >> isGradientFill
[
	^ false
]

InfiniteForm >> isOrientedFill
[
	^ true
]

InfiniteForm >> isSolidFill
[
	^ false
]

InfiniteForm >> isTiled
[
	"Return true if the receiver should be drawn as a tiled pattern"

	^ true
]

InfiniteForm >> isTranslucent
[
	"Return true since the bitmap may be translucent and we don't really want to check"

	^ true
]

InfiniteForm >> mightBeTranslucent
[
	"Return true since the bitmap may be translucent and we don't really want to check"

	^ true
]

InfiniteForm >> normal
[
	^ 0 @ patternForm height
]

InfiniteForm >> offset
[
	"Refer to the comment in DisplayObject|offset."

	^ 0 @ 0
]

InfiniteForm >> origin
[
	^ 0 @ 0
]

InfiniteForm >> origin: aPoint
[
	"Ignored"

	
]

InfiniteForm >> raisedColor
[
	^ Color transparent
]

InfiniteForm class >> with: aForm
[
	"Answer an instance of me whose pattern form is the argument, aForm."

	^ self new form: aForm
]

