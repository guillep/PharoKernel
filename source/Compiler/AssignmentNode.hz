AssignmentNode
	superclass: #ParseNode;
	instanceVariables: #(#variable #value );
	package: #Compiler.

AssignmentNode >> accept: aVisitor
[
	^ aVisitor visitAssignmentNode: self
]

AssignmentNode >> analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools
[
	"<BlockNode>"

	"<MethodNode>"

	"<Dictionary>"

	"N.B.  since assigment happens _after_ the value is evaluated the value is sent the message _first_."

	value analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools.
	variable beingAssignedToAnalyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools
]

AssignmentNode >> emitCodeForEffect: stack encoder: encoder
[
	variable emitCodeForLoad: stack encoder: encoder.
	value emitCodeForValue: stack encoder: encoder.
	pc := encoder methodStreamPosition + 1.	"debug pc is first byte of the store, i.e. the next byte"
	variable emitCodeForStorePop: stack encoder: encoder
]

AssignmentNode >> emitCodeForValue: stack encoder: encoder
[
	variable emitCodeForLoad: stack encoder: encoder.
	value emitCodeForValue: stack encoder: encoder.
	pc := encoder methodStreamPosition + 1.	"debug pc is first byte of the store, i.e. the next byte"
	variable emitCodeForStore: stack encoder: encoder
]

AssignmentNode >> isAssignmentNode
[
	^ true
]

AssignmentNode >> printOn: aStream indent: level
[
	variable printOn: aStream indent: level.
	aStream nextPutAll: ' := '.
	value printOn: aStream indent: level + 2
]

AssignmentNode >> printOn: aStream indent: level precedence: p
[
	aStream nextPut: $(.
	self printOn: aStream indent: level.
	aStream nextPut: $)
]

AssignmentNode >> sizeCodeForEffect: encoder
[
	^ (variable sizeCodeForLoad: encoder) + (value sizeCodeForValue: encoder) + (variable sizeCodeForStorePop: encoder)
]

AssignmentNode >> sizeCodeForValue: encoder
[
	^ (variable sizeCodeForLoad: encoder) + (value sizeCodeForValue: encoder) + (variable sizeCodeForStore: encoder)
]

AssignmentNode >> toDoIncrement: var
[
	var = variable
		ifFalse: [ ^ nil ].
	(value isMemberOf: MessageNode)
		ifTrue: [ ^ value toDoIncrement: var ]
		ifFalse: [ ^ nil ]
]

AssignmentNode >> value
[
	^ value
]

AssignmentNode >> variable
[
	^ variable
]

AssignmentNode >> variable: aVariable value: expression
[
	variable := aVariable.
	value := expression
]

AssignmentNode >> variable: aVariable value: expression from: encoder
[
	(aVariable isMemberOf: MessageAsTempNode)
		ifTrue: [ "Case of remote temp vars"
			^ aVariable store: expression from: encoder ].
	variable := aVariable.
	value := expression
]

AssignmentNode >> variable: aVariable value: expression from: encoder sourceRange: range
[
	encoder noteSourceRange: range forNode: self.
	^ self variable: aVariable value: expression from: encoder
]

