VariableNode
	superclass: #LeafNode;
	instanceVariables: #(#name );
	package: #Compiler.

VariableNode >> accept: aVisitor
[
	^ aVisitor visitVariableNode: self
]

VariableNode >> asStorableNode: encoder
[
	^ self
]

VariableNode >> assignmentCheck: encoder at: location
[
	^ (encoder cantStoreInto: name)
		ifTrue: [ location ]
		ifFalse: [ -1 ]
]

VariableNode >> beingAssignedToAnalyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools
[
	"<BlockNode>"

	"<MethodNode>"

	"<Dictionary>"

	"No-op overridden by TempVariableNode"

	^ self
]

VariableNode >> emitCodeForReturn: stack encoder: encoder
[
	encoder
		if: code
		isSpecialLiteralForReturn: [ :specialLiteral | "short returns"
			encoder genReturnSpecialLiteral: specialLiteral.
			stack push: 1.	"doesnt seem right"
			^ self ].
	(self code = LdSelf or: [ self code = LdSuper ])
		ifTrue: [ "short returns"
			encoder genReturnReceiver.
			stack push: 1.	"doesnt seem right"
			^ self ].
	super emitCodeForReturn: stack encoder: encoder
]

VariableNode >> emitCodeForStore: stack encoder: encoder
[
	self shouldNotImplement
]

VariableNode >> emitCodeForStorePop: stack encoder: encoder
[
	self assert: [ self type ~= 1 ].
	encoder genStorePopInstVar: index.
	stack pop: 1
]

VariableNode >> emitCodeForValue: stack encoder: encoder
[
	stack push: 1.
	encoder if: code isSpecialLiteralForPush: [ :specialLiteral | ^ encoder genPushSpecialLiteral: specialLiteral ].
	(code = LdSelf or: [ code = LdSuper ])
		ifTrue: [ ^ encoder genPushReceiver ].
	code = LdThisContext
		ifTrue: [ ^ encoder genPushThisContext ].
	self flag: 'probably superfluous'.
	^ encoder genPushInstVar: index
]

VariableNode >> fieldOffset
[
	"Return temp or instVar offset for this variable"

	^ index ifNil: [ code < 256
				ifTrue: [ code \\ 16 ]
				ifFalse: [ code \\ 256 ] ]
]

VariableNode >> index
[
	"This code attempts to reconstruct the index from its encoding in code."

	code < 0
		ifTrue: [ ^ nil ].
	code > 256
		ifTrue: [ [ index = (code \\ 256) ] assert.
			^ code \\ 256 ].
	code >= (CodeBases at: self type)
		ifTrue: [ [ index = (code - (CodeBases at: self type)) ] assert.
			^ code - (CodeBases at: self type) ].
	[ index = (code - self type) ] assert.
	^ code - self type
]

VariableNode >> isSelfPseudoVariable
[
	"Answer if this ParseNode represents the 'self' pseudo-variable."

	^ key = 'self' or: [ name = '{{self}}' ]
]

VariableNode >> isVariableNode
[
	^ true
]

VariableNode >> isVariableReference
[
	^ true
]

VariableNode >> name
[
	^ name
]

VariableNode >> name: string
[
	"Change name"

	name := string
]

VariableNode >> name: varName index: i type: type
[
	"Only used for initting instVar refs"

	^ self
		name: varName
		key: varName
		index: i
		type: type
]

VariableNode >> name: string key: object code: byte
[
	"Only used for initting std variables, nil, true, false, self, etc."

	name := string.
	key := object.
	code := byte
]

VariableNode >> name: varName key: objRef index: i type: type
[
	"Only used for initting global (litInd) variables"

	^ self name: varName key: objRef code: (self code: (index := i) type: type)
]

VariableNode >> printOn: aStream indent: level
[
	aStream nextPutAll: name
]

VariableNode >> returns
[
	^ false
]

VariableNode >> sizeCodeForReturn: encoder
[
	encoder if: code isSpecialLiteralForPush: [ :specialLiteral | ^ encoder sizeReturnSpecialLiteral: specialLiteral ].
	(self code = LdSelf or: [ self code = LdSuper ])
		ifTrue: [ ^ encoder sizeReturnReceiver ].
	^ super sizeCodeForReturn: encoder
]

VariableNode >> sizeCodeForStore: encoder
[
	self shouldNotImplement
]

VariableNode >> sizeCodeForStorePop: encoder
[
	self shouldNotImplement
]

VariableNode >> sizeCodeForValue: encoder
[
	self reserve: encoder.
	encoder
		if: code
		isSpecialLiteralForPush: [ :specialLiteral | "i.e. the pseudo-variables nil true & false"
			^ encoder sizePushSpecialLiteral: specialLiteral ].
	(code = LdSelf or: [ code = LdSuper ])
		ifTrue: [ ^ encoder sizePushReceiver ].
	code = LdThisContext
		ifTrue: [ ^ encoder sizePushThisContext ].
	self flag: 'probably superfluous'.
	^ encoder sizePushInstVar: index
]

VariableNode >> type
[
	"This code attempts to reconstruct the type from its encoding in code.
		This allows one to test, for instance, (aNode type = LdInstType)."

	| type |
	code < 0
		ifTrue: [ ^ code negated ].
	code >= 256
		ifTrue: [ ^ code // 256 ].
	type := CodeBases findFirst: [ :one | code < one ].
	^ type = 0
		ifTrue: [ 5 ]
		ifFalse: [ type - 1 ]
]

VariableNode class >> initialize
[
	"VariableNode initialize.  Decompiler initialize"

	| encoder |
	encoder := Encoder new.
	StdVariables := Dictionary new: 16.
	encoder
		fillDict: StdVariables
		with: VariableNode
		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true')
		to: (Array with: LdSelf with: LdThisContext with: LdSuper) , (Array with: LdNil with: LdFalse with: LdTrue).
	StdSelectors := Dictionary new: 64.
	encoder
		fillDict: StdSelectors
		with: SelectorNode
		mapping: ((1 to: Smalltalk specialSelectorSize) collect: [ :i | Smalltalk specialSelectorAt: i ])
		to: (SendPlus to: SendPlus + 31).
	StdLiterals := LiteralDictionary new: 16.
	encoder
		fillDict: StdLiterals
		with: LiteralNode
		mapping: #(-1 0 1 2)
		to: (LdMinus1 to: LdMinus1 + 3).
	encoder initScopeAndLiteralTables.
	NodeNil := encoder encodeVariable: 'nil'.
	NodeTrue := encoder encodeVariable: 'true'.
	NodeFalse := encoder encodeVariable: 'false'.
	NodeSelf := encoder encodeVariable: 'self'.
	NodeThisContext := encoder encodeVariable: 'thisContext'.
	NodeSuper := encoder encodeVariable: 'super'
]

