BytecodeEncoder
	superclass: #Encoder;
	instanceVariables: #(#stream #position #rootNode #blockExtentsToLocals );
	package: #Compiler.

BytecodeEncoder >> bindAndJuggle: name
[
	"This is used to insert a new temp and reorcder temps on editing.
	 It doesn't really work for closure compilation since we have multiple
	 locations for temps.  Simply signal a reparse is necessary."

	ReparseAfterSourceEditing signal
]

BytecodeEncoder >> bindBlockArg: name within: aBlockNode
[
	"Read the comment in the superclass's method.
	 If we have closures we should check the argument
	 count against the block, not the method.

	(Note that this isn't entirely adequate either since optimized blocks
	 will slip through the cracks (their arguments (i.e. ifNotNil: [:expr|)
	 are charged against their enclosing block, not themselves))."

	| nArgs |
	self supportsClosureOpcodes
		ifFalse: [ ^ super bindBlockArg: name within: aBlockNode ].
	(nArgs := aBlockNode nArgsSlot) ifNil: [ aBlockNode nArgsSlot: (nArgs := 0) ].
	nArgs >= 15
		ifTrue: [ ^ self notify: 'Too many arguments' ].
	aBlockNode nArgsSlot: nArgs + 1.
	^ (self bindTemp: name)
		beBlockArg;
		nowHasDef;
		nowHasRef;
		yourself
]

BytecodeEncoder >> bindBlockTemp: name within: aBlockNode
[
	"Read the comment in the superclass's bindBlockArg:within: method.
	 If we have closures we should check the argument
	 count against the block, not the method.

	(Note that this isn't entirely adequate either since optimized blocks
	 will slip through the cracks (their arguments (i.e. ifNotNil: [:expr|)
	 are charged against their enclosing block, not themselves))."

	| nArgs |
	self supportsClosureOpcodes
		ifFalse: [ ^ super bindBlockTemp: name within: aBlockNode ].
	(nArgs := aBlockNode nArgsSlot) ifNil: [ aBlockNode nArgsSlot: (nArgs := 0) ].
	nArgs >= (CompiledMethod fullFrameSize - 1)
		ifTrue: [ ^ self notify: 'Too many temporaries' ].
	aBlockNode nArgsSlot: nArgs + 1.
	^ self bindTemp: name
]

BytecodeEncoder >> bindTemp: name
[
	"Declare a temporary; error not if a field or class variable or out-of-scope temp.
	 Read the comment in Encoder5>>bindBlockArg:within: and subclass implementations."

	self supportsClosureOpcodes
		ifFalse: [ ^ super bindTemp: name ].
	scopeTable
		at: name
		ifPresent: [ :node | requestor interactive
				ifTrue: [ self evaluateShadowingInteractivelyOf: node ]
				ifFalse: [ self evaluateShadowingNotInteractivelyOf: node ] ].
	^ self reallyBind: name
]

BytecodeEncoder >> blockExtentsToTempsMap
[
	"Answer a Dictionary of blockExtent to temp locations for the current method.
	 This is used by the debugger to locate temp vars in contexts.  A temp map
	 entry is a pair of the temp's name and its index, where an index is either an
	 integer for a normal temp or a pair of the index of the indirect temp vector
	 containing  the temp and the index of the temp in its indirect temp vector."

	| blockExtentsToTempsMap |
	blockExtentsToLocals ifNil: [ ^ nil ].
	blockExtentsToTempsMap := Dictionary new.
	blockExtentsToLocals
		keysAndValuesDo: [ :blockExtent :locals | blockExtentsToTempsMap
				at: blockExtent
				put:
					(Array
						streamContents: [ :str | locals
								withIndexDo: [ :local :index | local isIndirectTempVector
										ifTrue: [ local remoteTemps
												withIndexDo: [ :remoteLocal :innerIndex | str nextPut: {(remoteLocal key).
															{index.
															innerIndex}} ] ]
										ifFalse: [ str nextPut: {(local key).
													index} ] ] ]) ].
	^ blockExtentsToTempsMap
]

BytecodeEncoder >> hasGeneratedMethod
[
	^ blockExtentsToLocals notNil
]

BytecodeEncoder >> if: code isSpecialLiteralForPush: aBlock
[
	"If code is that of a special literal for push then evaluate aBlock with the special literal
	 The special literals for push are nil true false -1 0 1 & 2 which have special encodings
	 in the blue book bytecode set.  Answer whether it was a special literal."

	^ (code between: LdTrue and: LdNil + 4) and: [ aBlock value: (#(true false nil -1 0 1 2) at: code - LdSelf).
			true ]
]

BytecodeEncoder >> if: code isSpecialLiteralForReturn: aBlock
[
	"If code is that of a special literal for return then evaluate aBlock with the special literal.
	 The special literals for return are nil true false which have special encodings
	 in the blue book bytecode set.  Answer whether it was a special literal."

	^ (code between: LdTrue and: LdNil) and: [ aBlock value: (#(true false nil) at: code - LdSelf).
			true ]
]

BytecodeEncoder >> methodStreamPosition
[
	^ stream position
]

BytecodeEncoder >> nextPut: aByte
[
	"For sizing make the encoder its own stream and
	 keep track of position with this version of nextPut:"

	position := position + 1
]

BytecodeEncoder >> noteBlockExtent: blockExtent hasLocals: tempNodes
[
	blockExtentsToLocals ifNil: [ blockExtentsToLocals := Dictionary new ].
	blockExtentsToLocals at: blockExtent put: tempNodes asArray
]

BytecodeEncoder >> outOfRangeError: string index: index range: rangeStart to: rangeEnd
[
	"For now..."

	^ self
		error:
			thisContext sender method selector , ' ' , string , ' index ' , index printString , ' is out of range '
				, rangeStart printString , ' to ' , rangeEnd printString
]

BytecodeEncoder >> rootNode
[
	"^<BlockNode>"

	^ rootNode
]

BytecodeEncoder >> rootNode: node
[
	"<BlockNode>"

	rootNode := node
]

BytecodeEncoder >> sizeBranchPopFalse: distance
[
	^ self sizeOpcodeSelector: #genBranchPopFalse: withArguments: {distance}
]

BytecodeEncoder >> sizeBranchPopTrue: distance
[
	^ self sizeOpcodeSelector: #genBranchPopTrue: withArguments: {distance}
]

BytecodeEncoder >> sizeDup
[
	^ self sizeOpcodeSelector: #genDup withArguments: #()
]

BytecodeEncoder >> sizeJump: distance
[
	^ self sizeOpcodeSelector: #genJump: withArguments: {distance}
]

BytecodeEncoder >> sizeJumpLong: distance
[
	^ self sizeOpcodeSelector: #genJumpLong: withArguments: {distance}
]

BytecodeEncoder >> sizeOpcodeSelector: genSelector withArguments: args
[
	stream := self.
	position := 0.
	self perform: genSelector withArguments: args.
	^ position
]

BytecodeEncoder >> sizePop
[
	^ self sizeOpcodeSelector: #genPop withArguments: #()
]

BytecodeEncoder >> sizePushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize
[
	^ self
		sizeOpcodeSelector: #genPushClosureCopyNumCopiedValues:numArgs:jumpSize:
		withArguments: {numCopied.
			numArgs.
			jumpSize}
]

BytecodeEncoder >> sizePushConsArray: numElements
[
	^ self sizeOpcodeSelector: #genPushConsArray: withArguments: {numElements}
]

BytecodeEncoder >> sizePushInstVar: instVarIndex
[
	^ self sizeOpcodeSelector: #genPushInstVar: withArguments: {instVarIndex}
]

BytecodeEncoder >> sizePushInstVarLong: instVarIndex
[
	^ self sizeOpcodeSelector: #genPushInstVarLong: withArguments: {instVarIndex}
]

BytecodeEncoder >> sizePushLiteral: literalIndex
[
	^ self sizeOpcodeSelector: #genPushLiteral: withArguments: {literalIndex}
]

BytecodeEncoder >> sizePushLiteralVar: literalIndex
[
	^ self sizeOpcodeSelector: #genPushLiteralVar: withArguments: {literalIndex}
]

BytecodeEncoder >> sizePushNewArray: size
[
	^ self sizeOpcodeSelector: #genPushNewArray: withArguments: {size}
]

BytecodeEncoder >> sizePushReceiver
[
	^ self sizeOpcodeSelector: #genPushReceiver withArguments: #()
]

BytecodeEncoder >> sizePushRemoteTemp: tempIndex inVectorAt: tempVectorIndex
[
	^ self sizeOpcodeSelector: #genPushRemoteTemp:inVectorAt: withArguments: {tempIndex.
			tempVectorIndex}
]

BytecodeEncoder >> sizePushSpecialLiteral: specialLiteral
[
	^ self sizeOpcodeSelector: #genPushSpecialLiteral: withArguments: {specialLiteral}
]

BytecodeEncoder >> sizePushTemp: tempIndex
[
	^ self sizeOpcodeSelector: #genPushTemp: withArguments: {tempIndex}
]

BytecodeEncoder >> sizePushThisContext
[
	^ self sizeOpcodeSelector: #genPushThisContext withArguments: #()
]

BytecodeEncoder >> sizeReturnReceiver
[
	^ self sizeOpcodeSelector: #genReturnReceiver withArguments: #()
]

BytecodeEncoder >> sizeReturnSpecialLiteral: specialLiteral
[
	^ self sizeOpcodeSelector: #genReturnSpecialLiteral: withArguments: {specialLiteral}
]

BytecodeEncoder >> sizeReturnTop
[
	^ self sizeOpcodeSelector: #genReturnTop withArguments: #()
]

BytecodeEncoder >> sizeReturnTopToCaller
[
	^ self sizeOpcodeSelector: #genReturnTopToCaller withArguments: #()
]

BytecodeEncoder >> sizeSend: selectorLiteralIndex numArgs: nArgs
[
	^ self sizeOpcodeSelector: #genSend:numArgs: withArguments: {selectorLiteralIndex.
			nArgs}
]

BytecodeEncoder >> sizeSendSuper: selectorLiteralIndex numArgs: nArgs
[
	^ self sizeOpcodeSelector: #genSendSuper:numArgs: withArguments: {selectorLiteralIndex.
			nArgs}
]

BytecodeEncoder >> sizeStoreInstVar: instVarIndex
[
	^ self sizeOpcodeSelector: #genStoreInstVar: withArguments: {instVarIndex}
]

BytecodeEncoder >> sizeStoreInstVarLong: instVarIndex
[
	^ self sizeOpcodeSelector: #genStoreInstVarLong: withArguments: {instVarIndex}
]

BytecodeEncoder >> sizeStoreLiteralVar: literalIndex
[
	^ self sizeOpcodeSelector: #genStoreLiteralVar: withArguments: {literalIndex}
]

BytecodeEncoder >> sizeStorePopInstVar: instVarIndex
[
	^ self sizeOpcodeSelector: #genStorePopInstVar: withArguments: {instVarIndex}
]

BytecodeEncoder >> sizeStorePopInstVarLong: instVarIndex
[
	^ self sizeOpcodeSelector: #genStorePopInstVarLong: withArguments: {instVarIndex}
]

BytecodeEncoder >> sizeStorePopLiteralVar: literalIndex
[
	^ self sizeOpcodeSelector: #genStorePopLiteralVar: withArguments: {literalIndex}
]

BytecodeEncoder >> sizeStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex
[
	^ self sizeOpcodeSelector: #genStorePopRemoteTemp:inVectorAt: withArguments: {tempIndex.
			tempVectorIndex}
]

BytecodeEncoder >> sizeStorePopTemp: tempIndex
[
	^ self sizeOpcodeSelector: #genStorePopTemp: withArguments: {tempIndex}
]

BytecodeEncoder >> sizeStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex
[
	^ self sizeOpcodeSelector: #genStoreRemoteTemp:inVectorAt: withArguments: {tempIndex.
			tempVectorIndex}
]

BytecodeEncoder >> sizeStoreTemp: tempIndex
[
	^ self sizeOpcodeSelector: #genStoreTemp: withArguments: {tempIndex}
]

BytecodeEncoder >> streamToMethod: aCompiledMethod
[
	stream := WriteStream with: aCompiledMethod.
	stream position: aCompiledMethod initialPC - 1
]

BytecodeEncoder >> supportsClosureOpcodes
[
	"Answer if the receiver supports the
		genPushNewArray:/genPushConsArray:
		genPushRemoteTemp:inVectorAt:
		genStoreRemoteTemp:inVectorAt:
		genStorePopRemoteTemp:inVectorAt:
		genPushClosureCopyCopiedValues:numArgs:jumpSize:
	 opcodes"

	^ false
]

