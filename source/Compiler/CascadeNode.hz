CascadeNode
	superclass: #ParseNode;
	instanceVariables: #(#receiver #messages );
	package: #Compiler.

CascadeNode >> accept: aVisitor
[
	^ aVisitor visitCascadeNode: self
]

CascadeNode >> analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools
[
	"<BlockNode>"

	"<MethodNode>"

	"<Dictionary>"

	{receiver} , messages
		do: [ :node | node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools ]
]

CascadeNode >> emitCodeForValue: stack encoder: encoder
[
	receiver emitCodeForValue: stack encoder: encoder.
	1 to: messages size - 1 do: [ :i | encoder genDup.
		stack push: 1.
		(messages at: i) emitCodeForValue: stack encoder: encoder.
		encoder genPop.
		stack pop: 1 ].
	messages last emitCodeForValue: stack encoder: encoder
]

CascadeNode >> messages
[
	^ messages
]

CascadeNode >> printOn: aStream indent: level
[
	self printOn: aStream indent: level precedence: 0
]

CascadeNode >> printOn: aStream indent: level precedence: p
[
	p > 0
		ifTrue: [ aStream nextPut: $( ].
	messages first printReceiver: receiver on: aStream indent: level.
	1 to: messages size do: [ :i | (messages at: i) printOn: aStream indent: level.
		i < messages size
			ifTrue: [ aStream nextPut: $;.
				messages first precedence >= 2
					ifTrue: [ aStream crtab: level + 1 ] ] ].
	p > 0
		ifTrue: [ aStream nextPut: $) ]
]

CascadeNode >> receiver
[
	^ receiver
]

CascadeNode >> receiver: receivingObject messages: msgs
[
	" Transcript show: 'abc'; cr; show: 'def' "

	receiver := receivingObject.
	messages := msgs
]

CascadeNode >> sizeCodeForValue: encoder
[
	| size |
	size := (receiver sizeCodeForValue: encoder) + ((messages size - 1) * (encoder sizeDup + encoder sizePop)).
	messages do: [ :aMessage | size := size + (aMessage sizeCodeForValue: encoder) ].
	^ size
]

