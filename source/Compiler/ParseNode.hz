ParseNode
	instanceVariables: #(#comment #pc );
	classVariables: #(#Store #NodeSelf #JmpLimit #LdSuper #LongLongDoAll #LdThisContext #Dup #StdVariables #Send #LdLitIndType #DblExtDoAll #StdLiterals #NodeSuper #EndMethod #CodeLimits #SendLong #JmpLong #SendType #SendPlus #LdLitType #NodeThisContext #NodeNil #ShortStoP #LdInstLong #StorePop #EndRemote #LdTrue #BtpLong #LdNil #LdMinus1 #Jmp #NodeTrue #StdSelectors #LdFalse #CodeBases #Bfp #SendLong2 #LoadLong #NodeFalse #LdInstType #SendLimit #Pop #LdTempType #LdSelf );
	sharedPools: #(#TextConstants );
	package: #Compiler.

ParseNode >> accept: aVisitor
[
	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.
	 All such implementations under ParseNode should answer the result of the dispatch, e.g.
		^aVisitor visitBlockNode: self"

	^ self subclassResponsibility
]

ParseNode >> asReturnNode
[
	^ ReturnNode new expr: self
]

ParseNode >> assignmentCheck: encoder at: location
[
	"For messageNodes masquerading as variables for the debugger.
	For now we let this through - ie we allow stores ev
	into args.  Should check against numArgs, though."

	^ -1
]

ParseNode >> canCascade
[
	^ false
]

ParseNode >> comment
[
	^ comment
]

ParseNode >> comment: newComment
[
	comment := newComment
]

ParseNode >> emitCodeForBlockValue: stack encoder: encoder
[
	"Generate code for evaluating the last statement in a block"

	^ self emitCodeForValue: stack encoder: encoder
]

ParseNode >> emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder
[
	stack pop: 1.
	dist = 0
		ifTrue: [ ^ encoder genPop ].
	condition
		ifTrue: [ encoder genBranchPopTrue: dist ]
		ifFalse: [ encoder genBranchPopFalse: dist ]
]

ParseNode >> emitCodeForEffect: stack encoder: encoder
[
	self emitCodeForValue: stack encoder: encoder.
	encoder genPop.
	stack pop: 1
]

ParseNode >> emitCodeForJump: dist encoder: encoder
[
	dist = 0
		ifFalse: [ encoder genJump: dist ]
]

ParseNode >> emitCodeForReturn: stack encoder: encoder
[
	self emitCodeForValue: stack encoder: encoder.
	encoder genReturnTop
]

ParseNode >> encodeSelector: aSelector
[
	^ nil
]

ParseNode >> ensureCanCascade: encoder
[
	
]

ParseNode >> ifNilReceiver
[
	"assuming this object is the receiver of an ifNil:, what object is being asked about?"

	^ self
]

ParseNode >> isArg
[
	^ false
]

ParseNode >> isAssignmentNode
[
	^ false
]

ParseNode >> isBlockNode
[
	^ false
]

ParseNode >> isComplex
[
	"Used for pretty printing to determine whether to start a new line"

	^ false
]

ParseNode >> isConstantNumber
[
	"Overridden in LiteralNode"

	^ false
]

ParseNode >> isDoIt
[
	"polymorphic with RBNodes; called by debugger"

	^ false
]

ParseNode >> isJust: node
[
	^ false
]

ParseNode >> isLiteralNode
[
	^ false
]

ParseNode >> isMessage
[
	^ false
]

ParseNode >> isMessage: selSymbol receiver: rcvrPred arguments: argsPred
[
	"See comment in MessageNode."

	^ false
]

ParseNode >> isMessageNode
[
	^ false
]

ParseNode >> isOnlySubnodeOf: aSubtree in: aParseTree
[
	"<ParseNode>"

	"<ParseNode>"

	"Answer if the receiver only occurs within aSubtree of aParseTree, not in the rest of aParseTree.
	 Assumes that aSubtree is in fact a subnode of aParseTree."

	| isSubnode |
	isSubnode := false.
	aSubtree accept: (ParseNodeEnumerator ofBlock: [ :node | node == self
						ifTrue: [ isSubnode := true ] ]).
	isSubnode
		ifFalse: [ ^ false ].
	aParseTree
		accept:
			(ParseNodeEnumerator ofBlock: [ :node | node == self
						ifTrue: [ ^ false ] ] select: [ :node | node ~= aSubtree ]).
	^ true
]

ParseNode >> isReturn
[
	^ false
]

ParseNode >> isReturnSelf
[
	^ false
]

ParseNode >> isReturningIf
[
	^ false
]

ParseNode >> isSelfPseudoVariable
[
	"Overridden in VariableNode."

	^ false
]

ParseNode >> isSpecialConstant
[
	^ false
]

ParseNode >> isTemp
[
	^ false
]

ParseNode >> isUndefTemp
[
	^ false
]

ParseNode >> isUnusedTemp
[
	^ false
]

ParseNode >> isVariableNode
[
	^ false
]

ParseNode >> isVariableReference
[
	^ false
]

ParseNode >> nextWordFrom: aStream setCharacter: aBlock
[
	| outStream char |
	outStream := (String new: 16) writeStream.
	[ (aStream peekFor: Character space) or: [ aStream peekFor: Character tab ] ] whileTrue.
	[ aStream atEnd or: [ char := aStream next.
			char = Character cr or: [ char = Character space ] ] ]
		whileFalse: [ outStream nextPut: char ].
	aBlock value: char.
	^ outStream contents
]

ParseNode >> nodePrintOn: aStrm indent: nn
[
	| var aaStrm myLine |
	"Show just the sub nodes and the code."
	(aaStrm := aStrm) ifNil: [ aaStrm := (String new: 500) writeStream ].
	nn timesRepeat: [ aaStrm tab ].
	aaStrm
		nextPutAll: self class name;
		space.
	myLine := self printString copyWithout: Character cr.
	myLine := myLine copyFrom: 1 to: (myLine size min: 70).
	aaStrm
		nextPutAll: myLine;
		cr.
	1 to: self class instSize do: [ :ii | var := self instVarAt: ii.
		(var respondsTo: #asReturnNode)
			ifTrue: [ var nodePrintOn: aaStrm indent: nn + 1 ] ].
	1 to: self class instSize do: [ :ii | var := self instVarAt: ii.
		(var isKindOf: SequenceableCollection)
			ifTrue: [ var do: [ :aNode | (aNode respondsTo: #asReturnNode)
							ifTrue: [ aNode nodePrintOn: aaStrm indent: nn + 1 ] ] ] ].
	^ aaStrm
]

ParseNode >> nodesDo: aBlock
[
	self accept: (ParseNodeEnumerator ofBlock: aBlock)
]

ParseNode >> nowHasDef
[
	"Ignored in all but VariableNode"

	
]

ParseNode >> nowHasRef
[
	"Ignored in all but VariableNode"

	
]

ParseNode >> pc
[
	"Used by encoder source mapping."

	^ pc ifNil: [ 0 ]
]

ParseNode >> pc: anInteger
[
	"Used by encoder source mapping."

	pc := anInteger
]

ParseNode >> printAsIfCompiledOn: aStream
[
	"Refer to the comment in Object|printOn:."

	self printOn: aStream indent: 0
]

ParseNode >> printCommentOn: aStream indent: indent
[
	| thisComment |
	self comment == nil
		ifTrue: [ ^ self ].
	1 to: self comment size do: [ :index | index > 1
			ifTrue: [ aStream crtab: indent ].
		aStream nextPut: $".
		thisComment := self comment at: index.
		self printSingleComment: thisComment on: aStream indent: indent.
		aStream nextPut: $" ]
]

ParseNode >> printOn: aStream
[
	"Refer to the comment in Object|printOn:."

	aStream nextPut: ${.
	self printAsIfCompiledOn: aStream.
	aStream nextPut: $}
]

ParseNode >> printOn: aStream indent: anInteger
[
	"If control gets here, avoid recursion loop."

	super printOn: aStream
]

ParseNode >> printOn: aStream indent: level precedence: p
[
	self printOn: aStream indent: level
]

ParseNode >> printSingleComment: aString on: aStream indent: indent
[
	"Print the comment string, assuming it has been indented indent tabs.
	Break the string at word breaks, given the widths in the default
	font, at 450 points."

	| readStream word position lineBreak font wordWidth tabWidth spaceWidth lastChar |
	readStream := aString readStream.
	font := TextStyle default defaultFont.
	tabWidth := DefaultTab.
	spaceWidth := font widthOf: Character space.
	position := indent * tabWidth.
	lineBreak := 450.
	[ readStream atEnd ]
		whileFalse: [ word := self nextWordFrom: readStream setCharacter: [ :lc | lastChar := lc ].
			wordWidth := word inject: 0 into: [ :width :char | width + (font widthOf: char) ].
			position := position + wordWidth.
			position > lineBreak
				ifTrue: [ aStream
						skip: -1;
						crtab: indent.
					position := indent * tabWidth + wordWidth + spaceWidth.
					lastChar = Character cr
						ifTrue: [ [ readStream peekFor: Character tab ] whileTrue ].
					word isEmpty
						ifFalse: [ aStream
								nextPutAll: word;
								space ] ]
				ifFalse: [ aStream nextPutAll: word.
					readStream atEnd
						ifFalse: [ position := position + spaceWidth.
							aStream space ].
					lastChar = Character cr
						ifTrue: [ aStream
								skip: -1;
								crtab: indent.
							position := indent * tabWidth.
							[ readStream peekFor: Character tab ] whileTrue ] ] ]
]

ParseNode >> shortPrintOn: aStream
[
	self printOn: aStream indent: 0
]

ParseNode >> sizeCode: encoder forBranchOn: condition dist: dist
[
	dist = 0
		ifTrue: [ ^ encoder sizePop ].
	^ condition
		ifTrue: [ encoder sizeBranchPopTrue: dist ]
		ifFalse: [ encoder sizeBranchPopFalse: dist ]
]

ParseNode >> sizeCode: encoder forJump: dist
[
	^ dist = 0
		ifTrue: [ 0 ]
		ifFalse: [ encoder sizeJump: dist ]
]

ParseNode >> sizeCodeForBlockValue: encoder
[
	"Answer the size for evaluating the last statement in a block"

	^ self sizeCodeForValue: encoder
]

ParseNode >> sizeCodeForEffect: encoder
[
	^ (self sizeCodeForValue: encoder) + encoder sizePop
]

ParseNode >> sizeCodeForReturn: encoder
[
	^ (self sizeCodeForValue: encoder) + encoder sizeReturnTop
]

ParseNode >> toDoIncrement: ignored
[
	"Only meant for Messages or Assignments - else return nil"

	^ nil
]

ParseNode class >> blockReturnCode
[
	^ EndRemote
]

ParseNode class >> initialize
[
	"ParseNode initialize. VariableNode initialize"

	LdInstType := 1.
	LdTempType := 2.
	LdLitType := 3.
	LdLitIndType := 4.
	SendType := 5.
	CodeBases := #(0 16 32 64 208).
	CodeLimits := #(16 16 32 32 16).
	LdSelf := 112.
	LdTrue := 113.
	LdFalse := 114.
	LdNil := 115.
	LdMinus1 := 116.
	LoadLong := 128.
	Store := 129.
	StorePop := 130.
	ShortStoP := 96.
	SendLong := 131.
	DblExtDoAll := 132.
	SendLong2 := 134.
	LdSuper := 133.
	Pop := 135.
	Dup := 136.
	LdThisContext := 137.
	EndMethod := 124.
	EndRemote := 125.
	Jmp := 144.
	Bfp := 152.
	JmpLimit := 8.
	JmpLong := 164.	"code for jmp 0"
	BtpLong := 168.
	SendPlus := 176.
	Send := 208.
	SendLimit := 16
]

ParseNode class >> popCode
[
	^ Pop
]

ParseNode class >> pushNilCode
[
	^ LdNil
]

ParseNode class >> tempSortBlock
[
	"Answer a block that can sort a set of temporaries into a stable
	 order so that different compilations produce the same results."

	^ [ :t1 :t2 | | be1 be2 bs1 bs2 |
	t1 index < t2 index
		or: [ t1 index = t2 index
				and: [ t1 isRemote ~= t2 isRemote
						ifTrue: [ t2 isRemote ]
						ifFalse: [ ((be1 := t1 definingScope blockExtent) isNil or: [ (be2 := t2 definingScope blockExtent) isNil ])
								ifTrue: [ t1 name < t2 name ]
								ifFalse: [ "put temps from outer scopes before those from inner scopes"
									(bs1 := be1 first) < (bs2 := be2 first) or: [ bs1 = bs2 and: [ t1 name < t2 name ] ] ]	"only have the name left to go on" ]	"put direct temps before indirect temps" ]	"complex tie break" ]	"simple sort by index." ]	"only have the name left to go on"
]

