ReturnNode
	superclass: #ParseNode;
	instanceVariables: #(#expr );
	package: #Compiler.

ReturnNode >> accept: aVisitor
[
	^ aVisitor visitReturnNode: self
]

ReturnNode >> analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools
[
	"<BlockNode>"

	"<MethodNode>"

	"<Dictionary>"

	"Note we could do this:
		scopeBlock ~~ rootNode block ifTrue:
			[scopeBlock noteNonLocalReturn].
	 and pass up the flag in <BlockNode>>>analyseTempsWithin:rootNode:
	 which may be fast but will also give less information the debugger.
	 For now we consider clean blocks a premature optimization."

	self flag: 'consider clean blocks'.
	expr analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools
]

ReturnNode >> asReturnNode
[
	
]

ReturnNode >> code
[
	^ expr code
]

ReturnNode >> emitCodeForReturn: stack encoder: encoder
[
	expr emitCodeForReturn: stack encoder: encoder.
	pc := encoder methodStreamPosition
]

ReturnNode >> emitCodeForValue: stack encoder: encoder
[
	expr emitCodeForReturn: stack encoder: encoder.
	pc := encoder methodStreamPosition
]

ReturnNode >> expr
[
	^ expr
]

ReturnNode >> expr: e
[
	expr := e
]

ReturnNode >> expr: e encoder: encoder sourceRange: range
[
	expr := e.
	encoder noteSourceRange: range forNode: self
]

ReturnNode >> isReturn
[
	^ true
]

ReturnNode >> isReturnSelf
[
	^ expr == NodeSelf
]

ReturnNode >> isSpecialConstant
[
	^ expr isSpecialConstant
]

ReturnNode >> isVariableReference
[
	^ expr isVariableReference
]

ReturnNode >> printOn: aStream indent: level
[
	aStream nextPutAll: '^ '.
	expr printOn: aStream indent: level.
	expr printCommentOn: aStream indent: level
]

ReturnNode >> sizeCodeForReturn: encoder
[
	^ expr sizeCodeForReturn: encoder
]

ReturnNode >> sizeCodeForValue: encoder
[
	^ expr sizeCodeForReturn: encoder
]

