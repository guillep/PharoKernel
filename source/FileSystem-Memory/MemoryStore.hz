Class
	name: #MemoryStore;
	superclass: #ClassFileSystemStore;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#root );
	classVariables: #();
	package: #'FileSystem-Memory'.

Class MemoryStore >> basenameFromEntry: aMemoryFileSystemEntry
[
^ aMemoryFileSystemEntry basename
]

Class MemoryStore >> basicCreationTime: aMemoryFileSystemEntry
[
^ aMemoryFileSystemEntry creationTime
]

Class MemoryStore >> basicIsDirectory: aMemoryFileSystemEntry
[
^ aMemoryFileSystemEntry isDirectory
]

Class MemoryStore >> basicIsFile: aMemoryFileSystemEntry
[
^ aMemoryFileSystemEntry isFile
]

Class MemoryStore >> basicIsSymlink: aNode
[
^ false
]

Class MemoryStore >> basicModificationTime: aMemoryFileSystemEntry
[
^ aMemoryFileSystemEntry modificationTime
]

Class MemoryStore >> basicOpen: path writable: aBoolean
[
^ self	nodeAt: path	ifPresent: [ :aMemoryFileSystemEntry | aMemoryFileSystemEntry ]	ifAbsent: [ 		aBoolean			ifFalse: [ self signalFileDoesNotExist: path ]			ifTrue: [ self createFile: path ] ]
]

Class MemoryStore >> basicPosixPermissions: anEntry
[
^ 8r777
]

Class MemoryStore >> basicSize: aMemoryFileSystemEntry
[
^ aMemoryFileSystemEntry fileSize
]

Class MemoryStore >> checkName: aString fixErrors: fixErrors
[
aString ifEmpty: [ self error: 'zero length file name' ].^ aString
]

Class MemoryStore >> copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: aFilesystem
[
| sourceNode destinationNode |sourceNode := self nodeAt: sourcePath ifPresent: [ :source | source ] ifAbsent: [ ^ absentBlock value ].sourceNode isDirectory	ifTrue: [ ^ absentBlock value ].destinationNode := self	nodeAt: destinationPath parent	ifPresent: [ :destination | destination ]	ifAbsent: [ ^ self signalDirectoryDoesNotExist: destinationPath parent ].destinationNode isFile	ifTrue: [ self signalDirectoryDoesNotExist: destinationPath parent ].(destinationNode includes: destinationPath basename)	ifTrue: [ 		"cannot overwrite existing file"		^ presentBlock value ].destinationNode fileEntryAt: destinationPath basename put: sourceNode copy
]

Class MemoryStore >> createDirectory: path
[
| parent |parent := path parent.^ self	nodeAt: parent	ifPresent: [ :entry | 		entry			fileEntryAt: path basename			ifPresent: [ :node | 				node isDirectory					ifTrue: [ self signalDirectoryExists: path ]					ifFalse: [ self signalFileExists: path ] ].		entry ensureDirectory: path basename ]	ifAbsent: [ self signalDirectoryDoesNotExist: parent ]
]

Class MemoryStore >> createFile: aPath
[
^ self	nodeAt: aPath parent	ifPresent: [ :entry | 		entry isDirectory			ifTrue: [ entry ensureFile: aPath basename ] ]	ifAbsent: [ self signalDirectoryDoesNotExist: aPath parent ]
]

Class MemoryStore >> delete: path
[
self nodeAt: path parent ifPresent: [ :dict | dict remove: path basename ] ifAbsent: [  ]
]

Class MemoryStore >> directoryAt: aPath ifAbsent: absentBlock nodesDo: aBlock
[
^ self	nodeAt: aPath	ifPresent: [ :entry | 		entry isDirectory			ifFalse: [ ^ absentBlock value ].		entry fileEntriesDo: aBlock ]	ifAbsent: absentBlock
]

Class MemoryStore >> forReferencePrintOn: aStream
[
aStream nextPutAll: 'memory:'
]

Class MemoryStore >> handleClass
[
^ MemoryHandle
]

Class MemoryStore >> initialize
[
root := MemoryFileSystemDirectory new
]

Class MemoryStore >> nodeAt: aPath ifPresent: presentBlock ifAbsent: absentBlock
[
| current |current := self root.aPath	do: [ :segment | 		current isDirectory			ifTrue: [ current := current fileEntryAt: segment ifAbsent: [ ^ absentBlock value ] ]			ifFalse: [ ^ absentBlock value ] ].^ presentBlock value: current
]

Class MemoryStore >> openFileStream: path writable: isWriteStream
[
| entry |entry := self basicOpen: path writable: isWriteStream.^ isWriteStream	ifTrue: [ entry writeStream ]	ifFalse: [ entry readStream ]
]

Class MemoryStore >> replaceFile: path in: aBlock
[
^ self	nodeAt: path parent	ifPresent: [ :entry | 		| old new |		entry isDirectory			ifFalse: [ self signalFileDoesNotExist: path ].		old := entry fileEntryAt: path basename ifAbsent: [ self signalFileDoesNotExist: path ].		new := aBlock value: old.		entry fileEntryAt: path basename put: new ]	ifAbsent: [ self signalFileDoesNotExist: path ]
]

Class MemoryStore >> root
[
^ root
]

Metaclass
	name: #MemoryStore;
	instanceVariables: #().

Metaclass MemoryStore >> delimiter
[
^ $/
]

Metaclass MemoryStore >> isCaseSensitive
[
^ true
]

Metaclass MemoryStore >> separator
[
^ $:
]

