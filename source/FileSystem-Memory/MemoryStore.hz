MemoryStore
	superclass: #FileSystemStore;
	instanceVariables: #(#root );
	package: #'FileSystem-Memory'.

MemoryStore >> basenameFromEntry: aMemoryFileSystemEntry
[
	^ aMemoryFileSystemEntry basename
]

MemoryStore >> basicCreationTime: aMemoryFileSystemEntry
[
	^ aMemoryFileSystemEntry creationTime
]

MemoryStore >> basicEntry: entry nodesDo: aBlock
[
	entry fileEntriesDo: aBlock
]

MemoryStore >> basicEntry: directoryEntry path: aPath nodesDo: aBlock
[
	directoryEntry fileEntriesDo: aBlock
]

MemoryStore >> basicIsDirectory: aMemoryFileSystemEntry
[
	^ aMemoryFileSystemEntry isDirectory
]

MemoryStore >> basicIsFile: aMemoryFileSystemEntry
[
	^ aMemoryFileSystemEntry isFile
]

MemoryStore >> basicIsSymlink: aNode
[
	^ false
]

MemoryStore >> basicModificationTime: aMemoryFileSystemEntry
[
	^ aMemoryFileSystemEntry modificationTime
]

MemoryStore >> basicOpen: path writable: aBoolean
[
	^ self
		nodeAt: path
		ifPresent: [ :aMemoryFileSystemEntry | aMemoryFileSystemEntry ]
		ifAbsent: [ aBoolean
				ifFalse: [ self signalFileDoesNotExist: path ]
				ifTrue: [ self createFile: path ] ]
]

MemoryStore >> basicPosixPermissions: anEntry
[
	^ 8r777
]

MemoryStore >> basicSize: aMemoryFileSystemEntry
[
	^ aMemoryFileSystemEntry fileSize
]

MemoryStore >> checkName: aString fixErrors: fixErrors
[
	aString ifEmpty: [ self error: 'zero length file name' ].
	^ aString
]

MemoryStore >> copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: aFilesystem
[
	| sourceNode destinationNode |
	sourceNode := self nodeAt: sourcePath ifPresent: [ :source | source ] ifAbsent: [ ^ absentBlock value ].
	sourceNode isDirectory
		ifTrue: [ ^ absentBlock value ].
	destinationNode := self
		nodeAt: destinationPath parent
		ifPresent: [ :destination | destination ]
		ifAbsent: [ ^ self signalDirectoryDoesNotExist: destinationPath parent ].
	destinationNode isFile
		ifTrue: [ self signalDirectoryDoesNotExist: destinationPath parent ].
	(destinationNode fileEntriesIncludes: destinationPath basename)
		ifTrue: [ "cannot overwrite existing file"
			^ presentBlock value ].
	destinationNode
		fileEntryAt: destinationPath basename
		put: (sourceNode copy
				basename: destinationPath basename;
				yourself)
]

MemoryStore >> createDirectory: path
[
	| parent |
	parent := path parent.
	^ self
		nodeAt: parent
		ifPresent: [ :entry | entry
				fileEntryAt: path basename
				ifPresent: [ :node | node isDirectory
						ifTrue: [ self signalDirectoryExists: path ]
						ifFalse: [ self signalFileExists: path ] ].
			entry ensureCreateDirectory: path basename ]
		ifAbsent: [ self signalDirectoryDoesNotExist: parent ]
]

MemoryStore >> createFile: aPath
[
	^ self
		nodeAt: aPath parent
		ifPresent: [ :entry | entry isDirectory
				ifTrue: [ entry ensureCreateFile: aPath basename ] ]
		ifAbsent: [ self signalDirectoryDoesNotExist: aPath parent ]
]

MemoryStore >> delete: path
[
	self
		nodeAt: path parent
		ifPresent: [ :dict | dict fileEntryRemove: path basename ifAbsent: [ FileDoesNotExist signalWith: path ] ]
		ifAbsent: [ DirectoryDoesNotExist signalWith: path parent ]
]

MemoryStore >> forReferencePrintOn: aStream
[
	aStream nextPutAll: 'memory://'
]

MemoryStore >> handleClass
[
	^ MemoryHandle
]

MemoryStore >> initialize
[
	root := MemoryFileSystemDirectory new
]

MemoryStore >> nodeAt: aPath ifPresent: presentBlock ifAbsent: absentBlock
[
	| current |
	current := self root.
	aPath
		do: [ :segment | current isDirectory
				ifTrue: [ current := current fileEntryAt: segment ifAbsent: [ ^ absentBlock value ] ]
				ifFalse: [ ^ absentBlock value ] ].
	^ presentBlock value: current
]

MemoryStore >> openFileStream: path writable: isWriteStream
[
	| entry |
	entry := self basicOpen: path writable: isWriteStream.
	^ isWriteStream
		ifTrue: [ entry writeStream ]
		ifFalse: [ entry readStream ]
]

MemoryStore >> rename: sourcePath to: destinationPath
[
	| sourceEntry destinationParentEntry newName |
	sourceEntry := self nodeAt: sourcePath.
	newName := destinationPath basename.
	destinationParentEntry := self nodeAt: destinationPath parent.
	destinationParentEntry isDirectory
		ifFalse: [ Error signal: 'Copy destination has to be a directory' ].
	destinationParentEntry fileEntryAt: newName ifPresent: [ Error signal: 'Destination file exists already' ].
	destinationParentEntry fileEntryAt: newName put: sourceEntry.
	sourceEntry basename: newName.
	(self nodeAt: sourcePath parent) fileEntryRemove: sourcePath basename
]

MemoryStore >> replaceFile: path in: aBlock
[
	^ self
		nodeAt: path parent
		ifPresent: [ :entry | | old new |
			entry isDirectory
				ifFalse: [ self signalFileDoesNotExist: path ].
			old := entry fileEntryAt: path basename ifAbsent: [ self signalFileDoesNotExist: path ].
			new := aBlock value: old.
			entry fileEntryAt: path basename put: new ]
		ifAbsent: [ self signalFileDoesNotExist: path ]
]

MemoryStore >> root
[
	^ root
]

MemoryStore class >> delimiter
[
	^ $/
]

MemoryStore class >> isCaseSensitive
[
	^ true
]

MemoryStore class >> separator
[
	^ $:
]

