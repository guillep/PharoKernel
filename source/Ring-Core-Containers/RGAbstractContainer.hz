RGAbstractContainer
	superclass: #RGNamedDefinition;
	instanceVariables: #(#elements );
	package: #'Ring-Core-Containers'.

RGAbstractContainer >> addElement: anObject
[
	anObject addInContainer: self
]

RGAbstractContainer >> addElement: anObject in: aCollection
[
	aCollection isDictionary
		ifTrue: [ aCollection at: anObject fullName put: anObject ]
		ifFalse: [ aCollection add: anObject ]
]

RGAbstractContainer >> elementNamed: elementName
[
	| aSymbol found |
	aSymbol := elementName asSymbol.
	elements do: [ :collection | (found := self elementNamed: aSymbol in: collection) notNil
				ifTrue: [ ^ found ] ].
	^ nil
]

RGAbstractContainer >> elementNamed: elementName in: aCollection
[
	| aSymbol |
	aSymbol := elementName asSymbol.
	^ aCollection isDictionary
		ifTrue: [ aCollection at: aSymbol ifAbsent: [ nil ] ]
		ifFalse: [ aCollection detect: [ :each | each fullName = aSymbol ] ifNone: [ nil ] ]
]

RGAbstractContainer >> elements
[
	"Retrieves the elements"

	^ elements
]

RGAbstractContainer >> elementsCategorized: aSymbol
[
	"Retrieves a group of elements.
	If does not exist set an Set"

	^ elements at: aSymbol ifAbsentPut: [ Set ]
]

RGAbstractContainer >> elementsCategorized: aSymbol with: aCollection
[
	"Allows to define other groups of elements with a particular kind of collection"

	elements at: aSymbol put: aCollection
]

RGAbstractContainer >> elementsDo: aBlock
[
	elements valuesDo: [ :collection | collection do: [ :each | aBlock value: each ] ]
]

RGAbstractContainer >> flushElements
[
	elements := IdentityDictionary new
]

RGAbstractContainer >> includesElement: anRGDefinition
[
	^ anRGDefinition isIncludedInContainer: self
]

RGAbstractContainer >> includesElementNamed: elementName
[
	| aSymbol |
	aSymbol := elementName asSymbol.
	elements do: [ :collection | (self includesElementNamed: aSymbol in: collection)
				ifTrue: [ ^ true ] ].
	^ false
]

RGAbstractContainer >> includesElementNamed: elementName in: aCollection
[
	| aSymbol |
	aSymbol := elementName asSymbol.
	^ aCollection isDictionary
		ifTrue: [ aCollection includesKey: aSymbol ]
		ifFalse: [ aCollection anySatisfy: [ :each | each name = aSymbol ] ]
]

RGAbstractContainer >> initialize
[
	super initialize.
	elements := IdentityDictionary new
]

RGAbstractContainer >> removeElement: anObject
[
	anObject removeFromContainer: self
]

RGAbstractContainer >> removeElement: anObject from: aCollection
[
	aCollection isDictionary
		ifTrue: [ aCollection removeKey: anObject fullName ifAbsent: [  ] ]
		ifFalse: [ aCollection remove: anObject ifAbsent: [  ] ]
]

RGAbstractContainer >> removeElementsCategorized: aSymbol
[
	"Deletes a group of elements"

	elements removeKey: aSymbol ifAbsent: [  ]
]

