RGClassDefinition
	superclass: #RGClassDescriptionDefinition;
	instanceVariables: #(#metaClass #comment #classVariables #category #package #sharedPools );
	package: #'Ring-Core-Kernel'.

RGClassDefinition >> addClassVarNamed: aString
[
	| var |
	var := self factory createClassVariableNamed: aString parent: self.
	self addVariable: var in: classVariables.
	^ var
]

RGClassDefinition >> addClassVariable: aRCClassVariable
[
	self addVariable: (aRCClassVariable parent: self) in: classVariables
]

RGClassDefinition >> addClassVariables: aCollection
[
	aCollection do: [ :var | self addClassVarNamed: var ]
]

RGClassDefinition >> addSharedPool: aRGPoolVariableDefinition
[
	self addVariable: (aRGPoolVariableDefinition parent: self) in: sharedPools
]

RGClassDefinition >> addSharedPoolNamed: poolName
[
	| pool |
	pool := self factory createPoolVariableNamed: poolName parent: self.
	self addVariable: pool in: sharedPools.
	^ pool
]

RGClassDefinition >> addSharedPools: aCollection
[
	aCollection do: [ :pool | self addSharedPoolNamed: pool ]
]

RGClassDefinition >> addUser: aRGClassDefinition
[
	"The receiver registers the aRGClassDefinition as an user.  An reinforces its status as a shared pool."

	aRGClassDefinition isClass
		ifFalse: [ ^ self ].
	(aRGClassDefinition theNonMetaClass sharedPoolNamed: self name) isNil
		ifTrue: [ aRGClassDefinition theNonMetaClass addSharedPoolNamed: self name ].
	self isPool: true.
	self users add: aRGClassDefinition theNonMetaClass
]

RGClassDefinition >> allClassVarNames
[
	^ self allClassVariables collect: [ :cvar | cvar name ]
]

RGClassDefinition >> allClassVariables
[
	"Answer a collection of the receiver's classVariables, including those defined its superclasses"

	^ self hasSuperclass
		ifFalse: [ classVariables ]
		ifTrue: [ self superclass allClassVariables , classVariables ]
]

RGClassDefinition >> allSharedPoolNames
[
	^ self allSharedPools collect: [ :pool | pool name ]
]

RGClassDefinition >> allSharedPools
[
	"Answer a collection of the pools the receiver shares, including those defined  
	in the superclasses of the receiver."

	^ self hasSuperclass
		ifFalse: [ sharedPools ]
		ifTrue: [ self superclass allSharedPools , sharedPools ]
]

RGClassDefinition >> category
[
	"retrieves a tag for its package"

	^ category
]

RGClassDefinition >> category: aSymbol
[
	"stores a tag for its package"

	category := aSymbol
]

RGClassDefinition >> classSymbol
[
	^ self className
]

RGClassDefinition >> classVarNamed: aString
[
	^ classVariables detect: [ :v | v name = aString asSymbol ] ifNone: [ nil ]
]

RGClassDefinition >> classVarNames
[
	"Answer a collection of the names of the class variables defined in the receiver."

	^ classVariables collect: [ :cvar | cvar name ]
]

RGClassDefinition >> classVariables
[
	^ classVariables
]

RGClassDefinition >> classVariables: aCollection
[
	classVariables := aCollection
]

RGClassDefinition >> comment
[
	"Retrieves the comment definition object"

	^ comment
]

RGClassDefinition >> comment: anObject
[
	"Sets a RGCommentDefinition object based on the argument"

	comment := self factory createComment: anObject parent: self
]

RGClassDefinition >> hasComment
[
	^ comment isEmptyOrNil not
]

RGClassDefinition >> hasMetaclass
[
	^ metaClass notNil
]

RGClassDefinition >> hasStamp
[
	^ self stamp isEmptyOrNil not
]

RGClassDefinition >> includesUser: aRGBehaviorDefinition
[
	^ self users includes: aRGBehaviorDefinition
]

RGClassDefinition >> initialize
[
	super initialize.
	classVariables := OrderedCollection new.
	sharedPools := OrderedCollection new
]

RGClassDefinition >> isPool
[
	"The receiver is a shared pool if it inherits from SharedPool"

	^ self annotationNamed: self class isPoolKey ifAbsent: [ self superclassName == #SharedPool ]
]

RGClassDefinition >> isPool: aBoolean
[
	^ self annotationNamed: self class isPoolKey put: aBoolean
]

RGClassDefinition >> isSameRevisionAs: aRGClassDefinition
[
	"This method look for equality of the properties of the receiver"

	^ (super isSameRevisionAs: aRGClassDefinition)
		and: [ self superclassName == aRGClassDefinition superclassName
				and: [ self category = aRGClassDefinition category
						and: [ self classVarNames sorted = aRGClassDefinition classVarNames sorted
								and: [ self sharedPoolNames sorted = aRGClassDefinition sharedPoolNames sorted
										and: [ self traitCompositionSource = aRGClassDefinition traitCompositionSource
												and: [ ((self hasComment and: [ self comment isSameRevisionAs: aRGClassDefinition comment ]) or: [ self hasComment not ])
														and: [ self theMetaClass isSameRevisionAs: aRGClassDefinition theMetaClass ] ] ] ] ] ] ]
]

RGClassDefinition >> package
[
	"Retrieves the package in which this class is contained, if exists"

	^ package
]

RGClassDefinition >> package: aRGPackage
[
	"Sets the package in which this class is contained"

	package := aRGPackage
]

RGClassDefinition >> removeClassVarNamed: aString
[
	self removeVariable: (self classVarNamed: aString) from: classVariables
]

RGClassDefinition >> removeClassVariable: aRGClassVariableDefinition
[
	self removeVariable: aRGClassVariableDefinition from: classVariables
]

RGClassDefinition >> removeSharedPool: aRGPoolVariableDefinition
[
	self removeVariable: aRGPoolVariableDefinition from: sharedPools
]

RGClassDefinition >> removeSharedPoolNamed: poolName
[
	self removeVariable: (self sharedPoolNamed: poolName) from: sharedPools
]

RGClassDefinition >> removeUser: aRGClassDefinition
[
	"Removes this RGClassDefinition from the users of the receiver"

	aRGClassDefinition isClass
		ifFalse: [ ^ self ].
	aRGClassDefinition theNonMetaClass removeSharedPoolNamed: self name.
	self users remove: aRGClassDefinition theNonMetaClass ifAbsent: [  ]
]

RGClassDefinition >> sharedPoolNamed: poolName
[
	^ sharedPools detect: [ :v | v name = poolName asSymbol ] ifNone: [ nil ]
]

RGClassDefinition >> sharedPoolNames
[
	^ sharedPools collect: [ :pool | pool name ]
]

RGClassDefinition >> sharedPools
[
	"Keeps the pool variable relationship of the receiver"

	^ sharedPools
]

RGClassDefinition >> sharedPools: aCollection
[
	sharedPools := aCollection
]

RGClassDefinition >> stamp
[
	^ self hasComment
		ifTrue: [ self comment stamp ]
		ifFalse: [ nil ]
]

RGClassDefinition >> stamp: aString
[
	self hasComment
		ifTrue: [ self comment stamp: aString ]
		ifFalse: [ self factory createComment
				parent: self;
				stamp: aString ]
]

RGClassDefinition >> theMetaClass
[
	^ metaClass
]

RGClassDefinition >> theNonMetaClass
[
	^ self
]

RGClassDefinition >> users
[
	"If the reciever is a SharedPool then retrieves its users"

	^ self isPool
		ifTrue: [ self annotationNamed: self class usersKey ifAbsentPut: [ OrderedCollection new ] ]
		ifFalse: [ #() ]
]

RGClassDefinition >> withMetaclass
[
	"Registers explicitly the metaclass of a class"

	metaClass := self factory createMetaclassOf: self
]

RGClassDefinition >> withMetaclass: aRGMetaclassDefinition
[
	"Registers explicitly the metaclass of a class"

	metaClass := aRGMetaclassDefinition.
	metaClass baseClass: self
]

