RemoteString
	instanceVariables: #(#sourceFileNumber #filePositionHi );
	package: #Files.

RemoteString >> fileNumber: fileNumber position: position
fileNumber: fileNumber position: position
	sourceFileNumber := fileNumber.
	filePositionHi := position

RemoteString >> fileStream
fileStream
	"Answer the file stream with position set at the beginning of my string.
	Answer a read only copy to avoid syntax errors when accessed via
	multiple processes."

	| theFile |
	(sourceFileNumber isNil or: [ (SourceFiles at: sourceFileNumber) isNil ])
		ifTrue: [ ^ nil ].
	theFile := (SourceFiles at: sourceFileNumber) readOnlyCopy.
	filePositionHi > theFile size
		ifTrue: [ self error: 'RemoteString past end of file' ].
	theFile position: filePositionHi.
	^ theFile

RemoteString >> last
last
	^ self string ifNotNil: [ :s | s last ]

RemoteString >> position
position
	"Answer the location of the string on a file."

	^ filePositionHi

RemoteString >> setSourcePointer: aSourcePointer
setSourcePointer: aSourcePointer
	sourceFileNumber := SourceFiles fileIndexFromSourcePointer: aSourcePointer.
	filePositionHi := SourceFiles filePositionFromSourcePointer: aSourcePointer

RemoteString >> sourceFileNumber
sourceFileNumber
	"Answer the index of the file on which the string is stored."

	^ sourceFileNumber

RemoteString >> sourcePointer
sourcePointer
	sourceFileNumber ifNil: [ ^ 0 ].
	^ SourceFiles sourcePointerFromFileIndex: sourceFileNumber andPosition: filePositionHi

RemoteString >> string
string
	"Answer the receiver's string if remote files are enabled.
	Use a read only copy to avoid syntax errors when accessed via
	multiple processes."

	| theFile |
	(sourceFileNumber isNil or: [ (SourceFiles at: sourceFileNumber) isNil ])
		ifTrue: [ ^ '' ].
	theFile := (SourceFiles at: sourceFileNumber) readOnlyCopy.
	^ [ filePositionHi > theFile size
		ifTrue: [ self error: 'RemoteString past end of file' ].
	theFile position: filePositionHi.
	theFile nextChunk ]
		ensure: [ theFile close ]

RemoteString >> string: aString onFileNumber: fileNumber
string: aString onFileNumber: fileNumber
	"Store this as my string if source files exist."

	| theFile |
	(SourceFiles at: fileNumber)
		ifNotNil: [ theFile := SourceFiles at: fileNumber.
			theFile
				setToEnd;
				cr.
			self string: aString onFileNumber: fileNumber toFile: theFile ]

RemoteString >> string: aString onFileNumber: fileNumber toFile: aFileStream
string: aString onFileNumber: fileNumber toFile: aFileStream
	"Store this as the receiver's string if source files exist."

	| position |
	position := aFileStream position.
	self fileNumber: fileNumber position: position.
	aFileStream nextChunkPut: aString.
	^ self

RemoteString >> text
text
	^ self string asText

RemoteString class >> newFileNumber: sourceIndex position: anInteger
newFileNumber: sourceIndex position: anInteger
	"Answer an instance of me fora file indexed by sourceIndex, at the 
	position anInteger. Assume that the string is already stored on the file 
	and the instance will be used to access it."

	^ self new fileNumber: sourceIndex position: anInteger

RemoteString class >> newString: aString onFileNumber: sourceIndex
newString: aString onFileNumber: sourceIndex
	"Answer an instance of me for string, aString, on file indexed by 
	sourceIndex. Put the string on the file and create the remote reference."

	^ self new string: aString onFileNumber: sourceIndex

RemoteString class >> newString: aString onFileNumber: sourceIndex toFile: aFileStream
newString: aString onFileNumber: sourceIndex toFile: aFileStream
	"Answer an instance of me for string, aString, on file indexed by 
	sourceIndex. Put the string on the file, aFileStream, and create the 
	remote reference. Assume that the index corresponds properly to 
	aFileStream."

	^ self new string: aString onFileNumber: sourceIndex toFile: aFileStream

