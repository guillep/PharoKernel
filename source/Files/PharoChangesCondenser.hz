PharoChangesCondenser
	instanceVariables: #(#newChangesFile #stream #job #remoteStringMap #sourceStreams );
	package: #Files.

PharoChangesCondenser >> backupOldChanges
[
	| changesFile |
	changesFile := self originalFile.
	changesFile moveTo: (changesFile , 'bak') nextVersion
]

PharoChangesCondenser >> basicCondense
[
	self
		condenseClassesAndTraits;
		swapSourcePointers;
		installNewChangesFile;
		reset
]

PharoChangesCondenser >> condense
[
	job := [ newChangesFile writeStreamDo: [ :aStream | stream := aStream.
			self basicCondense ] ] asJob.
	job
		title: 'Condensing Changes';
		max: Smalltalk classNames size + Smalltalk traitNames size;
		run
]

PharoChangesCondenser >> condenseClassOrTrait: classOrTrait
[
	self writeClassComment: classOrTrait.
	classOrTrait theNonMetaClass
		methodsDo: [ :method | (self shouldCondenseMethod: method)
				ifTrue: [ self writeMethodSource: method ] ].
	classOrTrait theMetaClass
		methodsDo: [ :method | (self shouldCondenseMethod: method)
				ifTrue: [ self writeMethodSource: method ] ]
]

PharoChangesCondenser >> condenseClassesAndTraits
[
	Smalltalk allClassesAndTraitsDo: [ :classOrTrait | self condenseClassOrTrait: classOrTrait ]
]

PharoChangesCondenser >> fileIndex
[
	"Return the index into the SourceFiles:
	1: the .sources file
	2. the .changes file"

	^ 2
]

PharoChangesCondenser >> initialize
[
	self reset
]

PharoChangesCondenser >> installNewChangesFile
[
	(SourceFiles at: self fileIndex) close.
	self updateQuitPosition.
	stream flush close.
	self backupOldChanges.
	self originalFile ensureDelete.
	newChangesFile moveTo: self originalFile.
	Smalltalk openSourceFiles
]

PharoChangesCondenser >> nextChunkDo: aBlock
[
	stream nextChunkPut: (String streamContents: aBlock)
]

PharoChangesCondenser >> nextCommentChunkDo: aBlock
[
	stream
		cr;
		nextPut: $!.
	self nextChunkDo: aBlock.
	stream cr
]

PharoChangesCondenser >> originalFile
[
	^ Smalltalk changesFile
]

PharoChangesCondenser >> reset
[
	remoteStringMap := IdentityDictionary new.
	newChangesFile := self temporaryFile.	"Keep a copy of the source streams for performance"
	sourceStreams := Array with: PharoFilesOpener default sourcesFileOrNil with: PharoFilesOpener default changesFileOrNil
]

PharoChangesCondenser >> shouldCondenseMethod: aMethod
[
	"Only write methods with changes in the current file (not .sources)"

	^ aMethod hasSourceCodeInChangesFile
]

PharoChangesCondenser >> sourceCodeOfMethod: aMethod
[
	"Optimized version of: aMethod sourceCode
	Reuse the same stream instead of reopening a new stream on each read"

	^ (self sourceStreamOfMethod: aMethod) nextChunk
]

PharoChangesCondenser >> sourceStreamOfMethod: aMethod
[
	| aStream |
	aStream := sourceStreams at: aMethod fileIndex.
	aStream position: aMethod filePosition.
	^ aStream
]

PharoChangesCondenser >> stampOfMethod: aMethod
[
	"Optimized version of: aMethod stamp
	Reuse the same stream instead of reopening a new stream on each read"

	^ aMethod timeStampFromFile: (self sourceStreamOfMethod: aMethod)
]

PharoChangesCondenser >> swapClassComment: classOrTrait
[
	remoteStringMap at: classOrTrait ifPresent: [ :remoteString | classOrTrait organization comment: remoteString ]
]

PharoChangesCondenser >> swapSourcePointerOfClassOrTrait: classOrTrait
[
	self swapClassComment: classOrTrait.
	classOrTrait methodsDo: [ :method | self swapSourcePointerOfMethod: method ].
	classOrTrait classSide methodsDo: [ :method | self swapSourcePointerOfMethod: method ]
]

PharoChangesCondenser >> swapSourcePointerOfMethod: method
[
	remoteStringMap at: method ifPresent: [ :remoteString | method setSourcePointer: remoteString sourcePointer ]
]

PharoChangesCondenser >> swapSourcePointers
[
	job
		title: 'Swapping source pointers';
		currentValue: 0.
	Smalltalk
		allClassesAndTraitsDo: [ :classOrTrait | job increment.
			self swapSourcePointerOfClassOrTrait: classOrTrait ]
]

PharoChangesCondenser >> temporaryFile
[
	^ (Smalltalk changesFile , 'new') nextVersion
]

PharoChangesCondenser >> updateQuitPosition
[
	Smalltalk lastQuitLogPosition: stream position
]

PharoChangesCondenser >> writeClassComment: aClass
[
	| organizer commentRemoteString stamp |
	organizer := aClass organization.
	commentRemoteString := organizer commentRemoteStr.
	(commentRemoteString isNil or: [ commentRemoteString sourceFileNumber = 1 ])
		ifTrue: [ ^ self ].
	self
		nextCommentChunkDo: [ :strm | strm
				nextPutAll: aClass name;
				nextPutAll: ' commentStamp: '.
			stamp := organizer commentStamp ifNil: [ '<historical>' ].
			stamp storeOn: strm ].
	self writeRemoteString: organizer classComment for: aClass
]

PharoChangesCondenser >> writeMethodSource: aMethod
[
	self
		nextCommentChunkDo: [ :strm | strm
				nextPutAll: aMethod methodClass name;
				nextPutAll: ' methodsFor: ';
				store: aMethod category asString;
				nextPutAll: ' stamp: ';
				store: (self stampOfMethod: aMethod) ].
	self writeRemoteString: (self sourceCodeOfMethod: aMethod) for: aMethod.
	stream
		nextPutAll: ' !';
		cr
]

PharoChangesCondenser >> writeRemoteString: aString for: reference
[
	| remoteString |
	remoteString := RemoteString newString: aString onFileNumber: self fileIndex toFile: stream.
	remoteStringMap at: reference put: remoteString.
	^ remoteString
]

PharoChangesCondenser class >> condense
[
	^ self new condense
]

