LIFOQueue
	superclass: #AtomicCollection;
	instanceVariables: #(#head );
	package: #'Collections-Atomic'.

LIFOQueue >> errorEmptyStack
[
	self error: 'this stack is empty'
]

LIFOQueue >> fastPeek
[
	"Answer a top-most value without removing it from queue.
	Answer nil, if queue is empty or currently blocked by other process,
	which reading from queue"

	| item result |
	item := head.
	[ (result := item object) == item ]
		whileTrue: [ item isCircular
				ifTrue: [ ^ nil ].
			(item := item next) ifNil: [ ^ nil ] ].
	^ result
]

LIFOQueue >> initialize
[
	| dummy |
	dummy := self newItem.
	dummy
		next: nil;
		object: dummy.
	head := dummy
]

LIFOQueue >> next
[
	| dummy tail |
	dummy := self newItem.
	dummy object: dummy.	"this is atomic"
	tail := head.
	head := dummy.	"skip over dummies"
	[ tail object == tail ]
		whileTrue: [ [ tail isCircular ] whileTrue: [ self yield ].
			(tail := tail next)
				ifNil: [ | result |
					"queue is empty. block until new items appear"
					head == dummy
						ifTrue: [ self signalNoMoreItems ].
					[ head == dummy ] whileTrue: [ self waitForNewItems ].
					dummy next: nil.
					result := self next.
					^ result ] ].
	dummy next: tail next.
	^ tail object
]

LIFOQueue >> nextIfNone: aBlock
[
	| dummy tail |
	dummy := self newItem.
	dummy object: dummy.
	tail := head.
	head := dummy.	"skip over dummies"
	[ tail object == tail ]
		whileTrue: [ [ tail isCircular ] whileTrue: [ self yield ].
			(tail := tail next)
				ifNil: [ dummy next: nil.
					dummy == head
						ifTrue: [ self signalNoMoreItems ].
					^ aBlock value ] ].
	dummy next: tail next.
	^ tail object
]

LIFOQueue >> nextOrNil
[
	^ self nextIfNone: [ nil ]
]

LIFOQueue >> nextPut: anObject
[
	| newItem oldHead |
	newItem := self newItem.
	newItem object: anObject.	"this is atomic"
	oldHead := head.
	head := newItem.
	newItem next: oldHead.
	self signalAddedNewItem.
	^ anObject
]

LIFOQueue >> peek
[
	"answer a top-most value without removing it,  or nil, if queue is empty.
	May block if there's another process reading from queue"

	| item result |
	item := head.
	[ (result := item object) == item ]
		whileTrue: [ [ item isCircular ] whileTrue: [ self yield ].
			(item := item next) ifNil: [ ^ nil ] ].
	^ result
]

LIFOQueue >> pop
[
	^ self nextIfNone: [ self errorEmptyStack ]
]

LIFOQueue >> push: anObject
[
	^ self nextPut: anObject
]

 [ self errorEmptyStack ]
]

LIFOQueue >> push: anObject
[push: anObject
	^ self nextPut: anObject
]

