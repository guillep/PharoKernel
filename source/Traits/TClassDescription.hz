Trait named: #TClassDescription
	package: #'Traits-Kernel-Traits'.TClassDescription >> acceptsLoggingOfCompilation
[
	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself
	Weird name is so that it will come lexically before #compile, so that a clean build can make it through."

	^ true
]

TClassDescription >> addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor
[
	^ self explicitRequirement
]

TClassDescription >> addCategory: newName before: aCategory
[
	^ self organization addCategory: newName before: aCategory
]

TClassDescription >> addInstVarNamed: aString
[
	^ self explicitRequirement
]

TClassDescription >> addSelector: selector withMethod: compiledMethod notifying: requestor
[
	| priorMethodOrNil |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [ nil ].
	self addSelectorSilently: selector withMethod: compiledMethod.
	priorMethodOrNil
		ifNil: [ SystemAnnouncer uniqueInstance
				methodAdded: compiledMethod
				selector: selector
				inClass: self
				requestor: requestor ]
		ifNotNil: [ SystemAnnouncer uniqueInstance
				methodChangedFrom: priorMethodOrNil
				to: compiledMethod
				selector: selector
				inClass: self
				requestor: requestor ]
]

TClassDescription >> addSelectorSilently: selector withMethod: compiledMethod
[
	super addSelectorSilently: selector withMethod: compiledMethod.
	self instanceSide noteAddedSelector: selector meta: self isMeta
]

TClassDescription >> allInstVarNamesEverywhere
[
	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"

	| aList |
	aList := OrderedCollection new.
	self allSuperclasses , self withAllSubclasses asOrderedCollection do: [ :cls | aList addAll: cls instVarNames ].
	^ aList asSet	"BorderedMorph allInstVarNamesEverywhere"
]

TClassDescription >> allProtocolsUpTo: mostGenericClass
[
	"Answer a list of all the method protocols of the receiver and all its superclasses, up through mostGenericClass"

	| otherClassCategories thisClassCategories lowercaseSortBlock |
	otherClassCategories := OrderedCollection new.
	lowercaseSortBlock := [ :a :b | a asLowercase <= b asLowercase ].
	(self allSuperclassesIncluding: mostGenericClass)
		do: [ :aClass | otherClassCategories addAll: aClass organization categories ].
	otherClassCategories remove: 'no messages' ifAbsent: [  ].
	thisClassCategories := self organization categories sorted: lowercaseSortBlock.
	^ thisClassCategories
		,
			((otherClassCategories asSet removeAllSuchThat: [ :each | thisClassCategories includes: each ])
				sorted: lowercaseSortBlock)
]

TClassDescription >> allSelectorsInProtocol: aName
[
	"Answer a list of all the methods of the receiver and all its 
	superclasses that are in the protocol named aName"

	| aColl |
	aColl := OrderedCollection new.
	self withAllSuperclasses do: [ :aClass | aColl addAll: (aClass organization listAtCategoryNamed: aName) ].
	^ aColl asSet asArray sort
]

TClassDescription >> allSharedPools
[
	"Answer an ordered collection  of the shared pools the receiver shares, including those defined  in the superclasses of the receiver."

	^ OrderedCollection new
]

TClassDescription >> applyChangesOfNewTraitCompositionReplacing: oldComposition
[
	| changedSelectors oldMethodDict |
	oldMethodDict := self methodDict copy.
	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.
	self noteRecategorizedSelectors: changedSelectors oldComposition: oldComposition.
	self noteChangesFrom: oldMethodDict.
	^ changedSelectors
]

TClassDescription >> authors
[
	"Returns a bag representing the author frequency based on the latest version of the methods of the receiver."

	^ self methods , self class methods collect: [ :each | each author ] as: Bag
]

TClassDescription >> basicOrganization
[
	^ self explicitRequirement
]

TClassDescription >> basicOrganization: aClassOrg
[
	^ self explicitRequirement
]

TClassDescription >> checkForInstVarsOK: instVarString
[
	"Return true if instVarString does no include any names used in a subclass"

	| instVarArray |
	instVarArray := instVarString subStrings: ' '.
	self allSubclasses
		do: [ :cl | cl instVarNames
				do: [ :n | (instVarArray includes: n)
						ifTrue: [ self error: n , ' is already used in ' , cl name.
							^ false ] ] ].
	^ true
]

TClassDescription >> classComment: aString
[
	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."

	^ self classComment: aString stamp: '<historical>'
]

TClassDescription >> classComment: aString stamp: aStamp
[
	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."

	| pointer header file oldCommentRemoteString oldComment oldStamp |
	oldComment := self organization classComment.
	oldStamp := self organization commentStamp.
	(aString isKindOf: RemoteString)
		ifTrue: [ SystemAnnouncer uniqueInstance
				class: self
				oldComment: oldComment
				newComment: aString string
				oldStamp: oldStamp
				newStamp: aStamp.
			^ self organization classComment: aString stamp: aStamp ].
	oldCommentRemoteString := self organization commentRemoteStr.
	aString size = 0 & oldCommentRemoteString isNil
		ifTrue: [ ^ self organization classComment: nil ].	"never had a class comment, no need to write empty string out"
	pointer := oldCommentRemoteString ifNil: [ 0 ] ifNotNil: [ oldCommentRemoteString sourcePointer ].
	(file := SourceFiles at: 2)
		ifNotNil: [ file
				setToEnd;
				cr;
				nextPut: $!.	"directly"	"Should be saying (file command: 'H3') for HTML, but ignoring it here"
			header := String
				streamContents: [ :strm | strm
						nextPutAll: self name;
						nextPutAll: ' commentStamp: '.
					aStamp storeOn: strm.
					strm
						nextPutAll: ' prior: ';
						nextPutAll: pointer printString ].
			file nextChunkPut: header ].
	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.
	SystemAnnouncer uniqueInstance
		class: self
		oldComment: oldComment
		newComment: aString
		oldStamp: oldStamp
		newStamp: aStamp
]

TClassDescription >> classCommentBlank
[
	| existingComment stream |
	existingComment := self theNonMetaClass organization classComment.
	existingComment isEmpty
		ifFalse: [ ^ existingComment ].
	stream := (String new: 100) writeStream.
	stream
		nextPutAll: 'A';
		nextPutAll: (self name first isVowel
						ifTrue: [ 'n ' ]
						ifFalse: [ ' ' ]);
		nextPutAll: self name;
		nextPutAll: ' is xxxxxxxxx.'.
	self instVarNames size > 0
		ifTrue: [ stream
				cr;
				cr;
				nextPutAll: 'Instance Variables' ].
	self instVarNames asSortedCollection
		do: [ :each | stream
				cr;
				tab;
				nextPutAll: each;
				nextPut: $:;
				tab;
				tab;
				nextPutAll: '<Object>' ].
	stream cr.
	self instVarNames asSortedCollection
		do: [ :each | stream
				cr;
				nextPutAll: each;
				cr;
				tab;
				nextPutAll: '- xxxxx';
				cr ].
	^ stream contents
]

TClassDescription >> classSide
[
	^ self theMetaClass
]

TClassDescription >> classThatDefinesClassVariable: classVarName
[
	"Answer the class that defines the given class variable"

	(self classPool includesKey: classVarName asSymbol)
		ifTrue: [ ^ self ].
	^ self superclass ifNotNil: [ self superclass classThatDefinesClassVariable: classVarName ]
]

TClassDescription >> classThatDefinesInstanceVariable: instVarName
[
	(self instVarNames notNil and: [ self instVarNames includes: instVarName asString ])
		ifTrue: [ ^ self ].
	^ self superclass ifNotNil: [ self superclass classThatDefinesInstanceVariable: instVarName ]
]

TClassDescription >> classVariablesString
[
	"Answer a string of my class variable names separated by spaces."

	^ String
		streamContents: [ :stream | self classVarNames do: [ :each | stream nextPutAll: each ] separatedBy: [ stream space ] ]
]

TClassDescription >> classesThatImplementAllOf: selectorSet
[
	"Return an array of any classes that implement all the messages in selectorSet."

	| found remaining |
	found := OrderedCollection new.
	selectorSet do: [ :sel | (self includesSelector: sel)
				ifTrue: [ found add: sel ] ].
	found isEmpty
		ifTrue: [ ^ self subclasses
				inject: Array new
				into: [ :subsThatDo :sub | subsThatDo , (sub classesThatImplementAllOf: selectorSet) ] ]
		ifFalse: [ remaining := selectorSet copyWithoutAll: found.
			remaining isEmpty
				ifTrue: [ ^ Array with: self ].
			^ self subclasses
				inject: Array new
				into: [ :subsThatDo :sub | subsThatDo , (sub classesThatImplementAllOf: remaining) ] ]
]

TClassDescription >> comment
[
	"Answer the receiver's comment. (If missing, supply a template) "

	| aString |
	aString := self instanceSide organization classComment.
	aString isEmpty
		ifFalse: [ ^ aString ].
	^ self classCommentBlank
]

TClassDescription >> comment: aStringOrText
[
	"Set the receiver's comment to be the argument, aStringOrText."

	self instanceSide classComment: aStringOrText
]

TClassDescription >> comment: aStringOrText stamp: aStamp
[
	"Set the receiver's comment to be the argument, aStringOrText."

	self instanceSide classComment: aStringOrText stamp: aStamp
]

TClassDescription >> commentInventory
[
	"Answer a string with a count of the classes with and without comments 
	for all the classes in the package of which this class is a member."

	"Morph commentInventory"

	^ self environment organization commentInventory: (self category copyUpTo: $-) , '*'
]

TClassDescription >> commentStamp: changeStamp
[
	self organization commentStamp: changeStamp.
	^ self commentStamp: changeStamp prior: 0
]

TClassDescription >> commentStamp: changeStamp prior: indexAndOffset
[
	"Prior source link ignored when filing in."

	^ ClassCommentReader new setClass: self category: #Comment changeStamp: changeStamp
]

TClassDescription >> compile: code classified: heading
[
	"Compile the argument, code, as source code in the context of the 
	receiver and install the result in the receiver's method dictionary under 
	the classification indicated by the second argument, heading. nil is to be 
	notified if an error occurs. The argument code is either a string or an 
	object that converts to a string or a PositionableStream on an object that 
	converts to a string."

	^ self compile: code classified: heading notifying: nil
]

TClassDescription >> compile: text classified: category notifying: requestor
[
	| stamp |
	stamp := self acceptsLoggingOfCompilation
		ifTrue: [ Author changeStamp ]
		ifFalse: [ nil ].
	^ self
		compile: text
		classified: category
		withStamp: stamp
		notifying: requestor
]

TClassDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor
[
	^ self
		compile: text
		classified: category
		withStamp: changeStamp
		notifying: requestor
		logSource: self acceptsLoggingOfCompilation
]

TClassDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
	| method |
	method := self compiler
		source: text;
		requestor: requestor;
		category: category;
		failBlock: [ ^ nil ];
		compile.
	logSource
		ifTrue: [ self
				logMethodSource: (requestor ifNotNil: [ :r | r text ] ifNil: [ text ])
				forMethod: method
				inCategory: category
				withStamp: changeStamp	"the requestor text might have been changed by the compiler and may be different thant text argument" ].
	self
		addAndClassifySelector: method selector
		withMethod: method
		inProtocol: category
		notifying: requestor.
	self instanceSide noteCompilationOf: method selector meta: self isClassSide.
	^ method selector
]

TClassDescription >> compile: code notifying: requestor
[
	"Refer to the comment in Behavior|compile:notifying:."

	^ self compile: code classified: Protocol unclassified notifying: requestor
]

TClassDescription >> compileSilently: code classified: category
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."

	^ self compileSilently: code classified: category notifying: nil
]

TClassDescription >> compileSilently: code classified: category notifying: requestor
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."

	^ SystemAnnouncer uniqueInstance suspendAllWhile: [ self compile: code classified: category notifying: requestor ]
]

TClassDescription >> copy: sel from: class
[
	"Install the method associated with the first argument, sel, a message 
	selector, found in the method dictionary of the second argument, class, 
	as one of the receiver's methods. Classify the message under -As yet not 
	classified-."

	self copy: sel from: class classified: nil
]

TClassDescription >> copy: sel from: class classified: cat
[
	"Install the method associated with the first arugment, sel, a message 
	selector, found in the method dictionary of the second argument, class, 
	as one of the receiver's methods. Classify the message under the third 
	argument, cat."

	| code category |
	"Useful when modifying an existing class"
	code := class sourceCodeAt: sel.
	code
		ifNotNil: [ cat ifNil: [ category := class organization categoryOfElement: sel ] ifNotNil: [ category := cat ].
			(self includesLocalSelector: sel)
				ifTrue: [ code asString = (self sourceCodeAt: sel) asString
						ifFalse: [ self error: self name , ' ' , sel , ' will be redefined if you proceed.' ] ].
			self compile: code classified: category ]
]

TClassDescription >> copyAll: selArray from: class
[
	"Install all the methods found in the method dictionary of the second 
	argument, class, as the receiver's methods. Classify the messages under 
	-As yet not classified-."

	self copyAll: selArray from: class classified: nil
]

TClassDescription >> copyAll: selArray from: class classified: cat
[
	"Install all the methods found in the method dictionary of the second 
	argument, class, as the receiver's methods. Classify the messages under 
	the third argument, cat."

	selArray do: [ :s | (class includesLocalSelector: s)
				ifTrue: [ self copy: s from: class classified: cat ] ]
]

TClassDescription >> copyAllCategoriesFrom: aClass
[
	"Specify that the categories of messages for the receiver include all of 
	those found in the class, aClass. Install each of the messages found in 
	these categories into the method dictionary of the receiver, classified 
	under the appropriate categories."

	aClass organization categories do: [ :cat | self copyCategory: cat from: aClass ]
]

TClassDescription >> copyCategory: cat from: class
[
	"Specify that one of the categories of messages for the receiver is cat, as 
	found in the class, class. Copy each message found in this category."

	self copyCategory: cat from: class classified: cat
]

TClassDescription >> copyCategory: cat from: aClass classified: newCat
[
	"Specify that one of the categories of messages for the receiver is the 
	third argument, newCat. Copy each message found in the category cat in 
	class aClass into this new category."

	self copyAll: (aClass organization listAtCategoryNamed: cat) from: aClass classified: newCat
]

TClassDescription >> copyMethodDictionaryFrom: donorClass
[
	"Copy the method dictionary of the donor class over to the receiver"

	self methodDict: donorClass copyOfMethodDictionary.
	self organization: donorClass organization deepCopy
]

TClassDescription >> definition
[
	^ self explicitRequirement
]

TClassDescription >> errorCategoryName
[
	self error: 'Category name must be a String'
]

TClassDescription >> fileOutCategory: catName
[
	| internalStream |
	internalStream := (String new: 1000) writeStream.
	internalStream
		header;
		timeStamp.
	self
		fileOutCategory: catName
		on: internalStream
		moveSource: false
		toFile: 0.
	internalStream trailer.
	^ FileStream writeSourceCodeFrom: internalStream baseName: self name , '-' , catName isSt: true
]

TClassDescription >> fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the receiver's category, aString, onto aFileStream. If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.sources file, and should only write one preamble per method category."

	| selectors |
	aFileStream cr.
	selectors := self selectorsToFileOutCategory: aSymbol.	"Overridden to preserve author stamps in sources file regardless"
	selectors
		do: [ :sel | self
				printMethodChunk: sel
				withPreamble: true
				on: aFileStream
				moveSource: moveSource
				toFile: fileIndex ].
	^ self
]

TClassDescription >> fileOutChangedMessages: aSet on: aFileStream
[
	"File a description of the messages of the receiver that have been 
	changed (i.e., are entered into the argument, aSet) onto aFileStream."

	self
		fileOutChangedMessages: aSet
		on: aFileStream
		moveSource: false
		toFile: 0
]

TClassDescription >> fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the messages of this class that have been 
	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.changes file, and should only write a preamble for every method."

	| org |
	(org := self organization) categories
		do: [ :cat | | sels |
			sels := (org listAtCategoryNamed: cat) select: [ :sel | aSet includes: sel ].
			sels
				do: [ :sel | self
						printMethodChunk: sel
						withPreamble: true
						on: aFileStream
						moveSource: moveSource
						toFile: fileIndex ] ]
]

TClassDescription >> fileOutMethod: selector
[
	"Write source code of a single method on a file.  Make up a name for the file."

	| internalStream |
	internalStream := (String new: 1000) writeStream.
	self fileOutMethod: selector on: internalStream.
	FileStream
		writeSourceCodeFrom: internalStream
		baseName: self name , '-' , (selector copyReplaceAll: ':' with: '')
		isSt: true
]

TClassDescription >> fileOutMethod: selector on: aStream
[
	selector == #Comment
		ifTrue: [ ^ self inform: 'Sorry, cannot file out class comment in isolation.' ].
	(self includesSelector: selector)
		ifFalse: [ ^ self error: 'Selector ' , selector asString , ' not found' ].
	aStream
		header;
		timeStamp.
	self
		printMethodChunk: selector
		withPreamble: true
		on: aStream
		moveSource: false
		toFile: 0
]

TClassDescription >> fileOutOn: aFileStream
[
	"File a description of the receiver on aFileStream."

	self fileOutOn: aFileStream moveSource: false toFile: 0
]

TClassDescription >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the receiver on aFileStream. If the boolean 
	argument, moveSource, is true, then set the trailing bytes to the position 
	of aFileStream and to fileIndex in order to indicate where to find the 
	source code."

	aFileStream nextChunkPut: self definition.
	self organization
		putCommentOnFile: aFileStream
		numbered: fileIndex
		moveSource: moveSource
		forClass: self.
	self organization categories
		do: [ :heading | self
				fileOutCategory: heading
				on: aFileStream
				moveSource: moveSource
				toFile: fileIndex ]
]

TClassDescription >> fileOutOrganizationOn: aFileStream
[
	"File a description of the receiver's organization on aFileStream."

	aFileStream
		cr;
		nextPut: $!.
	aFileStream
		nextChunkPut: self name , ' reorganize';
		cr.
	aFileStream
		nextChunkPut: self organization stringForFileOut;
		cr
]

TClassDescription >> forceNewFrom: anArray
[
	"Create a new instance of the class and fill
    its instance variables up with the array."

	| object max |
	object := self new.
	max := self instSize.
	anArray doWithIndex: [ :each :index | index > max
				ifFalse: [ object instVarAt: index put: each ] ].
	^ object
]

TClassDescription >> hasClassSide
[
	^ self subclassResponsibility
]

TClassDescription >> hasComment
[
	"return whether this class truly has a comment other than the default"

	| org |
	org := self instanceSide organization.
	^ org classComment isEmptyOrNil not
]

TClassDescription >> hasInstVarNamed: aString
[
	"Return true whether the receiver defines an instance variable named aString."

	^ self instVarNames includes: aString
]

TClassDescription >> hasSharedPools
[
	"Only a class may have shared pools"

	^ false
]

TClassDescription >> instVarIndexFor: instVarName
[
	"Answer the index of the named instance variable."

	| index |
	index := self instanceVariables == nil
		ifTrue: [ 0 ]
		ifFalse: [ self instanceVariables indexOf: instVarName ].
	index = 0
		ifTrue: [ ^ self superclass == nil
				ifTrue: [ 0 ]
				ifFalse: [ self superclass instVarIndexFor: instVarName ] ].
	^ self superclass == nil
		ifTrue: [ index ]
		ifFalse: [ index + self superclass instSize ]
]

TClassDescription >> instVarIndexFor: instVarName ifAbsent: aBlock
[
	"Answer the index of the named instance variable."

	| index |
	index := self instanceVariables == nil
		ifTrue: [ 0 ]
		ifFalse: [ self instanceVariables indexOf: instVarName ifAbsent: [ 0 ] ].
	index = 0
		ifTrue: [ ^ self superclass == nil
				ifTrue: [ aBlock value ]
				ifFalse: [ self superclass instVarIndexFor: instVarName ifAbsent: aBlock ] ].
	^ self superclass == nil
		ifTrue: [ index ]
		ifFalse: [ index + self superclass instSize ]
]

TClassDescription >> instVarMappingFrom: oldClass
[
	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."

	| oldInstVarNames |
	oldInstVarNames := oldClass allInstVarNames.
	^ self allInstVarNames collect: [ :instVarName | oldInstVarNames indexOf: instVarName ]
]

TClassDescription >> instVarNameForIndex: index
[
	"Answer the named instance variable with index index or nil if none."

	| superInstSize |
	index > self instSize
		ifTrue: [ ^ nil ].
	superInstSize := self superclass ifNil: [ 0 ] ifNotNil: [ self superclass instSize ].
	index > superInstSize
		ifTrue: [ ^ self instanceVariables at: index - superInstSize ].
	self superclass ifNil: [ ^ nil ].
	^ self superclass instVarNameForIndex: index	"(Object allSubclasses select:		[:cls| cls instSize > cls superclass instSize and: [cls subclasses isEmpty and: [cls superclass instSize > 0]]]) collect:			[:cls| (1 to: cls instSize) collect: [:i| cls instVarNameForIndex: i]]"
]

TClassDescription >> instVarNames
[
	"Answer an Array of the receiver's instance variable names."

	self instanceVariables == nil
		ifTrue: [ ^ #() ]
		ifFalse: [ ^ self instanceVariables ]
]

TClassDescription >> instVarNamesAndOffsetsDo: aBinaryBlock
[
	"This is part of the interface between the compiler and a class's instance or field names.
	 The class should enumerate aBinaryBlock with the instance variable name strings and
	 their integer offsets.  The order is important. Names evaluated later will override the
	 same names occurring earlier."

	| superInstSize |
	(superInstSize := self superclass notNil
		ifTrue: [ self superclass instSize ]
		ifFalse: [ 0 ]) > 0
		ifTrue: [ self superclass instVarNamesAndOffsetsDo: aBinaryBlock ].
	1 to: self instSize - superInstSize do: [ :i | aBinaryBlock value: (self instanceVariables at: i) value: i + superInstSize ]
]

TClassDescription >> instanceSide
[
	^ self theNonMetaClass
]

TClassDescription >> instanceVariables
[
	^ self explicitRequirement
]

TClassDescription >> instanceVariables: anObject
[
	^ self explicitRequirement
]

TClassDescription >> instanceVariablesString
[
	"Answer a string of my instance variable names separated by spaces."

	^ String
		streamContents: [ :stream | self instVarNames do: [ :each | stream nextPutAll: each ] separatedBy: [ stream space ] ]
]

TClassDescription >> isClassSide
[
	^ self == self classSide
]

TClassDescription >> isInstanceSide
[
	^ self isClassSide not
]

TClassDescription >> isMeta
[
	^ self isClassSide
]

TClassDescription >> isTestCase
[
	^ false
]

TClassDescription >> linesOfCode
[
	"An approximate measure of lines of code.
	Includes comments, but excludes blank lines."

	| lines |
	lines := self localMethods inject: 0 into: [ :sum :each | sum + each linesOfCode ].
	^ self isMeta
		ifTrue: [ lines ]
		ifFalse: [ lines + self class linesOfCode ]
]

TClassDescription >> localMethods
[
	"returns the methods of classes including the ones of the traits that the class uses"

	^ self methods select: [ :each | self includesLocalSelector: each selector ]
]

TClassDescription >> logMethodSource: aText forMethod: aCompiledMethod inCategory: category withStamp: changeStamp
[
	aCompiledMethod
		putSource: aText
		class: self
		category: category
		withStamp: changeStamp
		inFile: 2
		priorMethod: (self compiledMethodAt: aCompiledMethod selector ifAbsent: [  ])
]

TClassDescription >> methodsFor: categoryName
[
	"Answer a ClassCategoryReader for compiling the messages in the category, categoryName, of the receiver."

	^ ClassCategoryReader new setClass: self category: categoryName asSymbol	"(False methodsFor: 'logical operations') inspect"
]

TClassDescription >> moveChangesTo: newFile
[
	"Used in the process of condensing changes, this message requests that 
	the source code of all methods of the receiver that have been changed 
	should be moved to newFile."

	| changes |
	changes := self selectors select: [ :sel | (self compiledMethodAt: sel) fileIndex > 1 ].
	self
		fileOutChangedMessages: changes
		on: newFile
		moveSource: true
		toFile: 2
]

TClassDescription >> newInstanceFrom: oldInstance variable: variable size: instSize map: map
[
	"Create a new instance of the receiver based on the given old instance.
	The supplied map contains a mapping of the old instVar names into
	the receiver's instVars"

	| new |
	variable
		ifTrue: [ new := self basicNew: oldInstance basicSize ]
		ifFalse: [ new := self basicNew ].
	1 to: instSize do: [ :offset | (map at: offset) > 0
			ifTrue: [ new instVarAt: offset put: (oldInstance instVarAt: (map at: offset)) ] ].
	variable
		ifTrue: [ 1 to: oldInstance basicSize do: [ :offset | new basicAt: offset put: (oldInstance basicAt: offset) ] ].
	^ new
]

TClassDescription >> noteAddedSelector: aSelector meta: isMeta
[
	"A hook allowing some classes to react to adding of certain selectors"

	
]

TClassDescription >> noteChangesFrom: oldMethodDict
[
	^ self explicitRequirement
]

TClassDescription >> noteCompilationOf: aSelector meta: isMeta
[
	"A hook allowing some classes to react to recompilation of certain selectors"

	
]

TClassDescription >> noteMethodAdded: aMethod
[
	SystemAnnouncer uniqueInstance methodAdded: aMethod
]

TClassDescription >> noteMethodChanged: oldMethod to: newMethod
[
	SystemAnnouncer uniqueInstance methodChangedFrom: oldMethod to: newMethod
]

TClassDescription >> noteMethodRemoved: oldMethod
[
	SystemAnnouncer uniqueInstance methodRemoved: oldMethod
]

TClassDescription >> noteRecategorizedSelector: aSymbol from: oldCategoryOrNil to: newCategoryOrNil
[
	| changedCategories |
	changedCategories := self
		updateOrganizationSelector: aSymbol
		oldCategory: oldCategoryOrNil
		newCategory: newCategoryOrNil.
	changedCategories
		do: [ :each | (self organization isEmptyCategoryNamed: each)
				ifTrue: [ self organization removeCategory: each ] ]
]

TClassDescription >> noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition
[
	aCollection
		do: [ :each | | oldCategory newCategory |
			oldCategory := self organization categoryOfElement: each.
			newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.
			self noteRecategorizedSelector: each from: oldCategory to: newCategory ]
]

TClassDescription >> notifyOfRecategorizedSelector: element from: oldCategory to: newCategory
[
	SystemAnnouncer uniqueInstance
		selector: element
		recategorizedFrom: oldCategory
		to: newCategory
		inClass: self.
	SystemAnnouncer uniqueInstance
		suspendAllWhile: [ self notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory ]
]

TClassDescription >> notifyRepackage: selector method: compiledMethod oldProtocol: oldProtocol newProtocol: newProtocol
[
	| oldPackage newPackage |
	newProtocol = oldProtocol
		ifTrue: [ ^ self ].	"This indirection is because we need to abstract RPackage from the kernel"
	#RPackage
		asClassIfPresent: [ :rPackageClass | newPackage := rPackageClass organizer packageForProtocol: newProtocol inClass: self.
			oldPackage := rPackageClass organizer packageForProtocol: oldProtocol inClass: self.	"Announce recategorization"
			newPackage = oldPackage
				ifFalse: [ SystemAnnouncer uniqueInstance methodRepackaged: compiledMethod from: oldPackage to: newPackage ] ].
	SystemAnnouncer uniqueInstance
		selector: selector
		recategorizedFrom: oldProtocol
		to: newProtocol
		inClass: self
]

TClassDescription >> notifyUsersOfChangedSelectors: aCollection
[
	self users do: [ :each | each noteChangedSelectors: aCollection ]
]

TClassDescription >> notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory
[
	self users do: [ :each | each noteRecategorizedSelector: element from: oldCategory to: newCategory ]
]

TClassDescription >> numberOfMethods
[
	"count all methods that are local (not comming from a trait)"

	| num |
	num := self localMethods size.
	^ self isMeta
		ifTrue: [ num ]
		ifFalse: [ num + self class numberOfMethods ]
]

TClassDescription >> obsolete
[
	"Make the receiver obsolete."

	self superclass removeSubclass: self.
	self organization: nil.
	super obsolete
]

TClassDescription >> organization
[
	"Answer the instance of ClassOrganizer that represents the organization 
	of the messages of the receiver."

	self basicOrganization
		ifNil: [ self
				basicOrganization:
					(self isTrait
						ifTrue: [ ClassOrganization new ]
						ifFalse: [ ClassOrganization forClass: self ]) ].
	^ self basicOrganization setSubject: self	"Making sure that subject is set correctly. It should not be necessary."
]

TClassDescription >> organization: aClassOrg
[
	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."

	aClassOrg ifNotNil: [ aClassOrg setSubject: self ].
	self basicOrganization: aClassOrg
]

TClassDescription >> printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod
[
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

	"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream
		cr;
		nextPut: $!.
	aFileStream
		nextChunkPut:
			(String
				streamContents: [ :strm | strm
						nextPutAll: self name;
						nextPutAll: ' methodsFor: ';
						print: category asString.
					(changeStamp ~~ nil and: [ changeStamp size > 0 or: [ priorMethod ~~ nil ] ])
						ifTrue: [ strm
								nextPutAll: ' stamp: ';
								print: changeStamp ].
					priorMethod ~~ nil
						ifTrue: [ strm
								nextPutAll: ' prior: ';
								print: priorMethod sourcePointer ] ])
]

TClassDescription >> printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
[
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."

	| preamble method oldPos newPos sourceFile endPos |
	doPreamble
		ifTrue: [ preamble := self name , ' methodsFor: ' , (self organization categoryOfElement: selector) asString printString ]
		ifFalse: [ preamble := '' ].
	method := self methodDict
		at: selector
		ifAbsent: [ outStream
				nextPutAll: selector;
				cr.
			outStream
				tab;
				nextPutAll: '** ERROR!  THIS SCRIPT IS MISSING ** ' translated;
				cr;
				cr.
			outStream nextPutAll: '  '.
			^ outStream ].
	oldPos := method filePosition.
	sourceFile := SourceFiles at: method fileIndex.
	preamble size > 0
		ifTrue: [ "Copy the preamble"
			outStream copyPreamble: preamble from: sourceFile at: oldPos ]
		ifFalse: [ sourceFile position: oldPos ].	"Copy the method chunk"
	newPos := outStream position.
	outStream copyMethodChunkFrom: sourceFile.
	sourceFile skipSeparators.	"The following chunk may have ]style["
	sourceFile peek == $]
		ifTrue: [ outStream
				cr;
				copyMethodChunkFrom: sourceFile ].
	moveSource
		ifTrue: [ "Set the new method source pointer"
			endPos := outStream position.
			method setSourcePosition: newPos inFile: fileIndex ].
	preamble size > 0
		ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream cr
]

TClassDescription >> printOn: aStream
[
	aStream nextPutAll: self name
]

TClassDescription >> printSubclassesOn: aStream level: level
[
	"As part of the algorithm for printing a description of the receiver, print the
	subclass on the file stream, aStream, indenting level times."

	| subclassNames |
	aStream crtab: level.
	aStream nextPutAll: self name.
	aStream
		space;
		print: self instVarNames.
	self == Class
		ifTrue: [ aStream
				crtab: level + 1;
				nextPutAll: '[ ... all the Metaclasses ... ]'.
			^ self ].
	subclassNames := self subclasses asSortedCollection: [ :c1 :c2 | c1 name <= c2 name ].	"Print subclasses in alphabetical order"
	subclassNames do: [ :subclass | subclass printSubclassesOn: aStream level: level + 1 ]
]

TClassDescription >> putClassCommentToCondensedChangesFile: aFileStream
[
	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."

	| header aStamp aCommentRemoteStr |
	self isMeta
		ifTrue: [ ^ self ].	"bulletproofing only"
	((aCommentRemoteStr := self organization commentRemoteStr) isNil or: [ aCommentRemoteStr sourceFileNumber = 1 ])
		ifTrue: [ ^ self ].
	aFileStream
		cr;
		nextPut: $!.
	header := String
		streamContents: [ :strm | strm
				nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
			(aStamp := self organization commentStamp ifNil: [ '<historical>' ]) storeOn: strm.
			strm nextPutAll: ' prior: 0' ].
	aFileStream nextChunkPut: header.
	aFileStream cr.
	self organization
		classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream)
		stamp: aStamp
]

TClassDescription >> reformatAll
[
	"Reformat all methods in this class"

	self methods do: [ :method | method reformat ]
]

TClassDescription >> removeInstVarNamed: aString
[
	"Remove the argument, aString, as one of the receiver's instance 
	variables. Create an error notification if the argument is not found."

	^ self subclassResponsibility
]

TClassDescription >> removeProtocol: aString
[
	"Remove each of the messages categorized under aString in the method 
	dictionary of the receiver. Then remove the category aString."

	| categoryName |
	categoryName := aString asSymbol.
	(self organization listAtCategoryNamed: categoryName) do: [ :sel | self removeSelector: sel ].
	self organization removeCategory: categoryName
]

TClassDescription >> removeSelector: selector
[
	"Remove the message whose selector is given from the method 
	dictionary of the receiver, if it is there. Answer nil otherwise."

	| priorMethod priorProtocol origin |
	priorMethod := self compiledMethodAt: selector ifAbsent: [ ^ nil ].
	origin := priorMethod origin.
	priorProtocol := self whichCategoryIncludesSelector: selector.
	super removeSelector: selector.
	SystemAnnouncer uniqueInstance
		suspendAllWhile: [ self updateOrganizationSelector: selector oldCategory: priorProtocol newCategory: nil ].
	SystemAnnouncer uniqueInstance
		methodRemoved: priorMethod
		selector: selector
		inProtocol: priorProtocol
		class: self
		origin: origin
]

TClassDescription >> reorganize
[
	"During fileIn, !Rectangle reorganize! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"

	^ self organization
]

TClassDescription >> selectorsInCategory: aName
[
	"Answer a list of the selectors of the receiver that are in category named aName"

	| aColl |
	aColl := Set withAll: (self organization listAtCategoryNamed: aName).
	^ aColl asArray sort
]

TClassDescription >> selectorsInProtocol: aName
[
	"Answer a list of the selectors of the receiver that are in category named aName"

	| aColl |
	aColl := Set withAll: (self organization listAtCategoryNamed: aName).
	^ aColl asArray sort
]

TClassDescription >> selectorsToFileOutCategory: aSymbol
[
	^ self organization listAtCategoryNamed: aSymbol
]

TClassDescription >> sharedPoolOfVarNamed: aString
[
	"Only classes may have shared pools"

	^ nil
]

TClassDescription >> sharedPoolsString
[
	"Answer a string of my shared pool names separated by spaces."

	^ String
		streamContents: [ :stream | self sharedPools
				do: [ :each | stream nextPutAll: (self environment keyAtIdentityValue: each ifAbsent: [ 'private' ]) ]
				separatedBy: [ stream space ] ]
]

TClassDescription >> spaceUsed
[
	^ super spaceUsed + (self hasClassSide
				ifTrue: [ self classSide spaceUsed ]
				ifFalse: [ 0 ])
]

TClassDescription >> storeOn: aStream
[
	"Classes and Metaclasses have global names."

	aStream nextPutAll: self name
]

TClassDescription >> subclassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."

	^ self subclasses do: aBlock
]

TClassDescription >> superclass: aClass methodDictionary: mDict format: fmt
[
	"Basic initialization of the receiver"

	super superclass: aClass methodDictionary: mDict format: fmt.
	self instanceVariables: nil.
	self organization: nil
]

TClassDescription >> theMetaClass
[
	^ self explicitRequirement
]

TClassDescription >> theNonMetaClass
[
	^ self explicitRequirement
]

TClassDescription >> uncategorizedSelectors
[
	^ self selectorsInProtocol: Protocol unclassified
]

TClassDescription >> updateInstances: oldInstances from: oldClass isMeta: isMeta
[
	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary. Return the array of old instances (none of which should be pointed to legally by anyone but the array)."

	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."

	| map variable instSize newInstances |
	oldInstances isEmpty
		ifTrue: [ ^ #() ].	"no instances to convert"
	isMeta
		ifTrue: [ oldInstances size = 1
				ifFalse: [ ^ self error: 'Metaclasses can only have one instance' ].
			self soleInstance class == self
				ifTrue: [ ^ self error: 'Metaclasses can only have one instance' ] ].
	map := self instVarMappingFrom: oldClass.
	variable := self isVariable.
	instSize := self instSize.
	newInstances := Array new: oldInstances size.
	1 to: oldInstances size do: [ :i | newInstances
			at: i
			put: (self
					newInstanceFrom: (oldInstances at: i)
					variable: variable
					size: instSize
					map: map) ].	"Now perform a bulk mutation of old instances into new ones"
	oldInstances elementsExchangeIdentityWith: newInstances.
	^ newInstances	"which are now old"
]

TClassDescription >> updateInstancesFrom: oldClass
[
	"Recreate any existing instances of the argument, oldClass, as instances of 
	the receiver, which is a newly changed class. Permute variables as 
	necessary. Return the array of old instances (none of which should be
	pointed to legally by anyone but the array)."

	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:"

	| oldInstances |
	oldInstances := oldClass allInstances asArray.
	oldInstances := self updateInstances: oldInstances from: oldClass isMeta: self isMeta.
	^ oldInstances	"	| crashingBlock class |	class := Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar := value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock := (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"
]

TClassDescription >> updateOrganizationDescription: each oldCategory: newCategoryOrNil newCategory: oldCategoryOrNil changed: changedCategories
[
	| sel effectiveCategory currentCategory |
	sel := each selector.
	(self includesLocalSelector: sel)
		ifTrue: [ ^ self ].
	currentCategory := self organization categoryOfElement: sel.
	effectiveCategory := each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.
	effectiveCategory
		ifNil: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
			self organization removeElement: sel.
			^ self ].
	(currentCategory isNil or: [ currentCategory == Protocol ambiguous or: [ currentCategory == oldCategoryOrNil ] ])
		ifFalse: [ ^ self ].
	currentCategory ~~ effectiveCategory
		ifTrue: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
			self organization classify: sel under: effectiveCategory suppressIfDefault: false ]
]

TClassDescription >> updateOrganizationDescription: aTraitMethodDescription oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil changedCategories: changedCategories
[
	| sel effectiveCategory currentCategory |
	sel := aTraitMethodDescription selector.
	(self includesLocalSelector: sel)
		ifTrue: [ ^ self ].
	currentCategory := self organization categoryOfElement: sel.
	effectiveCategory := aTraitMethodDescription effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.
	effectiveCategory
		ifNil: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
			^ self organization removeElement: sel ].
	((currentCategory isNil or: [ currentCategory == Protocol ambiguous or: [ currentCategory == oldCategoryOrNil ] ])
		and: [ currentCategory ~~ effectiveCategory ])
		ifTrue: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
			self organization classify: sel under: effectiveCategory suppressIfDefault: false ]
]

TClassDescription >> updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil
[
	^ self explicitRequirement
]

TClassDescription >> usesLocalPoolVarNamed: aString
[
	^ false
]

TClassDescription >> usesPoolVarNamed: aString
[
	"Only classes may use a pool variable named: aString"

	^ false
]

TClassDescription >> wantsChangeSetLogging
[
	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism."

	^ true
]

TClassDescription >> wantsRecompilationProgressReported
[
	"Answer whether the receiver would like progress of its recompilation reported interactively to the user."

	^ true
]

TClassDescription >> whichCategoryIncludesSelector: aSelector
[
	"Answer the category of the argument, aSelector, in the organization of 
	the receiver, or answer nil if the receiver does not inlcude this selector."

	(self includesSelector: aSelector)
		ifTrue: [ ^ self organization categoryOfElement: aSelector ]
		ifFalse: [ ^ nil ]
]

TClassDescription >> zapOrganization
[
	"Remove the organization of this class by message categories.
	This is typically done to save space in small systems.  Classes and methods
	created or filed in subsequently will, nonetheless, be organized"

	self organization: nil.
	self isClassSide
		ifFalse: [ self classSide zapOrganization ]
]

