SqNumberParser
	superclass: #NumberParser;
	package: #'Kernel-Numbers'.

SqNumberParser >> allowPlusSign
[
	"return a boolean indicating if plus sign is allowed or not"

	^ false
]

SqNumberParser >> exponentLetters
[
	"answer the list of possible exponents for Numbers.
	Note: this parser will not honour precision attached to the exponent.
	different exponent do not lead to different precisions.
	only IEEE 754 floating point numbers will be created"

	^ 'edq'
]

SqNumberParser >> makeIntegerOrScaledInteger
[
	"at this point, there is no digit, nor fractionPart.
	maybe it can be a scaled decimal with fraction omitted..."

	neg
		ifTrue: [ integerPart := integerPart negated ].
	self readExponent
		ifTrue: [ ^ integerPart * (base raisedToInteger: exponent) ].
	self readScale
		ifTrue: [ ^ integerPart asScaledDecimal: scale ].
	^ integerPart
]

SqNumberParser >> nextInteger
[
	"Main method for reading an Integer.
	This won't try to read a Float nor a ScaledDecimal."

	| numberOfTrailingZeroInIntegerPart |
	base := 10.
	neg := self peekSignIsMinus.
	integerPart := self nextUnsignedIntegerOrNilBase: base.
	integerPart ifNil: [ self fail ].
	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.
	(sourceStream peekFor: $r)
		ifTrue: [ | oldNeg "<base>r<integer>" pos |
			pos := sourceStream position.
			(base := integerPart) < 2
				ifTrue: [ "A radix currently need to be greater than 1, ungobble the r and return the integer part"
					sourceStream skip: -1.
					^ neg
						ifTrue: [ base negated ]
						ifFalse: [ base ] ].
			oldNeg := neg.
			self peekSignIsMinus
				ifTrue: [ neg := neg not ].
			integerPart := self nextUnsignedIntegerOrNilBase: base.
			integerPart ifNil: [ self fail ].
			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero ].
	neg
		ifTrue: [ integerPart := integerPart negated ].
	self readExponent
		ifTrue: [ ^ integerPart * (base raisedToInteger: exponent) ].
	^ integerPart
]

SqNumberParser >> nextNumber
[
	"main method for reading a number.
	This one can read Float Integer and ScaledDecimal"

	| numberOfTrailingZeroInIntegerPart |
	base := 10.
	neg := self peekSignIsMinus.
	integerPart := self nextUnsignedIntegerOrNilBase: base.
	integerPart
		ifNil: [ 
			"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"
			^ self readNamedFloatOrFail ].
	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.
	(sourceStream peekFor: $r)
		ifTrue: [ "<base>r<integer>"
			(base := integerPart) < 2
				ifTrue: [ sourceStream skip: -1.
					^ self expected: 'an integer greater than 1 as valid radix' ].
			self peekSignIsMinus
				ifTrue: [ neg := neg not ].
			integerPart := self nextUnsignedIntegerBase: base.
			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero ].
	^ (sourceStream peekFor: $.)
		ifTrue: [ self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart ]
		ifFalse: [ self makeIntegerOrScaledInteger ]
]

SqNumberParser >> nextNumberBase: b
[
	"Method for reading a number without radix prefix.
	This one can read Float Integer and ScaledDecimal"

	| numberOfTrailingZeroInIntegerPart |
	base := b.
	neg := sourceStream peekFor: $-.
	integerPart := self nextUnsignedIntegerOrNilBase: base.
	integerPart
		ifNil: [ 
			"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"
			^ self readNamedFloatOrFail ].
	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.
	^ (sourceStream peekFor: $.)
		ifTrue: [ self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart ]
		ifFalse: [ self makeIntegerOrScaledInteger ]
]

SqNumberParser >> nextScaledDecimal
[
	"Main method for reading a (scaled) decimal number.
	Good Gracious, do not accept a decimal in another base than 10!
	In other words, do not accept radix notation like 2r1.1, even not 10r5.3
	Do not accept exponent notation neither, like 1.0e-3"

	| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart |
	base := 10.
	neg := sourceStream peekFor: $-.
	integerPart := self nextUnsignedIntegerBase: base.
	(sourceStream peekFor: $.)
		ifTrue: [ fractionPart := self nextUnsignedIntegerOrNilBase: base.
			fractionPart
				ifNil: [ "Oops, the decimal point seems not part of this number"
					sourceStream skip: -1.
					^ neg
						ifTrue: [ integerPart negated asScaledDecimal: 0 ]
						ifFalse: [ integerPart asScaledDecimal: 0 ] ].
			numberOfNonZeroFractionDigits := lastNonZero.
			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.
			self readScale
				ifFalse: [ "No scale were provided. use number of digits after decimal point as scale"
					scale := nDigits ].
			^ self
				makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits
				andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart ].
	self readScale.
	neg
		ifTrue: [ integerPart := integerPart negated ].
	^ integerPart asScaledDecimal: scale
]

SqNumberParser >> readNamedFloatOrFail
[
	"This method is used when there is no digit encountered:
	It try and read a named Float NaN or Infinity.
	Negative sign for -Infinity has been read before sending this method, and is indicated in the neg inst.var.
	Fail if no named Float is found"

	neg
		ifFalse: [ (sourceStream nextMatchAll: 'NaN')
				ifTrue: [ ^ Float nan ] ].
	(sourceStream nextMatchAll: 'Infinity')
		ifTrue: [ ^ neg
				ifTrue: [ Float infinity negated ]
				ifFalse: [ Float infinity ] ].
	^ self expected: 'a digit between 0 and ' , (String with: (Character digitValue: base - 1))
]

SqNumberParser >> readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart
[
	"at this stage, sign integerPart and a decimal point have been read.
	try and form a number with a fractionPart"

	| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart mantissa value |
	fractionPart := self nextUnsignedIntegerOrNilBase: base.
	fractionPart
		ifNil: [ "No fractionPart found,ungobble the decimal point and return the integerPart"
			sourceStream skip: -1.
			^ neg
				ifTrue: [ integerPart negated ]
				ifFalse: [ integerPart ] ].
	numberOfNonZeroFractionDigits := lastNonZero.
	numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.
	self readExponent
		ifFalse: [ self readScale
				ifTrue: [ ^ self
						makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits
						andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart ] ].
	fractionPart isZero
		ifTrue: [ mantissa := integerPart // (base raisedToInteger: numberOfTrailingZeroInIntegerPart).
			exponent := exponent + numberOfTrailingZeroInIntegerPart ]
		ifFalse: [ mantissa := integerPart * (base raisedToInteger: numberOfNonZeroFractionDigits)
				+ (fractionPart // (base raisedToInteger: numberOfTrailingZeroInFractionPart)).
			exponent := exponent - numberOfNonZeroFractionDigits ].
	value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.
	^ neg
		ifTrue: [ value isZero
				ifTrue: [ Float negativeZero ]
				ifFalse: [ value negated ] ]
		ifFalse: [ value ]
]

SqNumberParser >> readScale
[
	"read the scale if any (stored in instVar).
	Answer true if found, answer false if none.
	If scale letter is not followed by a digit, this is not considered as an error.
	Scales are always read in base 10, though i do not see why..."

	scale := 0.
	sourceStream atEnd
		ifTrue: [ ^ false ].
	(sourceStream peekFor: $s)
		ifFalse: [ ^ false ].
	scale := self nextUnsignedIntegerOrNilBase: 10.
	scale ifNil: [ scale := 0.
			sourceStream skip: -1.	"ungobble the s"
			^ false ].
	^ true
]

