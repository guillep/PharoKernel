ExtendedNumberParser
	superclass: #SqNumberParser;
	package: #'Kernel-Numbers'.

ExtendedNumberParser >> allowPlusSign
[
	^ true
]

ExtendedNumberParser >> nextInteger
[
	"Main method for reading an Integer.
	This won't try to read a Float nor a ScaledDecimal."

	| numberOfTrailingZeroInIntegerPart |
	base := 10.
	neg := self peekSignIsMinus.
	integerPart := self nextUnsignedIntegerOrNilBase: base.
	integerPart ifNil: [ self fail ].
	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.
	(sourceStream peekFor: $r)
		ifTrue: [ | oldNeg "<base>r<integer>" pos |
			pos := sourceStream position.
			(base := integerPart) < 2
				ifTrue: [ "A radix currently need to be greater than 1, ungobble the r and return the integer part"
					sourceStream skip: -1.
					^ neg
						ifTrue: [ base negated ]
						ifFalse: [ base ] ].
			oldNeg := neg.
			self peekSignIsMinus
				ifTrue: [ neg := neg not ].
			integerPart := self nextUnsignedIntegerOrNilBase: base.
			integerPart ifNil: [ self fail ].
			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero ].
	neg
		ifTrue: [ integerPart := integerPart negated ].
	self readExponent
		ifTrue: [ ^ integerPart * (base raisedToInteger: exponent) ].
	^ integerPart
]

ExtendedNumberParser >> nextNumber
[
	"main method for reading a number.
	This one can read Float Integer and ScaledDecimal"

	| numberOfTrailingZeroInIntegerPart |
	base := 10.
	neg := self peekSignIsMinus.
	integerPart := self nextUnsignedIntegerOrNilBase: base.
	integerPart
		ifNil: [ 
			(sourceStream peekFor: $.)
				ifTrue: [ "Try .1 syntax"
					^ self readNumberWithoutIntegerPart ]
				ifFalse: [ 
					"This is not a regular number beginning with a digit			It is time to check for exceptional condition NaN and Infinity"
					^ self readNamedFloatOrFail ] ].
	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.
	(sourceStream peekFor: $r)
		ifTrue: [ | oldNeg "<base>r<integer>" pos |
			pos := sourceStream position.
			(base := integerPart) < 2
				ifTrue: [ "A radix currently need to be greater than 1, ungobble the r and return the integer part"
					sourceStream skip: -1.
					^ neg
						ifTrue: [ base negated ]
						ifFalse: [ base ] ].
			oldNeg := neg.
			self peekSignIsMinus
				ifTrue: [ neg := neg not ].
			integerPart := self nextUnsignedIntegerOrNilBase: base.
			integerPart
				ifNil: [ (sourceStream peekFor: $.)
						ifTrue: [ self readNumberWithoutIntegerPartOrNil ifNotNil: [ :aNumber | ^ aNumber ] ].
					sourceStream position: pos.
					^ oldNeg
						ifTrue: [ base negated ]
						ifFalse: [ base ] ].
			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero ].
	^ (sourceStream peekFor: $.)
		ifTrue: [ self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart ]
		ifFalse: [ self makeIntegerOrScaledInteger ]
]

ExtendedNumberParser >> readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart
[
	"at this stage, sign integerPart and a decimal point have been read.
	try and form a number with a fractionPart"

	| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart mantissa value |
	fractionPart := self nextUnsignedIntegerOrNilBase: base.
	fractionPart
		ifNil: [ "No fractionPart found, but can be a 1.e2 syntax"
			fractionPart := 0.
			numberOfNonZeroFractionDigits := 0.
			numberOfTrailingZeroInFractionPart := 0 ]
		ifNotNil: [ numberOfNonZeroFractionDigits := lastNonZero.
			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero ].
	self readExponent
		ifFalse: [ self readScale
				ifTrue: [ ^ self
						makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits
						andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart ] ].
	fractionPart isZero
		ifTrue: [ mantissa := integerPart // (base raisedToInteger: numberOfTrailingZeroInIntegerPart).
			exponent := exponent + numberOfTrailingZeroInIntegerPart ]
		ifFalse: [ mantissa := integerPart * (base raisedToInteger: numberOfNonZeroFractionDigits)
				+ (fractionPart // (base raisedToInteger: numberOfTrailingZeroInFractionPart)).
			exponent := exponent - numberOfNonZeroFractionDigits ].
	value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.
	^ neg
		ifTrue: [ value isZero
				ifTrue: [ Float negativeZero ]
				ifFalse: [ value negated ] ]
		ifFalse: [ value ]
]

ExtendedNumberParser >> readNumberWithoutIntegerPart
[
	"at this stage, sign followed by a decimal point have been read, but no intergerPart
	try and form a number with a fractionPart"

	^ self readNumberWithoutIntegerPartOrNil
		ifNil: [ "No integer part, no fractionPart, this does not look like a number..."
			^ self expected: 'a digit between 0 and 9' ]
]

ExtendedNumberParser >> readNumberWithoutIntegerPartOrNil
[
	"at this stage, sign followed by a decimal point have been read, but no intergerPart
	try and form a number with a fractionPart"

	| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart mantissa value |
	integerPart := 0.
	fractionPart := self nextUnsignedIntegerOrNilBase: base.
	fractionPart ifNil: [ "No integer part, no fractionPart, this does not look like a number..."
			^ nil ].
	numberOfNonZeroFractionDigits := lastNonZero.
	numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.
	self readExponent
		ifFalse: [ self readScale
				ifTrue: [ ^ self
						makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits
						andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart ] ].
	fractionPart isZero
		ifTrue: [ mantissa := 0 ]
		ifFalse: [ mantissa := fractionPart // (base raisedToInteger: numberOfTrailingZeroInFractionPart).
			exponent := exponent - numberOfNonZeroFractionDigits ].
	value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.
	^ neg
		ifTrue: [ value isZero
				ifTrue: [ Float negativeZero ]
				ifFalse: [ value negated ] ]
		ifFalse: [ value ]
]

