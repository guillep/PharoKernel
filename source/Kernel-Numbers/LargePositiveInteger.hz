Class
	name: #LargePositiveInteger;
	superclass: #ClassInteger;
	instanceSpecification: #(#variable #byte );
	instanceVariables: #();
	classVariables: #();
	package: #'Kernel-Numbers'.

Class LargePositiveInteger >> * anInteger
[
	"Primitive. Multiply the receiver by the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "
	<primitive: 29>
^ super * anInteger
]

Class LargePositiveInteger >> + anInteger
[
	"Primitive. Add the receiver to the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."
	<primitive: 21>
^ super + anInteger
]

Class LargePositiveInteger >> - anInteger
[
	"Primitive. Subtract the argument from the receiver and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."
	<primitive: 22>
^ super - anInteger
]

Class LargePositiveInteger >> / anInteger
[
	"Primitive. Divide the receiver by the argument and answer with the	result if the division is exact. Fail if the result is not a whole integer.	Fail if the argument is 0. Fail if either the argument or the result is not	a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "
	<primitive: 30>
^ super / anInteger
]

Class LargePositiveInteger >> // anInteger
[
	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards negative infinity to make it a whole	integer. Fail if the argument is 0. Fail if either the argument or the	result is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive. "
	<primitive: 32>
^ super // anInteger
]

Class LargePositiveInteger >> < anInteger
[
	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive."
	<primitive: 23>
^ super < anInteger
]

Class LargePositiveInteger >> <= anInteger
[
	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger or a LargePositiveInteger less	than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."
	<primitive: 25>
^ super <= anInteger
]

Class LargePositiveInteger >> > anInteger
[
	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."
	<primitive: 24>
^ super > anInteger
]

Class LargePositiveInteger >> >= anInteger
[
	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger or a LargePositiveInteger	less than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."
	<primitive: 26>
^ super >= anInteger
]

Class LargePositiveInteger >> \\ anInteger
[
	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided	by the argument. Fail if the argument is 0. Fail if either the argument	or the result is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."
	<primitive: 31>
^ super \\ anInteger
]

Class LargePositiveInteger >> \\\ anInteger
[
	"a faster modulo method for use in DSA. Be careful if you try to use this elsewhere"
^ (self digitDiv: anInteger neg: false) second
]

Class LargePositiveInteger >> abs
[

]

Class LargePositiveInteger >> as31BitSmallInt
[
	"This is only for 31 bit numbers.  Keep my 31 bits the same, but put them in a small int.  The small int will be negative since my 31st bit is 1.  We know my 31st bit is 1 because otherwise I would already be a positive small int."
self highBit = 31	ifFalse: [ self error: 'more than 31 bits can not fit in a SmallInteger' ].^ self - 16r80000000
]

Class LargePositiveInteger >> asFloat
[
	"Answer a Float that best approximates the value of the receiver.	This algorithm is optimized to process only the significant digits of a LargeInteger.	And it does honour IEEE 754 round to nearest even mode in case of excess precision (see details below)."
	"How numbers are rounded in IEEE 754 default rounding mode:	A shift is applied so that the highest 53 bits are placed before the floating point to form a mantissa.	The trailing bits form the fraction part placed after the floating point.	This fractional number must be rounded to the nearest integer.	If fraction part is 2r0.1, exactly between two consecutive integers, there is a tie.	The nearest even integer is chosen in this case.	Examples (First 52bits of mantissa are omitted for brevity):	2r0.00001 is rounded downward to 2r0	2r1.00001 is rounded downward to 2r1	2r0.1 is a tie and rounded to 2r0 (nearest even)	2r1.1 is a tie and rounded to 2r10 (nearest even)	2r0.10001 is rounded upward to 2r1	2r1.10001 is rounded upward to 2r10	Thus, if the next bit after floating point is 0, the mantissa is left unchanged.	If next bit after floating point is 1, an odd mantissa is always rounded upper.	An even mantissa is rounded upper only if the fraction part is not a tie."
	"Algorihm details:	Floating point hardware will correctly handle the rounding by itself with a single inexact operation if mantissa has one excess bit of precision.	Except in the last case when extra bits are present after an even mantissa, we must round upper by ourselves.	Note 1: the inexact flag in floating point hardware must not be trusted because it won't take into account the bits we truncated by ourselves.	Note 2: the floating point hardware is presumed configured in default rounding mode."
| mantissa shift sum excess |"Check how many bits excess the maximum precision of a Float mantissa."excess := self highBitOfMagnitude - Float precision.excess > 1	ifTrue: [ 		"Remove the excess bits but one."		mantissa := self bitShift: 1 - excess.		shift := excess - 1.	"Handle the case of extra bits truncated after an even mantissa."		((mantissa bitAnd: 2r11) = 2r01 and: [ self anyBitOfMagnitudeFrom: 1 to: shift ])			ifTrue: [ mantissa := mantissa + 1 ] ]	ifFalse: [ 		mantissa := self.		shift := 0 ].	"Now that mantissa has at most 1 excess bit of precision, let floating point operations perform the final rounding."sum := 0.0.1 to: mantissa digitLength do: [ :byteIndex | 	sum := sum + ((mantissa digitAt: byteIndex) asFloat timesTwoPower: shift).	shift := shift + 8 ].^ sum
]

Class LargePositiveInteger >> bitAt: anInteger
[
	"Optimize super algorithm to avoid long bit operations.	Instead work on digits which are known to be SmallInteger and fast.	Note that this algorithm does not work for negative integers."
| digitIndex bitIndex |digitIndex := (anInteger - 1) // 8 + 1.digitIndex > self digitLength	ifTrue: [ ^ 0 ].bitIndex := (anInteger - 1) \\ 8 + 1.^ (self digitAt: digitIndex) bitAt: bitIndex
]

Class LargePositiveInteger >> digitAt: index
[
	"Primitive. Answer the value of an indexable field in the receiver.   LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds. Essential.  See Object documentation whatIsAPrimitive."
	<primitive: 60>
self digitLength < index	ifTrue: [ ^ 0 ]	ifFalse: [ ^ super at: index ]
]

Class LargePositiveInteger >> digitAt: index put: value
[
	"Primitive. Store the second argument (value) in the indexable field of 	the receiver indicated by index. Fail if the value is negative or is larger 	than 255. Fail if the index is not an Integer or is out of bounds. Answer 	the value that was stored. Essential. See Object documentation 	whatIsAPrimitive."
	<primitive: 61>
^ super at: index put: value
]

Class LargePositiveInteger >> digitLength
[
	"Primitive. Answer the number of indexable fields in the receiver. This 	value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."
	<primitive: 62>
self primitiveFailed
]

Class LargePositiveInteger >> hash
[
^ ByteArray hashBytes: self startingWith: self species hash
]

Class LargePositiveInteger >> hashMultiply
[
	"Truncate to 28 bits and try again"
^ (self bitAnd: 16rFFFFFFF) hashMultiply
]

Class LargePositiveInteger >> highBit
[
	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."
^ self highBitOfMagnitude
]

Class LargePositiveInteger >> highBitOfMagnitude
[
	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero.  	This method is used for LargeNegativeIntegers as well,  	since LargeIntegers are sign/magnitude."
| realLength lastDigit |realLength := self digitLength.[ (lastDigit := self digitAt: realLength) = 0 ]	whileTrue: [ 		(realLength := realLength - 1) = 0			ifTrue: [ ^ 0 ] ].^ lastDigit highBitOfPositiveReceiver + (8 * (realLength - 1))
]

Class LargePositiveInteger >> isLarge
[
^ true
]

Class LargePositiveInteger >> isPrime
[
	"Answer true if the receiver is a prime number. Use a probabilistic implementation	 that	is much faster for large integers, and that is correct to an extremely high statistical	level of confidence (effectively deterministic)."
^ self isProbablyPrime
]

Class LargePositiveInteger >> ln
[
	"This function is defined because super ln might overflow."
| res h |res := super ln.res isFinite	ifTrue: [ ^ res ].h := self highBit.^ 2 ln * h + (self / (1 << h)) asFloat ln
]

Class LargePositiveInteger >> log
[
	"This function is defined because super log might overflow."
| res h |res := super log.res isFinite	ifTrue: [ ^ res ].h := self highBit.^ 2 log * h + (self / (1 << h)) asFloat log
]

Class LargePositiveInteger >> mightBeASquare
[
	"In base 16, a square number can end only with 0,1,4 or 9 and	- in case 0, only 0,1,4,9 can precede it,	- in case 4, only even numbers can precede it.	See http://en.wikipedia.org/wiki/Square_number	So, in hex, the last byte must be one of:		00		10		40		90		x1		e4		x9	where x is any hex digit and e is any even digit	Also, the receiver must be an aven power of two."
| lsb |lsb := self digitAt: 1.^ (lsb = 0 and: [ self lowBit odd ])	or: [ 		lsb = 16r40			or: [ (lsb bitAnd: 16r7) = 1 or: [ (lsb bitAnd: 16r1F) = 4 or: [ (lsb bitAnd: 16r7F) = 16 ]	"even|4" ]	"any|1 or any|9" ]	"40" ]	"00 (and even power of 2)"	"10 or 90"
]

Class LargePositiveInteger >> negated
[
^ (self copyto: (LargeNegativeInteger new: self digitLength)) normalize	"Need to normalize to catch SmallInteger minVal"
]

Class LargePositiveInteger >> negative
[
	"Answer whether the receiver is mathematically negative."
^ false
]

Class LargePositiveInteger >> normalize
[
	"Check for leading zeroes and return shortened copy if so"
	<primitive: 'primNormalizePositive' module: 'LargeIntegers'>
| sLen val len oldLen |len := oldLen := self digitLength.	"First establish len = significant length"[ len = 0	ifTrue: [ ^ 0 ].(self digitAt: len) = 0 ] whileTrue: [ len := len - 1 ].	"Now check if in SmallInteger range"sLen := SmallInteger maxVal digitLength.(len <= sLen and: [ (self digitAt: sLen) <= (SmallInteger maxVal digitAt: sLen) ])	ifTrue: [ 		"If so, return its SmallInt value"		val := 0.		len to: 1 by: -1 do: [ :i | val := val * 256 + (self digitAt: i) ].		^ val ].	"Return self, or a shortened copy"len < oldLen	ifTrue: [ ^ self growto: len ]	ifFalse: [ ^ self ]
]

Class LargePositiveInteger >> positive
[
	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"
^ true
]

Class LargePositiveInteger >> printOn: aStream base: b
[
	"Append a representation of this number in base b on aStream.	In order to reduce cost of LargePositiveInteger ops, split the number in approximately two equal parts in number of digits."
| halfDigits halfPower head tail nDigitsUnderestimate |"Don't engage any arithmetic if not normalized"(self digitLength = 0 or: [ (self digitAt: self digitLength) = 0 ])	ifTrue: [ ^ self normalize printOn: aStream base: b ].nDigitsUnderestimate := b = 10	ifTrue: [ ((self highBit - 1) * 1233 >> 12) + 1	"This is because (2 log)/(10 log)*4096 is slightly greater than 1233" ]	ifFalse: [ self highBit quo: b highBit ].	"splitting digits with a whole power of two is more efficient"halfDigits := 1 bitShift: nDigitsUnderestimate highBit - 2.halfDigits <= 1	ifTrue: [ 		"Hmmm, this could happen only in case of a huge base b... Let lower level fail"		^ self printOn: aStream base: b nDigits: (self numberOfDigitsInBase: b) ].	"Separate in two halves, head and tail"halfPower := b raisedToInteger: halfDigits.head := self quo: halfPower.tail := self - (head * halfPower).	"print head"head printOn: aStream base: b.	"print tail without the overhead to count the digits"tail printOn: aStream base: b nDigits: halfDigits
]

Class LargePositiveInteger >> printOn: aStream base: b nDigits: n
[
	"Append a representation of this number in base b on aStream using n digits.	In order to reduce cost of LargePositiveInteger ops, split the number of digts approximatily in two	Should be invoked with: 0 <= self < (b raisedToInteger: n)"
| halfPower half head tail |n <= 1	ifTrue: [ 		n <= 0			ifTrue: [ self error: 'Number of digits n should be > 0' ].	"Note: this is to stop an infinite loop if one ever attempts to print with a huge base		This can happen because choice was to not hardcode any limit for base b		We let Character>>#digitValue: fail"		^ aStream nextPut: (Character digitValue: self) ].halfPower := n bitShift: -1.half := b raisedToInteger: halfPower.head := self quo: half.tail := self - (head * half).head printOn: aStream base: b nDigits: n - halfPower.tail printOn: aStream base: b nDigits: halfPower
]

Class LargePositiveInteger >> quo: anInteger
[
	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards zero to make it a whole integer. Fail if	the argument is 0. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."
	<primitive: 33>
^ super quo: anInteger
]

Class LargePositiveInteger >> replaceFrom: start to: stop with: replacement startingAt: repStart
[
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."
	<primitive: 105>
^ super	replaceFrom: start	to: stop	with: replacement	startingAt: repStart
]

Class LargePositiveInteger >> sign
[
	"Optimization. Answer 1 since receiver is greater than 0."
^ 1
]

Class LargePositiveInteger >> sqrt
[
	"If we know for sure no exact solution exists, then just answer the cheap float approximation without wasting time."
| selfAsFloat |self mightBeASquare	ifFalse: [ 		selfAsFloat := self asFloat.		selfAsFloat isFinite			ifTrue: [ ^ self asFloat sqrt ] ].	"If some exact solution might exist, or self asFloat isInfinite, call potentially expensive super"^ super sqrt
]

Class LargePositiveInteger >> sqrtFloor
[
	"Return the integer part of the square root of self"
| powerOfTwo |(powerOfTwo := (self lowBit - 1) // 2) > 1	ifFalse: [ ^ super sqrtFloor ].^ (self bitShift: -2 * powerOfTwo) sqrtFloor bitShift: powerOfTwo
]

Class LargePositiveInteger >> strictlyPositive
[
	"Answer whether the receiver is mathematically positive."
^ true
]

Class LargePositiveInteger >> withAtLeastNDigits: desiredLength
[
| new |self size >= desiredLength	ifTrue: [ ^ self ].new := self class new: desiredLength.new	replaceFrom: 1	to: self size	with: self	startingAt: 1.^ new
]

Metaclass
	name: #LargePositiveInteger;
	instanceVariables: #().

