ContextPart
	superclass: #InstructionStream;
	instanceVariables: #(#stackp );
	classVariables: #(#QuickStep #PrimitiveFailToken #SpecialPrimitiveSimulators #TryNamedPrimitiveTemplateMethod );
	package: #Kernel.

ContextPart >> activateMethod: newMethod withArgs: args receiver: rcvr class: class
[activateMethod: newMethod withArgs: args receiver: rcvr class: class
	"Answer a ContextPart initialized with the arguments."

	^ MethodContext
		sender: self
		receiver: rcvr
		method: newMethod
		arguments: args
]

ContextPart >> activateReturn: aContext value: value
[activateReturn: aContext value: value
	"Activate 'aContext return: value' in place of self, so execution will return to aContext's sender"

	^ self
		activateMethod: ContextPart theReturnMethod
		withArgs: {value}
		receiver: aContext
		class: aContext class
]

ContextPart >> arguments
[arguments
	"returns the arguments of a message invocation"

	| arguments numargs |
	numargs := self method numArgs.
	arguments := Array new: numargs.
	1 to: numargs do: [ :i | arguments at: i put: (self tempAt: i) ].
	^ arguments
]

ContextPart >> at: index
[at: index
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not an
	 Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 210>
	index isInteger
		ifTrue: [ self errorSubscriptBounds: index ].
	index isNumber
		ifTrue: [ ^ self at: index asInteger ]
		ifFalse: [ self errorNonIntegerIndex ]
]

ContextPart >> at: index put: value
[at: index put: value
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not
	 an Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 211>
	index isInteger
		ifTrue: [ self errorSubscriptBounds: index ].
	index isNumber
		ifTrue: [ ^ self at: index asInteger put: value ]
		ifFalse: [ self errorNonIntegerIndex ]
]

ContextPart >> basicAt: index
[basicAt: index
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not an
	 Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 210>
	index isInteger
		ifTrue: [ self errorSubscriptBounds: index ].
	index isNumber
		ifTrue: [ ^ self at: index asInteger ]
		ifFalse: [ self errorNonIntegerIndex ]
]

ContextPart >> basicAt: index put: value
[basicAt: index put: value
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not
	 an Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 211>
	index isInteger
		ifTrue: [ self errorSubscriptBounds: index ].
	index isNumber
		ifTrue: [ ^ self at: index asInteger put: value ]
		ifFalse: [ self errorNonIntegerIndex ]
]

ContextPart >> basicSize
[basicSize
	"Primitive. Answer the number of indexable variables in the receiver. 
	This value is the same as the largest legal subscript. Essential. Do not 
	override in any subclass. See Object documentation whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	"The number of indexable fields of fixed-length objects is 0"

	<primitive: 212>
	^ self primitiveFail
]

ContextPart >> bottomContext
[bottomContext
	"Return the last context (the first context invoked) in my sender chain"

	^ self findContextSuchThat: [ :context | context sender isNil ]
]

ContextPart >> canHandleSignal: exception
[canHandleSignal: exception
	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then return true, otherwise forward this message to the next handler context.  If none left, return false (see nil>>canHandleSignal:)"

	^ ((self exceptionClass handles: exception) and: [ self exceptionHandlerIsActive ])
		or: [ self nextHandlerContext canHandleSignal: exception ]
]

ContextPart >> cannotReturn: result to: homeContext
[cannotReturn: result to: homeContext
	"The receiver tried to return result to homeContext that no longer exists."

	^ BlockCannotReturn new
		result: result;
		deadHome: homeContext;
		signal
]

ContextPart >> client
[client
	"Answer the client, that is, the object that sent the message that created this context."

	^ sender receiver
]

ContextPart >> closureCopy: numArgs copiedValues: anArray
[closureCopy: numArgs copiedValues: anArray
	"Distinguish a block of code from its enclosing method by 
	creating a BlockClosure for that block. The compiler inserts into all 
	methods that contain blocks the bytecodes to send the message 
	closureCopy:copiedValues:. Do not use closureCopy:copiedValues: in code that you write! Only the 
	compiler can decide to send the message closureCopy:copiedValues:. Fail if numArgs is 
	not a SmallInteger. Optional. No Lookup. See Object documentation 
	whatIsAPrimitive."

	<primitive: 200>
	^ BlockClosure
		outerContext: self
		startpc: pc + 2
		numArgs: numArgs
		copiedValues: anArray
]

ContextPart >> completeCallee: aContext
[completeCallee: aContext
	"Simulate the execution of bytecodes until a return to the receiver."

	| context current nextContext |
	context := aContext.
	[ context == current or: [ context hasSender: self ] ]
		whileTrue: [ current := context.
			nextContext := context quickStep.
			nextContext ifNil: [ self halt ].
			context := nextContext ].
	^ self stepToSendOrReturn
]

ContextPart >> contextStack
[contextStack
	"Answer an Array of the contexts on the receiver's sender chain."

	^ self stackOfSize: 100000
]

ContextPart >> copyStack
[copyStack
	^ self copyTo: nil
]

ContextPart >> copyTo: aContext
[copyTo: aContext
	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home.  It is best to use BlockClosures instead.  They only hold a ContextTag, which will work for all copies of the original home context."

	^ self copyTo: aContext blocks: IdentityDictionary new
]

ContextPart >> copyTo: aContext blocks: dict
[copyTo: aContext blocks: dict
	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home."

	| copy |
	self == aContext
		ifTrue: [ ^ nil ].
	copy := self copy.
	dict at: self ifPresent: [ :blocks | blocks do: [ :block | block privHome: copy ] ].
	self sender ifNotNil: [ copy privSender: (self sender copyTo: aContext blocks: dict) ].
	^ copy
]

ContextPart >> cut: aContext
[cut: aContext
	"Cut aContext and its senders from my sender chain"

	| context callee |
	context := self.
	[ context == aContext ]
		whileFalse: [ callee := context.
			context := context sender.
			context ifNil: [ aContext ifNotNil: [ self error: 'aContext not a sender' ] ] ].
	callee privSender: nil
]

ContextPart >> debug
[debug
	^ Smalltalk tools debugger openContext: self label: self printString contents: nil
]

ContextPart >> debugStack: stackSize on: aStream
[debugStack: stackSize on: aStream
	"print a condensed version of the stack up to stackSize on aStream"

	(self stackOfSize: stackSize) do: [ :item | item printDebugOn: aStream.
			aStream cr ]
]

ContextPart >> debugStackOn: aStream
[debugStackOn: aStream
	"print the top ten contexts on my sender chain."

	^ self debugStack: 100 on: aStream
]

ContextPart >> depthBelow: aContext
[depthBelow: aContext
	"Answer how many calls there are between this and aContext."

	| context depth |
	context := self.
	depth := 0.
	[ context == aContext or: [ context == nil ] ] whileFalse: [ context := context sender.
			depth := depth + 1 ].
	^ depth
]

ContextPart >> doDup
[doDup
	"Simulate the action of a 'duplicate top of stack' bytecode."

	self push: self top
]

ContextPart >> doPop
[doPop
	"Simulate the action of a 'remove top of stack' bytecode."

	self pop
]

ContextPart >> doPrimitive: primitiveIndex method: method receiver: receiver args: arguments
[doPrimitive: primitiveIndex method: method receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex. The simulated receiver and arguments are given as arguments to this message. Any primitive which provikes execution needs to be intercepted and simulated to avoid execution running away."

	<primitive: 19>
	| value |
	primitiveIndex = 83
		ifTrue: [ ^ self
				send: arguments first
				to: receiver
				with: arguments allButFirst
				super: false ].	"Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	"	(primitiveIndex = 19) ifTrue:		[Smalltalk tools debugger			openContext: self			label:'Code simulation error'			contents: nil]."	"Object>>perform:[with:...]"
	primitiveIndex = 84
		ifTrue: [ ^ self
				send: arguments first
				to: receiver
				with: (arguments at: 2)
				super: false ].	"Object>>perform:withArguments:"
	primitiveIndex = 188
		ifTrue: [ arguments size = 2
				ifTrue: [ "Object>>withArgs:executeMethod:"
					^ MethodContext
						sender: self
						receiver: receiver
						method: (arguments at: 2)
						arguments: (arguments at: 1) ].
			arguments size = 3
				ifTrue: [ "CompiledMethod class >> #receiver:withArguments:executeMethod:"
					^ MethodContext
						sender: self
						receiver: (arguments at: 1)
						method: (arguments at: 3)
						arguments: (arguments at: 2) ] ].
	primitiveIndex = 189
		ifTrue: [ "Object >> (#with:)*executeMethod"
			^ MethodContext
				sender: self
				receiver: receiver
				method: arguments last
				arguments: arguments allButLast ].	"Closure primitives"
	(primitiveIndex = 200 and: [ receiver == self ])
		ifTrue: [ "ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"
			^ self
				push:
					(BlockClosure
						outerContext: receiver
						startpc: pc + 2
						numArgs: arguments first
						copiedValues: arguments last) ].
	((primitiveIndex between: 201 and: 205) or: [ primitiveIndex between: 221 and: 222 ])
		ifTrue: [ "BlockClosure>>valueNoContextSwitch[:]"
			^ receiver simulateValueWithArguments: arguments caller: self ].	"BlockClosure>>value[:value:...]"
	primitiveIndex = 206
		ifTrue: [ "BlockClosure>>valueWithArguments:"
			^ receiver simulateValueWithArguments: arguments first caller: self ].
	primitiveIndex = 120
		ifTrue: [ "FFI method"
			value := method literals first tryInvokeWithArguments: arguments ]
		ifFalse: [ value := self
				simulatePrimitive: primitiveIndex
				in: method
				receiver: receiver
				arguments: arguments ].
	^ (self isFailToken: value)
		ifTrue: [ value ]
		ifFalse: [ self push: value ]
]

ContextPart >> errorReportOn: stream
[errorReportOn: stream
	"Write a detailed error report on the stack (above me) on a  
	stream.  For both the error file, and emailing a bug report.   
	Suppress any errors while getting printStrings.  Limit the length."

	| stackDepth aContext startPos |
	stream
		print: Date today;
		space;
		print: Time now;
		cr.
	stream cr.
	stream
		nextPutAll: 'VM: ';
		nextPutAll: Smalltalk os name asString;
		nextPutAll: ' - ';
		nextPutAll: Smalltalk os subtype asString;
		nextPutAll: ' - ';
		nextPutAll: Smalltalk os version asString;
		nextPutAll: ' - ';
		nextPutAll: Smalltalk vm version asString;
		cr.
	stream
		nextPutAll: 'Image: ';
		nextPutAll: SystemVersion current version asString;
		nextPutAll: ' [';
		nextPutAll: Smalltalk lastUpdateString asString;
		nextPutAll: ']';
		cr.
	stream cr.	"Note: The following is an open-coded version of  ContextPart>>stackOfSize: since this method may be called during a  low space condition and we might run out of space for allocating the  full stack."
	stackDepth := 0.
	startPos := stream position.
	aContext := self.
	[ aContext notNil and: [ (stackDepth := stackDepth + 1) < 40 ] ]
		whileTrue: [ "variable values"
			aContext printDetails: stream.
			stream cr.
			aContext := aContext sender ].
	stream
		cr;
		nextPutAll: '--- The full stack ---';
		cr.
	aContext := self.
	stackDepth := 0.
	[ aContext == nil ]
		whileFalse: [ 
			stackDepth := stackDepth + 1.
			stackDepth = 40
				ifTrue: [ 
					stream
						nextPutAll:
								' - - - - - - - - - - - - - - -  			- - - - - - - - - - - - - - - - - -';
						cr ].	"just class>>selector"
			stream
				print: aContext;
				cr.
			stream position > (startPos + 150000)
				ifTrue: [ stream nextPutAll: '...etc...'.	"exit early"
					^ self ].
			stackDepth > 200
				ifTrue: [ stream nextPutAll: '-- and more not shown --'.
					^ self ].
			aContext := aContext sender ]
]

ContextPart >> exceptionClass
[exceptionClass
	"handlercontext only. access temporaries from BlockClosure>>#on:do:"

	^ self tempAt: 1
]

ContextPart >> exceptionHandlerBlock
[exceptionHandlerBlock
	"handlercontext only. access temporaries from BlockClosure>>#on:do:"

	^ self tempAt: 2
]

ContextPart >> exceptionHandlerIsActive
[exceptionHandlerIsActive
	"handlercontext only. access temporaries from BlockClosure>>#on:do:"

	^ self tempAt: 3
]

ContextPart >> exceptionHandlerIsActive: aBoolean
[exceptionHandlerIsActive: aBoolean
	"handlercontext only. access temporaries from BlockClosure>>#on:do:"

	self tempAt: 3 put: aBoolean
]

ContextPart >> findContextSuchThat: testBlock
[findContextSuchThat: testBlock
	"Search self and my sender chain for first one that satisfies testBlock.  Return nil if none satisfy"

	| context |
	context := self.
	[ context isNil ] whileFalse: [ (testBlock value: context)
				ifTrue: [ ^ context ].
			context := context sender ].
	^ nil
]

ContextPart >> findNextHandlerContextStarting
[findNextHandlerContextStarting
	"Return the next handler marked context, returning nil if there is none.  Search starts with self and proceeds up to nil."

	<primitive: 197>
	| context |
	context := self.
	[ context isHandlerContext
		ifTrue: [ ^ context ].
	(context := context sender) == nil ] whileFalse.
	^ nil
]

ContextPart >> findNextUnwindContextUpTo: aContext
[findNextUnwindContextUpTo: aContext
	"Return the next unwind marked above the receiver, returning nil if there is none.  Search proceeds up to but not including aContext."

	<primitive: 195>
	| context |
	context := self.
	[ (context := context sender) == nil or: [ context == aContext ] ]
		whileFalse: [ context isUnwindContext
				ifTrue: [ ^ context ] ].
	^ nil
]

ContextPart >> findSecondToOldestSimilarSender
[findSecondToOldestSimilarSender
	"Search the stack for the second-to-oldest occurance of self's method.  Very useful for an infinite recursion.  Gets back to the second call so you can see one complete recursion cycle, and how it was called at the beginning."

	| secondContext context lastContext |
	secondContext := self.
	context := self.
	[ lastContext := context findSimilarSender.
	lastContext isNil ]
		whileFalse: [ secondContext := context.
			context := lastContext ].
	^ secondContext
]

ContextPart >> findSimilarSender
[findSimilarSender
	"Return the closest sender with the same method, return nil if none found"

	| method |
	method := self method.
	^ self sender findContextSuchThat: [ :context | context method == method ]
]

ContextPart >> handleSignal: exception
[handleSignal: exception
	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."

	| value |
	((self exceptionClass handles: exception) and: [ self exceptionHandlerIsActive ])
		ifFalse: [ ^ self nextHandlerContext handleSignal: exception ].
	exception privHandlerContext: self contextTag.	"disable self while executing handle block"
	self exceptionHandlerIsActive: false.
	value := [ self exceptionHandlerBlock cull: exception ]
		ensure: [ self exceptionHandlerIsActive: true ].	"return from self if not otherwise directed in handle block"
	self return: value
]

ContextPart >> hasContext: aContext
[hasContext: aContext
	"Answer whether aContext is me or one of my senders"

	^ (self findContextSuchThat: [ :context | context == aContext ]) notNil
]

ContextPart >> hasSender: context
[hasSender: context
	"Answer whether the receiver is strictly above context on the stack."

	| senderContext |
	self == context
		ifTrue: [ ^ false ].
	senderContext := sender.
	[ senderContext == nil ]
		whileFalse: [ senderContext == context
				ifTrue: [ ^ true ].
			senderContext := senderContext sender ].
	^ false
]

ContextPart >> home
[home
	"Answer the context in which the receiver was defined."

	self subclassResponsibility
]

ContextPart >> insertSender: aContext
[insertSender: aContext
	"Insert aContext and its sender chain between me and my sender.  Return new callee of my original sender."

	| context |
	context := aContext bottomContext.
	context privSender: self sender.
	self privSender: aContext.
	^ context
]

ContextPart >> isBottomContext
[isBottomContext
	"Answer if this is the last context (the first context invoked) in my sender chain"

	^ sender isNil
]

ContextPart >> isContext
[isContext
	^ true
]

ContextPart >> isDead
[isDead
	"Has self finished"

	^ pc isNil
]

ContextPart >> isFailToken: anObject
[isFailToken: anObject
	^ anObject class == Array and: [ anObject size = 2 and: [ (anObject at: 1) == PrimitiveFailToken ] ]
]

ContextPart >> isHandlerContext
[isHandlerContext
	^ false
]

ContextPart >> isUnwindContext
[isUnwindContext
	^ false
]

ContextPart >> jump
[jump
	"Abandon thisContext and resume self instead (using the same current process).  You may want to save thisContext's sender before calling this so you can jump back to it.
	Self MUST BE a top context (ie. a suspended context or a abandoned context that was jumped out of).  A top context already has its return value on its stack (see Interpreter>>primitiveSuspend and other suspending primitives).
	thisContext's sender is converted to a top context (by pushing a nil return value on its stack) so it can be jump back to."

	| top |
	"Make abandoned context a top context (has return value (nil)) so it can be jumped back to"
	thisContext sender push: nil.	"Pop self return value then return it to self (since we jump to self by returning to it)"
	stackp = 0
		ifTrue: [ self stepToSendOrReturn ].
	stackp = 0
		ifTrue: [ self push: nil ].	"must be quick return self/constant"
	top := self pop.
	thisContext privSender: self.
	^ top
]

ContextPart >> jump: distance
[jump: distance
	"Simulate the action of a 'unconditional jump' bytecode whose offset is 
	the argument, distance."

	pc := pc + distance
]

ContextPart >> jump: distance if: condition
[jump: distance if: condition
	"Simulate the action of a 'conditional jump' bytecode whose offset is the 
	argument, distance, and whose condition is the argument, condition."

	| bool |
	bool := self pop.
	(bool == true or: [ bool == false ])
		ifFalse: [ ^ self
				send: #mustBeBooleanIn:
				to: bool
				with: {self}
				super: false ].
	(bool eqv: condition)
		ifTrue: [ self jump: distance ]
]

ContextPart >> longStack
[longStack
	"Answer a String showing the top 100 contexts on my sender chain."

	^ String streamContents: [ :stream | (self stackOfSize: 100) do: [ :item | stream
						print: item;
						cr ] ]
]

ContextPart >> method
[method
	"Answer the method of this context."

	self subclassResponsibility
]

ContextPart >> methodClass
[methodClass
	"Answer the class in which the receiver's method was found."

	^ self method methodClass ifNil: [ self receiver class ]
]

ContextPart >> methodNode
[methodNode
	^ self method methodNode
]

ContextPart >> methodReturnConstant: value
[methodReturnConstant: value
	"Simulate the action of a 'return constant' bytecode whose value is the
	 argument, value. This corresponds to a source expression like '^0'."

	^ self return: value from: self methodReturnContext
]

ContextPart >> methodReturnContext
[methodReturnContext
	"Answer the context from which an ^-return should return from."

	self subclassResponsibility
]

ContextPart >> methodReturnReceiver
[methodReturnReceiver
	"Simulate the action of a 'return receiver' bytecode. This corresponds to
	 the source expression '^self'."

	^ self return: self receiver from: self methodReturnContext
]

ContextPart >> methodReturnTop
[methodReturnTop
	"Simulate the action of a 'return top of stack' bytecode. This corresponds
	 to source expressions like '^something'."

	^ self return: self pop from: self methodReturnContext
]

ContextPart >> methodSelector
[methodSelector
	^ self method selector
]

ContextPart >> namedTempAt: index
[namedTempAt: index
	"Answer the value of the temp at index in the receiver's sequence of tempNames."

	^ self debuggerMap namedTempAt: index in: self
]

ContextPart >> namedTempAt: index put: aValue
[namedTempAt: index put: aValue
	"Set the value of the temp at index in the receiver's sequence of tempNames.
	 (Note that if the value is a copied value it is also set out along the lexical chain,
	  but alas not in along the lexical chain.)."

	^ self debuggerMap namedTempAt: index put: aValue in: self
]

ContextPart >> nextHandlerContext
[nextHandlerContext
	^ self sender findNextHandlerContextStarting
]

ContextPart >> objectSize: anObject
[objectSize: anObject
	"Answer the number of indexable variables in the argument anObject without sending
	it a message. This mimics the action of the VM when it fetches an object's variable size.
	Used to simulate the execution machinery by, for example, the debugger.
	Primitive.  See Object documentation whatIsAPrimitive."

	"The number of indexable fields of fixed-length objects is 0"

	<primitive: 62>
	^ 0
]

ContextPart >> pop
[pop
	"Answer the top of the receiver's stack and remove the top of the stack."

	| value |
	value := self at: stackp.
	self stackp: stackp - 1.
	^ value
]

ContextPart >> popIntoLiteralVariable: value
[popIntoLiteralVariable: value
	"Simulate the action of bytecode that removes the top of the stack and 
	stores it into a literal variable of my method."

	value value: self pop
]

ContextPart >> popIntoReceiverVariable: offset
[popIntoReceiverVariable: offset
	"Simulate the action of bytecode that removes the top of the stack and 
	stores it into an instance variable of my receiver."

	self receiver instVarAt: offset + 1 put: self pop
]

ContextPart >> popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
[popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
	"Simulate the action of bytecode that removes the top of the stack and  stores
	 it into an offset in one of my local variables being used as a remote temp vector."

	(self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self pop
]

ContextPart >> popIntoTemporaryVariable: offset
[popIntoTemporaryVariable: offset
	"Simulate the action of bytecode that removes the top of the stack and 
	stores it into one of my temporary variables."

	self at: offset + 1 put: self pop
]

ContextPart >> print: anObject on: aStream
[print: anObject on: aStream
	"Safely print anObject in the face of direct ProtoObject subclasses"

	| title |
	(anObject class canUnderstand: #printOn:)
		ifTrue: [ ^ anObject printOn: aStream ].
	title := anObject class name.
	aStream
		nextPutAll: (title first isVowel
						ifTrue: [ 'an ' ]
						ifFalse: [ 'a ' ]);
		nextPutAll: title
]

ContextPart >> printDebugOn: aStream
[printDebugOn: aStream
	"print a condensed for of the stack.
		For methods simply print Class >> selector
		For blocks only print the first line"

	self printOn: aStream
]

ContextPart >> printDetails: stream
[printDetails: stream
	"Put my class>>selector and arguments and temporaries on the stream.  Protect against errors during printing."

	| string |
	self printOn: stream.
	stream
		cr;
		tab;
		nextPutAll: 'Arguments and temporary variables: ';
		cr.
	string := [ self tempsAndValuesLimitedTo: 80 indent: 2 ] ifError: [ '<<error during printing>>' ].
	stream nextPutAll: string.
	stream peekLast == Character cr
		ifFalse: [ stream cr ]
]

ContextPart >> printOn: aStream
[printOn: aStream
	| selector class mclass |
	self method == nil
		ifTrue: [ ^ super printOn: aStream ].
	class := self receiver class.
	mclass := self methodClass.
	selector := self selector ifNil: [ self method defaultSelector ].
	aStream nextPutAll: class name.
	mclass == class
		ifFalse: [ aStream nextPut: $(.
			aStream nextPutAll: mclass name.
			aStream nextPut: $) ].
	aStream nextPutAll: '>>'.
	aStream nextPutAll: selector.
	selector = #doesNotUnderstand:
		ifTrue: [ aStream space.
			(self tempAt: 1) selector printOn: aStream ]
]

ContextPart >> privSender: aContext
[privSender: aContext
	sender := aContext
]

ContextPart >> push: value
[push: value
	"Push value on the receiver's stack."

	self stackp: stackp + 1.
	self at: stackp put: value
]

ContextPart >> push: numObjects fromIndexable: anIndexableCollection
[push: numObjects fromIndexable: anIndexableCollection
	"Push the elements of anIndexableCollection onto the receiver's stack.
	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."

	1 to: numObjects do: [ :i | self push: (anIndexableCollection at: i) ]
]

ContextPart >> pushActiveContext
[pushActiveContext
	"Simulate the action of bytecode that pushes the the active context on the 
	top of its own stack."

	self push: self
]

ContextPart >> pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize
[pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize
	"Simulate the action of a 'closure copy' bytecode whose result is the
	 new BlockClosure for the following code"

	| copiedValues |
	numCopied > 0
		ifTrue: [ copiedValues := Array new: numCopied.
			numCopied to: 1 by: -1 do: [ :i | copiedValues at: i put: self pop ] ]
		ifFalse: [ copiedValues := nil ].
	self push: (BlockClosure
				outerContext: self
				startpc: pc
				numArgs: numArgs
				copiedValues: copiedValues).
	self jump: blockSize
]

ContextPart >> pushConstant: value
[pushConstant: value
	"Simulate the action of bytecode that pushes the constant, value, on the 
	top of the stack."

	self push: value
]

ContextPart >> pushLiteralVariable: value
[pushLiteralVariable: value
	"Simulate the action of bytecode that pushes the contents of the literal 
	variable whose index is the argument, index, on the top of the stack."

	self push: value value
]

ContextPart >> pushNewArrayOfSize: arraySize
[pushNewArrayOfSize: arraySize
	self push: (Array new: arraySize)
]

ContextPart >> pushReceiver
[pushReceiver
	"Simulate the action of bytecode that pushes the active context's receiver 
	on the top of the stack."

	self push: self receiver
]

ContextPart >> pushReceiverVariable: offset
[pushReceiverVariable: offset
	"Simulate the action of bytecode that pushes the contents of the receiver's 
	instance variable whose index is the argument, index, on the top of the 
	stack."

	self push: (self receiver instVarAt: offset + 1)
]

ContextPart >> pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
[pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
	"Simulate the action of bytecode that pushes the value at remoteTempIndex
	 in one of my local variables being used as a remote temp vector."

	self push: ((self at: tempVectorIndex + 1) at: remoteTempIndex + 1)
]

ContextPart >> pushTemporaryVariable: offset
[pushTemporaryVariable: offset
	"Simulate the action of bytecode that pushes the contents of the 
	temporary variable whose index is the argument, index, on the top of 
	the stack."

	self push: (self at: offset + 1)
]

ContextPart >> quickSend: selector to: receiver with: arguments super: superFlag
[quickSend: selector to: receiver with: arguments super: superFlag
	"Send the given selector with arguments in an environment which closely resembles the non-simulating environment, with an interjected unwind-protected block to catch nonlocal returns.
	Attention: don't get lost!"

	| lookupClass contextToReturnTo result |
	contextToReturnTo := self.
	lookupClass := superFlag
		ifTrue: [ (self method literalAt: self method numLiterals) value superclass ]
		ifFalse: [ receiver class ].
	[ | oldSender |
	oldSender := thisContext sender swapSender: self.
	result := receiver perform: selector withArguments: arguments inSuperclass: lookupClass.
	thisContext sender swapSender: oldSender ]
		ifCurtailed: [ 
			contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"
			contextToReturnTo jump: -1.	"skip to front of return bytecode causing this unwind"
			contextToReturnTo nextByte = 16r7C
				ifTrue: [ 
					"If it was a returnTop, push the value to be returned.			Otherwise the value is implicit in the bytecode"
					contextToReturnTo push: (thisContext sender tempAt: 1) ].
			thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"
			contextToReturnTo ].
	contextToReturnTo push: result.
	^ contextToReturnTo
]

ContextPart >> quickStep
[quickStep
	"If the next instruction is a send, just perform it.
	Otherwise, do a normal step."

	self willSend
		ifTrue: [ QuickStep := self ].
	^ self step
]

ContextPart >> receiver
[receiver
	"Answer the receiver of the message that created this context."

	self subclassResponsibility
]

ContextPart >> release
[release
	"Remove information from the receiver and all of the contexts on its 
	sender chain in order to break circularities."

	self releaseTo: nil
]

ContextPart >> releaseTo: caller
[releaseTo: caller
	"Remove information from the receiver and the contexts on its sender 
	chain up to caller in order to break circularities."

	| contex senderContext |
	contex := self.
	[ contex == nil or: [ contex == caller ] ]
		whileFalse: [ senderContext := contex sender.
			contex singleRelease.
			contex := senderContext ]
]

ContextPart >> restart
[restart
	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	| context unwindBlock |
	self isDead
		ifTrue: [ self cannotReturn: nil to: self ].
	self privRefresh.
	context := thisContext.
	[ context := context findNextUnwindContextUpTo: self.
	context isNil ]
		whileFalse: [ context unwindComplete
				ifNil: [ context unwindComplete: true.
					unwindBlock := context unwindBlock.
					thisContext terminateTo: context.
					unwindBlock value ] ].
	thisContext terminateTo: self.
	self jump
]

ContextPart >> resume
[resume
	"Roll back thisContext to self and resume.  Execute unwind blocks when rolling back.  ASSUMES self is a sender of thisContext"

	self resume: nil
]

ContextPart >> resume: value
[resume: value
	"Unwind thisContext to self and resume with value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	self resume: value through: (thisContext findNextUnwindContextUpTo: self)
]

ContextPart >> resume: value through: firstUnwindContext
[resume: value through: firstUnwindContext
	"Unwind thisContext to self and resume with value as result of last send.
	 Execute any unwind blocks while unwinding.
	 ASSUMES self is a sender of thisContext."

	| context unwindBlock |
	self isDead
		ifTrue: [ self cannotReturn: value to: self ].
	context := firstUnwindContext.
	[ context isNil ]
		whileFalse: [ context unwindComplete
				ifNil: [ context unwindComplete: true.
					unwindBlock := context unwindBlock.
					thisContext terminateTo: context.
					unwindBlock value ].
			context := context findNextUnwindContextUpTo: self ].
	thisContext terminateTo: self.
	^ value
]

ContextPart >> return
[return
	"Unwind until my sender is on top"

	self return: self receiver
]

ContextPart >> return: value
[return: value
	"Unwind thisContext to self and return value to self's sender.  Execute any unwind blocks while unwinding.  ASSUMES self is a sender of thisContext"

	sender ifNil: [ self cannotReturn: value to: sender ].
	sender resume: value
]

ContextPart >> return: value from: aSender
[return: value from: aSender
	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"

	| newTop context |
	aSender isDead
		ifTrue: [ ^ self
				send: #cannotReturn:
				to: self
				with: {value}
				super: false ].
	newTop := aSender sender.
	context := self findNextUnwindContextUpTo: newTop.
	context
		ifNotNil: [ ^ self
				send: #aboutToReturn:through:
				to: self
				with: {value.
					context}
				super: false ].
	self releaseTo: newTop.
	newTop ifNotNil: [ newTop push: value ].
	^ newTop
]

ContextPart >> return: value through: firstUnwindContext
[return: value through: firstUnwindContext
	"Unwind thisContext to self and return value to self's sender.
	 Execute any unwind blocks while unwinding.
	 ASSUMES self is a sender of thisContext."

	sender ifNil: [ self cannotReturn: value to: sender ].
	sender resume: value through: firstUnwindContext
]

ContextPart >> return: value to: aSender
[return: value to: aSender
	"Simulate the return of value to aSender."

	self releaseTo: aSender.
	aSender ifNil: [ ^ nil ].
	^ aSender push: value
]

ContextPart >> runSimulated: aBlock contextAtEachStep: block2
[runSimulated: aBlock contextAtEachStep: block2
	"Simulate the execution of the argument, aBlock, until it ends. aBlock 
	MUST NOT contain an '^'. Evaluate block2 with the current context 
	prior to each instruction executed. Answer the simulated value of aBlock."

	| current returnContext exception |
	aBlock hasMethodReturn
		ifTrue: [ self error: 'simulation of blocks with ^ can run loose' ].
	current := [ aBlock
		on: Exception
		do: [ :ex | SimulationExceptionWrapper signalForException: ex ] ] asContext.
	returnContext := MethodContext
		sender: nil
		receiver: self home receiver
		method: self home method
		arguments: self home arguments.
	current pushArgs: Array new from: returnContext.
	[ current == returnContext ] whileFalse: [ block2 value: current.
			current := current step ].
	exception := returnContext pop.
	exception class == SimulationExceptionWrapper
		ifTrue: [ ^ exception exception signal ].
	^ exception
]

ContextPart >> runUntilErrorOrReturnFrom: aSender
[runUntilErrorOrReturnFrom: aSender
	"ASSUMES aSender is a sender of self.  Execute self's stack until aSender returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSender returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."

	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSender that jumps back to thisContext when evaluated.  We also insert an exception handler under aSender that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."

	| error context here topContext |
	here := thisContext.	"Insert ensure and exception handler contexts under aSender"
	error := nil.
	context := aSender
		insertSender:
			(ContextPart
				contextOn: UnhandledError , Halt
				do: [ :ex | error
						ifNil: [ "this is ugly but it fixes the side-effects of not sending an Unhandled error on Halt"
							error := (ex isKindOf: Halt)
								ifTrue: [ ex ]
								ifFalse: [ ex exception ].
							topContext := thisContext.
							ex resumeUnchecked: here jump ]
						ifNotNil: [ ex pass ] ]).
	context := context
		insertSender: (ContextPart contextEnsure: [ error ifNil: [ topContext := thisContext.
							here jump ] ]).	"Control jumps to self"
	self jump.	"Control resumes here once above ensure block or exception handler is executed"
	^ error
		ifNil: [ "No error was raised, remove ensure context by stepping until popped"
			[ context isDead ] whileFalse: [ topContext := topContext stepToCallee ].
			{topContext.
			nil} ]
		ifNotNil: [ "Error was raised, remove inserted above contexts then return signaler context"
			"remove above ensure and handler contexts"
			aSender terminateTo: context sender.
			{topContext.
			error} ]
]

ContextPart >> secondFromBottom
[secondFromBottom
	"Return the second from bottom of my sender chain"

	self sender ifNil: [ ^ nil ].
	^ self findContextSuchThat: [ :context | context sender sender isNil ]
]

ContextPart >> selector
[selector
	"Answer the selector of the method that created the receiver."

	^ self method selector ifNil: [ self method defaultSelector ]
]

ContextPart >> send: selector super: superFlag numArgs: numArgs
[send: selector super: superFlag numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, 
	selector. The argument, superFlag, tells whether the receiver of the 
	message was specified with 'super' in the source method. The arguments 
	of the message are found in the top numArgs locations on the stack and 
	the receiver just below them."

	| receiver arguments |
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop ].
	receiver := self pop.	"	selector == #doPrimitive:method:receiver:args:		ifTrue: [answer := receiver 					doPrimitive: (arguments at: 1)					method: (arguments at: 2)					receiver: (arguments at: 3)					args: (arguments at: 4).				self push: answer.				^self]. "
	QuickStep == self
		ifTrue: [ QuickStep := nil.
			^ self
				quickSend: selector
				to: receiver
				with: arguments
				super: superFlag ].
	^ self
		send: selector
		to: receiver
		with: arguments
		super: superFlag
]

ContextPart >> send: selector to: receiver with: arguments super: superFlag
[send: selector to: receiver with: arguments super: superFlag
	"Simulate the action of sending a message with selector, selector, and 
	arguments, args, to receiver. The argument, superFlag, tells whether the 
	receiver of the message was specified with 'super' in the source method."

	| class method value context |
	class := superFlag
		ifTrue: [ (self method literalAt: self method numLiterals) value superclass ]
		ifFalse: [ receiver class ].
	method := class lookupSelector: selector.
	method == nil
		ifTrue: [ ^ self
				send: #doesNotUnderstand:
				to: receiver
				with: (Array with: (Message selector: selector arguments: arguments))
				super: superFlag ].
	value := self tryPrimitiveFor: method receiver: receiver args: arguments.	"primitive runs without failure?"
	(self isFailToken: value)
		ifFalse: [ ^ value ].
	(selector == #doesNotUnderstand: and: [ (class canUnderstand: #doesNotUnderstand:) not ])
		ifTrue: [ ^ self error: 'Simulated message ' , (arguments at: 1) selector , ' not understood' ].	"failure.. lets activate the method"
	context := self
		activateMethod: method
		withArgs: arguments
		receiver: receiver
		class: class.	"check if activated method handles the error code (a first bytecode will be store into temp)"	"long store temp"
	(context method at: context pc) = 129
		ifTrue: [ context at: context stackPtr put: value last ].
	^ context
]

ContextPart >> sender
[sender
	"Answer the context that sent the message that created the receiver."

	^ sender
]

ContextPart >> setNamedPrimitiveInformationFrom: fromMethod toMethod: toMethod
[setNamedPrimitiveInformationFrom: fromMethod toMethod: toMethod
	"For named primitives, the first literal contains a special object that has information of the primitive. Example:
(StandardFileStream >> #primOpen:writable:) literalAt: 1 ----->>>>   #(#FilePlugin #primitiveFileOpen 0 147).
In this method we cope such information from one to another one."

	| spec |
	spec := toMethod literalAt: 1.
	spec
		replaceFrom: 1
		to: spec size
		with: (fromMethod literalAt: 1)
		startingAt: 1
]

ContextPart >> setNumArgs: numArgs toMethod: theMethod
[setNumArgs: numArgs toMethod: theMethod
	"All that line is to change the argument count of a CompiledMethod header. The argument count is 4 bits starting in the 24 and finishign in 27.
16r787FFFFF is the hexa representation of a number that is all 1 and only those 4 bits in 0. Hence, when doing (theMethod header bitAnd: 16r787FFFFF) what we do is just to put zeros in those 4 bits.

Now with the new argument size, we do bitShift: 24 and we obtain a 32 bits number with all zeros and just our 4 bits with the value we want.
Since in the previous step we cleaned those 4 bits doing now a bitOr: with the second step, we have the result.
"

	| xpc |
	theMethod
		objectAt: 1
		put:
			(((theMethod header bitAnd: 2r01110000000000111111111111111111) bitOr: (numArgs bitShift: 24))
				bitOr: (numArgs + 1 bitShift: 18)).
	xpc := theMethod initialPC.	"long store temp"
	(theMethod at: xpc) = 129
		ifTrue: [ theMethod at: xpc + 1 put: 16r40 + numArgs.
			theMethod at: xpc + 3 put: 16r10 + numArgs ]
]

ContextPart >> shortDebugStack
[shortDebugStack
	"Answer a String showing the top ten contexts on my sender chain."

	^ String streamContents: [ :stream | self debugStack: 10 on: stream ]
]

ContextPart >> shortDebugStackOn: aStream
[shortDebugStackOn: aStream
	"print the top 30 contexts on my sender chain."

	^ self debugStack: 30 on: aStream
]

ContextPart >> shortStack
[shortStack
	"Answer a String showing the top ten contexts on my sender chain."

	^ String streamContents: [ :stream | (self stackOfSize: 10) do: [ :item | stream
						print: item;
						cr ] ]
]

ContextPart >> simulatePrimitive: primitiveIndex in: method receiver: receiver arguments: arguments
[simulatePrimitive: primitiveIndex in: method receiver: receiver arguments: arguments
	| key simulator |
	key := primitiveIndex = 117
		ifTrue: [ | literal |
			literal := method literalAt: 1.	"primitive name, module name"
			{(literal second).
			(literal first)} ]
		ifFalse: [ primitiveIndex ].
	simulator := self class specialPrimitiveSimulators
		at: key
		ifAbsent: [ 
			"named primitives"
			^ primitiveIndex = 117
				ifTrue: [ 
					self withoutPrimitiveTryNamedPrimitiveIn: method for: receiver withArgs: arguments	"this uses primitive 218, which doesn't works as expected... 					self tryNamedPrimitiveIn: method for: receiver withArgs: arguments " ]
				ifFalse: [ receiver tryPrimitive: primitiveIndex withArgs: arguments ] ].
	^ simulator
		simulatePrimitiveFor: method
		receiver: receiver
		arguments: arguments
		context: self
]

ContextPart >> singleRelease
[singleRelease
	"Remove information from the receiver in order to break circularities."

	stackp ifNotNil: [ 1 to: stackp do: [ :i | self at: i put: nil ] ].
	sender := nil.
	pc := nil
]

ContextPart >> size
[size
	"Primitive. Answer the number of indexable variables in the receiver. 
	This value is the same as the largest legal subscript. Essential. See Object 
	documentation whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	"The number of indexable fields of fixed-length objects is 0"

	<primitive: 212>
	^ self primitiveFail
]

ContextPart >> sourceCode
[sourceCode
	^ self method sourceCode
]

ContextPart >> stack
[stack
	"Answer an Array of the contexts on the receiver's sender chain."

	^ self stackOfSize: 9999
]

ContextPart >> stackOfSize: limit
[stackOfSize: limit
	"Answer an OrderedCollection of the top 'limit' contexts
	 on the receiver's sender chain."

	| stack context |
	stack := OrderedCollection new.
	stack addLast: (context := self).
	[ (context := context sender) ~~ nil and: [ stack size < limit ] ] whileTrue: [ stack addLast: context ].
	^ stack
]

ContextPart >> stackPtr
[stackPtr
	"For use only by the SystemTracer and the Debugger, Inspectors etc"

	^ stackp
]

ContextPart >> stackp: newStackp
[stackp: newStackp
	"Storing into the stack pointer is a potentially dangerous thing.
	This primitive stores nil into any cells that become accessible as a result,
	and it performs the entire operation atomically."

	"Once this primitive is implemented, failure code should cause an error"

	<primitive: 76>
	self error: 'stackp store failure'	"	stackp == nil ifTrue: [stackp := 0].	newStackp > stackp  'effectively checks that it is a number'		ifTrue: [oldStackp := stackp.				stackp := newStackp.				'Nil any newly accessible cells'				oldStackp + 1 to: stackp do: [:i | self at: i put: nil]]		ifFalse: [stackp := newStackp]"
]

ContextPart >> step
[step
	"Simulate the execution of the receiver's next bytecode. Answer the 
	context that would be the active context after this bytecode."

	^ self interpretNextInstructionFor: self
]

ContextPart >> stepToCallee
[stepToCallee
	"Step to callee or sender"

	| context |
	context := self.
	[ (context := context step) == self ] whileTrue.
	^ context
]

ContextPart >> stepToSendOrReturn
[stepToSendOrReturn
	"Simulate the execution of bytecodes until either sending a message or 
	returning a value to the receiver (that is, until switching contexts)."

	| context |
	[ self willSend or: [ self willReturn or: [ self willStore or: [ self willCreateBlock ] ] ] ]
		whileFalse: [ context := self step.
			context == self
				ifFalse: [ "Caused by mustBeBoolean handling"
					^ context ] ]
]

ContextPart >> storeIntoLiteralVariable: value
[storeIntoLiteralVariable: value
	"Simulate the action of bytecode that stores the top of the stack into a 
	literal variable of my method."

	value value: self top
]

ContextPart >> storeIntoReceiverVariable: offset
[storeIntoReceiverVariable: offset
	"Simulate the action of bytecode that stores the top of the stack into an 
	instance variable of my receiver."

	self receiver instVarAt: offset + 1 put: self top
]

ContextPart >> storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
[storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
	"Simulate the action of bytecode that stores the top of the stack at
	 an offset in one of my local variables being used as a remote temp vector."

	(self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self top
]

ContextPart >> storeIntoTemporaryVariable: offset
[storeIntoTemporaryVariable: offset
	"Simulate the action of bytecode that stores the top of the stack into one 
	of my temporary variables."

	self at: offset + 1 put: self top
]

ContextPart >> swapSender: coroutine
[swapSender: coroutine
	"Replace the receiver's sender with coroutine and answer the receiver's 
	previous sender. For use in coroutining."

	| oldSender |
	oldSender := sender.
	sender := coroutine.
	^ oldSender
]

ContextPart >> tempAt: index
[tempAt: index
	"Answer the value of the temporary variable whose index is the 
	argument, index."

	self subclassResponsibility
]

ContextPart >> tempAt: index put: value
[tempAt: index put: value
	"Store the argument, value, as the temporary variable whose index is the 
	argument, index."

	self subclassResponsibility
]

ContextPart >> tempNamed: aName
[tempNamed: aName
	"Answer the value of the temporary variable whose name is the 
	argument, aName."

	self subclassResponsibility
]

ContextPart >> tempNamed: aName put: value
[tempNamed: aName put: value
	"Store the argument, value, as the temporary variable whose name is the 
	argument, aName."

	self subclassResponsibility
]

ContextPart >> tempNames
[tempNames
	"Answer a SequenceableCollection of the names of the receiver's temporary 
	 variables, which are strings."

	^ self debuggerMap tempNamesForContext: self
]

ContextPart >> tempsAndValues
[tempsAndValues
	"Return a string of the temporary variabls and their current values"

	^ String
		streamContents: [ :aStream | self tempNames
				doWithIndex: [ :title :index | aStream
						nextPutAll: title;
						nextPut: $:;
						space;
						tab.
					self print: (self namedTempAt: index) on: aStream.
					aStream cr ] ]
]

ContextPart >> tempsAndValuesLimitedTo: sizeLimit indent: indent
[tempsAndValuesLimitedTo: sizeLimit indent: indent
	"Return a string of the temporary variabls and their current values"

	^ String
		streamContents: [ :aStream | self tempNames
				doWithIndex: [ :title :index | indent timesRepeat: [ aStream tab ].
					aStream
						nextPutAll: title;
						nextPut: $:;
						space;
						tab.
					aStream nextPutAll: ((self namedTempAt: index) printStringLimitedTo: (sizeLimit - 3 - title size max: 1)).
					aStream cr ] ]
]

ContextPart >> terminate
[terminate
	"Make myself unresumable."

	sender := nil.
	pc := nil
]

ContextPart >> terminateTo: previousContext
[terminateTo: previousContext
	"Terminate all the Contexts between me and previousContext, if previousContext is on my Context stack. Make previousContext my sender."

	<primitive: 196>
	| currentContext sendingContext |
	(self hasSender: previousContext)
		ifTrue: [ currentContext := sender.
			[ currentContext == previousContext ]
				whileFalse: [ sendingContext := currentContext sender.
					currentContext terminate.
					currentContext := sendingContext ] ].
	sender := previousContext
]

ContextPart >> top
[top
	"Answer the top of the receiver's stack."

	^ self at: stackp
]

ContextPart >> tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
[tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
	<primitive: 218 error: #errorCode>
	errorCode
		ifNotNil: [ 
			"If errorCode is an integer other than -1 there was a problem with primitive 218,		 not with the external primitive itself.  -1 indicates a generic failure (where		 errorCode should be nil) but errorCode = nil means primitive 218 is not implemented.  So		 interpret -1 to mean the external primitive failed with a nil error code."
			errorCode isInteger
				ifTrue: [ errorCode = -1
						ifTrue: [ errorCode := nil ]
						ifFalse: [ self primitiveFailed ] ].
			^ self class primitiveFailTokenFor: errorCode ].	"Assume a nil error code implies the primitive is not implemented and fall back on the old code."	"The primitive doesn't exist or there was an error. Hence, we follow another solution without the primitive"
	^ self withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
]

ContextPart >> tryPrimitiveFor: method receiver: receiver args: arguments
[tryPrimitiveFor: method receiver: receiver args: arguments
	"If this method has a primitive index, then run the primitive and return its result.
	Otherwise (and also if the primitive fails) return PrimitiveFailToken,
	as an indication that the method should be activated and run as bytecodes."

	| primIndex |
	(primIndex := method primitive) = 0
		ifTrue: [ ^ self class primitiveFailToken ].
	^ self
		doPrimitive: primIndex
		method: method
		receiver: receiver
		args: arguments
]

ContextPart >> unwindBlock
[unwindBlock
	"unwindContext only. access temporaries from BlockClosure>>#ensure: and BlockClosure>>#ifCurtailed:"

	^ self tempAt: 1
]

ContextPart >> unwindComplete
[unwindComplete
	"unwindContext only. access temporaries from BlockClosure>>#ensure: and BlockClosure>>#ifCurtailed:"

	^ self tempAt: 2
]

ContextPart >> unwindComplete: aBoolean
[unwindComplete: aBoolean
	"unwindContext only. access temporaries from BlockClosure>>#ensure: and BlockClosure>>#ifCurtailed:"

	self tempAt: 2 put: aBoolean
]

ContextPart >> unwindTo: aContext
[unwindTo: aContext
	| context unwindBlock |
	context := self.
	[ (context := context findNextUnwindContextUpTo: aContext) isNil ]
		whileFalse: [ context unwindComplete
				ifNil: [ context unwindComplete: true.
					unwindBlock := context unwindBlock.
					unwindBlock value ] ]
]

ContextPart >> withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
[withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
	"When using the debugger we want to run a method step by step. What what happens when we do a step into a CompiledMethod which has a primitive? If such a method is executed form outside the Debugger (normal scenario) the VM knows that such CompiledMethod has a primitive declaration and hence executes it. If it fails then it continues executing all the bytecode of the method. Otherwise, it just returns. 

Now, what is the problem with the Debugger? The problem is that if the primitive fail, we don't want that the VM directly executes all the remaining bytecodes of the method. Instead, we would like to go step by step witht he Debugger, just as happens with normal methods. 

To solve the mentioned problem, we use the following trick: We have the orignal compiled method (the one that has a primitive invokation), the receiver and the arguments. So the idea is to use a template compiled method that ONLY contains the primitive delcaration (it doesn't include all the smalltalk code after the primitive). #tryNamedPrimitiveTemplateMethod answers such a template method which looks like:

tryNamedPrimitive
	<primitive:'' module:''>
	^ ContextPart primitiveFailToken'

 Since this method does not change its bytecodes for every invokation, we can reuse it for all methods with primitives. There are only 2 things we have to change in the template: the number of arguments and the primitive declaration (to use the correct primitive name and module name).

Then what we do is to run that compiled method with the receiver and arguments we have. The result is that we will be invoking almost the same original method but a slighly different version that does not have the smalltalk part after the primitive and that in contrast is sends #primitiveFailToken. If this method invokation does not fail, then the Debugger continues debugging the sender of the primitive method. In this case, the step in is the same as step over. If the primitive fails, then the debugger continues executing the smalltalk part after the primitive method. In this case, step in is a real step in.  "

	| theMethod |
	arguments size > 8
		ifTrue: [ ^ self class primitiveFailToken ].
	theMethod := self class tryNamedPrimitiveTemplateMethod.
	self setNumArgs: arguments size toMethod: theMethod.
	theMethod == nil
		ifTrue: [ ^ self class primitiveFailToken ].
	self setNamedPrimitiveInformationFrom: aCompiledMethod toMethod: theMethod.
	theMethod flushCache.
	^ theMethod valueWithReceiver: aReceiver arguments: arguments
]

ContextPart class >> basicNew: size
[basicNew: size
	self error: 'Contexts must only be created with newForMethod:'
]

ContextPart class >> carefullyPrint: anObject on: aStream
[carefullyPrint: anObject on: aStream
	aStream nextPutAll: ([ anObject printString ]
				on: Error
				do: [ 'unprintable ' , anObject class name ])
]

ContextPart class >> contextEnsure: block
[contextEnsure: block
	"Create an #ensure: context that is ready to return from executing its receiver"

	| ctxt chain |
	ctxt := thisContext.
	[ chain := thisContext sender cut: ctxt.
	ctxt jump ]
		ensure: block.	"jump above will resume here without unwinding chain"
	^ chain
]

ContextPart class >> contextOn: exceptionClass do: block
[contextOn: exceptionClass do: block
	"Create an #on:do: context that is ready to return from executing its receiver"

	| ctxt chain |
	ctxt := thisContext.
	[ chain := thisContext sender cut: ctxt.
	ctxt jump ]
		on: exceptionClass
		do: block.	"jump above will resume here without unwinding chain"
	^ chain
]

ContextPart class >> initialize
[initialize
	"A unique object to be returned when a primitive fails during simulation"

	PrimitiveFailToken := Object new.
	self initializeTryNamedPrimitiveTemplateMethod.
	SpecialPrimitiveSimulators := nil.
	QuickStep := nil
]

ContextPart class >> initializePrimitiveSimulators
[initializePrimitiveSimulators
	"extra primitive simulators can be registered by implementing
	#registerPrimitiveSimulators method in class side of your class.
	 "

	SpecialPrimitiveSimulators := Dictionary new.
	Class
		allSubclassesDo: [ :metaclass | (metaclass includesSelector: #registerPrimitiveSimulators)
				ifTrue: [ metaclass theNonMetaClass registerPrimitiveSimulators ] ]
]

ContextPart class >> initializeTryNamedPrimitiveTemplateMethod
[initializeTryNamedPrimitiveTemplateMethod
	| source method |
	source := 'tryNamedPrimitive	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ ContextPart primitiveFailTokenFor: errorCode'.
	method := Smalltalk compiler
		class: UndefinedObject;
		source: source;
		compile.
	TryNamedPrimitiveTemplateMethod := method copyWithSource: source
]

ContextPart class >> new
[new
	self error: 'Contexts must only be created with newForMethod:'
]

ContextPart class >> new: size
[new: size
	self error: 'Contexts must only be created with newForMethod:'
]

ContextPart class >> newForMethod: aMethod
[newForMethod: aMethod
	"This is the only method for creating new contexts, other than primitive cloning.
	Any other attempts, such as inherited methods like shallowCopy, should be
	avoided or must at least be rewritten to determine the proper size from the
	method being activated.  This is because asking a context its size (even basicSize!)
	will not return the real object size but only the number of fields currently
	accessible, as determined by stackp."

	^ super basicNew: aMethod frameSize
]

ContextPart class >> primitiveFailToken
[primitiveFailToken
	^ self primitiveFailTokenFor: nil
]

ContextPart class >> primitiveFailTokenFor: errorCode
[primitiveFailTokenFor: errorCode
	^ {PrimitiveFailToken.
	errorCode}
]

ContextPart class >> runSimulated: aBlock
[runSimulated: aBlock
	"Simulate the execution of the argument, current. Answer the result it 
	returns."

	^ thisContext sender runSimulated: aBlock contextAtEachStep: [ :ignored |  ]	"ContextPart runSimulated: [Pen new defaultNib: 5; go: 100]"
]

ContextPart class >> simulatePrimitive: primName module: moduleName with: simulator
[simulatePrimitive: primName module: moduleName with: simulator
	^ self specialPrimitiveSimulators at: {primName.
			moduleName} put: simulator
]

ContextPart class >> simulatePrimitiveNumber: num with: simulator
[simulatePrimitiveNumber: num with: simulator
	^ self specialPrimitiveSimulators at: num put: simulator
]

ContextPart class >> specialPrimitiveSimulators
[specialPrimitiveSimulators
	SpecialPrimitiveSimulators ifNil: [ self initializePrimitiveSimulators ].
	^ SpecialPrimitiveSimulators
]

ContextPart class >> tallyInstructions: aBlock
[tallyInstructions: aBlock
	"This method uses the simulator to count the number of occurrences of
	each of the Smalltalk instructions executed during evaluation of aBlock.
	Results appear in order of the byteCode set."

	| tallies |
	tallies := Bag new.
	thisContext sender runSimulated: aBlock contextAtEachStep: [ :current | tallies add: current nextByte ].
	^ tallies sortedElements	"ContextPart tallyInstructions: [3.14159 printString]"
]

ContextPart class >> tallyMethods: aBlock
[tallyMethods: aBlock
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. Results are given in order of decreasing counts."

	| prev tallies |
	tallies := Bag new.
	prev := aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep: [ :current | current == prev
				ifFalse: [ "call or return"
					prev sender ifNotNil: [ "call only"
							tallies add: current printString ].
					prev := current ] ].
	^ tallies sortedCounts	"ContextPart tallyMethods: [3.14159 printString]"
]

ContextPart class >> theReturnMethod
[theReturnMethod
	| meth |
	meth := self lookupSelector: #return:.
	meth isPrimitive
		ifTrue: [ ^ self error: 'expected #return: to not be a primitive' ].
	^ meth
]

ContextPart class >> trace: aBlock
[trace: aBlock
	"ContextPart trace: [3 factorial]"

	"This method uses the simulator to print calls and returned values in the Transcript."

	Transcript clear.
	^ self trace: aBlock on: Transcript
]

ContextPart class >> trace: aBlock on: aStream
[trace: aBlock on: aStream
	"ContextPart trace: [3 factorial]"

	"This method uses the simulator to print calls to a file."

	| prev |
	prev := aBlock.
	^ thisContext sender
		runSimulated: aBlock
		contextAtEachStep: [ :current | 
			Sensor anyButtonPressed
				ifTrue: [ ^ nil ].
			current == prev
				ifFalse: [ 
					prev sender
						ifNil: [ 
							"Following does not work anymore due to closures?"
							"						aStream space; nextPut: $^.						self carefullyPrint: current top on: aStream						"
							 ].
					aStream cr.
					(current depthBelow: aBlock) timesRepeat: [ aStream space ].
					self carefullyPrint: current receiver on: aStream.
					aStream
						space;
						nextPutAll: current selector;
						flush.
					prev := current ] ]
]

ContextPart class >> trace: aBlock onFileNamed: fileName
[trace: aBlock onFileNamed: fileName
	"ContextPart trace: [3 factorial] onFileNamed: 'trace'"

	"This method uses the simulator to print calls to a file."

	| aStream |
	^ [ aStream := FileStream fileNamed: fileName.
	self trace: aBlock on: aStream ]
		ensure: [ aStream close ]
]

ContextPart class >> tryNamedPrimitiveTemplateMethod
[tryNamedPrimitiveTemplateMethod
	^ TryNamedPrimitiveTemplateMethod
]

