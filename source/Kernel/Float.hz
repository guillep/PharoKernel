Float
	superclass: #Number;
	instanceSpecification: #(#variable #words );
	classVariables: #(#RadiansPerDegree #Twopi #Epsilon #Infinity #Ln10 #ThreePi #MaxValLn #NegativeInfinity #Halfpi #NegativeZero #Ln2 #NaN #MaxVal #MinValLogBase2 #Pi #E #Sqrt2 );
	package: #Kernel.

Float >> * aNumber
[* aNumber
	"Primitive. Answer the result of multiplying the receiver by aNumber.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 49>
	^ aNumber adaptToFloat: self andSend: #*
]

Float >> + aNumber
[+ aNumber
	"Primitive. Answer the sum of the receiver and aNumber. Essential.
	Fail if the argument is not a Float. See Object documentation
	whatIsAPrimitive."

	<primitive: 41>
	^ aNumber adaptToFloat: self andSend: #+
]

Float >> - aNumber
[- aNumber
	"Primitive. Answer the difference between the receiver and aNumber.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 42>
	^ aNumber adaptToFloat: self andSend: #-
]

Float >> / aNumber
[/ aNumber
	"Primitive. Answer the result of dividing receiver by aNumber.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 50>
	aNumber = 0.0
		ifTrue: [ ZeroDivide signalWithDividend: self ].
	^ aNumber adaptToFloat: self andSend: #/
]

Float >> < aNumber
[< aNumber
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is less than the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 43>
	^ aNumber adaptToFloat: self andCompare: #<
]

Float >> <= aNumber
[<= aNumber
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is less than or equal to the argument. Otherwise return
	false. Fail if the argument is not a Float. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 45>
	^ aNumber adaptToFloat: self andCompare: #<=
]

Float >> = aNumber
[= aNumber
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is equal to the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 47>
	aNumber isNumber
		ifFalse: [ ^ false ].
	^ aNumber adaptToFloat: self andCompare: #=
]

Float >> > aNumber
[> aNumber
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is greater than the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 44>
	^ aNumber adaptToFloat: self andCompare: #>
]

Float >> >= aNumber
[>= aNumber
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is greater than or equal to the argument. Otherwise return
	false. Fail if the argument is not a Float. Optional. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 46>
	^ aNumber adaptToFloat: self andCompare: #>=
]

Float >> abs
[abs
	"This is faster than using Number abs and works for negativeZero."

	self <= 0.0
		ifTrue: [ ^ 0.0 - self ]
		ifFalse: [ ^ self ]
]

Float >> absPrintExactlyOn: aStream base: base
[absPrintExactlyOn: aStream base: base
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	This version guarantees that the printed representation exactly represents my value
	by using exact integer arithmetic."

	| fBase significand exp baseExpEstimate be be1 r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount |
	self isInfinite
		ifTrue: [ aStream nextPutAll: 'Float infinity'.
			^ self ].
	fBase := base asFloat.
	significand := self significandAsInteger.
	roundingIncludesLimits := significand even.
	exp := self exponent - 52 max: MinValLogBase2.
	baseExpEstimate := (self exponent * fBase reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue: [ be := 1 << exp.
			significand ~= 16r10000000000000
				ifTrue: [ r := significand * be * 2.
					s := 2.
					mPlus := be ]
				ifFalse: [ be1 := be * 2.
					r := significand * be1 * 2.
					s := 4.
					mPlus := be1 ].
			mMinus := be ]
		ifFalse: [ exp = MinValLogBase2 | (significand ~= 16r10000000000000)
				ifTrue: [ r := significand * 2.
					s := (1 << exp negated) * 2.
					mPlus := 1 ]
				ifFalse: [ r := significand * 4.
					s := (1 << (exp negated + 1)) * 2.
					mPlus := 2 ].
			mMinus := 1 ].
	baseExpEstimate >= 0
		ifTrue: [ s := s * (base raisedToInteger: baseExpEstimate) ]
		ifFalse: [ scale := base raisedToInteger: baseExpEstimate negated.
			r := r * scale.
			mPlus := mPlus * scale.
			mMinus := mMinus * scale ].
	r + mPlus > s | (roundingIncludesLimits & (r + mPlus = s))
		ifTrue: [ baseExpEstimate := baseExpEstimate + 1 ]
		ifFalse: [ r := r * base.
			mPlus := mPlus * base.
			mMinus := mMinus * base ].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue: [ decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [ aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate) ] ]
		ifFalse: [ decPointCount := 1 ].
	[ d := r // s.
	r := r \\ s.
	(tc1 := r < mMinus | (roundingIncludesLimits & (r = mMinus)))
		| (tc2 := r + mPlus > s | (roundingIncludesLimits & (r + mPlus = s))) ]
		whileFalse: [ aStream nextPut: (Character digitValue: d).
			r := r * base.
			mPlus := mPlus * base.
			mMinus := mMinus * base.
			decPointCount := decPointCount - 1.
			decPointCount = 0
				ifTrue: [ aStream nextPut: $. ] ].
	tc2
		ifTrue: [ tc1 not | (tc1 & (r * 2 >= s))
				ifTrue: [ d := d + 1 ] ].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue: [ decPointCount - 1 to: 1 by: -1 do: [ :i | aStream nextPut: $0 ].
			aStream nextPutAll: '.0' ].
	fixedFormat
		ifFalse: [ aStream nextPut: $e.
			aStream nextPutAll: (baseExpEstimate - 1) printString ]
]

Float >> absPrintInexactlyOn: aStream base: base
[absPrintInexactlyOn: aStream base: base
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	This version performs all calculations with Floats instead of LargeIntegers, and loses
	about 3 lsbs of accuracy compared to an exact conversion."

	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |
	self isInfinite
		ifTrue: [ aStream nextPutAll: 'Float infinity'.
			^ self ].
	significantBits := 50.	"approximately 3 lsb's of accuracy loss during conversion"
	fBase := base asFloat.
	exp := self exponent.
	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue: [ r := self.
			s := 1.0.
			mPlus := 1.0 timesTwoPower: exp - significantBits.
			mMinus := self significand ~= 1.0
				ifTrue: [ mPlus ]
				ifFalse: [ mPlus / 2.0 ] ]
		ifFalse: [ r := self timesTwoPower: significantBits.
			s := 1.0 timesTwoPower: significantBits.
			mMinus := 1.0 timesTwoPower: (exp max: -1024).
			mPlus := exp = MinValLogBase2 | (self significand ~= 1.0)
				ifTrue: [ mMinus ]
				ifFalse: [ mMinus * 2.0 ] ].
	baseExpEstimate >= 0
		ifTrue: [ s := s * (fBase raisedToInteger: baseExpEstimate).
			exp = 1023
				ifTrue: [ "scale down to prevent overflow to Infinity during conversion"
					r := r / fBase.
					s := s / fBase.
					mPlus := mPlus / fBase.
					mMinus := mMinus / fBase ] ]
		ifFalse: [ exp < -1023
				ifTrue: [ "scale up to prevent denorm reciprocals overflowing to Infinity"
					d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.
					scale := fBase raisedToInteger: d.
					r := r * scale.
					mPlus := mPlus * scale.
					mMinus := mMinus * scale.
					scale := fBase raisedToInteger: (baseExpEstimate + d) negated ]
				ifFalse: [ scale := fBase raisedToInteger: baseExpEstimate negated ].
			s := s / scale ].
	r + mPlus >= s
		ifTrue: [ baseExpEstimate := baseExpEstimate + 1 ]
		ifFalse: [ s := s / fBase ].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue: [ decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [ aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate) ] ]
		ifFalse: [ decPointCount := 1 ].
	[ d := (r / s) truncated.
	r := r - (d * s).
	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s) ]
		whileFalse: [ aStream nextPut: (Character digitValue: d).
			r := r * fBase.
			mPlus := mPlus * fBase.
			mMinus := mMinus * fBase.
			decPointCount := decPointCount - 1.
			decPointCount = 0
				ifTrue: [ aStream nextPut: $. ] ].
	tc2
		ifTrue: [ tc1 not | (tc1 & (r * 2.0 >= s))
				ifTrue: [ d := d + 1 ] ].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue: [ decPointCount - 1 to: 1 by: -1 do: [ :i | aStream nextPut: $0 ].
			aStream nextPutAll: '.0' ].
	fixedFormat
		ifFalse: [ aStream nextPut: $e.
			aStream nextPutAll: (baseExpEstimate - 1) printString ]
]

Float >> absPrintOn: aStream base: base digitCount: digitCount
[absPrintOn: aStream base: base digitCount: digitCount
	"Print me in the given base, using digitCount significant figures."

	| fuzz x exp q fBase scale logScale xi |
	self isInfinite
		ifTrue: [ ^ aStream nextPutAll: 'Infinity' ].
	fBase := base asFloat.	"x is myself normalized to [1.0, fBase), exp is my exponent"
	exp := self < 1.0
		ifTrue: [ self reciprocalFloorLog: fBase ]
		ifFalse: [ self floorLog: fBase ].
	scale := 1.0.
	logScale := 0.
	[ (x := fBase raisedTo: exp + logScale) = 0 ] whileTrue: [ scale := scale * fBase.
			logScale := logScale + 1 ].
	x := self * scale / x.
	fuzz := fBase raisedTo: 1 - digitCount.	"round the last digit to be printed"
	x := 0.5 * fuzz + x.
	x >= fBase
		ifTrue: [ "check if rounding has unnormalized x"
			x := x / fBase.
			exp := exp + 1 ].
	(exp < 6 and: [ exp > -4 ])
		ifTrue: [ "decimal notation"
			q := 0.
			exp < 0
				ifTrue: [ 1 to: 1 - exp do: [ :i | aStream nextPut: ('0.0000' at: i) ] ] ]
		ifFalse: [ "scientific notation"
			q := exp.
			exp := 0 ].
	[ x >= fuzz ]
		whileTrue: [ "use fuzz to track significance"
			xi := x asInteger.
			aStream nextPut: (Character digitValue: xi).
			x := (x - xi asFloat) * fBase.
			fuzz := fuzz * fBase.
			exp := exp - 1.
			exp = -1
				ifTrue: [ aStream nextPut: $. ] ].
	[ exp >= -1 ] whileTrue: [ aStream nextPut: $0.
			exp := exp - 1.
			exp = -1
				ifTrue: [ aStream nextPut: $. ] ].
	q ~= 0
		ifTrue: [ aStream nextPut: $e.
			q printOn: aStream ]
]

Float >> adaptToFraction: rcvr andCompare: selector
[adaptToFraction: rcvr andCompare: selector
	"If I am involved in comparison with a Fraction, convert myself to a
	Fraction. This way, no bit is lost and comparison is exact."

	self isFinite
		ifFalse: [ selector == #=
				ifTrue: [ ^ false ].
			selector == #~=
				ifTrue: [ ^ true ].
			self isNaN
				ifTrue: [ ^ false ].
			(selector = #< or: [ selector = #<= ])
				ifTrue: [ ^ self positive ].
			(selector = #> or: [ selector = #>= ])
				ifTrue: [ ^ self positive not ].
			^ self error: 'unknow comparison selector' ].	"Try to avoid asTrueFraction because it can cost"
	selector == #=
		ifTrue: [ rcvr denominator isPowerOfTwo
				ifFalse: [ ^ false ] ].
	selector == #~=
		ifTrue: [ rcvr denominator isPowerOfTwo
				ifFalse: [ ^ true ] ].
	^ rcvr perform: selector with: self asTrueFraction
]

Float >> adaptToFraction: rcvr andSend: selector
[adaptToFraction: rcvr andSend: selector
	"If I am involved in arithmetic with a Fraction, convert it to a Float."

	^ rcvr asFloat perform: selector with: self
]

Float >> adaptToInteger: rcvr andCompare: selector
[adaptToInteger: rcvr andCompare: selector
	"If I am involved in comparison with an Integer, convert myself to a
	Fraction. This way, no bit is lost and comparison is exact."

	self isFinite
		ifFalse: [ selector == #=
				ifTrue: [ ^ false ].
			selector == #~=
				ifTrue: [ ^ true ].
			self isNaN
				ifTrue: [ ^ false ].
			(selector = #< or: [ selector = #<= ])
				ifTrue: [ ^ self positive ].
			(selector = #> or: [ selector = #>= ])
				ifTrue: [ ^ self positive not ].
			^ self error: 'unknow comparison selector' ].	"Try to avoid asTrueFraction because it can cost"
	selector == #=
		ifTrue: [ self fractionPart = 0.0
				ifFalse: [ ^ false ] ].
	selector == #~=
		ifTrue: [ self fractionPart = 0.0
				ifFalse: [ ^ true ] ].
	^ rcvr perform: selector with: self asTrueFraction
]

Float >> adaptToInteger: rcvr andSend: selector
[adaptToInteger: rcvr andSend: selector
	"If I am involved in arithmetic with an Integer, convert it to a Float."

	^ rcvr asFloat perform: selector with: self
]

Float >> arcCos
[arcCos
	"Answer the angle in radians."

	^ Halfpi - self arcSin
]

Float >> arcSin
[arcSin
	"Answer the angle in radians."

	(self < -1.0 or: [ self > 1.0 ])
		ifTrue: [ ^ DomainError signal: 'Value out of range' from: -1 to: 1 ].
	(self = -1.0 or: [ self = 1.0 ])
		ifTrue: [ ^ Halfpi * self ]
		ifFalse: [ ^ (self / (1.0 - (self * self)) sqrt) arcTan ]
]

Float >> arcTan
[arcTan
	"Answer the angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 57>
	| theta eps step sinTheta cosTheta |
	self < 0.0
		ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"Newton-Raphson"	"first guess"
	theta := self * Halfpi / (self + 1.0).	"iterate"
	eps := Halfpi * Epsilon.
	step := theta.
	[ step * step > eps ]
		whileTrue: [ sinTheta := theta sin.
			cosTheta := theta cos.
			step := sinTheta * cosTheta - (self * cosTheta * cosTheta).
			theta := theta - step ].
	^ theta
]

Float >> arcTan: denominator
[arcTan: denominator
	"Answer the angle in radians.
	 Optional. See Object documentation whatIsAPrimitive.
	Implementation note: use sign in order to catch cases of negativeZero"

	^ self = 0.0
		ifTrue: [ denominator sign >= 0
				ifTrue: [ 0 ]
				ifFalse: [ self sign >= 0
						ifTrue: [ Pi ]
						ifFalse: [ Pi negated ] ] ]
		ifFalse: [ denominator = 0.0
				ifTrue: [ self > 0.0
						ifTrue: [ Halfpi ]
						ifFalse: [ Halfpi negated ] ]
				ifFalse: [ denominator > 0
						ifTrue: [ (self / denominator) arcTan ]
						ifFalse: [ self > 0
								ifTrue: [ (self / denominator) arcTan + Pi ]
								ifFalse: [ (self / denominator) arcTan - Pi ] ] ] ]
]

Float >> asApproximateFraction
[asApproximateFraction
	"Answer a Fraction approximating the receiver. This conversion uses the 
	continued fraction method to approximate a floating point number."

	^ self asApproximateFractionAtOrder: 0
]

Float >> asApproximateFractionAtOrder: maxOrder
[asApproximateFractionAtOrder: maxOrder
	"Answer a Fraction approximating the receiver. This conversion uses the 
	continued fraction method to approximate a floating point number. If maxOrder
	is zero, use maximum order"

	| num1 denom1 num2 denom2 int frac newD temp order |
	num1 := self asInteger.	"The first of two alternating numerators"
	denom1 := 1.	"The first of two alternating denominators"
	num2 := 1.	"The second numerator"
	denom2 := 0.	"The second denominator--will update"
	int := num1.	"The integer part of self"
	frac := self fractionPart.	"The fractional part of self"
	order := maxOrder = 0
		ifTrue: [ -1 ]
		ifFalse: [ maxOrder ].
	[ frac = 0 or: [ order = 0 ] ]
		whileFalse: [ 
			"repeat while the fractional part is not zero and max order is not reached"
			order := order - 1.
			newD := 1.0 / frac.	"Take reciprocal of the fractional part"
			int := newD asInteger.	"get the integer part of this"
			frac := newD fractionPart.	"and save the fractional part for next time"
			temp := num2.	"Get old numerator and save it"
			num2 := num1.	"Set second numerator to first"
			num1 := num1 * int + temp.	"Update first numerator"
			temp := denom2.	"Get old denominator and save it"
			denom2 := denom1.	"Set second denominator to first"
			denom1 := int * denom1 + temp.	"Update first denominator"
			10000000000.0 < denom1
				ifTrue: [ 
					"Is ratio past float precision?  If so, pick which 					of the two ratios to use"
					num2 = 0.0
						ifTrue: [ "Is second denominator 0?"
							^ Fraction numerator: num1 denominator: denom1 ].
					^ Fraction numerator: num2 denominator: denom2 ] ].	"If fractional part is zero, return the first ratio"
	denom1 = 1
		ifTrue: [ "Am I really an Integer?"
			^ num1	"Yes, return Integer result" ]
		ifFalse: [ "Otherwise return Fraction result"
			^ Fraction numerator: num1 denominator: denom1 ]
]

Float >> asFloat
[asFloat
	"Answer the receiver itself."

	^ self
]

Float >> asFraction
[asFraction
	^ self asTrueFraction
]

Float >> asIEEE32BitWord
[asIEEE32BitWord
	"Convert the receiver into a 32 bit Integer value representing the same number in IEEE 32 bit format.
	Used for conversion in FloatArrays only."

	| word1 word2 sign mantissa exponent destWord truncatedBits mask roundToUpper |
	"skip fast positive and nnegative zero"
	self = 0.0
		ifTrue: [ ^ self basicAt: 1 ].	"retrieve 64 bits of IEEE 754 double"
	word1 := self basicAt: 1.
	word2 := self basicAt: 2.	"prepare sign exponent and mantissa of 32 bits float"
	sign := word1 bitAnd: 16r80000000.
	exponent := ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.
	mantissa := (word2 bitShift: -29) + ((word1 bitAnd: 16rFFFFF) bitShift: 3).
	truncatedBits := word2 bitAnd: 16r1FFFFFFF.	"We must now honour default IEEE rounding mode (round to nearest even)"	"we are below gradual underflow, even if rounded to upper mantissa"
	exponent < -24
		ifTrue: [ ^ sign	"this can be negative zero" ].	"BEWARE: rounding occurs on less than 23bits when gradual underflow"
	exponent <= 0
		ifTrue: [ mask := 1 bitShift: exponent negated.
			mantissa := mantissa bitOr: 16r800000.
			roundToUpper := (mantissa bitAnd: mask) isZero not
				and: [ truncatedBits isZero not or: [ (mantissa bitAnd: mask - 1) isZero not or: [ (mantissa bitAnd: mask * 2) isZero not ] ] ].
			mantissa := mantissa bitShift: exponent - 1	"exponent := exponent + 1" ]
		ifFalse: [ roundToUpper := (truncatedBits bitAnd: 16r10000000) isZero not
				and: [ (mantissa bitAnd: 16r1) isZero not or: [ (truncatedBits bitAnd: 16r0FFFFFFF) isZero not ] ] ].	"adjust mantissa and exponent due to IEEE rounding mode"
	roundToUpper
		ifTrue: [ mantissa := mantissa + 1.
			mantissa > 16r7FFFFF
				ifTrue: [ mantissa := 0.
					exponent := exponent + 1 ] ].
	exponent > 254
		ifTrue: [ "Overflow"
			exponent := 255.
			self isNaN
				ifTrue: [ mantissa isZero
						ifTrue: [ "BEWARE: do not convert a NaN to infinity due to truncatedBits"
							mantissa := 1 ] ]
				ifFalse: [ mantissa := 0 ] ].	"Encode the word"
	destWord := (sign bitOr: ((exponent max: 0) bitShift: 23)) bitOr: mantissa.
	^ destWord
]

Float >> asMinimalDecimalFraction
[asMinimalDecimalFraction
	"Answer the shortest decimal Fraction that will equal self when converted back asFloat.
	A decimal Fraction has only powers of 2 and 5 as decnominator.
	For example, 0.1 asMinimalDecimalFraction = (1/10)."

	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead denominator numerator |
	self isFinite
		ifFalse: [ self error: 'Only finite Float can be converted to a Fraction' ].
	self = 0.0
		ifTrue: [ ^ 0 ].
	self < 0.0
		ifTrue: [ ^ self negated asMinimalDecimalFraction negated ].
	numerator := 0.
	denominator := 0.
	significand := self significandAsInteger.
	roundingIncludesLimits := significand even.
	exp := self exponent - 52 max: MinValLogBase2.
	baseExpEstimate := (self exponent * 10 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue: [ significand ~= 16r10000000000000
				ifTrue: [ r := significand bitShift: 1 + exp.
					s := 2.
					mPlus := mMinus := 1 bitShift: exp ]
				ifFalse: [ r := significand bitShift: 2 + exp.
					s := 4.
					mPlus := 2 * (mMinus := 1 bitShift: exp) ] ]
		ifFalse: [ (exp = MinValLogBase2 or: [ significand ~= 16r10000000000000 ])
				ifTrue: [ r := significand bitShift: 1.
					s := 1 bitShift: 1 - exp.
					mPlus := mMinus := 1 ]
				ifFalse: [ r := significand bitShift: 2.
					s := 1 bitShift: 2 - exp.
					mPlus := 2.
					mMinus := 1 ] ].
	baseExpEstimate >= 0
		ifTrue: [ s := s * (10 raisedToInteger: baseExpEstimate) ]
		ifFalse: [ scale := 10 raisedToInteger: baseExpEstimate negated.
			r := r * scale.
			mPlus := mPlus * scale.
			mMinus := mMinus * scale ].
	((r + mPlus < s) not and: [ roundingIncludesLimits or: [ r + mPlus > s ] ])
		ifTrue: [ baseExpEstimate := baseExpEstimate + 1 ]
		ifFalse: [ r := r * 10.
			mPlus := mPlus * 10.
			mMinus := mMinus * 10 ].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue: [ decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [ denominator := 10 raisedTo: baseExpEstimate negated ] ]
		ifFalse: [ decPointCount := 1 ].
	slowbit := 1 - s lowBit.
	shead := s bitShift: slowbit.
	[ d := (r bitShift: slowbit) // shead.
	r := r - (d * s).
	(tc1 := (r > mMinus) not and: [ roundingIncludesLimits or: [ r < mMinus ] ])
		| (tc2 := (r + mPlus < s) not and: [ roundingIncludesLimits or: [ r + mPlus > s ] ]) ]
		whileFalse: [ numerator := 10 * numerator + d.
			denominator := 10 * denominator.
			r := r * 10.
			mPlus := mPlus * 10.
			mMinus := mMinus * 10.
			decPointCount := decPointCount - 1.
			decPointCount = 0
				ifTrue: [ denominator := 1 ] ].
	tc2
		ifTrue: [ (tc1 not or: [ r * 2 >= s ])
				ifTrue: [ d := d + 1 ] ].
	numerator := 10 * numerator + d.
	denominator := 10 * denominator.
	decPointCount > 0
		ifTrue: [ numerator := (10 raisedTo: decPointCount - 1) * numerator ].
	fixedFormat
		ifFalse: [ baseExpEstimate - 1 > 0
				ifTrue: [ numerator := (10 raisedTo: baseExpEstimate - 1) * numerator ]
				ifFalse: [ denominator := (10 raisedTo: 1 - baseExpEstimate) * (denominator max: 1) ] ].
	denominator < 2
		ifTrue: [ ^ numerator ].
	^ numerator / denominator
]

Float >> asTrueFraction
[asTrueFraction
	" Answer a fraction that EXACTLY represents self,
	  a double precision IEEE floating point number.
	  Floats are stored in the same form on all platforms.
	  (Does handle gradual underflow but not NANs.)
	  By David N. Smith with significant performance
	  improvements by Luciano Esteban Notarfrancesco.
	  (Version of 11April97)"

	| signexp positive expPart exp fraction fractionPart signedFraction result zeroBitsCount |
	self isInfinite
		ifTrue: [ self error: 'Cannot represent infinity as a fraction' ].
	self isNaN
		ifTrue: [ self error: 'Cannot represent Not-a-Number as a fraction' ].	" Extract the sign and the biased exponent "
	signexp := (self basicAt: 1) bitShift: -20.
	positive := (signexp bitAnd: 16r800) = 0.
	expPart := signexp bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "
	fractionPart := (((self basicAt: 1) bitAnd: 16rFFFFF) bitShift: 32) + (self basicAt: 2).
	(expPart = 0 and: [ fractionPart = 0 ])
		ifTrue: [ ^ 0 ].	" Replace omitted leading 1 in fraction unless gradual underflow"
	fraction := expPart = 0
		ifTrue: [ fractionPart bitShift: 1 ]
		ifFalse: [ fractionPart bitOr: 16r0010000000000000 ].
	signedFraction := positive
		ifTrue: [ fraction ]
		ifFalse: [ fraction negated ].	"Unbias exponent: 16r3FF is bias; 52 is fraction width"
	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "
	exp negative
		ifTrue: [ result := signedFraction bitShift: exp negated ]
		ifFalse: [ 
			zeroBitsCount := fraction lowBit - 1.
			exp := exp - zeroBitsCount.
			exp <= 0
				ifTrue: [ 
					zeroBitsCount := zeroBitsCount + exp.	"exp := 0."	" Not needed; exp notrefernced again "
					result := signedFraction bitShift: zeroBitsCount negated ]
				ifFalse: [ result := Fraction numerator: (signedFraction bitShift: zeroBitsCount negated) denominator: (1 bitShift: exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."
	^ result
]

Float >> at: index
[at: index
	^ self basicAt: index
]

Float >> at: index put: value
[at: index put: value
	^ self basicAt: index put: value
]

Float >> basicAt: index
[basicAt: index
	"Primitive. Assumes receiver is indexable. Answer the value of an 
	indexable element in the receiver. Fail if the argument index is not an 
	Integer or is out of bounds. Essential. Do not override in a subclass. See 
	Object documentation whatIsAPrimitive.

	This version of basicAt: is specifically for floats, answering the most significant
	word for index 1 and the least significant word for index 2.  This alows the VM
	to store floats in whatever order it chooses while it appears to the image that
	they are always in big-endian/PowerPC order."

	<primitive: 38>
	^ super basicAt: index
]

Float >> basicAt: index put: value
[basicAt: index put: value
	"Primitive. Assumes receiver is indexable. Store the second argument 
	value in the indexable element of the receiver indicated by index. Fail 
	if the index is not an Integer or is out of bounds. Or fail if the value is 
	not of the right type for this kind of collection. Answer the value that 
	was stored. Essential. Do not override in a subclass. See Object 
	documentation whatIsAPrimitive.

	This version of basicAt: is specifically for floats, answering the most significant
	word for index 1 and the least significant word for index 2.  This alows the VM
	to store floats in whatever order it chooses while it appears to the image that
	they are always in big-endian/PowerPC order."

	<primitive: 39>
	^ super basicAt: index put: value
]

Float >> closeTo: num
[closeTo: num
	"are these two numbers close?"

	num isNumber
		ifFalse: [ ^ [ self = num ] ifError: [ false ] ].
	self = 0.0
		ifTrue: [ ^ num abs < 0.0001 ].
	num = 0
		ifTrue: [ ^ self abs < 0.0001 ].
	^ self = num asFloat or: [ (self - num) abs / (self abs max: num abs) < 0.0001 ]
]

Float >> copySignTo: aNumber
[copySignTo: aNumber
	"Return a number with same magnitude as aNumber and same sign as self.
	Implementation note: take care of Float negativeZero, which is considered as having a negative sign."

	(self > 0.0 or: [ (self at: 1) = 0 ])
		ifTrue: [ ^ aNumber abs ].
	^ aNumber withNegativeSign
]

Float >> cos
[cos
	"Answer the cosine of the receiver taken as an angle in radians."

	^ (self + Halfpi) sin
]

Float >> deepCopy
[deepCopy
	^ self copy
]

Float >> degreeCos
[degreeCos
	"Take care of exceptional values"

	self isFinite
		ifTrue: [ ^ super degreeCos ].
	^ self degreesToRadians cos
]

Float >> degreeSin
[degreeSin
	"Take care of exceptional values"

	self isFinite
		ifTrue: [ ^ super degreeSin ].
	^ self degreesToRadians sin
]

Float >> degreesToRadians
[degreesToRadians
	"Answer the receiver in radians. Assumes the receiver is in degrees."

	^ self * RadiansPerDegree
]

Float >> exp
[exp
	"Answer E raised to the receiver power.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 59>
	| base fract correction delta div |
	self < 0.0
		ifTrue: [ ^ self negated exp reciprocal ].	"Taylor series"	"check the special cases"
	self = 0.0
		ifTrue: [ ^ 1 ].
	self abs > MaxValLn
		ifTrue: [ self error: 'exp overflow' ].	"get first approximation by raising e to integer power"
	base := E raisedToInteger: self truncated.	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"
	fract := self fractionPart.
	fract = 0.0
		ifTrue: [ ^ base ].	"no correction required"
	correction := 1.0 + fract.
	delta := fract * fract / 2.0.
	div := 2.0.
	[ delta > Epsilon ]
		whileTrue: [ correction := correction + delta.
			div := div + 1.0.
			delta := delta * fract / div ].
	correction := correction + delta.
	^ base * correction
]

Float >> exponent
[exponent
	"Primitive. Consider the receiver to be represented as a power of two
	multiplied by a mantissa (between one and two). Answer with the
	SmallInteger to whose power two is raised. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 53>
	| positive |
	self >= 1.0
		ifTrue: [ ^ self floorLog: 2 ].
	self > 0.0
		ifTrue: [ positive := (1.0 / self) exponent.
			self = (1.0 / (1.0 timesTwoPower: positive))
				ifTrue: [ ^ positive negated ]
				ifFalse: [ ^ positive negated - 1 ] ].
	self = 0.0
		ifTrue: [ ^ -1 ].
	^ self negated exponent
]

Float >> floorLog: radix
[floorLog: radix
	"Answer the floor of the log base radix of the receiver.
	The result may be off by one due to rounding errors, except in base 2."

	(radix = 2 and: [ self > 0.0 ])
		ifTrue: [ ^ self exponent ].
	^ (self log: radix) floor
]

Float >> fractionPart
[fractionPart
	"Primitive. Answer a Float whose value is the difference between the 
	receiver and the receiver's asInteger value. Optional. See Object 
	documentation whatIsAPrimitive."

	<primitive: 52>
	^ self - self truncated asFloat
]

Float >> hasContentsInExplorer
[hasContentsInExplorer
	^ false
]

Float >> hash
[hash
	"Hash is reimplemented because = is implemented. Both words of the float are used; 8 bits are removed from each end to clear most of the exponent regardless of the byte ordering. (The bitAnd:'s ensure that the intermediate results do not become a large integer.) Slower than the original version in the ratios 12:5 to 2:1 depending on values. (DNS, 11 May, 1997)"

	(self isFinite and: [ self fractionPart = 0.0 ])
		ifTrue: [ ^ self truncated hash ].
	^ ((self basicAt: 1) bitAnd: 16r00FFFF00) + ((self basicAt: 2) bitAnd: 16r00FFFF00) bitShift: -8
]

Float >> hex
[hex
	^ String
		streamContents: [ :strm | | word nibble |
			1 to: 2 do: [ :i | word := self at: i.
				1 to: 8 do: [ :s | nibble := (word bitShift: (-8 + s) * 4) bitAnd: 16rF.
					strm nextPut: ('0123456789ABCDEF' at: nibble + 1) ] ] ]	"(-2.0 to: 2.0) collect: [:f | f hex]"
]

Float >> integerPart
[integerPart
	"Answer a Float whose value is the receiver's truncated value."

	^ self - self fractionPart
]

Float >> isFinite
[isFinite
	"simple, byte-order independent test for rejecting Not-a-Number and (Negative)Infinity"

	^ self - self = 0.0
]

Float >> isFloat
[isFloat
	^ true
]

Float >> isInfinite
[isInfinite
	"Return true if the receiver is positive or negative infinity."

	^ self = Infinity or: [ self = NegativeInfinity ]
]

Float >> isLiteral
[isLiteral
	"There is no literal representation of NaN.
	However, there are literal representations of Infinity, like 1.0e1000.
	But since they are not able to print properly, only case of finite Float is considered."

	^ self isFinite
]

Float >> isNaN
[isNaN
	"simple, byte-order independent test for Not-a-Number"

	^ self ~= self
]

Float >> isPowerOfTwo
[isPowerOfTwo
	"Return true if the receiver is an integral power of two.
	Floats never return true here."

	^ false
]

Float >> isSelfEvaluating
[isSelfEvaluating
	^ true
]

Float >> isZero
[isZero
	^ self = 0.0
]

Float >> ln
[ln
	"Answer the natural logarithm of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 58>
	| expt n mant x div pow delta sum eps |
	self <= 0.0
		ifTrue: [ ^ DomainError signal: 'ln is only defined for x > 0' from: 0 ].	"Taylor series"	"get a rough estimate from binary exponent"
	expt := self exponent.
	n := Ln2 * expt.
	mant := self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"
	x := mant - 1.0.
	div := 1.0.
	pow := delta := sum := x.
	x := x negated.	"x <= 0"
	eps := Epsilon * (n abs + 1.0).
	[ delta > eps ]
		whileTrue: [ "pass one: delta is positive"
			div := div + 1.0.
			pow := pow * x.
			delta := pow / div.
			sum := sum + delta.	"pass two: delta is negative"
			div := div + 1.0.
			pow := pow * x.
			delta := pow / div.
			sum := sum + delta ].
	^ n + sum	"2.718284 ln 1.0"
]

Float >> log
[log
	"Answer the base 10 logarithm of the receiver."

	^ self ln / Ln10
]

Float >> negated
[negated
	"Answer a Number that is the negation of the receiver.
	Implementation note: this version cares of negativeZero."

	^ -1.0 * self
]

Float >> nthRoot: aPositiveInteger
[nthRoot: aPositiveInteger
	"Answer the nth root of the receiver."

	aPositiveInteger = 2
		ifTrue: [ ^ self sqrt ].
	(aPositiveInteger isInteger not or: [ aPositiveInteger negative ])
		ifTrue: [ ^ ArithmeticError signal: 'nth root only defined for positive Integer n.' ].
	^ self negative
		ifTrue: [ aPositiveInteger odd
				ifTrue: [ (self negated raisedTo: 1.0 / aPositiveInteger) negated ]
				ifFalse: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ] ]
		ifFalse: [ self raisedTo: 1.0 / aPositiveInteger ]
]

Float >> predecessor
[predecessor
	| ulp |
	self isFinite
		ifFalse: [ (self isNaN or: [ self negative ])
				ifTrue: [ ^ self ].
			^ Float fmax ].
	self = 0.0
		ifTrue: [ ^ Float fmin negated ].
	ulp := self ulp.
	^ self - (0.5 * ulp) = self
		ifTrue: [ self - ulp ]
		ifFalse: [ self - (0.5 * ulp) ]
]

Float >> printOn: stream base: base
[printOn: stream base: base
	"Handle sign, zero, and NaNs; all other values passed to FloatPrintPolicy"

	self isNaN
		ifTrue: [ ^ stream nextPutAll: 'Float nan' ].	"check for NaN before sign"
	self isInfinite
		ifTrue: [ stream nextPutAll: 'Float infinity'.
			^ self sign = -1
				ifTrue: [ stream nextPutAll: ' negated' ] ].
	self > 0.0
		ifTrue: [ FloatPrintPolicy absPrint: self on: stream base: base ]
		ifFalse: [ self sign = -1
				ifTrue: [ stream nextPut: $- ].
			self = 0.0
				ifTrue: [ stream nextPutAll: '0.0' ]
				ifFalse: [ FloatPrintPolicy absPrint: self negated on: stream base: base ] ]
]

Float >> printPaddedWith: aCharacter to: aNumber
[printPaddedWith: aCharacter to: aNumber
	"Answer the string containing the ASCII representation of the receiver 
	padded on the left with aCharacter to be at least on aNumber 
	integerPart characters and padded the right with aCharacter to be at 
	least anInteger fractionPart characters."

	| aStream digits fPadding fLen iPadding iLen curLen periodIndex |
	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"
	aStream := (String new: 10) writeStream.
	self printOn: aStream.
	digits := aStream contents.
	periodIndex := digits indexOf: $..
	curLen := periodIndex - 1.
	iLen := aNumber integerPart.
	curLen < iLen
		ifTrue: [ iPadding := (String new: (iLen - curLen) asInteger)
				atAllPut: aCharacter;
				yourself ]
		ifFalse: [ iPadding := '' ].
	curLen := digits size - periodIndex.	"n.b. Treat aNumber as a string format specifier rather than as a number, because	floating point truncation can produce incorrect results for the fraction part."
	fLen := (aNumber asString copyAfterLast: $.) ifNotEmpty: [ :s | s asInteger ] ifEmpty: [ 0 ].
	curLen < fLen
		ifTrue: [ fPadding := (String new: fLen - curLen)
				atAllPut: aCharacter;
				yourself ]
		ifFalse: [ fPadding := '' ].
	^ iPadding , digits , fPadding
]

Float >> printShowingDecimalPlaces: placesDesired
[printShowingDecimalPlaces: placesDesired
	"This implementation avoids any rounding error caused by rounded or roundTo:"

	^ self asTrueFraction printShowingDecimalPlaces: placesDesired
]

Float >> radiansToDegrees
[radiansToDegrees
	"Answer the receiver in degrees. Assumes the receiver is in radians."

	^ self / RadiansPerDegree
]

Float >> reciprocal
[reciprocal
	"Returns the reciprocal.
	If self is 0.0 the / signals a ZeroDivide"

	^ 1.0 / self
]

Float >> reciprocalFloorLog: radix
[reciprocalFloorLog: radix
	"Quick computation of (self log: radix) floor, when self < 1.0.
	Avoids infinite recursion problems with denormalized numbers"

	| adjust scale n |
	adjust := 0.
	scale := 1.0.
	[ (n := radix / (self * scale)) isInfinite ] whileTrue: [ scale := scale * radix.
			adjust := adjust + 1 ].
	^ ((n floorLog: radix) + adjust) negated
]

Float >> reciprocalLogBase2
[reciprocalLogBase2
	"optimized for self = 10, for use in conversion for printing"

	^ self = 10.0
		ifTrue: [ Ln2 / Ln10 ]
		ifFalse: [ Ln2 / self ln ]
]

Float >> reduce
[reduce
	"If self is close to an integer, return that integer"

	(self closeTo: self rounded)
		ifTrue: [ ^ self rounded ]
]

Float >> round: numberOfWishedDecimal
[round: numberOfWishedDecimal
	"only leave a fixed amount of decimal"

	"10.12345 round: 2 => 10.12"

	| v |
	v := 10 raisedTo: numberOfWishedDecimal.
	^ ((self * v) rounded / v) asFloat
]

Float >> rounded
[rounded
	"Answer the integer nearest the receiver.
	Implementation note: super would not handle tricky inexact arithmetic"

	"self assert: 5000000000000001.0 rounded = 5000000000000001"

	self fractionPart abs < 0.5
		ifTrue: [ ^ self truncated ]
		ifFalse: [ ^ self truncated + self sign rounded ]
]

Float >> safeArcCos
[safeArcCos
	"Answer the angle in radians."

	(self between: -1.0 and: 1.0)
		ifTrue: [ ^ self arcCos ]
		ifFalse: [ ^ self sign arcCos ]
]

Float >> shallowCopy
[shallowCopy
	^ self - 0.0
]

Float >> sign
[sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.
	Handle IEEE-754 negative-zero by reporting a sign of -1"

	self > 0
		ifTrue: [ ^ 1 ].
	(self < 0 or: [ ((self at: 1) bitShift: -31) = 1 ])
		ifTrue: [ ^ -1 ].
	^ 0
]

Float >> significand
[significand
	^ self timesTwoPower: self exponent negated
]

Float >> significandAsInteger
[significandAsInteger
	"Answer the mantissa of a Float shifted so as to have the ulp equal to 1.
	For exceptional values, infinity and nan, just answer the bit pattern."

	self isFinite
		ifTrue: [ ^ (self timesTwoPower: self class precision - 1 - (self exponent max: self class emin)) truncated abs ].
	^ (((self basicAt: 1) bitAnd: 16r000FFFFF) bitShift: 32) bitOr: (self basicAt: 2)
]

Float >> sin
[sin
	"Answer the sine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 56>
	| sum delta self2 i |
	self < 0.0
		ifTrue: [ ^ 0.0 - (0.0 - self) sin ].	"Taylor series"	"normalize to the range [0..Pi/2]"
	self > Twopi
		ifTrue: [ ^ (self \\ Twopi) sin ].
	self > Pi
		ifTrue: [ ^ 0.0 - (self - Pi) sin ].
	self > Halfpi
		ifTrue: [ ^ (Pi - self) sin ].	"unroll loop to avoid use of abs"
	sum := delta := self.
	self2 := 0.0 - (self * self).
	i := 2.0.
	[ delta > Epsilon ]
		whileTrue: [ "once"
			delta := delta * self2 / (i * (i + 1.0)).
			i := i + 2.0.
			sum := sum + delta.	"twice"
			delta := delta * self2 / (i * (i + 1.0)).
			i := i + 2.0.
			sum := sum + delta ].
	^ sum
]

Float >> sqrt
[sqrt
	"Answer the square root of the receiver. 
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 55>
	| exp guess eps delta |
	self <= 0.0
		ifTrue: [ self = 0.0
				ifTrue: [ ^ 0.0 ]
				ifFalse: [ "v Chg"
					^ DomainError signal: 'sqrt undefined for number less than zero.' ] ].	"Newton-Raphson"	"first guess is half the exponent"
	exp := self exponent // 2.
	guess := self timesTwoPower: 0 - exp.	"get eps value"
	eps := guess * Epsilon.
	eps := eps * eps.
	delta := (self - (guess * guess)) / (guess * 2.0).
	[ delta * delta > eps ] whileTrue: [ guess := guess + delta.
			delta := (self - (guess * guess)) / (guess * 2.0) ].
	^ guess
]

Float >> storeOn: aStream
[storeOn: aStream
	"Print the Number exactly so it can be interpreted back unchanged"

	self storeOn: aStream base: 10
]

Float >> storeOn: aStream base: base
[storeOn: aStream base: base
	"Print the Number exactly so it can be interpreted back unchanged"

	self isFinite
		ifTrue: [ self sign = -1
				ifTrue: [ aStream nextPutAll: '-' ].
			base = 10
				ifFalse: [ aStream
						print: base;
						nextPut: $r ].
			self = 0.0
				ifTrue: [ aStream nextPutAll: '0.0' ]
				ifFalse: [ self abs absPrintExactlyOn: aStream base: base ] ]
		ifFalse: [ self isNaN
				ifTrue: [ aStream nextPutAll: 'Float nan' ]
				ifFalse: [ self > 0.0
						ifTrue: [ aStream nextPutAll: 'Float infinity' ]
						ifFalse: [ aStream nextPutAll: 'Float infinity negated' ] ] ]
]

Float >> successor
[successor
	| ulp |
	self isFinite
		ifFalse: [ (self isNaN or: [ self positive ])
				ifTrue: [ ^ self ].
			^ Float fmax negated ].
	self = 0.0
		ifTrue: [ ^ Float fmin ].
	ulp := self ulp.
	^ self + (0.5 * ulp) = self
		ifTrue: [ self + ulp ]
		ifFalse: [ self + (0.5 * ulp) ]
]

Float >> tan
[tan
	"Answer the tangent of the receiver taken as an angle in radians."

	^ self sin / self cos
]

Float >> timesTwoPower: anInteger
[timesTwoPower: anInteger
	"Primitive. Answer with the receiver multiplied by 2.0 raised
	to the power of the argument.
	Optional. See Object documentation whatIsAPrimitive."

	<primitive: 54>
	anInteger < -29
		ifTrue: [ ^ self * (2.0 raisedToInteger: anInteger) ].
	anInteger < 0
		ifTrue: [ ^ self / (1 bitShift: 0 - anInteger) asFloat ].
	anInteger < 30
		ifTrue: [ ^ self * (1 bitShift: anInteger) asFloat ].
	^ self * (2.0 raisedToInteger: anInteger)
]

Float >> truncated
[truncated
	"Answer with a SmallInteger equal to the value of the receiver without 
	its fractional part. The primitive fails if the truncated value cannot be 
	represented as a SmallInteger. In that case, the code below will compute 
	a LargeInteger truncated value.
	Essential. See Object documentation whatIsAPrimitive. "

	<primitive: 51>
	(self isInfinite or: [ self isNaN ])
		ifTrue: [ self error: 'Cannot truncate this number' ].
	self abs < 2.0e16
		ifTrue: [ | di "Fastest way when it may not be an integer" "^ (self quo: 1073741823.0) * 1073741823 + (self rem: 1073741823.0) truncated" df q r |
			di := (SmallInteger maxVal bitShift: -1) + 1.
			df := di asFloat.
			q := self quo: df.
			r := self - (q asFloat * df).
			^ q * di + r truncated ]
		ifFalse: [ ^ self asTrueFraction	"Extract all bits of the mantissa and shift if necess" ]
]

Float >> ulp
[ulp
	"Answer the unit of least precision of self (the power of two corresponding to last bit of mantissa)"

	| exponent |
	self isFinite
		ifFalse: [ self isNaN
				ifTrue: [ ^ self ].
			^ Float infinity ].
	self = 0.0
		ifTrue: [ ^ Float fmin ].
	exponent := self exponent.
	^ exponent < self class emin
		ifTrue: [ Float fminDenormalized ]
		ifFalse: [ Float epsilon timesTwoPower: exponent ]
]

Float >> veryDeepCopyWith: deepCopier
[veryDeepCopyWith: deepCopier
	"Return self.  Do not record me."

	^ self shallowCopy
]

Float >> withNegativeSign
[withNegativeSign
	"Same as super, but handle the subtle case of Float negativeZero"

	self = 0.0
		ifTrue: [ ^ self class negativeZero ].
	^ super withNegativeSign
]

Float >> ~= aNumber
[~= aNumber
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is not equal to the argument. Otherwise return false.
	Fail if the argument is not a Float. Optional. See Object documentation
	whatIsAPrimitive."

	<primitive: 48>
	^ super ~= aNumber
]

Float class >> denormalized
[denormalized
	"Answer whether implementation supports denormalized numbers (also known as gradual underflow)."

	^ true
]

Float class >> e
[e
	"Answer the constant, E."

	^ E
]

Float class >> emax
[emax
	"Answer exponent of maximal representable value"

	^ 1023
]

Float class >> emin
[emin
	"Answer exponent of minimal normalized representable value"

	^ -1022
]

Float class >> epsilon
[epsilon
	"Answer difference between 1.0 and previous representable value"

	^ 1.0 timesTwoPower: 1 - self precision
]

Float class >> fmax
[fmax
	"Answer the maximum finite floating point value representable."

	^ MaxVal
]

Float class >> fmin
[fmin
	"Answer minimum positive representable value."

	^ self denormalized
		ifTrue: [ self fminDenormalized ]
		ifFalse: [ self fminNormalized ]
]

Float class >> fminDenormalized
[fminDenormalized
	"Answer the minimum denormalized value representable."

	^ 1.0 timesTwoPower: MinValLogBase2
]

Float class >> fminNormalized
[fminNormalized
	"Answer the minimum normalized value representable."

	^ 1.0 timesTwoPower: -1022
]

Float class >> fromIEEE32Bit: word
[fromIEEE32Bit: word
	"Convert the given 32 bit word (which is supposed to be a positive 32bit value) from a 32bit IEEE floating point representation into an actual Pharo float object (being 64bit wide). Should only be used for conversion in FloatArrays or likewise objects."

	| sign mantissa exponent newFloat delta |
	word negative
		ifTrue: [ ^ self error: 'Cannot deal with negative numbers' ].
	word = 0
		ifTrue: [ ^ 0.0 ].
	sign := word bitAnd: 16r80000000.
	word = sign
		ifTrue: [ ^ self negativeZero ].
	exponent := ((word bitShift: -23) bitAnd: 16rFF) - 127.
	mantissa := word bitAnd: 16r7FFFFF.
	exponent = 128
		ifTrue: [ "Either NAN or INF"
			mantissa = 0
				ifFalse: [ ^ Float nan ].
			sign = 0
				ifTrue: [ ^ Float infinity ]
				ifFalse: [ ^ Float infinity negated ] ].
	exponent = -127
		ifTrue: [ 
			"gradual underflow (denormalized number)		Remove first bit of mantissa and adjust exponent"
			delta := mantissa highBit.
			mantissa := (mantissa bitShift: 1) bitAnd: (1 bitShift: delta) - 1.
			exponent := exponent + delta - 23 ].	"Create new float"
	newFloat := self new: 2.
	newFloat basicAt: 1 put: ((sign bitOr: (1023 + exponent bitShift: 20)) bitOr: (mantissa bitShift: -3)).
	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).
	^ newFloat
]

Float class >> halfPi
[halfPi
	^ Halfpi
]

Float class >> infinity
[infinity
	"Answer the value used to represent an infinite magnitude"

	^ Infinity
]

Float class >> initialize
[initialize
	"Float initialize"

	"Constants from Computer Approximations, pp. 182-183:
		Pi = 3.14159265358979323846264338327950288
		Pi/2 = 1.57079632679489661923132169163975144
		Pi*2 = 6.28318530717958647692528676655900576
		Pi/180 = 0.01745329251994329576923690768488612
		2.0 ln = 0.69314718055994530941723212145817657
		2.0 sqrt = 1.41421356237309504880168872420969808"

	Pi := 3.14159265358979323846264338327950288.
	Halfpi := Pi / 2.0.
	Twopi := Pi * 2.0.
	ThreePi := Pi * 3.0.
	RadiansPerDegree := Pi / 180.0.
	Ln2 := 0.69314718055994530941723212145817657.
	Ln10 := 10.0 ln.
	Sqrt2 := 1.41421356237309504880168872420969808.
	E := 2.718281828459045235360287471353.
	Epsilon := 0.000000000001.	"Defines precision of mathematical functions"
	MaxVal := 1.7976931348623157e308.
	MaxValLn := 709.782712893384.
	MinValLogBase2 := -1074.
	Infinity := MaxVal * MaxVal.
	NegativeInfinity := 0.0 - Infinity.
	NaN := Infinity - Infinity.
	NegativeZero := 1.0 / Infinity negated
]

Float class >> maxExactInteger
[maxExactInteger
	"Answer the biggest integer such that it is exactly represented in a float, and all smaller integers also are"

	^ 1 bitShift: self precision
]

Float class >> nan
[nan
	"Answer the canonical value used to represent Not-A-Number"

	^ NaN
]

Float class >> negativeZero
[negativeZero
	^ NegativeZero
]

Float class >> one
[one
	^ 1.0
]

Float class >> pi
[pi
	"Answer the constant, Pi."

	^ Pi
]

Float class >> precision
[precision
	"Answer the apparent precision of the floating point representation.
	That is the maximum number of radix-based digits (bits if radix=2) representable in floating point without round off error.
	Technically, 52 bits are stored in the representation, and normalized numbers have an implied leading 1 that does not need to be stored.
	Note that denormalized floating point numbers don't have the implied leading 1, and thus gradually loose precision.
	This format conforms IEEE 754 double precision standard."

	^ 53
]

Float class >> radix
[radix
	"Answer the radix used for internal floating point representation."

	^ 2
]

Float class >> readFrom: aStream
[readFrom: aStream
	"Answer a new Float as described on the stream, aStream."

	^ (super readFrom: aStream) asFloat
]

Float class >> readFrom: aStream ifFail: aBlock
[readFrom: aStream ifFail: aBlock
	"Answer a new Float as described on the stream, aStream."

	^ (super readFrom: aStream ifFail: [ ^ aBlock value ]) asFloat
]

Float class >> threePi
[threePi
	^ ThreePi
]

Float class >> twoPi
[twoPi
	^ Twopi
]

