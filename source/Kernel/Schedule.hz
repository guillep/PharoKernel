Schedule
	superclass: #Timespan;
	instanceVariables: #(#schedule );
	package: #Kernel.

Schedule >> between: aStart and: anEnd do: aBlock
[between: aStart and: anEnd do: aBlock
	"from Cuis 99"

	| element end i startDate |
	end := self end min: anEnd.
	element := self start.	"Performance optimization. Avoid going through unnecesary days if easy."
	startDate := aStart asDate.
	(startDate > element asDate and: [ self everyDayAtSameTimes ])
		ifTrue: [ element := DateAndTime date: startDate time: element asTime ].
	i := 1.
	[ element < aStart ]
		whileTrue: [ element := element + (schedule at: i).
			i := i + 1.
			i > schedule size
				ifTrue: [ i := 1 ] ].
	[ element <= end ]
		whileTrue: [ aBlock value: element.
			element := element + (schedule at: i).
			i := i + 1.
			i > schedule size
				ifTrue: [ i := 1 ] ]
]

Schedule >> dateAndTimes
[dateAndTimes
	| dateAndTimes |
	dateAndTimes := OrderedCollection new.
	self scheduleDo: [ :e | dateAndTimes add: e ].
	^ dateAndTimes asArray
]

Schedule >> everyDayAtSameTimes
[everyDayAtSameTimes
	"Answer false if unknown"

	| count |
	count := (Duration days: 1) / self scheduleDuration.
	^ count >= 1 and: [ count isInteger ]
]

Schedule >> includes: aDateAndTime
[includes: aDateAndTime
	| dt |
	dt := aDateAndTime asDateAndTime.
	self scheduleDo: [ :e | e = dt
				ifTrue: [ ^ true ] ].
	^ false
]

Schedule >> schedule
[schedule
	^ schedule
]

Schedule >> schedule: anArrayOfDurations
[schedule: anArrayOfDurations
	schedule := anArrayOfDurations
]

Schedule >> scheduleDo: aBlock
[scheduleDo: aBlock
	self between: self start and: self end do: aBlock
]

Schedule >> scheduleDuration
[scheduleDuration
	^ schedule sum
]

