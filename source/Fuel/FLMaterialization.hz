FLMaterialization
	instanceVariables: #(#clusterCount #clusters #root #decoder #header );
	package: #Fuel.

FLMaterialization >> additionalObjectAt: aKey
[
	^ header additionalObjectAt: aKey
]

FLMaterialization >> afterMaterializationStep
[
	clusters do: [ :aCluster | aCluster afterMaterializationStepWith: decoder ]
]

FLMaterialization >> clusterInstancesStep
[
	| aCluster |
	aCluster := decoder nextEncodedClusterClass newMaterializing.
	aCluster clusterMaterializeStepWith: self.
	aCluster materializeInstancesStepWith: decoder.
	self registerAll: aCluster objects.
	aCluster materializePostInstancesStepWith: decoder.
	clusters add: aCluster
]

FLMaterialization >> decoder
[
	^ decoder
]

FLMaterialization >> header: aHeader
[
	header := aHeader
]

FLMaterialization >> headerStep
[
	decoder decodeYourself.
	clusterCount := decoder nextEncodedPositiveInteger.
	clusters := OrderedCollection new: clusterCount.
	clusters resetTo: 1	"Hack that avoids OrderedCollection>>makeRoomAtLast"
]

FLMaterialization >> initializeWith: aDecoder
[
	self initialize.
	decoder := aDecoder
]

FLMaterialization >> instancesStep
[
	clusterCount timesRepeat: [ self clusterInstancesStep ]
]

FLMaterialization >> objects
[
	"Answer a collection with the materialized objects."

	^ decoder objects
]

FLMaterialization >> referencesStep
[
	clusters do: [ :aCluster | aCluster materializeReferencesStepWith: decoder ]
]

FLMaterialization >> registerAll: materializedObjects
[
	decoder registerAll: materializedObjects
]

FLMaterialization >> root
[
	^ root
]

FLMaterialization >> run
[
	self headerStep.
	self instancesStep.
	self referencesStep.
	self trailerStep.
	self afterMaterializationStep
]

FLMaterialization >> trailerStep
[
	root := decoder nextEncodedReference
]

FLMaterialization class >> with: aDecoder
[
	^ self basicNew
		initializeWith: aDecoder;
		yourself
]

