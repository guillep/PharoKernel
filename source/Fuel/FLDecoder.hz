FLDecoder
	instanceVariables: #(#stream #objects #isBigEndian #indexStream #migrations #objectsWriteStream #globalEnvironment );
	package: #Fuel.

FLDecoder >> classNamed: className
[
	^ migrations
		detect: [ :m | m sourceClassName = className ]
		ifFound: [ :migration | migration targetClass ]
		ifNone: [ self globalClassNamed: className ]
]

FLDecoder >> decodeYourself
[
	| objectCount |
	objectCount := self nextEncodedPositiveInteger.
	indexStream := FLIndexStream on: stream digits: objectCount digitLength.
	objects := Array new: objectCount.
	objectsWriteStream := WriteStream on: objects.
	isBigEndian := self nextEncodedPositiveInteger
]

FLDecoder >> globalClassNamed: className
[
	^ globalEnvironment at: className ifAbsent: [ FLClassNotFound signalWithName: className ]
]

FLDecoder >> globalEnvironment
[
	"Answer a dictionary where the look up for global symbols will be done during materialization."

	^ globalEnvironment
]

FLDecoder >> initializeOn: aStream migrations: aCollection globalEnvironment: aDictionary
[
	self initialize.
	stream := aStream.
	migrations := aCollection.
	globalEnvironment := aDictionary
]

FLDecoder >> isBigEndian
[
	^ isBigEndian
]

FLDecoder >> nextEncodedBitmap
[
	^ Bitmap newFromStream: stream
]

FLDecoder >> nextEncodedByte
[
	^ stream next
]

FLDecoder >> nextEncodedBytesInto: aBytesObject
[
	stream next: aBytesObject basicSize into: aBytesObject
]

FLDecoder >> nextEncodedClusterClass
[
	^ self class environment at: self nextEncodedString asSymbol
]

FLDecoder >> nextEncodedInt24
[
	| n firstDigit |
	n := firstDigit := stream next.
	n := (n bitShift: 8) + stream next.
	n := (n bitShift: 8) + stream next.
	firstDigit >= 128
		ifTrue: [ n := -16r1000000 + n ].	"decode negative 24-bit integer"
	^ n
]

FLDecoder >> nextEncodedInt32
[
	| n firstDigit |
	n := firstDigit := stream next.
	n := (n bitShift: 8) + stream next.
	n := (n bitShift: 8) + stream next.
	n := (n bitShift: 8) + stream next.
	firstDigit >= 128
		ifTrue: [ n := -16r100000000 + n ].	"decode negative 32-bit integer"
	^ n
]

FLDecoder >> nextEncodedPositiveInteger
[
	"Read a 32-bit signed integer from the next 4 bytes"

	| s |
	s := 0.
	1 to: 4 do: [ :i | s := (s bitShift: 8) + stream next ].
	^ s
]

FLDecoder >> nextEncodedReference
[
	^ objects at: indexStream nextIndex
]

FLDecoder >> nextEncodedString
[
	| length aByteArray |
	"read the length in binary mode"
	length := stream next.	"first byte."
	length >= 192
		ifTrue: [ length := length - 192.
			1 to: 3 do: [ :ii | length := length * 256 + stream next ] ].
	aByteArray := ByteArray new: length.
	stream nextInto: aByteArray.
	^ aByteArray asString
]

FLDecoder >> nextEncodedUint16
[
	"Answer the next unsigned, 16-bit integer from this (binary) stream."

	^ (stream next bitShift: 8) + stream next
]

FLDecoder >> nextEncodedUint24
[
	"Answer the next unsigned, 24-bit integer from this (binary) stream."

	| n |
	n := stream next.
	n := (n bitShift: 8) + stream next.
	n := (n bitShift: 8) + stream next.
	^ n
]

FLDecoder >> nextEncodedUint32
[
	"Answer the next unsigned, 32-bit integer from this (binary) stream."

	| n |
	n := stream next.
	n := (n bitShift: 8) + stream next.
	n := (n bitShift: 8) + stream next.
	n := (n bitShift: 8) + stream next.
	^ n
]

FLDecoder >> nextEncodedUint8
[
	"Answer the next unsigned, 16-bit integer from this (binary) stream."

	^ stream next
]

FLDecoder >> nextEncodedWordsInto: aWordsObject
[
	stream fuelNextWordsInto: aWordsObject
]

FLDecoder >> objects
[
	^ objects
]

FLDecoder >> registerAll: someObjects
[
	objectsWriteStream nextPutAll: someObjects
]

FLDecoder >> variablesMappingFor: aClass
[
	| variables |
	variables := FLVariablesMapping materializing: aClass from: self.
	migrations select: [ :m | m targetClass == aClass ] thenDo: [ :m | m applyTo: variables ].
	^ variables
]

FLDecoder class >> on: aStream migrations: aCollection globalEnvironment: aDictionary
[
	^ self basicNew
		initializeOn: aStream migrations: aCollection globalEnvironment: aDictionary;
		yourself
]

