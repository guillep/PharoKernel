FLAnalyzer
	instanceVariables: #(#internalClasses #pluggableSubstitutions #globalMappersFactory #analysisFactory #generalMapperFactory #globalSymbols #internalMethods #globalMappers #globalEnvironment );
	package: #Fuel.

FLAnalyzer >> analysisFor: anObject
analysisFor: anObject
	^ analysisFactory value: anObject

FLAnalyzer >> considerGlobal: aSymbol
considerGlobal: aSymbol
	globalSymbols add: aSymbol

FLAnalyzer >> firstInMapperChain
firstInMapperChain
	^ self mappers first

FLAnalyzer >> fuelAccept: aGeneralMapper
fuelAccept: aGeneralMapper
	^ aGeneralMapper visitSubstitution: self by: nil

FLAnalyzer >> generalMapper
generalMapper
	^ generalMapperFactory value

FLAnalyzer >> globalEnvironment
globalEnvironment
	"Answer a dictionary where the look up for global symbols will be done during serialization."

	^ globalEnvironment

FLAnalyzer >> globalEnvironment: aDictionary
globalEnvironment: aDictionary
	globalEnvironment := aDictionary

FLAnalyzer >> globalMappers
globalMappers
	^ globalMappersFactory value

FLAnalyzer >> globalSymbols
globalSymbols
	"Answer the collection of symbols whose associations and values in Smalltalk globals will be considered as globals by Fuel."

	^ globalSymbols

FLAnalyzer >> initialize
initialize
	super initialize.
	self setDefaultAnalysis.
	self useLightMappers.
	pluggableSubstitutions := OrderedCollection new.
	internalClasses := IdentitySet new.
	internalMethods := IdentitySet new.
	globalEnvironment := self class environment.
	globalSymbols := self class defaultGlobalSymbols asIdentitySet

FLAnalyzer >> lightGlobalMappers
lightGlobalMappers
	^ globalSymbols isEmpty
		ifTrue: [ #() ]
		ifFalse: [ Array with: (FLLightGlobalMapper for: globalSymbols in: self globalEnvironment) ]

FLAnalyzer >> mappers
mappers
	^ OrderedCollection new
		addAll: self pluggableSubstitutionMappers;
		addAll: self globalMappers;
		add: self generalMapper;
		reduceRight: [ :left :right | left next: right ];
		yourself

FLAnalyzer >> pluggableSubstitutionMappers
pluggableSubstitutionMappers
	^ pluggableSubstitutions collect: [ :aLink | FLPluggableSubstitutionMapper when: aLink key substituteBy: aLink value ]

FLAnalyzer >> privateFirstInMapperChain
privateFirstInMapperChain
	^ self privateMappers first

FLAnalyzer >> privateMappers
privateMappers
	^ OrderedCollection new
		addAll: self globalMappers;
		add: self generalMapper;
		reduceRight: [ :left :right | left next: right ];
		yourself

FLAnalyzer >> setDefaultAnalysis
setDefaultAnalysis
	analysisFactory := [ :anObject | (FLAnalysis newWith: self firstInMapperChain private: self privateFirstInMapperChain root: anObject)
		run;
		yourself ]

FLAnalyzer >> useLightMappers
useLightMappers
	globalMappersFactory := [ self lightGlobalMappers ].
	generalMapperFactory := [ FLLightGeneralMapper new ]

FLAnalyzer >> when: aCondition substituteBy: aFactory
when: aCondition substituteBy: aFactory
	pluggableSubstitutions add: aCondition -> aFactory

FLAnalyzer class >> defaultGlobalSymbols
defaultGlobalSymbols
	^ #(#Smalltalk #SourceFiles #Transcript #Undeclared #Display #TextConstants #ActiveWorld #ActiveHand #ActiveEvent #Sensor #Processor #SystemOrganization #World)
		select: [ :each | self environment includesKey: each ]

FLAnalyzer class >> newDefault
newDefault
	"Returns an instance with default configuration."

	^ self new

