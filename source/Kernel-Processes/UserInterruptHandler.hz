Class
	name: #UserInterruptHandler;
	superclass: #ClassInputEventHandler;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#interruptKey );
	classVariables: #(#CmdDotEnabled );
	sharedPools: #(#EventSensorConstants );	package: #'Kernel-Processes'.

Class UserInterruptHandler >> handleEvent: evt
[
	"Store the event in the queue if there's any"
| type |type := evt at: 1.type = EventTypeKeyboard	ifTrue: [ 		"Check if the event is a user interrupt"		((evt at: 4) = 0 and: [ ((evt at: 3) bitOr: (((evt at: 5) bitAnd: 8) bitShift: 8)) = interruptKey ])			ifTrue: [ 				Display deferUpdates: false.				(Smalltalk hasClassNamed: #SoundService)					ifTrue: [ (Smalltalk classNamed: #SoundService) default shutDown ].				self handleUserInterrupt ].		^ self ]
]

Class UserInterruptHandler >> handleUserInterrupt
[
	"This will be called from the event-fetcher process. 	Assume no system-vital processes have a lower priority than this, and are thus ok to interrupt"
UserInterruptHandler cmdDotEnabled	ifTrue: [ 		[ 		| toInterrupt |		toInterrupt := self processToInterrupt.		toInterrupt ifNotNil: [ toInterrupt debugWithTitle: 'User Interrupt' ]	"fork exceptions, we don't want interrupt handler to die" ]			on: Error			fork: [ :ex | ex pass ] ]
]

Class UserInterruptHandler >> processToInterrupt
[
	"look for best candidate to interrupt:	   first who is not weak-finalization process	   and only then weak-finalization process, if nothing left to interrupt.		  filter out the idle process, since killing it is fatal	"
| list |list := OrderedCollection new.Processor	scanSchedule: [ :p | 		"gather everything but idle process, and processes whose suspendedContext sender == nil,		which usually means that process is only scheduled but had no chance to run"		(p ~~ Processor backgroundProcess and: [ p suspendedContext sender notNil ])			ifTrue: [ list add: p ] ]	startingAt: Processor activePriority.	"now answer first process in list, skipping the finalization process"list	do: [ :p | 		p == WeakArray runningFinalizationProcess			ifFalse: [ ^ p ] ].	"now answer first process , if any"^ list isEmpty	ifTrue: [ nil ]	ifFalse: [ list first ]
]

Class UserInterruptHandler >> setInterruptKeyValue: anInt
[
interruptKey := anInt
]

Metaclass
	name: #UserInterruptHandler;
	instanceVariables: #().

Metaclass UserInterruptHandler >> cmdDotEnabled
[
^ CmdDotEnabled ifNil: [ CmdDotEnabled := true ]
]

Metaclass UserInterruptHandler >> cmdDotEnabled: aBoolean
[
CmdDotEnabled := aBoolean
]

Metaclass UserInterruptHandler >> new
[
^ super new setInterruptKeyValue: ($. asciiValue bitOr: 16r0800)
]

