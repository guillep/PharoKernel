UserInterruptHandler
	superclass: #InputEventHandler;
	instanceVariables: #(#interruptKey );
	classVariables: #(#CmdDotEnabled );
	sharedPools: #(#EventSensorConstants );
	package: #'Kernel-Processes'.

UserInterruptHandler >> handleEvent: evt
[
	"Interrupt event... evt is shared, so make a copy of it."

	| buf |
	buf := evt shallowCopy.
	(self isKbdEvent: evt)
		ifTrue: [ | keycode modifiers |
			"Check if the event is a user interrupt"
			keycode := buf sixth.
			modifiers := buf fifth.
			(keycode = interruptKey and: [ modifiers anyMask: 16r0E ])
				ifTrue: [ Display deferUpdates: false.
					(Smalltalk hasClassNamed: #SoundService)
						ifTrue: [ (Smalltalk classNamed: #SoundService) default shutDown ].
					self handleUserInterrupt ].
			^ self ]
]

UserInterruptHandler >> handleUserInterrupt
[
	"This will be called from the event-fetcher process. 
	Assume no system-vital processes have a lower priority than this, and are thus ok to interrupt"

	UserInterruptHandler cmdDotEnabled
		ifFalse: [ ^ self ].
	[ self processToInterrupt
		ifNotNil: [ :proc | proc debugWithTitle: 'User Interrupt' ]
		ifNil: [ UIManager default inform: 'Process not interruptable' ]	"fork exceptions, we don't want interrupt handler to die" ]
		on: Error
		fork: [ :ex | ex pass ]
]

UserInterruptHandler >> isKbdEvent: bufEvt
[
	^ bufEvt first = EventTypeKeyboard and: [ bufEvt fourth = EventKeyChar ]
]

UserInterruptHandler >> processToInterrupt
[
	"Look for best candidate to interrupt: 
           - any scheduled non-finalization process of lower priority 
           - the weak-finalization process, if scheduled 
           - the UI process 
        Never interrupt the idle process, since killing it is fatal"

	| fallback |
	fallback := UIManager default uiProcess.
	Processor
		scanSchedule: [ :p | "suspendedContext sender == nil usually means that process is only scheduled but had no chance to run"
			(p ~~ Processor backgroundProcess and: [ p suspendedContext sender notNil ])
				ifTrue: [ p ~~ WeakArray runningFinalizationProcess
						ifTrue: [ ^ p ]
						ifFalse: [ fallback := p ] ] ]
		startingAt: Processor activePriority.
	^ fallback
]

UserInterruptHandler >> setInterruptKeyValue: anInt
[
	interruptKey := anInt
]

UserInterruptHandler class >> cmdDotEnabled
[
	^ CmdDotEnabled ifNil: [ CmdDotEnabled := true ]
]

UserInterruptHandler class >> cmdDotEnabled: aBoolean
[
	CmdDotEnabled := aBoolean
]

UserInterruptHandler class >> new
[
	^ super new setInterruptKeyValue: $. asciiValue
]

