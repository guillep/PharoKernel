Collection >> * arg
* arg
	^ arg adaptToCollection: self andSend: #*

Collection >> + arg
+ arg
	^ arg adaptToCollection: self andSend: #+

Collection >> - arg
- arg
	^ arg adaptToCollection: self andSend: #-

Collection >> / arg
/ arg
	^ arg adaptToCollection: self andSend: #/

Collection >> // arg
// arg
	^ arg adaptToCollection: self andSend: #//

Collection >> \\ arg
\\ arg
	^ arg adaptToCollection: self andSend: #\\

Collection >> abs
abs
	"Absolute value of all elements in the collection"

	^ self collect: [ :a | a abs ]

Collection >> arcCos
arcCos
	^ self collect: [ :each | each arcCos ]

Collection >> arcSin
arcSin
	^ self collect: [ :each | each arcSin ]

Collection >> arcTan
arcTan
	^ self collect: [ :each | each arcTan ]

Collection >> average
average
	^ self sum / self size

Collection >> ceiling
ceiling
	^ self collect: [ :a | a ceiling ]

Collection >> cos
cos
	^ self collect: [ :each | each cos ]

Collection >> degreeCos
degreeCos
	^ self collect: [ :each | each degreeCos ]

Collection >> degreeSin
degreeSin
	^ self collect: [ :each | each degreeSin ]

Collection >> exp
exp
	^ self collect: [ :each | each exp ]

Collection >> floor
floor
	^ self collect: [ :a | a floor ]

Collection >> ln
ln
	^ self collect: [ :each | each ln ]

Collection >> log
log
	^ self collect: [ :each | each log ]

Collection >> max
max
	^ self inject: self anyOne into: [ :max :each | max max: each ]

Collection >> min
min
	^ self inject: self anyOne into: [ :min :each | min min: each ]

Collection >> negated
negated
	"Negated value of all elements in the collection"

	^ self collect: [ :a | a negated ]

Collection >> raisedTo: arg
raisedTo: arg
	^ arg adaptToCollection: self andSend: #raisedTo:

Collection >> range
range
	^ self max - self min

Collection >> reciprocal
reciprocal
	"Return the reciever full of reciprocated elements"

	^ self collect: [ :a | a reciprocal ]

Collection >> roundTo: quantum
roundTo: quantum
	^ self collect: [ :ea | ea roundTo: quantum ]

Collection >> rounded
rounded
	^ self collect: [ :a | a rounded ]

Collection >> sign
sign
	^ self collect: [ :each | each sign ]

Collection >> sin
sin
	^ self collect: [ :each | each sin ]

Collection >> sqrt
sqrt
	^ self collect: [ :each | each sqrt ]

Collection >> squared
squared
	^ self collect: [ :each | each * each ]

Collection >> sum
sum
	"This is implemented using a variant of the normal inject:into: pattern. 
	The reason for this is that it is not known whether we're in the normal 
	number line, i.e. whether 0 is a good initial value for the sum. 
	Consider a collection of measurement objects, 0 would be the unitless 
	value and would not be appropriate to add with the unit-ed objects."

	| sum sample |
	sample := self anyOne.
	sum := self inject: sample into: [ :accum :each | accum + each ].
	^ sum - sample

Collection >> tan
tan
	^ self collect: [ :each | each tan ]

Collection >> truncated
truncated
	^ self collect: [ :a | a truncated ]

