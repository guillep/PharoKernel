FloatArray >> * anObject
[* anObject
	^ self copy *= anObject
]

FloatArray >> *= anObject
[*= anObject
	^ anObject isNumber
		ifTrue: [ self primMulScalar: anObject asFloat ]
		ifFalse: [ self primMulArray: anObject ]
]

FloatArray >> + anObject
[+ anObject
	^ self copy += anObject
]

FloatArray >> += anObject
[+= anObject
	^ anObject isNumber
		ifTrue: [ self primAddScalar: anObject asFloat ]
		ifFalse: [ self primAddArray: anObject ]
]

FloatArray >> - anObject
[- anObject
	^ self shallowCopy -= anObject
]

FloatArray >> -= anObject
[-= anObject
	^ anObject isNumber
		ifTrue: [ self primSubScalar: anObject asFloat ]
		ifFalse: [ self primSubArray: anObject ]
]

FloatArray >> / anObject
[/ anObject
	^ self copy /= anObject
]

FloatArray >> /= anObject
[/= anObject
	^ anObject isNumber
		ifTrue: [ self primDivScalar: anObject asFloat ]
		ifFalse: [ self primDivArray: anObject ]
]

FloatArray >> \\= other
[\\= other
	other isNumber
		ifTrue: [ 1 to: self size do: [ :i | self at: i put: (self at: i) \\ other ].
			^ self ].
	1 to: (self size min: other size) do: [ :i | self at: i put: (self at: i) \\ (other at: i) ]
]

FloatArray >> adaptToNumber: rcvr andSend: selector
[adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with a Number. If possible,
	convert it to a float and perform the (more efficient) primitive operation."

	selector == #+
		ifTrue: [ ^ self + rcvr ].
	selector == #*
		ifTrue: [ ^ self * rcvr ].
	selector == #-
		ifTrue: [ ^ self negated += rcvr ].
	selector == #/
		ifTrue: [ 
			"DO NOT USE TRIVIAL CODE			^self reciprocal * rcvr		BECAUSE OF GRADUAL UNDERFLOW		self should: (1.0e-39 / (FloatArray with: 1.0e-39)) first < 2."
			^ (self class new: self size withAll: rcvr) / self ].
	^ super adaptToNumber: rcvr andSend: selector
]

FloatArray >> dot: aFloatVector
[dot: aFloatVector
	"Primitive. Return the dot product of the receiver and the argument.
	Fail if the argument is not of the same size as the receiver."

	| result |
	"<primitive:'primitiveFloatArrayDotProduct'>"
	self size = aFloatVector size
		ifFalse: [ ^ self error: 'Must be equal size' ].
	result := 0.0.
	1 to: self size do: [ :i | result := result + ((self at: i) * (aFloatVector at: i)) ].
	^ result
]

FloatArray >> negated
[negated
	^ self copy *= -1
]

