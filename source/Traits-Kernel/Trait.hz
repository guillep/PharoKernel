Trait
	superclass: #TraitDescription;
	traitComposition: #TBehaviorCategorization;
	instanceVariables: #(#name #environment #classTrait #category );
	package: #'Traits-Kernel'.

Trait >> allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level
[
	"Walk the tree of subclasses, giving the class and its level"

	"Empty implementation needed, compatibility with OmniBrowser"

	
]

Trait >> applyChangesOfNewTraitCompositionReplacing: oldComposition
[
	"Duplicated on Class"

	| changedSelectors |
	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.
	self classSide noteNewBaseTraitCompositionApplied: self traitComposition.
	^ changedSelectors
]

Trait >> baseTrait
[
	^ self
]

Trait >> basicCategory
[
	^ category
]

Trait >> basicCategory: aSymbol
[
	category := aSymbol
]

Trait >> binding
[
	^ self environment associationAt: name ifAbsent: [ nil -> self ]
]

Trait >> category
[
	"Answer the system organization category for the receiver. First check whether the
	category name stored in the ivar is still correct and only if this fails look it up
	(latter is much more expensive)"

	| result |
	self basicCategory
		ifNotNil: [ :symbol | ((self environment organization listAtCategoryNamed: symbol) includes: self name)
				ifTrue: [ ^ symbol ] ].
	self basicCategory: (result := self environment organization categoryOfElement: self name).
	^ result
]

Trait >> category: aString
[
	"Categorize the receiver under the system category, aString, removing it from 
	any previous categorization."

	| oldCategory |
	oldCategory := self basicCategory.
	aString isString
		ifTrue: [ self basicCategory: aString asSymbol.
			self environment organization classify: self name under: self basicCategory ]
		ifFalse: [ self errorCategoryName ].
	SystemAnnouncer uniqueInstance class: self recategorizedFrom: oldCategory to: self basicCategory
]

Trait >> classTrait
[
	^ classTrait
]

Trait >> classTrait: aTrait
[
	"Assigns the class trait associated with the receiver."

	[ aTrait isClassTrait ] assert.
	classTrait := aTrait
]

Trait >> copy
[
	| newTrait |
	newTrait := self class basicNew initialize
		name: self name
		traitComposition: self traitComposition copyTraitExpression
		methodDict: self methodDict copy
		localSelectors: self localSelectors copy
		organization: self organization copy.
	newTrait environment: self environment.
	newTrait classTrait initializeFrom: self classTrait.
	^ newTrait
]

Trait >> duplicateClassWithNewName: aSymbol
[
	" I am duplicated from Class, and used to duplicate a trait "

	| copysName class newDefinition |
	copysName := aSymbol asSymbol.
	copysName = self name
		ifTrue: [ ^ self ].
	(Smalltalk globals includesKey: copysName)
		ifTrue: [ ^ self error: copysName , ' already exists' ].
	newDefinition := self definition copyReplaceAll: '#' , self name asString with: '#' , copysName asString.
	class := self class evaluatorClass evaluate: newDefinition logged: true.
	class copyAllCategoriesFrom: self.
	class class copyAllCategoriesFrom: self class.
	^ class
]

Trait >> environment
[
	^ environment
]

Trait >> environment: anObject
[
	environment := anObject
]

Trait >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex
[
	"This is just copied from Class.. the whole fileout is a mess."

	^ self
		fileOutOn: aFileStream
		moveSource: moveSource
		toFile: fileIndex
		initializing: true
]

Trait >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool
[
	"File a description of the receiver on aFileStream. If the boolean argument,
	moveSource, is true, then set the trailing bytes to the position of aFileStream and
	to fileIndex in order to indicate where to find the source code."

	self crTrace: name.
	super fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex.
	self hasClassTrait
		ifTrue: [ aFileStream
				cr;
				nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!';
				cr;
				cr.
			self classTrait fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex ]
]

Trait >> hasClassTrait
[
	^ classTrait notNil
]

Trait >> initialize
[
	super initialize.
	classTrait := ClassTrait for: self
]

Trait >> isBaseTrait
[
	^ true
]

Trait >> isClassTrait
[
	^ false
]

Trait >> isObsolete
[
	"Return true if the receiver is obsolete."

	^ (self environment at: name ifAbsent: [ nil ]) ~~ self
]

Trait >> isSelfEvaluating
[
	"Return true if the receiver printString is evaluating back to self."

	^ self isObsolete not
]

Trait >> isValidTraitName: aSymbol
[
	^ (aSymbol isEmptyOrNil
		or: [ aSymbol first isLetter not or: [ aSymbol anySatisfy: [ :character | character isAlphaNumeric not ] ] ]) not
]

Trait >> name
[
	^ name
]

Trait >> name: aSymbol
[
	name := aSymbol
]

Trait >> name: aString traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
	"Used by copy"

	self name: aString.
	localSelectors := aSet.
	methodDict := aMethodDict.
	traitComposition := aComposition.
	self organization: aClassOrganization
]

Trait >> obsolete
[
	self name: ('AnObsolete' , self name) asSymbol.
	self hasClassTrait
		ifTrue: [ self classTrait obsolete ].
	super obsolete
]

Trait >> possibleVariablesFor: misspelled continuedFrom: oldResults
[
	| results |
	results := misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.
	^ misspelled correctAgainstDictionary: self environment continuedFrom: results
]

Trait >> removeFromSystem
[
	self removeFromSystem: true
]

Trait >> removeFromSystem: logged
[
	self users do: [ :user | user removeFromComposition: self ].
	self environment forgetClass: self logged: logged.
	self obsolete
]

Trait >> rename: aString
[
	"The new name of the receiver is the argument, aString."

	| newName |
	(newName := aString asSymbol) ~= self name
		ifFalse: [ ^ self ].
	(self environment includesKey: newName)
		ifTrue: [ ^ self error: newName , ' already exists' ].
	(Undeclared includesKey: newName)
		ifTrue: [ 
			self
				inform:
					'There are references to, ' , aString printString
						,
							'from Undeclared. Check them after this change.' ].
	self environment renameClass: self as: newName.
	name := newName
]

Trait >> setName: aSymbol andRegisterInCategory: categorySymbol environment: aSystemDictionary
[
	(self isValidTraitName: aSymbol)
		ifFalse: [ TraitException signal: 'Invalid trait name' ].
	(self environment == aSystemDictionary and: [ self name = aSymbol and: [ self category = categorySymbol ] ])
		ifTrue: [ ^ self ].
	((aSystemDictionary includes: aSymbol) and: [ (aSystemDictionary at: aSymbol) ~~ self ])
		ifTrue: [ TraitException signal: 'The name ''' , aSymbol , ''' is already used' ].
	(self environment notNil and: [ self name notNil and: [ self name ~= aSymbol ] ])
		ifTrue: [ self environment renameClass: self as: aSymbol ].
	self name: aSymbol.
	self environment: aSystemDictionary.
	self environment at: self name put: self.
	self environment organization classify: self name under: categorySymbol.
	^ true
]

Trait >> subclasses
[
	"for compatibility with classes"

	^ #()
]

Trait >> superclass
[
	"For compatibility with classes"

	^ nil
]

Trait >> variablesAndOffsetsDo: aBinaryBlock
[
	"This is the interface between the compiler and a class's instance or field names.  The
	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed
	 by the instance variable name strings and their integer offsets (1-relative).  The order is
	 important; names evaluated later will override the same names occurring earlier."

	"Since Traits don't confer state there is nothing to do here."

	
]

Trait class >> defaultEnvironment
[
	^ Smalltalk
]

Trait class >> named: aSymbol
[
	^ self named: aSymbol uses: {} category: 'Unclassified'
]

Trait class >> named: aSymbol uses: aTraitCompositionOrCollection category: aString
[
	| env |
	env := self environment.
	^ self
		named: aSymbol
		uses: aTraitCompositionOrCollection
		category: aString
		env: env
]

Trait class >> named: aSymbol uses: aTraitCompositionOrCollection category: aString env: anEnvironment
[
	| trait oldTrait systemCategory oldCategory |
	systemCategory := aString asSymbol.
	trait := anEnvironment at: aSymbol ifAbsent: [ nil ].
	oldTrait := trait copy.	"Since there some strange side effect who changes teh category before being able to 	  actually update (and that causes a problem on RPackage organization), we take also the 	  category"
	oldCategory := oldTrait ifNotNil: [ oldTrait category ].
	trait := trait ifNil: [ super new ].
	(trait isKindOf: Trait)
		ifFalse: [ ^ self error: trait name , ' is not a Trait' ].
	trait setName: aSymbol andRegisterInCategory: systemCategory environment: anEnvironment.
	trait setTraitComposition: aTraitCompositionOrCollection asTraitComposition.	"... notify interested clients ..."
	oldTrait ifNil: [ SystemAnnouncer uniqueInstance classAdded: trait inCategory: systemCategory.
			^ trait ].
	SystemAnnouncer uniqueInstance traitDefinitionChangedFrom: oldTrait to: trait.
	systemCategory ~= oldCategory
		ifTrue: [ SystemAnnouncer uniqueInstance class: trait recategorizedFrom: oldCategory to: systemCategory ].
	^ trait
]

Trait class >> new
[
	self shouldNotImplement
]

Trait class >> newTemplateIn: categoryString
[
	^ String
		streamContents: [ :stream | stream
				nextPutAll: self name;
				nextPutAll: ' named: #NameOfTrait';
				cr;
				tab;
				nextPutAll: 'uses: {}';
				cr;
				tab;
				nextPutAll: 'category: ';
				nextPut: $';
				nextPutAll: categoryString;
				nextPut: $' ]
]

