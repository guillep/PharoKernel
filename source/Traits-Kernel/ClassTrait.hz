ClassTrait
	superclass: #TraitDescription;
	traitComposition: TApplyingOnClassSide;
	instanceVariables: #(#baseTrait );
	package: #'Traits-Kernel'.

ClassTrait >> baseClass: aTrait traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
	self baseTrait: aTrait.
	self
		traitComposition: aComposition
		methodDict: aMethodDict
		localSelectors: aSet
		organization: aClassOrganization
]

ClassTrait >> baseTrait
[
	^ baseTrait
]

ClassTrait >> baseTrait: aTrait
[
	[ aTrait isBaseTrait ] assert.
	baseTrait := aTrait
]

ClassTrait >> category
[
	^ self baseTrait category
]

ClassTrait >> classTrait
[
	^ self
]

ClassTrait >> classTrait: aClassTrait
[
	self error: 'Trait is already a class trait!'
]

ClassTrait >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
	| classSideUsersOfBaseTrait message |
	classSideUsersOfBaseTrait := self baseTrait users select: [ :each | each isClassSide ].
	classSideUsersOfBaseTrait isEmpty
		ifFalse: [ message := String
				streamContents: [ :stream | stream
						nextPutAll: 'The instance side of this trait is used on ';
						cr.
					classSideUsersOfBaseTrait do: [ :each | stream nextPutAll: each name ] separatedBy: [ stream nextPutAll: ', ' ].
					stream
						cr;
						nextPutAll: ' You can not add methods to the class side of this trait!' ].
			^ TraitException signal: message ].
	^ super
		compile: text
		classified: category
		withStamp: changeStamp
		notifying: requestor
		logSource: logSource
]

ClassTrait >> copy
[
	"Make a copy of the receiver. Share the 
	reference to the base trait."

	^ self class new
		baseTrait: self baseTrait;
		initializeFrom: self;
		yourself
]

ClassTrait >> definition
[
	^ String
		streamContents: [ :stream | stream
				nextPutAll: self name;
				crtab;
				nextPutAll: 'uses: ';
				nextPutAll: self traitCompositionString ]
]

ClassTrait >> hasClassTrait
[
	^ false
]

ClassTrait >> initializeFrom: anotherClassTrait
[
	traitComposition := self traitComposition copyTraitExpression.
	methodDict := self methodDict copy.
	localSelectors := self localSelectors copy.
	organization := self organization copy
]

ClassTrait >> initializeWithBaseTrait: aTrait
[
	self baseTrait: aTrait.
	self noteNewBaseTraitCompositionApplied: aTrait traitComposition.
	aTrait users do: [ :each | self addUser: each classSide ]
]

ClassTrait >> isBaseTrait
[
	^ false
]

ClassTrait >> isClassTrait
[
	^ true
]

ClassTrait >> isSelfEvaluating
[
	"Return true if the receiver printString is evaluating back to self."

	^ baseTrait isObsolete not
]

ClassTrait >> name
[
	^ self baseTrait name , ' classTrait'
]

ClassTrait >> traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
	"Used by copy of Trait"

	localSelectors := aSet.
	methodDict := aMethodDict.
	traitComposition := aComposition.
	self organization: aClassOrganization
]

ClassTrait >> uses: aTraitCompositionOrArray
[
	| copyOfOldTrait newComposition |
	copyOfOldTrait := self copy.
	newComposition := aTraitCompositionOrArray asTraitComposition.
	self assertConsistantCompositionsForNew: newComposition.
	self setTraitComposition: newComposition.
	SystemAnnouncer uniqueInstance traitDefinitionChangedFrom: copyOfOldTrait to: self
]

ClassTrait class >> for: aTrait
[
	^ self new
		initializeWithBaseTrait: aTrait;
		yourself
]

