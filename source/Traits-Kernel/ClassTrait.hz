Class
	name: #ClassTrait;
	superclass: #ClassTraitDescription;
	traitComposition: #TApplyingOnClassSide;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#baseTrait );
	classVariables: #();
	package: #'Traits-Kernel'.

Class ClassTrait >> assertConsistantCompositionsForNew: aTraitComposition
[
	"Applying or modifying a trait composition on the class side	of a behavior has some restrictions."
| baseTraits notAddable message |baseTraits := aTraitComposition traits select: [ :each | each isBaseTrait ].baseTraits isEmpty	ifFalse: [ 		notAddable := baseTraits reject: [ :each | each classSide methodDict isEmpty ].		notAddable isEmpty			ifFalse: [ 				message := String					streamContents: [ :stream | 						stream							nextPutAll: 'You can not add the base trait(s)';							cr.						notAddable do: [ :each | stream nextPutAll: each name ] separatedBy: [ stream nextPutAll: ', ' ].						stream							cr;							nextPutAll: 'to this composition because it/they define(s) methods on the class side.' ].				^ TraitCompositionException signal: message ] ].self instanceSide traitComposition traits asSet	= (aTraitComposition traits select: [ :each | each isClassTrait ] thenCollect: [ :each | each baseTrait ]) asSet	ifFalse: [ 		^ TraitCompositionException			signal:				'You can not add or remove class side traits on				the class side of a composition. (But you can specify aliases or exclusions				for existing traits or add a trait which does not have any methods on the class side.)' ]
]

Class ClassTrait >> baseClass: aTrait traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
self baseTrait: aTrait.self	traitComposition: aComposition	methodDict: aMethodDict	localSelectors: aSet	organization: aClassOrganization
]

Class ClassTrait >> baseTrait
[
^ baseTrait
]

Class ClassTrait >> baseTrait: aTrait
[
[ aTrait isBaseTrait ] assert.baseTrait := aTrait
]

Class ClassTrait >> category
[
^ self baseTrait category
]

Class ClassTrait >> classTrait
[
^ self
]

Class ClassTrait >> classTrait: aClassTrait
[
self error: 'Trait is already a class trait!'
]

Class ClassTrait >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
| classSideUsersOfBaseTrait message |classSideUsersOfBaseTrait := self baseTrait users select: [ :each | each isClassSide ].classSideUsersOfBaseTrait isEmpty	ifFalse: [ 		message := String			streamContents: [ :stream | 				stream					nextPutAll: 'The instance side of this trait is used on ';					cr.				classSideUsersOfBaseTrait do: [ :each | stream nextPutAll: each name ] separatedBy: [ stream nextPutAll: ', ' ].				stream					cr;					nextPutAll: ' You can not add methods to the class side of this trait!' ].		^ TraitException signal: message ].^ super	compile: text	classified: category	withStamp: changeStamp	notifying: requestor	logSource: logSource
]

Class ClassTrait >> copy
[
	"Make a copy of the receiver. Share the 	reference to the base trait."
^ self class new	baseTrait: self baseTrait;	initializeFrom: self;	yourself
]

Class ClassTrait >> definition
[
^ String	streamContents: [ :stream | 		stream			nextPutAll: self name;			crtab;			nextPutAll: 'uses: ';			nextPutAll: self traitCompositionString ]
]

Class ClassTrait >> hasClassTrait
[
^ false
]

Class ClassTrait >> initializeFrom: anotherClassTrait
[
traitComposition := self traitComposition copyTraitExpression.methodDict := self methodDict copy.localSelectors := self localSelectors copy.organization := self organization copy
]

Class ClassTrait >> initializeWithBaseTrait: aTrait
[
self baseTrait: aTrait.self noteNewBaseTraitCompositionApplied: aTrait traitComposition.aTrait users do: [ :each | self addUser: each classSide ]
]

Class ClassTrait >> isBaseTrait
[
^ false
]

Class ClassTrait >> isClassTrait
[
^ true
]

Class ClassTrait >> isSelfEvaluating
[
	"Return true if the receiver printString is evaluating back to self."
^ baseTrait isObsolete not
]

Class ClassTrait >> name
[
^ self baseTrait name , ' classTrait'
]

Class ClassTrait >> noteNewBaseTraitCompositionApplied: aTraitComposition
[
	"The argument is the new trait composition of my base trait - add	the new traits or remove non existing traits on my class side composition.	(Each class trait in my composition has its base trait on the instance side	of the composition - manually added traits to the class side are always 	base traits.)"
| newComposition traitsFromInstanceSide |traitsFromInstanceSide := self traitComposition traits	select: [ :each | each isClassTrait ]	thenCollect: [ :each | each baseTrait ].newComposition := self traitComposition copyTraitExpression.(traitsFromInstanceSide copyWithoutAll: aTraitComposition traits)	do: [ :each | newComposition removeFromComposition: each classTrait ].(aTraitComposition traits copyWithoutAll: traitsFromInstanceSide) do: [ :each | newComposition add: each classTrait ].self setTraitComposition: newComposition
]

Class ClassTrait >> traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
	"Used by copy of Trait"
localSelectors := aSet.methodDict := aMethodDict.traitComposition := aComposition.self organization: aClassOrganization
]

Class ClassTrait >> uses: aTraitCompositionOrArray
[
| copyOfOldTrait newComposition |copyOfOldTrait := self copy.newComposition := aTraitCompositionOrArray asTraitComposition.self assertConsistantCompositionsForNew: newComposition.self setTraitComposition: newComposition.SystemAnnouncer uniqueInstance traitDefinitionChangedFrom: copyOfOldTrait to: self
]

Metaclass
	name: #ClassTrait;
	instanceVariables: #().

Metaclass ClassTrait >> for: aTrait
[
^ self new	initializeWithBaseTrait: aTrait;	yourself
]

