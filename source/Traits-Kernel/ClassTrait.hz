ClassTrait
	superclass: #TraitDescription;
	traitComposition: #TApplyingOnClassSide;
	instanceVariables: #(#baseTrait );
	package: #'Traits-Kernel'.

ClassTrait >> assertConsistantCompositionsForNew: aTraitComposition
[
	"Applying or modifying a trait composition on the class side
	of a behavior has some restrictions."

	| baseTraits notAddable message |
	baseTraits := aTraitComposition traits select: [ :each | each isBaseTrait ].
	baseTraits isEmpty
		ifFalse: [ notAddable := baseTraits reject: [ :each | each classSide methodDict isEmpty ].
			notAddable isEmpty
				ifFalse: [ message := String
						streamContents: [ :stream | stream
								nextPutAll: 'You can not add the base trait(s)';
								cr.
							notAddable do: [ :each | stream nextPutAll: each name ] separatedBy: [ stream nextPutAll: ', ' ].
							stream
								cr;
								nextPutAll: 'to this composition because it/they define(s) methods on the class side.' ].
					^ TraitCompositionException signal: message ] ].
	self instanceSide traitComposition traits asSet
		= (aTraitComposition traits select: [ :each | each isClassTrait ] thenCollect: [ :each | each baseTrait ]) asSet
		ifFalse: [ 
			^ TraitCompositionException
				signal:
					'You can not add or remove class side traits on				the class side of a composition. (But you can specify aliases or exclusions				for existing traits or add a trait which does not have any methods on the class side.)' ]
]

ClassTrait >> baseClass: aTrait traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
	self baseTrait: aTrait.
	self
		traitComposition: aComposition
		methodDict: aMethodDict
		localSelectors: aSet
		organization: aClassOrganization
]

ClassTrait >> baseTrait
[
	^ baseTrait
]

ClassTrait >> baseTrait: aTrait
[
	[ aTrait isBaseTrait ] assert.
	baseTrait := aTrait
]

ClassTrait >> category
[
	^ self baseTrait category
]

ClassTrait >> classTrait
[
	^ self
]

ClassTrait >> classTrait: aClassTrait
[
	self error: 'Trait is already a class trait!'
]

ClassTrait >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
	| classSideUsersOfBaseTrait message |
	classSideUsersOfBaseTrait := self baseTrait users select: [ :each | each isClassSide ].
	classSideUsersOfBaseTrait isEmpty
		ifFalse: [ message := String
				streamContents: [ :stream | stream
						nextPutAll: 'The instance side of this trait is used on ';
						cr.
					classSideUsersOfBaseTrait do: [ :each | stream nextPutAll: each name ] separatedBy: [ stream nextPutAll: ', ' ].
					stream
						cr;
						nextPutAll: ' You can not add methods to the class side of this trait!' ].
			^ TraitException signal: message ].
	^ super
		compile: text
		classified: category
		withStamp: changeStamp
		notifying: requestor
		logSource: logSource
]

ClassTrait >> copy
[
	"Make a copy of the receiver. Share the 
	reference to the base trait."

	^ self class new
		baseTrait: self baseTrait;
		initializeFrom: self;
		yourself
]

ClassTrait >> definition
[
	^ String
		streamContents: [ :stream | stream
				nextPutAll: self name;
				crtab;
				nextPutAll: 'uses: ';
				nextPutAll: self traitCompositionString ]
]

ClassTrait >> hasClassTrait
[
	^ false
]

ClassTrait >> initializeFrom: anotherClassTrait
[
	traitComposition := self traitComposition copyTraitExpression.
	methodDict := self methodDict copy.
	localSelectors := self localSelectors copy.
	organization := self organization copy
]

ClassTrait >> initializeWithBaseTrait: aTrait
[
	self baseTrait: aTrait.
	self noteNewBaseTraitCompositionApplied: aTrait traitComposition.
	aTrait users do: [ :each | self addUser: each classSide ]
]

ClassTrait >> isBaseTrait
[
	^ false
]

ClassTrait >> isClassTrait
[
	^ true
]

ClassTrait >> isSelfEvaluating
[
	"Return true if the receiver printString is evaluating back to self."

	^ baseTrait isObsolete not
]

ClassTrait >> name
[
	^ self baseTrait name , ' classTrait'
]

ClassTrait >> noteNewBaseTraitCompositionApplied: aTraitComposition
[
	"The argument is the new trait composition of my base trait - add
	the new traits or remove non existing traits on my class side composition.
	(Each class trait in my composition has its base trait on the instance side
	of the composition - manually added traits to the class side are always 
	base traits.)"

	| newComposition traitsFromInstanceSide |
	traitsFromInstanceSide := self traitComposition traits
		select: [ :each | each isClassTrait ]
		thenCollect: [ :each | each baseTrait ].
	newComposition := self traitComposition copyTraitExpression.
	(traitsFromInstanceSide copyWithoutAll: aTraitComposition traits)
		do: [ :each | newComposition removeFromComposition: each classTrait ].
	(aTraitComposition traits copyWithoutAll: traitsFromInstanceSide) do: [ :each | newComposition add: each classTrait ].
	self setTraitComposition: newComposition
]

ClassTrait >> traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
	"Used by copy of Trait"

	localSelectors := aSet.
	methodDict := aMethodDict.
	traitComposition := aComposition.
	self organization: aClassOrganization
]

ClassTrait >> uses: aTraitCompositionOrArray
[
	| copyOfOldTrait newComposition |
	copyOfOldTrait := self copy.
	newComposition := aTraitCompositionOrArray asTraitComposition.
	self assertConsistantCompositionsForNew: newComposition.
	self setTraitComposition: newComposition.
	SystemAnnouncer uniqueInstance traitDefinitionChangedFrom: copyOfOldTrait to: self
]

ClassTrait class >> for: aTrait
[
	^ self new
		initializeWithBaseTrait: aTrait;
		yourself
]

