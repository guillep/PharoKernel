TraitBehavior
	traitComposition: #TPureBehavior @ {#pureRemoveSelector:->#removeSelector:. #pureAddSelectorSilently:withMethod:->#addSelectorSilently:withMethod:};
	instanceVariables: #(#methodDict #traitComposition #localSelectors #users );
	package: #'Traits-Kernel'.

TraitBehavior >> addSelectorSilently: selector withMethod: compiledMethod
[
	self pureAddSelectorSilently: selector withMethod: compiledMethod.
	self notifyUsersOfChangedSelector: selector
]

TraitBehavior >> addTraitSelector: aSymbol withMethod: aCompiledMethod
[
	"Add aMethod with selector aSymbol to my
	methodDict. aMethod must not be defined locally."

	| source methodAndNode |
	[ (self includesLocalSelector: aSymbol) not ] assert.
	self ensureLocalSelectors.
	source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.
	methodAndNode := self
		compile: source
		classified: aCompiledMethod category
		notifying: nil
		trailer: self defaultMethodTrailer
		ifFail: [ ^ nil ].
	methodAndNode method
		putSource: source
		fromParseNode: methodAndNode node
		inFile: 2
		withPreamble: [ :f | f
				cr;
				nextPut: $!;
				nextChunkPut: 'Trait method';
				cr ].
	self basicAddSelector: aSymbol withMethod: methodAndNode method	"self 		addAndClassifySelector: aSymbol 		withMethod: methodAndNode method 		inProtocol: aCompiledMethod category 		notifying: nil"
]

TraitBehavior >> addUser: aClassOrTrait
[
	users add: aClassOrTrait
]

TraitBehavior >> allClassVarNames
[
	^ #()
]

TraitBehavior >> allInstVarNames
[
	^ #()
]

TraitBehavior >> allSelectors
[
	^ self selectors asSet
]

TraitBehavior >> allSubclasses
[
	^ Array new
]

TraitBehavior >> allSubclassesDo: aBlock
[
	
]

TraitBehavior >> allSuperclasses
[
	^ OrderedCollection new
]

TraitBehavior >> allSuperclassesDo: aBlock
[
	
]

TraitBehavior >> basicAddSelector: selector withMethod: compiledMethod
[
	"Add the message selector with the corresponding compiled method to the 
	receiver's method dictionary.
	Do this without sending system change notifications"

	| oldMethodOrNil |
	oldMethodOrNil := self lookupSelector: selector.
	self methodDict at: selector put: compiledMethod.
	compiledMethod methodClass: self.
	compiledMethod selector: selector.	"Now flush the method cache, when we replace a method"
	oldMethodOrNil ifNotNil: [ oldMethodOrNil flushCache ]
]

TraitBehavior >> basicLocalSelectors
[
	"Direct accessor for the instance variable localSelectors.
	Since localSelectors is lazily initialized, this may 
	return nil, which means that all selectors are local."

	^ localSelectors
]

TraitBehavior >> basicLocalSelectors: aSetOrNil
[
	localSelectors := aSetOrNil
]

TraitBehavior >> classPool
[
	^ Dictionary new
]

TraitBehavior >> classVarNames
[
	^ #()
]

TraitBehavior >> classesComposedWithMe
[
	^ users gather: [ :u | u classesComposedWithMe ]
]

TraitBehavior >> hasTraitComposition
[
	^ traitComposition notNil and: [ traitComposition notEmpty ]
]

TraitBehavior >> inheritsFrom: aClass
[
	"Used by RB"

	^ false
]

TraitBehavior >> initialize
[
	super initialize.
	self methodDict: MethodDictionary new.
	self traitComposition: nil.
	users := IdentitySet new
]

TraitBehavior >> instSize
[
	^ 0
]

TraitBehavior >> instVarNames
[
	^ #()
]

TraitBehavior >> isTrait
[
	^ true
]

TraitBehavior >> lookupSelector: selector
[
	^ (self includesSelector: selector)
		ifTrue: [ self compiledMethodAt: selector ]
		ifFalse: [ nil ]
]

TraitBehavior >> methodDict
[
	^ methodDict
]

TraitBehavior >> methodDict: aDictionary
[
	methodDict := aDictionary
]

TraitBehavior >> poolDictionaryNames
[
	^ #()
]

TraitBehavior >> precodeCommentOrInheritedCommentFor: aSelector
[
	^ self firstPrecodeCommentFor: aSelector
]

TraitBehavior >> recompile: selector from: oldClass
[
	"Compile the method associated with selector in the receiver's method dictionary."

	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"

	| method trailer methodNode |
	method := oldClass compiledMethodAt: selector.
	trailer := method trailer.
	methodNode := self compilerClass new
		compile: (oldClass sourceCodeAt: selector)
		in: self
		notifying: nil
		ifFail: [ ^ self ].	"Assume OK after proceed from SyntaxError"
	selector == methodNode selector
		ifFalse: [ self error: 'selector changed!' ].
	self basicAddSelector: selector withMethod: (methodNode generate: trailer)
]

TraitBehavior >> removeFromTraitCompositionOfUsers
[
	self users do: [ :each | each removeFromComposition: self ]
]

TraitBehavior >> removeSelector: selector
[
	self pureRemoveSelector: selector.
	self notifyUsersOfChangedSelector: selector
]

TraitBehavior >> removeUser: aClassOrTrait
[
	users remove: aClassOrTrait ifAbsent: [  ]
]

TraitBehavior >> selectorsWithArgs: numberOfArgs
[
	"Return all selectors defined in this class that take this number of arguments.  Could use String.keywords.  Could see how compiler does this."

	| list |
	list := OrderedCollection new.
	self
		selectorsDo: [ :aSel | | num |
			num := aSel count: [ :char | char == $: ].
			num = 0
				ifTrue: [ aSel last isLetter
						ifFalse: [ num := 1 ] ].
			num = numberOfArgs
				ifTrue: [ list add: aSel ] ].
	^ list
]

TraitBehavior >> sharedPools
[
	^ OrderedCollection new
]

TraitBehavior >> subclassDefinerClass
[
	^ nil subclassDefinerClass
]

TraitBehavior >> subclasses
[
	^ Array new
]

TraitBehavior >> thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte
[
	"Answer a set of selectors whose methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	| selectors |
	selectors := IdentitySet new.
	self
		selectorsAndMethodsDo: [ :sel :method | ((method refersToLiteral: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])
				ifTrue: [ selectors add: sel ] ].
	^ selectors
]

TraitBehavior >> traitComposition
[
	traitComposition ifNil: [ traitComposition := TraitComposition new ].
	^ traitComposition
]

TraitBehavior >> traitComposition: aTraitComposition
[
	traitComposition := aTraitComposition
]

TraitBehavior >> traitsProvidingSelector: aSymbol
[
	| result |
	result := OrderedCollection new.
	self hasTraitComposition
		ifFalse: [ ^ result ].
	(self traitComposition methodDescriptionsForSelector: aSymbol)
		do: [ :methodDescription | methodDescription selector = aSymbol
				ifTrue: [ result addAll: (methodDescription locatedMethods collect: [ :each | each methodClass ]) ] ].
	^ result
]

TraitBehavior >> users
[
	^ users
]

TraitBehavior >> whichClassIncludesSelector: aSymbol
[
	"Traits compatibile implementation for:
	
	Answer the class on the receiver's superclass chain where the 
	argument, aSymbol (a message selector), will be found. Answer nil if none found."

	^ (self includesSelector: aSymbol)
		ifTrue: [ self ]
		ifFalse: [ nil ]
]

TraitBehavior >> whichSelectorsReferTo: literal
[
	"Answer a Set of selectors whose methods access the argument as a
literal."

	| special byte |
	special := Smalltalk hasSpecialSelector: literal ifTrueSetByte: [ :b | byte := b ].
	^ self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."
]

TraitBehavior >> withAllSubclasses
[
	^ Array with: self
]

TraitBehavior >> zapAllMethods
[
	"Remove all methods in this trait which is assumed to be obsolete"

	methodDict := MethodDictionary new.
	self hasClassTrait
		ifTrue: [ self classTrait zapAllMethods ]
]

