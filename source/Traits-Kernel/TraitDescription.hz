Class
	name: #TraitDescription;
	superclass: #ClassTraitBehavior;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#organization );
	classVariables: #();
	package: #'Traits-Kernel'.

Class TraitDescription >> + aTraitOrTraitComposition
[
	"Use double dispatch to avoid having nested composition in cases where	parenthesis are used, such as T1 + (T2 + T3)"
^ aTraitOrTraitComposition addOnTheLeft: self
]

Class TraitDescription >> - anArrayOfSelectors
[
^ TraitExclusion	with: self	exclusions:		(anArrayOfSelectors isSymbol			ifTrue: [ {anArrayOfSelectors} ]			ifFalse: [ anArrayOfSelectors ])
]

Class TraitDescription >> @ anArrayOfAssociations
[
^ TraitAlias with: self aliases: anArrayOfAssociations
]

Class TraitDescription >> acceptsLoggingOfCompilation
[
	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself.  6/18/96 sw"
	"weird name is so that it will come lexically before #compile, so that a clean build can make it through.  7/7/96 sw"
^ true
]

Class TraitDescription >> addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor
[
| priorMethodOrNil oldProtocol newProtocol |priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [  ].	"We categorize first, so the users can use the categorization at the add moment"oldProtocol := self organization categoryOfElement: selector.SystemAnnouncer uniqueInstance suspendAllWhile: [ self organization classify: selector under: category ].self addSelectorSilently: selector withMethod: compiledMethod.newProtocol := self organization categoryOfElement: selector.priorMethodOrNil isNil	ifTrue: [ 		SystemAnnouncer uniqueInstance			methodAdded: compiledMethod			selector: selector			inProtocol: category			class: self			requestor: requestor ]	ifFalse: [ 		SystemAnnouncer uniqueInstance			methodChangedFrom: priorMethodOrNil			to: compiledMethod			selector: selector			inClass: self			oldProtocol: oldProtocol			newProtocol: newProtocol			requestor: requestor ]
]

Class TraitDescription >> addCompositionOnLeft: aTraitComposition
[
^ aTraitComposition add: self
]

Class TraitDescription >> addExclusionOf: aSymbol
[
^ self - {aSymbol}
]

Class TraitDescription >> addOnTheLeft: aTraitExpression
[
^ TraitComposition with: aTraitExpression with: self
]

Class TraitDescription >> addSelector: selector withMethod: compiledMethod notifying: requestor
[
| priorMethodOrNil |priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [ nil ].self addSelectorSilently: selector withMethod: compiledMethod.priorMethodOrNil isNil	ifTrue: [ 		SystemAnnouncer uniqueInstance			methodAdded: compiledMethod			selector: selector			inClass: self			requestor: requestor ]	ifFalse: [ 		SystemAnnouncer uniqueInstance			methodChangedFrom: priorMethodOrNil			to: compiledMethod			selector: selector			inClass: self			requestor: requestor ]
]

Class TraitDescription >> addSelectorSilently: selector withMethod: compiledMethod
[
super addSelectorSilently: selector withMethod: compiledMethod.self instanceSide noteAddedSelector: selector meta: self isMeta
]

Class TraitDescription >> aliasesForSelector: aSelector
[
^ OrderedCollection new
]

Class TraitDescription >> allAliasesDict
[
^ IdentityDictionary new
]

Class TraitDescription >> allMethodsInCategory: aName
[
	"Answer a list of all the method categories of the receiver"
| aColl |aColl := aName = ClassOrganizer allCategory	ifTrue: [ self organization allMethodSelectors ]	ifFalse: [ self organization listAtCategoryNamed: aName ].^ aColl asSet asArray sort
]

Class TraitDescription >> applyChangesOfNewTraitCompositionReplacing: oldComposition
[
| oldMethodDict changedSelectors |oldMethodDict := self methodDict copy.changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.self noteChangesFrom: oldMethodDict.^ changedSelectors
]

Class TraitDescription >> asTraitComposition
[
^ TraitComposition with: self
]

Class TraitDescription >> baseTrait
[
self subclassResponsibility
]

Class TraitDescription >> category
[
self subclassResponsibility
]

Class TraitDescription >> category: aString
[
self subclassResponsibility
]

Class TraitDescription >> changedSelectorsComparedTo: aTraitTransformation
[
| selectors otherSelectors changedSelectors aliases otherAliases |selectors := self allSelectors asIdentitySet.otherSelectors := aTraitTransformation allSelectors asIdentitySet.changedSelectors := IdentitySet	withAll: ((selectors difference: otherSelectors) union: (otherSelectors difference: selectors)).aliases := self allAliasesDict.otherAliases := aTraitTransformation allAliasesDict.aliases	keysAndValuesDo: [ :key :value | 		value ~~ (otherAliases at: key ifAbsent: [ nil ])			ifTrue: [ changedSelectors add: key ] ].otherAliases	keysAndValuesDo: [ :key :value | 		value ~~ (aliases at: key ifAbsent: [ nil ])			ifTrue: [ changedSelectors add: key ] ].^ changedSelectors
]

Class TraitDescription >> classComment: aString
[
	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."
^ self classComment: aString stamp: '<historical>'
]

Class TraitDescription >> classComment: aString stamp: aStamp
[
	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."
| ptr header file oldCommentRemoteStr oldComment oldStamp |oldComment := self organization classComment.oldStamp := self organization commentStamp.(aString isKindOf: RemoteString)	ifTrue: [ 		SystemAnnouncer uniqueInstance			class: self			oldComment: oldComment			newComment: aString string			oldStamp: oldStamp			newStamp: aStamp.		^ self organization classComment: aString stamp: aStamp ].oldCommentRemoteStr := self organization commentRemoteStr.aString size = 0 & oldCommentRemoteStr isNil	ifTrue: [ ^ self organization classComment: nil ].	"never had a class comment, no need to write empty string out"ptr := oldCommentRemoteStr ifNil: [ 0 ] ifNotNil: [ oldCommentRemoteStr sourcePointer ].SourceFiles	ifNotNil: [ 		(file := SourceFiles at: 2)			ifNotNil: [ 				file					setToEnd;					cr;					nextPut: $!.	"directly"	"Should be saying (file command: 'H3') for HTML, but ignoring it here"				header := String					streamContents: [ :strm | 						strm							nextPutAll: self name;							nextPutAll: ' commentStamp: '.						aStamp storeOn: strm.						strm							nextPutAll: ' prior: ';							nextPutAll: ptr printString ].				file nextChunkPut: header ] ].self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.SystemAnnouncer uniqueInstance	class: self	oldComment: oldComment	newComment: aString	oldStamp: oldStamp	newStamp: aStamp
]

Class TraitDescription >> classCommentBlank
[
| existingComment stream |existingComment := self instanceSide organization classComment.existingComment isEmpty	ifFalse: [ ^ existingComment ].stream := (String new: 100) writeStream.stream	nextPutAll: 'A';	nextPutAll:			(self name first isVowel					ifTrue: [ 'n ' ]					ifFalse: [ ' ' ]);	nextPutAll: self name;	nextPutAll: ' is xxxxxxxxx.'.stream cr.^ stream contents
]

Class TraitDescription >> classSide
[
^ self classTrait
]

Class TraitDescription >> classTrait
[
self subclassResponsibility
]

Class TraitDescription >> collectMethodsFor: aSelector into: methodDescription
[
(self includesSelector: aSelector)	ifTrue: [ methodDescription addLocatedMethod: (self compiledMethodAt: aSelector) ]
]

Class TraitDescription >> comment
[
	"Answer the receiver's comment. (If missing, supply a template) "
| aString |aString := self instanceSide organization classComment.aString isEmpty	ifFalse: [ ^ aString ].^ self classCommentBlank
]

Class TraitDescription >> comment: aStringOrText
[
	"Set the receiver's comment to be the argument, aStringOrText."
self instanceSide classComment: aStringOrText
]

Class TraitDescription >> comment: aStringOrText stamp: aStamp
[
	"Set the receiver's comment to be the argument, aStringOrText."
self instanceSide classComment: aStringOrText stamp: aStamp
]

Class TraitDescription >> commentStamp: changeStamp
[
self organization commentStamp: changeStamp.^ self commentStamp: changeStamp prior: 0
]

Class TraitDescription >> commentStamp: changeStamp prior: indexAndOffset
[
	"Prior source link ignored when filing in."
^ ClassCommentReader new setClass: self category: #Comment changeStamp: changeStamp
]

Class TraitDescription >> compile: code classified: heading
[
	"Compile the argument, code, as source code in the context of the 	receiver and install the result in the receiver's method dictionary under 	the classification indicated by the second argument, heading. nil is to be 	notified if an error occurs. The argument code is either a string or an 	object that converts to a string or a PositionableStream on an object that 	converts to a string."
^ self compile: code classified: heading notifying: nil
]

Class TraitDescription >> compile: text classified: category notifying: requestor
[
| stamp |stamp := self acceptsLoggingOfCompilation	ifTrue: [ Author changeStamp ]	ifFalse: [ nil ].^ self	compile: text	classified: category	withStamp: stamp	notifying: requestor
]

Class TraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor
[
^ self	compile: text	classified: category	withStamp: changeStamp	notifying: requestor	logSource: self acceptsLoggingOfCompilation
]

Class TraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
| methodAndNode |methodAndNode := self	compile: text asString	classified: category	notifying: requestor	trailer: self defaultMethodTrailer	ifFail: [ ^ nil ].logSource	ifTrue: [ 		" replace 'text' with 'methodAndNode node sourceText' "		self			logMethodSource: methodAndNode node sourceText			forMethodWithNode: methodAndNode			inCategory: category			withStamp: changeStamp			notifying: requestor ].self	addAndClassifySelector: methodAndNode selector	withMethod: methodAndNode method	inProtocol: category	notifying: requestor.self instanceSide noteCompilationOf: methodAndNode selector meta: self isClassSide.^ methodAndNode selector
]

Class TraitDescription >> compile: code notifying: requestor
[
	"Refer to the comment in Behavior|compile:notifying:."
^ self compile: code classified: ClassOrganizer default notifying: requestor
]

Class TraitDescription >> compileSilently: code
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."
^ self compileSilently: code classified: '' notifying: nil
]

Class TraitDescription >> compileSilently: code classified: category
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."
^ self compileSilently: code classified: category notifying: nil
]

Class TraitDescription >> compileSilently: code classified: category notifying: requestor
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."
^ SystemAnnouncer uniqueInstance	suspendAllWhile: [ 		self			compile: code			classified: category			withStamp: nil			notifying: requestor			logSource: false ]
]

Class TraitDescription >> copy: sel from: class
[
	"Install the method associated with the first argument, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under -As yet not 	classified-."
self copy: sel from: class classified: nil
]

Class TraitDescription >> copy: sel from: class classified: cat
[
	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."
| code category |"Useful when modifying an existing class"code := class sourceCodeAt: sel.code	ifNotNil: [ 		cat ifNil: [ category := class organization categoryOfElement: sel ] ifNotNil: [ category := cat ].		(self includesLocalSelector: sel)			ifTrue: [ 				code asString = (self sourceCodeAt: sel) asString					ifFalse: [ self error: self name , ' ' , sel , ' will be redefined if you proceed.' ] ].		self compile: code classified: category ]
]

Class TraitDescription >> copyAll: selArray from: class
[
	"Install all the methods found in the method dictionary of the second 	argument, class, as the receiver's methods. Classify the messages under 	-As yet not classified-."
self copyAll: selArray from: class classified: nil
]

Class TraitDescription >> copyAll: selArray from: class classified: cat
[
	"Install all the methods found in the method dictionary of the second 	argument, class, as the receiver's methods. Classify the messages under 	the third argument, cat."
selArray	do: [ :s | 		(class includesLocalSelector: s)			ifTrue: [ self copy: s from: class classified: cat ] ]
]

Class TraitDescription >> copyAllCategoriesFrom: aClass
[
	"Specify that the categories of messages for the receiver include all of 	those found in the class, aClass. Install each of the messages found in 	these categories into the method dictionary of the receiver, classified 	under the appropriate categories."
aClass organization categories do: [ :cat | self copyCategory: cat from: aClass ]
]

Class TraitDescription >> copyCategory: cat from: class
[
	"Specify that one of the categories of messages for the receiver is cat, as 	found in the class, class. Copy each message found in this category."
self copyCategory: cat from: class classified: cat
]

Class TraitDescription >> copyCategory: cat from: aClass classified: newCat
[
	"Specify that one of the categories of messages for the receiver is the 	third argument, newCat. Copy each message found in the category cat in 	class aClass into this new category."
self copyAll: (aClass organization listAtCategoryNamed: cat) from: aClass classified: newCat
]

Class TraitDescription >> copyMethodDictionaryFrom: donorClass
[
	"Copy the method dictionary of the donor class over to the receiver"
self methodDict: donorClass copyOfMethodDictionary.self organization: donorClass organization deepCopy
]

Class TraitDescription >> copyTraitExpression
[
	"When recursively copying a trait expression, the primitive traits should NOT be copiedbecause they are globally named 'well-known' objects"
^ self
]

Class TraitDescription >> definition
[
	"Answer a String that defines the receiver"
^ String	streamContents: [ :stream | 		stream nextPutAll: self class name.		stream			nextPutAll: ' named: ';			store: self name.		stream			cr;			tab;			nextPutAll: 'uses: ';			nextPutAll: self traitCompositionString.		stream			cr;			tab;			nextPutAll: 'category: ';			store: self category asString ]
]

Class TraitDescription >> duringTestCompileSilently: code
[
^ Author useAuthor: 'TestsAuthor' during: [ self compileSilently: code classified: '' ]
]

Class TraitDescription >> duringTestCompileSilently: code classified: aCategory
[
^ Author useAuthor: 'TestsAuthor' during: [ self compileSilently: code classified: aCategory ]
]

Class TraitDescription >> errorCategoryName
[
self error: 'Category name must be a String'
]

Class TraitDescription >> fileOut
[
	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."
| internalStream |internalStream := (String new: 100) writeStream.internalStream	header;	timeStamp.self fileOutOn: internalStream moveSource: false toFile: 0.internalStream trailer.FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true
]

Class TraitDescription >> fileOutCategory: catName
[
| internalStream |internalStream := (String new: 1000) writeStream.internalStream	header;	timeStamp.self	fileOutCategory: catName	on: internalStream	moveSource: false	toFile: 0.internalStream trailer.^ FileStream writeSourceCodeFrom: internalStream baseName: self name , '-' , catName isSt: true
]

Class TraitDescription >> fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."
| selectors |aFileStream cr.selectors := self selectorsToFileOutCategory: aSymbol.	"Overridden to preserve author stamps in sources file regardless"selectors	do: [ :sel | 		self			printMethodChunk: sel			withPreamble: true			on: aFileStream			moveSource: moveSource			toFile: fileIndex ].^ self
]

Class TraitDescription >> fileOutChangedMessages: aSet on: aFileStream
[
	"File a description of the messages of the receiver that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream."
self	fileOutChangedMessages: aSet	on: aFileStream	moveSource: false	toFile: 0
]

Class TraitDescription >> fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."
| org |(org := self organization) categories	do: [ :cat | 		| sels |		sels := (org listAtCategoryNamed: cat) select: [ :sel | aSet includes: sel ].		sels			do: [ :sel | 				self					printMethodChunk: sel					withPreamble: true					on: aFileStream					moveSource: moveSource					toFile: fileIndex ] ]
]

Class TraitDescription >> fileOutMethod: selector
[
	"Write source code of a single method on a file.  Make up a name for the file."
| internalStream |selector == #Comment	ifTrue: [ ^ self inform: 'Sorry, cannot file out class comment in isolation.' ].(self includesSelector: selector)	ifFalse: [ ^ self error: 'Selector ' , selector asString , ' not found' ].internalStream := (String new: 1000) writeStream.internalStream	header;	timeStamp.self	printMethodChunk: selector	withPreamble: true	on: internalStream	moveSource: false	toFile: 0.FileStream	writeSourceCodeFrom: internalStream	baseName: self name , '-' , (selector copyReplaceAll: ':' with: '')	isSt: true
]

Class TraitDescription >> fileOutOn: aFileStream
[
	"File a description of the receiver on aFileStream."
self fileOutOn: aFileStream moveSource: false toFile: 0
]

Class TraitDescription >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the receiver on aFileStream. If the boolean 	argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the 	source code."
aFileStream nextChunkPut: self definition.self organization	putCommentOnFile: aFileStream	numbered: fileIndex	moveSource: moveSource	forClass: self.self organization categories	do: [ :heading | 		self			fileOutCategory: heading			on: aFileStream			moveSource: moveSource			toFile: fileIndex ]
]

Class TraitDescription >> fileOutOrganizationOn: aFileStream
[
	"File a description of the receiver's organization on aFileStream."
aFileStream	cr;	nextPut: $!.aFileStream	nextChunkPut: self name , ' reorganize';	cr.aFileStream	nextChunkPut: self organization stringForFileOut;	cr
]

Class TraitDescription >> hasClassTrait
[
self subclassResponsibility
]

Class TraitDescription >> hasComment
[
	"return whether this class truly has a comment other than the default"
| org |org := self instanceSide organization.^ org classComment isEmptyOrNil not
]

Class TraitDescription >> instanceSide
[
^ self baseTrait
]

Class TraitDescription >> isBaseTrait
[
self subclassResponsibility
]

Class TraitDescription >> isClassSide
[
^ self == self classSide
]

Class TraitDescription >> isClassTrait
[
self subclassResponsibility
]

Class TraitDescription >> isInstanceSide
[
^ self isClassSide not
]

Class TraitDescription >> isMeta
[
^ self isClassSide
]

Class TraitDescription >> isTestCase
[
^ false
]

Class TraitDescription >> linesOfCode
[
	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."
| lines |lines := self localMethods inject: 0 into: [ :sum :each | sum + each linesOfCode ].^ self isMeta	ifTrue: [ lines ]	ifFalse: [ lines + self class linesOfCode ]
]

Class TraitDescription >> localMethods
[
	"returns the methods of classes including the ones of the traits that the class uses"
^ self methods select: [ :each | self includesLocalSelector: each selector ]
]

Class TraitDescription >> logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor
[
aCompiledMethodWithNode method	putSource: aText	fromParseNode: aCompiledMethodWithNode node	class: self	category: category	withStamp: changeStamp	inFile: 2	priorMethod: (self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [  ])
]

Class TraitDescription >> methods
[
	"returns the methods of classes including the ones of the traits that the class uses"
^ self methodDict values
]

Class TraitDescription >> methodsFor: categoryName
[
	"Answer a ClassCategoryReader for compiling the messages in the category, categoryName, of the receiver."
^ ClassCategoryReader new setClass: self category: categoryName asSymbol	"(False methodsFor: 'logical operations') inspect"
]

Class TraitDescription >> methodsFor: aString priorSource: sourcePosition inFile: fileIndex
[
	"Prior source pointer ignored when filing in."
^ self methodsFor: aString
]

Class TraitDescription >> methodsFor: categoryName stamp: changeStamp
[
^ self methodsFor: categoryName stamp: (Author fixStamp: changeStamp) prior: 0
]

Class TraitDescription >> methodsFor: categoryName stamp: changeStamp prior: indexAndOffset
[
	"Prior source link ignored when filing in."
^ ClassCategoryReader new setClass: self category: categoryName asSymbol changeStamp: changeStamp	"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"
]

Class TraitDescription >> methodsInCategory: aName
[
	"Answer a list of the methods of the receiver that are in category named aName"
| aColl |aColl := aName = ClassOrganizer allCategory	ifTrue: [ self organization allMethodSelectors ]	ifFalse: [ self organization listAtCategoryNamed: aName ].^ aColl asSet asArray sort
]

Class TraitDescription >> moveChangesTo: newFile
[
	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."
| changes |changes := self selectors select: [ :sel | (self compiledMethodAt: sel) fileIndex > 1 ].self	fileOutChangedMessages: changes	on: newFile	moveSource: true	toFile: 2
]

Class TraitDescription >> noteAddedSelector: aSelector meta: isMeta
[
	"A hook allowing some classes to react to adding of certain selectors"

]

Class TraitDescription >> noteChangesFrom: oldMethodDict
[
	"create notifications about the changes made to the method dictionary"
	"deal with additions"
self methodDict	keysAndValuesDo: [ :selector :currentMethod | oldMethodDict at: selector ifAbsent: [ self noteMethodAdded: currentMethod ] ].	" deal with removal / updates"oldMethodDict	keysAndValuesDo: [ :selector :oldMethod | 		self methodDict			at: selector			ifPresent: [ :currentMethod | 				currentMethod = oldMethod					ifFalse: [ self noteMethodChanged: oldMethod to: currentMethod ] ]			ifAbsent: [ self noteMethodRemoved: oldMethod ] ]
]

Class TraitDescription >> noteCompilationOf: aSelector meta: isMeta
[
	"A hook allowing some classes to react to recompilation of certain selectors"

]

Class TraitDescription >> noteMethodAdded: aMethod
[
SystemAnnouncer uniqueInstance methodAdded: aMethod
]

Class TraitDescription >> noteMethodChanged: oldMethod to: newMethod
[
SystemAnnouncer uniqueInstance methodChangedFrom: oldMethod to: newMethod
]

Class TraitDescription >> noteMethodRemoved: oldMethod
[
SystemAnnouncer uniqueInstance methodRemoved: oldMethod
]

Class TraitDescription >> noteRecategorizedSelector: aSymbol from: oldCategoryOrNil to: newCategoryOrNil
[
| changedCategories |changedCategories := self	updateOrganizationSelector: aSymbol	oldCategory: oldCategoryOrNil	newCategory: newCategoryOrNil.changedCategories	do: [ :each | 		(self organization isEmptyCategoryNamed: each)			ifTrue: [ self organization removeCategory: each ] ]
]

Class TraitDescription >> noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition
[
aCollection	do: [ :each | 		| oldCategory newCategory |		oldCategory := self organization categoryOfElement: each.		newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.		self noteRecategorizedSelector: each from: oldCategory to: newCategory ]
]

Class TraitDescription >> notifyOfRecategorizedSelector: element from: oldCategory to: newCategory
[
SystemAnnouncer uniqueInstance	selector: element	recategorizedFrom: oldCategory	to: newCategory	inClass: self.SystemAnnouncer uniqueInstance	suspendAllWhile: [ self notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory ]
]

Class TraitDescription >> notifyUsersOfChangedSelectors: aCollection
[
self users do: [ :each | each noteChangedSelectors: aCollection ]
]

Class TraitDescription >> notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory
[
self users do: [ :each | each noteRecategorizedSelector: element from: oldCategory to: newCategory ]
]

Class TraitDescription >> numberOfMethods
[
	"cound all methods that are local (not comming from a trait)"
| num |num := self localMethods size.self isMeta	ifTrue: [ ^ num ]	ifFalse: [ ^ num + self class numberOfMethods ]
]

Class TraitDescription >> obsolete
[
	"Make the receiver obsolete."
self organization: nil.super obsolete
]

Class TraitDescription >> organization
[
	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."
organization ifNil: [ self organization: (ClassOrganizer defaultList: self selectors asArray sort) ].	"Making sure that subject is set correctly. It should not be necessary."organization ifNotNil: [ organization setSubject: self ].^ organization
]

Class TraitDescription >> organization: aClassOrg
[
	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."
aClassOrg ifNotNil: [ aClassOrg setSubject: self ].organization := aClassOrg
]

Class TraitDescription >> printCategoryChunk: categoryName on: aFileStream
[
^ self printCategoryChunk: categoryName withStamp: '' on: aFileStream
]

Class TraitDescription >> printCategoryChunk: category on: aFileStream priorMethod: priorMethod
[
^ self	printCategoryChunk: category	on: aFileStream	withStamp: Author changeStamp	priorMethod: priorMethod
]

Class TraitDescription >> printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod
[
	"Print a method category preamble.  This must have a category name.	It may have an author/date stamp, and it may have a prior source link.	If it has a prior source link, it MUST have a stamp, even if it is empty."
	"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."
aFileStream	cr;	nextPut: $!.aFileStream	nextChunkPut:		(String			streamContents: [ :strm | 				strm					nextPutAll: self name;					nextPutAll: ' methodsFor: ';					print: category asString.				(changeStamp ~~ nil and: [ changeStamp size > 0 or: [ priorMethod ~~ nil ] ])					ifTrue: [ 						strm							nextPutAll: ' stamp: ';							print: changeStamp ].				priorMethod ~~ nil					ifTrue: [ 						strm							nextPutAll: ' prior: ';							print: priorMethod sourcePointer ] ])
]

Class TraitDescription >> printCategoryChunk: categoryName withStamp: changeStamp on: aFileStream
[
^ self	printCategoryChunk: categoryName	on: aFileStream	withStamp: changeStamp	priorMethod: nil
]

Class TraitDescription >> printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
[
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
| preamble method oldPos newPos sourceFile endPos |doPreamble	ifTrue: [ preamble := self name , ' methodsFor: ' , (self organization categoryOfElement: selector) asString printString ]	ifFalse: [ preamble := '' ].method := self methodDict	at: selector	ifAbsent: [ 		outStream			nextPutAll: selector;			cr.		outStream			tab;			nextPutAll: '** ERROR!  THIS SCRIPT IS MISSING ** ' translated;			cr;			cr.		outStream nextPutAll: '  '.		^ outStream ].((method fileIndex = 0 or: [ (SourceFiles at: method fileIndex) == nil ]) or: [ (oldPos := method filePosition) = 0 ])	ifTrue: [ 		"The source code is not accessible.  We must decompile..."		preamble size > 0			ifTrue: [ 				outStream					cr;					nextPut: $!;					nextChunkPut: preamble;					cr ].		outStream nextChunkPut: method decompileString ]	ifFalse: [ 		sourceFile := SourceFiles at: method fileIndex.		preamble size > 0			ifTrue: [ 				"Copy the preamble"				outStream copyPreamble: preamble from: sourceFile at: oldPos ]			ifFalse: [ sourceFile position: oldPos ].	"Copy the method chunk"		newPos := outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.	"The following chunk may have ]style["		sourceFile peek == $]			ifTrue: [ 				outStream					cr;					copyMethodChunkFrom: sourceFile ].		moveSource			ifTrue: [ 				"Set the new method source pointer"				endPos := outStream position.				method setSourcePosition: newPos inFile: fileIndex ] ].preamble size > 0	ifTrue: [ outStream nextChunkPut: ' ' ].^ outStream cr
]

Class TraitDescription >> printOn: aStream
[
aStream nextPutAll: self name
]

Class TraitDescription >> putClassCommentToCondensedChangesFile: aFileStream
[
	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."
| header aStamp aCommentRemoteStr |self isMeta	ifTrue: [ ^ self ].	"bulletproofing only"((aCommentRemoteStr := self organization commentRemoteStr) isNil or: [ aCommentRemoteStr sourceFileNumber = 1 ])	ifTrue: [ ^ self ].aFileStream	cr;	nextPut: $!.header := String	streamContents: [ :strm | 		strm			nextPutAll: self name;			nextPutAll: ' commentStamp: '.		(aStamp := self organization commentStamp ifNil: [ '<historical>' ]) storeOn: strm.		strm nextPutAll: ' prior: 0' ].aFileStream nextChunkPut: header.aFileStream cr.self organization	classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream)	stamp: aStamp
]

Class TraitDescription >> reformatAll
[
	"Reformat all methods in this class.	Leaves old code accessible to version browsing"
self selectorsDo: [ :sel | self reformatMethodAt: sel ]
]

Class TraitDescription >> reformatMethodAt: selector
[
| newCodeString method |newCodeString := self prettyPrinterClass format: (self sourceCodeAt: selector) in: self notifying: nil.method := self compiledMethodAt: selector.method	putSource: newCodeString	fromParseNode: nil	class: self	category: (self organization categoryOfElement: selector)	inFile: 2	priorMethod: method
]

Class TraitDescription >> removeCategory: aString
[
	"Remove each of the messages categorized under aString in the method 	dictionary of the receiver. Then remove the category aString."
| categoryName |categoryName := aString asSymbol.(self organization listAtCategoryNamed: categoryName) do: [ :sel | self removeSelector: sel ].self organization removeCategory: categoryName
]

Class TraitDescription >> removeSelector: selector
[
	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."
| priorMethod priorProtocol |priorMethod := self compiledMethodAt: selector ifAbsent: [ ^ nil ].priorProtocol := self whichCategoryIncludesSelector: selector.super removeSelector: selector.SystemAnnouncer uniqueInstance	suspendAllWhile: [ self updateOrganizationSelector: selector oldCategory: priorProtocol newCategory: nil ].SystemAnnouncer uniqueInstance	methodRemoved: priorMethod	selector: selector	inProtocol: priorProtocol	class: self
]

Class TraitDescription >> reorganize
[
	"During fileIn, !Rectangle reorganize! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"
^ self organization
]

Class TraitDescription >> selectorsToFileOutCategory: aSymbol
[
^ (aSymbol asString = ClassOrganizer allCategory	ifTrue: [ self organization allMethodSelectors ]	ifFalse: [ self organization listAtCategoryNamed: aSymbol ]) select: [ :sel | self includesLocalSelector: sel ]
]

Class TraitDescription >> spaceUsed
[
^ super spaceUsed	+		(self hasClassTrait			ifTrue: [ self classTrait spaceUsed ]			ifFalse: [ 0 ])
]

Class TraitDescription >> storeOn: aStream
[
	"Classes and Metaclasses have global names."
aStream nextPutAll: self name
]

Class TraitDescription >> theMetaClass
[
^ self classTrait
]

Class TraitDescription >> theNonMetaClass
[
^ self baseTrait
]

Class TraitDescription >> traitVersion
[
	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"
	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."
^ 0
]

Class TraitDescription >> updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil
[
| changedCategories composition |changedCategories := IdentitySet new.composition := self hasTraitComposition	ifTrue: [ self traitComposition ]	ifFalse: [ TraitComposition new ].(composition methodDescriptionsForSelector: aSymbol)	do: [ :each | 		| effectiveCategory sel currentCategory |		sel := each selector.		(self includesLocalSelector: sel)			ifFalse: [ 				currentCategory := self organization categoryOfElement: sel.				effectiveCategory := each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.				effectiveCategory isNil					ifTrue: [ 						currentCategory ifNotNil: [ changedCategories add: currentCategory ].						self organization removeElement: sel ]					ifFalse: [ 						((currentCategory isNil or: [ currentCategory == ClassOrganizer ambiguous or: [ currentCategory == oldCategoryOrNil ] ])							and: [ currentCategory ~~ effectiveCategory ])							ifTrue: [ 								currentCategory ifNotNil: [ changedCategories add: currentCategory ].								self organization classify: sel under: effectiveCategory suppressIfDefault: false ] ] ] ].^ changedCategories
]

Class TraitDescription >> variablesAndOffsetsDo: aBlock
[
^ self
]

Class TraitDescription >> version
[
	"Allows polymoprhism with ClassDescription>>version"
^ self traitVersion
]

Class TraitDescription >> wantsChangeSetLogging
[
	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.  7/12/96 sw"
^ true
]

Class TraitDescription >> wantsRecompilationProgressReported
[
	"Answer whether the receiver would like progress of its recompilation reported interactively to the user."
^ true
]

Class TraitDescription >> whichCategoryIncludesSelector: aSelector
[
	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."
(self includesSelector: aSelector)	ifTrue: [ ^ self organization categoryOfElement: aSelector ]	ifFalse: [ ^ nil ]
]

Class TraitDescription >> zapOrganization
[
	"Remove the organization of this class by message categories.	This is typically done to save space in small systems.  Classes and methods	created or filed in subsequently will, nonetheless, be organized"
self organization: nil.self isClassSide	ifFalse: [ self classSide zapOrganization ]
]

Metaclass
	name: #TraitDescription;
	instanceVariables: #().

