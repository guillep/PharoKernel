TraitDescription
	superclass: #TraitBehavior;
	traitComposition: TClassAndTraitDescription + TComposingDescription + TTransformationCompatibility;
	instanceVariables: #(#organization );
	package: #'Traits-Kernel'.

TraitDescription >> - anArrayOfSelectors
[
	^ TraitExclusion
		with: self
		exclusions: (anArrayOfSelectors isSymbol
				ifTrue: [ {anArrayOfSelectors} ]
				ifFalse: [ anArrayOfSelectors ])
]

TraitDescription >> addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor
[
	| priorMethodOrNil oldProtocol newProtocol |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [  ].	"We categorize first, so the users can use the categorization at the add moment"
	oldProtocol := self organization categoryOfElement: selector.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ self organization classify: selector under: category ].
	self addSelectorSilently: selector withMethod: compiledMethod.
	newProtocol := self organization categoryOfElement: selector.
	priorMethodOrNil isNil
		ifTrue: [ SystemAnnouncer uniqueInstance
				methodAdded: compiledMethod
				selector: selector
				inProtocol: category
				class: self
				requestor: requestor ]
		ifFalse: [ SystemAnnouncer uniqueInstance
				methodChangedFrom: priorMethodOrNil
				to: compiledMethod
				selector: selector
				inClass: self
				oldProtocol: oldProtocol
				newProtocol: newProtocol
				requestor: requestor ]
]

TraitDescription >> addExclusionOf: aSymbol
[
	^ self - {aSymbol}
]

TraitDescription >> allMethodsInCategory: aName
[
	"Answer a list of all the method categories of the receiver"

	| aColl |
	aColl := aName = ClassOrganizer allCategory
		ifTrue: [ self organization allMethodSelectors ]
		ifFalse: [ self organization listAtCategoryNamed: aName ].
	^ aColl asSet asArray sort
]

TraitDescription >> allSelectorsWithout: aBehaviorsCollection
[
	"For compatibility"

	^ self selectors
]

TraitDescription >> baseTrait
[
	self subclassResponsibility
]

TraitDescription >> category
[
	self subclassResponsibility
]

TraitDescription >> category: aString
[
	self subclassResponsibility
]

TraitDescription >> classCommentBlank
[
	| existingComment stream |
	existingComment := self instanceSide organization classComment.
	existingComment isEmpty
		ifFalse: [ ^ existingComment ].
	stream := (String new: 100) writeStream.
	stream
		nextPutAll: 'A';
		nextPutAll: (self name first isVowel
						ifTrue: [ 'n ' ]
						ifFalse: [ ' ' ]);
		nextPutAll: self name;
		nextPutAll: ' is xxxxxxxxx.'.
	stream cr.
	^ stream contents
]

TraitDescription >> classSide
[
	^ self classTrait
]

TraitDescription >> classTrait
[
	self subclassResponsibility
]

TraitDescription >> collectMethodsFor: aSelector into: methodDescription
[
	(self includesSelector: aSelector)
		ifTrue: [ methodDescription addLocatedMethod: (self compiledMethodAt: aSelector) ]
]

TraitDescription >> compile: text classified: category notifying: requestor
[
	| stamp |
	stamp := self acceptsLoggingOfCompilation
		ifTrue: [ Author changeStamp ]
		ifFalse: [ nil ].
	^ self
		compile: text
		classified: category
		withStamp: stamp
		notifying: requestor
]

TraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor
[
	^ self
		compile: text
		classified: category
		withStamp: changeStamp
		notifying: requestor
		logSource: self acceptsLoggingOfCompilation
]

TraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
	| methodAndNode |
	methodAndNode := self
		compile: text asString
		classified: category
		notifying: requestor
		trailer: self defaultMethodTrailer
		ifFail: [ ^ nil ].
	logSource
		ifTrue: [ self
				logMethodSource: methodAndNode node sourceCode
				forMethodWithNode: methodAndNode
				inCategory: category
				withStamp: changeStamp
				notifying: requestor ].
	self
		addAndClassifySelector: methodAndNode selector
		withMethod: methodAndNode method
		inProtocol: category
		notifying: requestor.
	self instanceSide noteCompilationOf: methodAndNode selector meta: self isClassSide.
	^ methodAndNode selector
]

TraitDescription >> copyTraitExpression
[
	"When recursively copying a trait expression, the primitive traits should NOT be copied
because they are globally named 'well-known' objects"

	^ self
]

TraitDescription >> fileOut
[
	"Create a file whose name is the name of the receiver with '.st' as the 
	extension, and file a description of the receiver onto it."

	| internalStream |
	internalStream := (String new: 100) writeStream.
	internalStream
		header;
		timeStamp.
	self fileOutOn: internalStream moveSource: false toFile: 0.
	internalStream trailer.
	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true
]

TraitDescription >> fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the messages of this class that have been 
	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.changes file, and should only write a preamble for every method."

	| org |
	(org := self organization) categories
		do: [ :cat | | sels |
			sels := (org listAtCategoryNamed: cat) select: [ :sel | aSet includes: sel ].
			sels
				do: [ :sel | self
						printMethodChunk: sel
						withPreamble: true
						on: aFileStream
						moveSource: moveSource
						toFile: fileIndex ] ]
]

TraitDescription >> hasClassTrait
[
	self subclassResponsibility
]

TraitDescription >> instanceSide
[
	^ self baseTrait
]

TraitDescription >> isBaseTrait
[
	self subclassResponsibility
]

TraitDescription >> isClassTrait
[
	self subclassResponsibility
]

TraitDescription >> isTestCase
[
	^ false
]

TraitDescription >> linesOfCode
[
	"An approximate measure of lines of code.
	Includes comments, but excludes blank lines."

	| lines |
	lines := self localMethods inject: 0 into: [ :sum :each | sum + each linesOfCode ].
	^ self isMeta
		ifTrue: [ lines ]
		ifFalse: [ lines + self class linesOfCode ]
]

TraitDescription >> logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor
[
	aCompiledMethodWithNode method
		putSource: aText
		fromParseNode: aCompiledMethodWithNode node
		class: self
		category: category
		withStamp: changeStamp
		inFile: 2
		priorMethod: (self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [  ])
]

TraitDescription >> methodsInCategory: aName
[
	"Answer a list of the methods of the receiver that are in category named aName"

	| aColl |
	aColl := Set
		withAll:
			(aName = ClassOrganizer allCategory
				ifTrue: [ self organization allMethodSelectors ]
				ifFalse: [ self organization listAtCategoryNamed: aName ]).
	^ aColl asArray sort
]

TraitDescription >> noteChangesFrom: oldMethodDict
[
	"create notifications about the changes made to the method dictionary"

	"deal with additions"

	self methodDict
		keysAndValuesDo: [ :selector :currentMethod | oldMethodDict at: selector ifAbsent: [ self noteMethodAdded: currentMethod ] ].	" deal with removal / updates"
	oldMethodDict
		keysAndValuesDo: [ :selector :oldMethod | self methodDict
				at: selector
				ifPresent: [ :currentMethod | currentMethod = oldMethod
						ifFalse: [ self noteMethodChanged: oldMethod to: currentMethod ] ]
				ifAbsent: [ self noteMethodRemoved: oldMethod ] ]
]

TraitDescription >> noteMethodAdded: aMethod
[
	SystemAnnouncer uniqueInstance methodAdded: aMethod
]

TraitDescription >> noteMethodChanged: oldMethod to: newMethod
[
	SystemAnnouncer uniqueInstance methodChangedFrom: oldMethod to: newMethod
]

TraitDescription >> noteMethodRemoved: oldMethod
[
	SystemAnnouncer uniqueInstance methodRemoved: oldMethod
]

TraitDescription >> noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition
[
	aCollection
		do: [ :each | | oldCategory newCategory |
			oldCategory := self organization categoryOfElement: each.
			newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.
			self noteRecategorizedSelector: each from: oldCategory to: newCategory ]
]

TraitDescription >> notifyOfRecategorizedSelector: element from: oldCategory to: newCategory
[
	SystemAnnouncer uniqueInstance
		selector: element
		recategorizedFrom: oldCategory
		to: newCategory
		inClass: self.
	SystemAnnouncer uniqueInstance
		suspendAllWhile: [ self notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory ]
]

TraitDescription >> notifyUsersOfChangedSelectors: aCollection
[
	self users do: [ :each | each noteChangedSelectors: aCollection ]
]

TraitDescription >> notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory
[
	self users do: [ :each | each noteRecategorizedSelector: element from: oldCategory to: newCategory ]
]

TraitDescription >> numberOfMethods
[
	"cound all methods that are local (not comming from a trait)"

	| num |
	num := self localMethods size.
	self isMeta
		ifTrue: [ ^ num ]
		ifFalse: [ ^ num + self class numberOfMethods ]
]

TraitDescription >> obsolete
[
	"Make the receiver obsolete."

	self organization: nil.
	super obsolete
]

TraitDescription >> organization
[
	"Answer the instance of ClassOrganizer that represents the organization 
	of the messages of the receiver."

	organization ifNil: [ self organization: (ClassOrganizer defaultList: self selectors asArray sort) ].	"Making sure that subject is set correctly. It should not be necessary."
	organization ifNotNil: [ organization setSubject: self ].
	^ organization
]

TraitDescription >> organization: aClassOrg
[
	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."

	aClassOrg ifNotNil: [ aClassOrg setSubject: self ].
	organization := aClassOrg
]

TraitDescription >> printCategoryChunk: category on: aFileStream priorMethod: priorMethod
[
	^ self
		printCategoryChunk: category
		on: aFileStream
		withStamp: Author changeStamp
		priorMethod: priorMethod
]

TraitDescription >> putClassCommentToCondensedChangesFile: aFileStream
[
	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."

	| header aStamp aCommentRemoteStr |
	self isMeta
		ifTrue: [ ^ self ].	"bulletproofing only"
	((aCommentRemoteStr := self organization commentRemoteStr) isNil or: [ aCommentRemoteStr sourceFileNumber = 1 ])
		ifTrue: [ ^ self ].
	aFileStream
		cr;
		nextPut: $!.
	header := String
		streamContents: [ :strm | strm
				nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
			(aStamp := self organization commentStamp ifNil: [ '<historical>' ]) storeOn: strm.
			strm nextPutAll: ' prior: 0' ].
	aFileStream nextChunkPut: header.
	aFileStream cr.
	self organization
		classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream)
		stamp: aStamp
]

TraitDescription >> spaceUsed
[
	^ super spaceUsed + (self hasClassTrait
				ifTrue: [ self classTrait spaceUsed ]
				ifFalse: [ 0 ])
]

TraitDescription >> theMetaClass
[
	^ self classTrait
]

TraitDescription >> theNonMetaClass
[
	^ self baseTrait
]

TraitDescription >> traitVersion
[
	"Default.  Any class may return a later version to inform readers that use ReferenceStream. 
	This method allows you to distinguish between class versions when the shape of the class 
	hasn't changed (when there's no change in the instVar names).
	In the conversion methods you usually can tell by the inst var names 
	what old version you have. In a few cases, though, the same inst var 
	names were kept but their interpretation changed (like in the layoutFrame).
	By changing the class version when you keep the same instVars you can 
	warn older and newer images that they have to convert."

	^ 0
]

TraitDescription >> variablesAndOffsetsDo: aBlock
[
	^ self
]

TraitDescription >> version
[
	"Allows polymoprhism with ClassDescription>>version"

	^ self traitVersion
]

