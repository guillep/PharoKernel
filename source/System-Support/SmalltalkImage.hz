SmalltalkImage
	instanceVariables: #(#globals #deferredStartupActions #specialObjectsArray #session );
	classVariables: #(#CompilerClass #MemoryHogs #EndianCache #ShouldDownloadSourcesFile #ShutDownList #Tools #CheckSourcesFileAvailability #CheckChangesFileAvailability #StartUpList #LowSpaceProcess #LastQuitLogPosition #SpecialSelectors #SourceFileVersionString #LowSpaceSemaphore #LastImagePath );
	package: #'System-Support'.

SmalltalkImage >> add: aClass toList: startUpOrShutDownList after: predecessor
[
	"Add the name of aClass to the startUp or shutDown list.
	Add it after the name of predecessor"

	(Smalltalk globals includes: aClass)
		ifFalse: [ self error: aClass name , ' cannot be found in Smalltalk dictionary.' ].	"Add after predecessor, moving it if already there."
	(Smalltalk globals includes: predecessor)
		ifFalse: [ self error: predecessor name , ' cannot be found in Smalltalk dictionary.' ].
	(startUpOrShutDownList includes: predecessor name)
		ifFalse: [ self error: predecessor name , ' cannot be found in the list.' ].
	startUpOrShutDownList remove: aClass name ifAbsent: [  ].
	startUpOrShutDownList add: aClass name after: predecessor name
]

SmalltalkImage >> add: aClass toList: startUpOrShutDownList before: successor
[
	"Add the name of aClass to the startUp or shutDown list.
	Add it before the name of successor"

	(Smalltalk globals includes: aClass)
		ifFalse: [ self error: aClass name , ' cannot be found in Smalltalk dictionary.' ].	"Add before successor, moving it if already there."
	(Smalltalk globals includes: successor)
		ifFalse: [ self error: successor name , ' cannot be found in Smalltalk dictionary.' ].
	(startUpOrShutDownList includes: successor name)
		ifFalse: [ self error: successor name , ' cannot be found in the list.' ].
	startUpOrShutDownList remove: aClass name ifAbsent: [  ].
	startUpOrShutDownList add: aClass name before: successor name
]

SmalltalkImage >> addDeferredStartupAction: aBlock
[
	"Add the monadic or nulladic block to the list of actions that we will be performed immediately after the startup is totally executed."

	deferredStartupActions ifNil: [ deferredStartupActions := OrderedCollection new ].
	deferredStartupActions add: aBlock
]

SmalltalkImage >> addSnapshotRecord: save andQuit: quit
[
	"Originally this code were in #snapshot:andQuit: .
	Just moved it to separate method to make caller more readable
	and don't look like swiss army knife which tries to do everything by own "

	| msg |
	(SourceFiles at: 2)
		ifNotNil: [ msg := String
				streamContents: [ :s | s
						nextPutAll: '----';
						nextPutAll:
								(save
										ifTrue: [ quit
												ifTrue: [ 'QUIT' ]
												ifFalse: [ 'SNAPSHOT' ] ]
										ifFalse: [ quit
												ifTrue: [ 'QUIT/NOSAVE' ]
												ifFalse: [ 'NOP' ] ]);
						nextPutAll: '----';
						print: Date dateAndTimeNow;
						space;
						nextPutAll: self imageFile basename;
						nextPutAll: ' priorSource: ';
						print: LastQuitLogPosition ].
			self assureStartupStampLogged.
			save
				ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2)
						setToEnd;
						position ].
			self logChange: msg.
			self traceCr: msg ]
]

SmalltalkImage >> addToShutDownList: aClass
[
	"This will add a ref to this class at the BEGINNING of the shutDown list."

	"No-op if already in the list."

	(ShutDownList includes: aClass name)
		ifFalse: [ ShutDownList addFirst: aClass name ]
]

SmalltalkImage >> addToShutDownList: aClass after: predecessor
[
	self add: aClass toList: ShutDownList after: predecessor
]

SmalltalkImage >> addToShutDownList: aClass before: predecessor
[
	self add: aClass toList: ShutDownList before: predecessor
]

SmalltalkImage >> addToStartUpList: aClass
[
	"This will add a ref to this class at the END of the startUp list."

	"No-op if already in the list."

	(StartUpList includes: aClass name)
		ifFalse: [ StartUpList addLast: aClass name ]
]

SmalltalkImage >> addToStartUpList: aClass after: predecessor
[
	self add: aClass toList: StartUpList after: predecessor
]

SmalltalkImage >> addToStartUpList: aClass before: predecessor
[
	self add: aClass toList: StartUpList before: predecessor
]

SmalltalkImage >> allClasses
[
	"Return all the class defines in the SmalltalkImage"

	"Smalltalk allClasses"

	"May be we could discard this one in the future"

	^ globals allClasses
]

SmalltalkImage >> allClassesAndTraits
[
	"Return all the classes and traits defined in the Smalltalk SmalltalkImage"

	^ globals allClassesAndTraits
]

SmalltalkImage >> allClassesAndTraitsDo: aBlock
[
	^ globals allClassesAndTraitsDo: aBlock
]

SmalltalkImage >> allClassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each class in the system."

	globals allClassesDo: aBlock
]

SmalltalkImage >> allTraits
[
	"Return all traits defined in the Smalltalk SmalltalkImage"

	^ globals allTraits
]

SmalltalkImage >> argumentAt: i
[
	"Answer the i-th argument of the command line, or nil if not so many argument."

	^ self vm getSystemAttribute: 2 + i
]

SmalltalkImage >> arguments
[
	"Answer an array with all the command line arguments.
	This does not include imagePath, documentPath nor any option."

	"Smalltalk commandLine arguments"

	^ Array
		streamContents: [ :str | | arg i |
			i := 1.
			[ i > 998 or: [ (arg := self argumentAt: i) == nil ] ] whileFalse: [ str nextPut: arg.
					i := i + 1 ] ]
]

SmalltalkImage >> associationAt: key ifAbsent: aBlock
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals associationAt: key ifAbsent: aBlock
]

SmalltalkImage >> associationOrUndeclaredAt: key
[
	"return an association or install in undeclared.  Used for mating up ImageSegments."

	^ globals associationOrUndeclaredAt: key
]

SmalltalkImage >> assureStartupStampLogged
[
	"If there is a startup stamp not yet actually logged to disk, do it now."

	ChangesLog default assureStartupStampLogged
]

SmalltalkImage >> at: aKey
[
	"Answer the global associated with the key."

	^ globals at: aKey
]

SmalltalkImage >> at: key ifAbsent: aBlock
[
	"Answer the global associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."

	^ globals at: key ifAbsent: aBlock
]

SmalltalkImage >> at: aKey ifAbsentPut: aBlock
[
	"Return the global at the given key. 
	If key is not included in the receiver store the result 
	of evaluating aBlock as new value."

	^ globals at: aKey ifAbsentPut: aBlock
]

SmalltalkImage >> at: key ifPresent: aBlock
[
	"Lookup the given key in the globals. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	^ globals at: key ifPresent: aBlock
]

SmalltalkImage >> at: aKey put: anObject
[
	"Set the global at key to be anObject.  If key is not found, create a
	new entry for key and set is value to anObject. Answer anObject."

	^ globals at: aKey put: anObject
]

SmalltalkImage >> backupImageInFileNamed: aFileReference
[
	"Save the  the image under the given file. 
	Unlike #saveImageInFileNamed: this method continues evaluation in the original image after saving a backup copy.
	Note: This method does not save the .changes file, use #saveAs:"

	| imageFile previousFullImageName isNewSession |
	imageFile := aFileReference asFileReference.
	imageFile parent ensureDirectory.
	previousFullImageName := self imagePath.
	isNewSession := false.
	[ "change to the new image name "
	self
		changeImagePathTo: imageFile fullName;
		closeSourceFiles;
		openSourceFiles.	"so SNAPSHOT appears in new changes file"
	isNewSession := self snapshot: true andQuit: false ]
		ensure: [ isNewSession
				ifFalse: [ "unlike #saveImageInFileNamed: we do NOT continue in the new image"
					"switch back to the old image"
					self
						changeImagePathTo: previousFullImageName;
						closeSourceFiles;
						openSourceFiles ] ].
	^ isNewSession
]

SmalltalkImage >> backupTo: newNameWithoutSuffix
[
	"Create a new backup of this image. 
	Unlike #saveAs: do not transfer the default execution to the new image. 
	Results:
		true  when continuing in the new session
		false for the current session"

	(SourceFiles at: 2)
		ifNotNil: [ self
				closeSourceFiles;
				saveChangesInFileNamed: (self fullNameForChangesNamed: newNameWithoutSuffix)	"so copying the changes file will always work" ].
	^ self backupImageInFileNamed: (self fullNameForImageNamed: newNameWithoutSuffix)
]

SmalltalkImage >> bindingOf: varName
[
	"Answer the binding of some variable resolved in the scope of the receiver"

	^ globals bindingOf: varName
]

SmalltalkImage >> bytesLeft
[
	"Answer the number of bytes of space available. Does a full garbage collection."

	^ self garbageCollect
]

SmalltalkImage >> bytesLeft: aBool
[
	"Return the amount of available space. If aBool is true, include possibly available swap space. If aBool is false, include possibly available physical memory. For a report on the largest free block currently availabe within Pharo memory but not counting extra memory use #primBytesLeft."

	<primitive: 112>
	^ self primBytesLeft
]

SmalltalkImage >> calcEndianness
[
	| bytes word blt |
	"What endian-ness is the current hardware?  The String '1234' will be stored into a machine word.  On BigEndian machines (the Mac), $1 will be the high byte if the word.  On LittleEndian machines (the PC), $4 will be the high byte."
	"SmalltalkImage current endianness"
	bytes := #[0 0 0 0].	"(1 2 3 4) or (4 3 2 1)"
	word := WordArray with: 16r01020304.
	blt := (BitBlt toForm: (Form new hackBits: bytes)) sourceForm: (Form new hackBits: word).
	blt combinationRule: Form over.	"store"
	blt
		sourceY: 0;
		destY: 0;
		height: 1;
		width: 4.
	blt
		sourceX: 0;
		destX: 0.
	blt copyBits.	"paste the word into the bytes"
	bytes first = 1
		ifTrue: [ ^ #big ].
	bytes first = 4
		ifTrue: [ ^ #little ].
	self error: 'Ted is confused'
]

SmalltalkImage >> changeImagePathTo: aString
[
	self imagePath: aString asSqueakPathName.
	LastImagePath := self imagePath
]

SmalltalkImage >> changesFile
[
	"Answer the file containing the current changes."

	^ FileLocator changes
]

SmalltalkImage >> changesName
[
	"Answer the name for the changes file corresponding to the image file name."

	"Smalltalk changesName"

	^ self changesFile fullName
]

SmalltalkImage >> changesSuffix
[
	^ 'changes'
]

SmalltalkImage >> checkAndOpenSourcesAndChanges
[
	"Open the changes and sources files and install them in SourceFiles. 
	Inform the user of problems regarding write permissions or CR/CRLF mixups."

	"Note: SourcesName and imageName are full paths; 
	changesName is a  local name."

	| sources changes msg wmsg |
	msg := 'Pharo cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.'.
	wmsg := 'Pharo cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.
	(sources := self openSources: self sourcesName forImage: LastImagePath)
		ifNil: [ [ self downloadSources ]
				on: MessageNotUnderstood
				do: [ :exception | "ignore"
					 ].
			sources := self openSources: self sourcesName forImage: LastImagePath ].
	changes := self openChanges: self changesName forImage: LastImagePath.
	((sources == nil or: [ sources atEnd ]) and: [ self checkSourcesFileAvailability ])
		ifTrue: [ 
			OSPlatform isMacOS
				ifTrue: [ 
					msg := msg
						,
							'Make sure the sources file is not an Alias.' ].
			self inform: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , self sourcesName) ].
	(changes == nil and: [ self checkChangesFileAvailability ])
		ifTrue: [ self inform: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , self changesName) ].
	(self checkChangesFileAvailability and: [ changes notNil ])
		ifTrue: [ 
			changes isReadOnly
				ifTrue: [ self inform: (wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , self changesName) ].
			((changes next: 200) includesSubstring: String crlf)
				ifTrue: [ 
					self
						inform:
							'The changes file named ' , self changesName
								,
									'has been injured by an unpacking utility.  Crs were changed to CrLfs.Please set the preferences in your decompressing program to "do not convert text files" and unpack the system again.' ] ].
	SourceFiles := Array with: sources with: changes
]

SmalltalkImage >> checkChangesFileAvailability
[
	^ self class checkChangesFileAvailability
]

SmalltalkImage >> checkSourcesFileAvailability
[
	^ self class checkSourcesFileAvailability
]

SmalltalkImage >> classNamed: className
[
	^ globals classOrTraitNamed: className
]

SmalltalkImage >> classNames
[
	^ globals classNames
]

SmalltalkImage >> classOrTraitNamed: aString
[
	"aString is either a class or trait name or a class or trait name followed by ' class' or 'classTrait' respectively. Answer the class or metaclass it names."

	^ globals classOrTraitNamed: aString
]

SmalltalkImage >> cleanOutUndeclared
[
	Undeclared removeUnreferencedKeys
]

SmalltalkImage >> cleanUp
[
	"Smalltalk cleanUp"

	"Gently clean up"

	^ self cleanUp: false
]

SmalltalkImage >> cleanUp: aggressive
[
	"Clean up. When aggressive is true, this will destroy change sets, etc."

	"Smalltalk cleanUp: false"

	"Smalltalk cleanUp: true"

	^ self cleanUp: aggressive except: #()
]

SmalltalkImage >> cleanUp: aggressive except: exclusions
[
	"Clean up. When aggressive is true, this will destroy resources, change sets, etc.
	Leave out any classes specifically listed in exclusions."

	"Smalltalk cleanUp: true except: {Point . ChangeSet}"

	^ self cleanUp: aggressive except: exclusions confirming: aggressive
]

SmalltalkImage >> cleanUp: aggressive except: exclusions confirming: aBool
[
	"Clean up. When aggressive is true, this will destroy resources, change sets, etc.
	Leave out any classes specifically listed in exclusions."

	"Smalltalk cleanUp: true except: {Point . ChangeSet} 
		- will ask for confirmation"

	"SmalltalkImage current cleanUp: true except: {} confirming: false 
		- will not ask for confirmation"

	| classes |
	aBool
		ifTrue: [ 
			"Give the user a chance to bail"
			(self
				confirm:
					'Cleanup will destroy projects, change sets and more.Are you sure you want to proceed?')
				ifFalse: [ ^ self ] ].	"Find all classes implementing #cleanUp or cleanUp:"
	classes := Smalltalk allClasses
		select: [ :aClass | (aClass class includesSelector: #cleanUp) or: [ aClass class includesSelector: #cleanUp: ] ].	"Leave out the classes in the exclusion set"
	classes := classes reject: [ :aClass | exclusions includes: aClass ].	"Arrange classes in superclass order, superclasses before subclasses.	This will ensure that specific cleanup (like MethodDictionary compaction)	will run after generic superclass cleanup (HashedCollection rehashing).	Otherwise generic superclass cleanup might undo specific one (in this	case rehashing will undo a good bit of MD compaction)."
	classes := Class superclassOrder: classes.	"Run the cleanup code"
	classes do: [ :aClass | aClass cleanUp: aggressive ] displayingProgress: [ :aClass | 'Cleaning up in ' , aClass name ]
]

SmalltalkImage >> clearExternalObjects
[
	"Clear the array of objects that have been registered for use in non-Smalltalk code."

	"Smalltalk clearExternalObjects"

	ExternalSemaphoreTable clearExternalObjects
]

SmalltalkImage >> closeLog: logger
[
	"This is a _private_ method,
	Because it really belongs to logging facility,
	we should delegate to it at some point "

	logger ifNotNil: [ logger close ]
]

SmalltalkImage >> closeSourceFiles
[
	"Shut down the source files if appropriate. Closing and nilification only take place if the entry was a FileStream, thus allowing stringified sources to remain in the saved image file"

	1 to: 2 do: [ :i | ((SourceFiles at: i) isKindOf: FileStream)
			ifTrue: [ (SourceFiles at: i) close.
				SourceFiles at: i put: nil ] ]
]

SmalltalkImage >> commandLine
[
	"Answer the object to query about command line."

	^ self
]

SmalltalkImage >> compactClassesArray
[
	"Smalltalk compactClassesArray"

	"Return the array of 31 classes whose instances may be
	represented compactly"

	^ self specialObjectsArray at: 29
]

SmalltalkImage >> compiler
[
	^ self compilerClass new
]

SmalltalkImage >> compilerClass
[
	^ CompilerClass ifNil: [ CompilerClass := Compiler ]
]

SmalltalkImage >> condenseChanges
[
	"Move all the changes onto a compacted sources file."

	"Smalltalk condenseChanges"

	| f file oldChanges |
	f := FileStream fileNamed: 'ST80.temp'.
	f
		header;
		timeStamp.
	'Condensing Changes File...'
		displayProgressFrom: 0
		to: self classNames size + self traitNames size
		during: [ :bar | | count |
			count := 0.
			self
				allClassesAndTraitsDo: [ :classOrTrait | bar current: (count := count + 1).
					classOrTrait moveChangesTo: f.
					classOrTrait putClassCommentToCondensedChangesFile: f.
					classOrTrait classSide moveChangesTo: f ] ].
	self lastQuitLogPosition: f position.
	f
		trailer;
		close.
	CompiledMethod cleanUp.
	oldChanges := SourceFiles at: 2.
	oldChanges close.
	(oldChanges name , '.old') asFileReference delete.
	(file := oldChanges name asFileReference) renameTo: file basename , '.old'.
	f name asFileReference renameTo: file basename.
	self setMacFileInfoOn: oldChanges name.
	SourceFiles at: 2 put: (FileStream oldFileNamed: oldChanges name)
]

SmalltalkImage >> condenseSources
[
	"Move all the changes onto a compacted sources file."

	"Smalltalk condenseSources"

	| f dir newVersionString |
	VirtualMachine isRunningCogit
		ifTrue: [ self error: 'Sources cannot be condensed in a Cog (JIT enabled) Virtual Machine. Try a Stack VM.' ].
	self fixUpProblemsWithAllCategory.	"The above removes any concrete, spurious '-- all --' categories, which mess up the process."
	dir := FileSystem workingDirectory.
	newVersionString := UIManager default
		request:
			'Please designate the versionfor the new source code file...'
		initialAnswer: Smalltalk sourceFileVersionString.
	newVersionString ifNil: [ ^ self ].
	newVersionString = self sourceFileVersionString
		ifTrue: [ ^ self error: 'The new source file must not be the same as the old.' ].
	Smalltalk sourceFileVersionString: newVersionString.	"Write all sources with fileIndex 1"
	f := FileStream newFileNamed: Smalltalk sourcesName.
	f
		header;
		timeStamp.
	'Condensing Sources File...'
		displayProgressFrom: 0
		to: self classNames size + self traitNames size
		during: [ :bar | | count |
			count := 0.
			Smalltalk
				allClassesAndTraitsDo: [ :classOrTrait | bar current: (count := count + 1).
					classOrTrait fileOutOn: f moveSource: true toFile: 1 ] ].
	f
		trailer;
		close.	"Make a new empty changes file"
	self closeSourceFiles.
	Smalltalk changesFile renameTo: Smalltalk changesFile basename , '.old'.
	(FileStream newFileNamed: Smalltalk changesName)
		header;
		timeStamp;
		close.
	self lastQuitLogPosition: 0.
	self setMacFileInfoOn: Smalltalk image changesName.
	self setMacFileInfoOn: Smalltalk image sourcesName.
	self openSourceFiles.
	self
		inform:
			'Source files have been rewritten!Check that all is well,and then save/quit.'
]

SmalltalkImage >> createStackOverflow
[
	"For testing the low space handler..."

	"Smalltalk installLowSpaceWatcher; createStackOverflow"

	self createStackOverflow	"infinite recursion"
]

SmalltalkImage >> datedVersion
[
	"Answer the version of this release."

	^ SystemVersion current datedVersion
]

SmalltalkImage >> disableModuleLoading
[
	"Primitive. Disable a new module loading mechanism for the rest of current session.
	This operation is not reversable.
	Any subsequent attempts to load either external or internal module(s) will fail"

	<primitive: 'primitiveDisableModuleLoading' module: ''>
	
]

SmalltalkImage >> do: aBlock
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals do: aBlock
]

SmalltalkImage >> endianness
[
	EndianCache ifNil: [ EndianCache := self calcEndianness ].
	^ EndianCache
]

SmalltalkImage >> environment
[
	"For conversion from Smalltalk to SystemDictionary"

	^ globals
]

SmalltalkImage >> event: anEvent
[
	"Hook for SystemChangeNotifier"

	ChangesLog default logEvent: anEvent
]

SmalltalkImage >> executeDeferredStartupActions: resuming
[
	"Execute the deferred actions which where added during startup, resuming is true if the iage was started fresh, false if we just saved an image"

	| errors |
	deferredStartupActions ifNil: [ ^ #() ].
	errors := OrderedCollection new.
	deferredStartupActions
		do: [ :each | self logStartUpErrorDuring: [ each cull: resuming ] into: errors tryDebugger: self isInteractive ].
	^ errors
]

SmalltalkImage >> exit: exitStatus
[
	"Primitive. Exit to another operating system on the host machine, if one
	exists. All state changes in the object space since the last snapshot are lost.
	Essential. See Object documentation whatIsAPrimitive.
	
	Possible values for exitStatus:
	0:   success
	> 1: error"

	<primitive: 113>
	self primitiveFailed
]

SmalltalkImage >> exitFailure
[
	"Quit the VM with a failing signal.
	Will lose all current changes."

	self exit: 1
]

SmalltalkImage >> exitSuccess
[
	"Quit the VM with a success signal.
	Will lose all current changes."

	self exit: 0
]

SmalltalkImage >> exitToDebugger
[
	"Primitive. Enter the machine language debugger, if one exists. Essential.
	See Object documentation whatIsAPrimitive."

	<primitive: 114>
	self primitiveFailed
]

SmalltalkImage >> externalObjects
[
	"Return an array of objects that have been registered for use in non-Smalltalk code. Smalltalk objects should be referrenced by external code only via indirection through this array, thus allowing the objects to move during compaction. This array can be cleared when the VM re-starts, since variables in external code do not survive snapshots. Note that external code should not attempt to access a Smalltalk object, even via this mechanism, while garbage collection is in progress."

	"Smalltalk externalObjects"

	^ ExternalSemaphoreTable externalObjects
]

SmalltalkImage >> extractMinusParameters
[
	"Returns a dictionary matching parameters beginning by a minus character and the list of the next parameters.
	Here is an example: 
		I suppose I run pharo with: `pharo myImage.image -minus1 'Hello' -minus2 -minus3 'Hello' 'World'`.
		This message will return a citionary with: 
			minus1 --> #(Hello)
			minus2 --> #()
			minus3 --> #('Hello' 'World')"

	| args dict str previous previousWithMinus index |
	dict := Dictionary new.
	args := OrderedCollection new.
	previous := previousWithMinus := ''.
	str := self vm getSystemAttribute: (index := 2).
	[ str isNil ] whileFalse: [ args add: str.
			str := self vm getSystemAttribute: (index := index + 1) ].
	args ifEmpty: [ ^ dict ].
	previous := previousWithMinus := args detect: [ :each | each first = $- ].
	[ args first = previous & args isEmpty not ] whileFalse: [ args removeFirst ].
	args
		do: [ :each | each first = $-
				ifTrue: [ previous first = $-
						ifTrue: [ dict at: previous allButFirst put: #() ].
					previousWithMinus := each ]
				ifFalse: [ dict
						at: previousWithMinus allButFirst
						put: (dict at: previousWithMinus allButFirst ifAbsent: [ #() ]) , (Array with: each) ].
			previous := each ].
	previous first = $-
		ifTrue: [ dict at: previous allButFirst put: #() ].
	^ dict
]

SmalltalkImage >> extractParameters
[
	| pName value index dict |
	dict := Dictionary new.
	index := 3.	"Muss bei 3 starten, da 2 documentName ist"
	[ pName := self vm getSystemAttribute: index.
	pName isEmptyOrNil ]
		whileFalse: [ index := index + 1.
			value := self vm getSystemAttribute: index.
			value ifNil: [ value := '' ].
			dict at: pName asUppercase put: value.
			index := index + 1 ].
	^ dict
]

SmalltalkImage >> fileForChangesNamed: aName
[
	^ (self imageDirectory resolve: aName) , self changesSuffix
]

SmalltalkImage >> fileForImageNamed: aString
[
	^ (self imageDirectory resolve: aString) , self imageSuffix
]

SmalltalkImage >> fixObsoleteReferences
[
	"SmalltalkImage current fixObsoleteReferences.
	SystemNavigation new obsoleteBehaviors size > 0
		ifTrue: [ SystemNavigation new obsoleteBehaviors inspect.
			self error:'Still have obsolete behaviors. See inspector']"

	| informee obsoleteBindings obsName realName realClass |
	Smalltalk
		garbageCollect;
		garbageCollect.
	CompiledMethod allInstances
		do: [ :method | obsoleteBindings := method literals
				select: [ :literal | literal isVariableBinding and: [ literal value isBehavior and: [ literal value isObsolete ] ] ].
			obsoleteBindings
				do: [ :binding | obsName := binding value name.
					self
						trace: 'Binding: ';
						traceCr: obsName.
					realName := obsName copyReplaceAll: 'AnObsolete' with: ''.
					realClass := Smalltalk globals at: realName asSymbol ifAbsent: [ UndefinedObject ].
					binding key: binding key value: realClass ] ].
	Behavior flushObsoleteSubclasses.
	Smalltalk
		garbageCollect;
		garbageCollect
]

SmalltalkImage >> fixUpProblemsWithAllCategory
[
	"Moves all methods that are in formally classified a category named '-- all --' into the default 'as yet unclassified' category"

	"Smalltalk fixUpProblemsWithAllCategory"

	| methodCount classCount |
	self flag: #ShouldBeMovedInClassOrganization.
	methodCount := 0.
	classCount := 0.
	self systemNavigation
		allBehaviorsDo: [ :aClass | | org any |
			org := aClass organization.
			(org categories includes: #'-- all --')
				ifTrue: [ any := false.
					aClass
						selectorsDo: [ :aSelector | | aCategory |
							aCategory := org categoryOfElement: aSelector.
							aCategory = #'-- all --'
								ifTrue: [ org classify: aSelector under: ClassOrganizer default suppressIfDefault: false.
									self crTrace: aClass name , ' >> ' , aSelector.
									methodCount := methodCount + 1.
									any := true ] ].
					any
						ifTrue: [ classCount := classCount + 1 ].
					org removeEmptyCategories ] ].
	self
		crTrace:
			methodCount printString , ' methods in ' , classCount printString
				, ' classes moved from "-- all --" to "as yet unclassified"'
]

SmalltalkImage >> flushClassNameCache
[
	"Smalltalk flushClassNameCache"

	"Force recomputation of the cached list of class names."

	globals flushClassNameCache
]

SmalltalkImage >> forceChangesToDisk
[
	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."

	| changesFile |
	changesFile := SourceFiles at: 2.
	(changesFile isKindOf: FileStream)
		ifTrue: [ changesFile flush.
			changesFile close.
			changesFile open: changesFile name forWrite: true.
			changesFile setToEnd ]
]

SmalltalkImage >> forceTenure
[
	"Primitive. Tell the GC logic to force a tenure on the next increment GC."

	<primitive: 'primitiveForceTenure'>
	^ self primitiveFailed
]

SmalltalkImage >> forgetModule: aString
[
	"Primitive. If the module named aString is loaded, unloaded. If not, and it is marked an unloadable, unmark it so the VM will try to load it again next time. See comment for #unloadModule:."

	<primitive: 571>
	^ self primitiveFailed
]

SmalltalkImage >> fullNameForChangesNamed: aName
[
	^ (self fileForChangesNamed: aName) fullName
]

SmalltalkImage >> fullNameForImageNamed: aString
[
	^ (self fileForImageNamed: aString) fullName
]

SmalltalkImage >> garbageCollect
[
	"Primitive. Reclaims all garbage and answers the number of bytes of available space."

	Object flushDependents.
	Object flushEvents.
	^ self primitiveGarbageCollect
]

SmalltalkImage >> garbageCollectMost
[
	"Primitive. Reclaims recently created garbage (which is usually most of it) fairly quickly and answers the number of bytes of available space."

	<primitive: 131>
	^ self primBytesLeft
]

SmalltalkImage >> getFileNameFromUser
[
	| newName |
	newName := UIManager default
		request: 'New File Name?' translated
		initialAnswer: (self imageFile basename copyUpToLast: Path extensionDelimiter).
	newName isEmptyOrNil
		ifTrue: [ ^ nil ].
	((self fileForImageNamed: newName) exists or: [ (self fileForChangesNamed: newName) exists ])
		ifTrue: [ (self confirm: ('{1} already exists. Overwrite?' translated format: {newName}))
				ifFalse: [ ^ nil ] ].
	^ newName
]

SmalltalkImage >> globals
[
	"Answer the global SystemDictionary"

	^ globals
]

SmalltalkImage >> globals: aSystemDictionary
[
	"Sets the system-wide globals"

	globals ifNotNil: [ self error: 'Cannot overwrite existing globals' ].
	globals := aSystemDictionary
]

SmalltalkImage >> handleStartupErrors: startupErrors
[
	"Handle the errors produced during startup.
	
	Resume to open a non-interactive debugger on the recorded errors"

	self logError: 'Got startup errors: ' inContext: nil.
	startupErrors do: [ :error | self logError: '    ' , error description inContext: nil ].
	self isInteractive
		ifFalse: [ self exitFailure ]
		ifTrue: [ | answer |
			answer := UIManager default
				confirm: 'Got startup errors, proceed to open debuggers'
				trueChoice: 'Debug'
				falseChoice: 'Cancel'.
			answer == true
				ifTrue: [ startupErrors do: #debug ] ]
]

SmalltalkImage >> hasBindingThatBeginsWith: aString
[
	^ globals hasBindingThatBeginsWith: aString
]

SmalltalkImage >> hasClassNamed: aString
[
	"Answer whether there is a class of the given name, but don't intern aString if it's not alrady interned."

	^ globals hasClassNamed: aString
]

SmalltalkImage >> hasSpecialSelector: aLiteral ifTrueSetByte: aBlock
[
	"Some basic messages such as #+ have their own bytecode for speed.
	To gain some space, the literal array of compiled methods does not contain such message selectors.
	This implies that the cross referencer and other tools have to check if a selector is of the optimized one 
	or not by calling this method. This is an optimization when machines were slow and small and it 
	may be removed in the future to gain simplicity."

	1 to: self specialSelectorSize do: [ :index | (self specialSelectorAt: index) == aLiteral
			ifTrue: [ aBlock value: index + 16rAF.
				^ true ] ].
	^ false
]

SmalltalkImage >> image
[
	"Answer the object to query about the current object memory and execution environment."

	^ self
]

SmalltalkImage >> imageDirectory
[
	"Answer the directory containing the current image."

	^ FileLocator imageDirectory
]

SmalltalkImage >> imageFile
[
	"Answer the file for the current image."

	"SmalltalkImage current imageName"

	^ FileLocator image
]

SmalltalkImage >> imageFormatVersion
[
	"Answer an integer identifying the type of image. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required). This invokes an optional primitive
	that may not be available on all virtual machines."

	"Smalltalk image imageFormatVersion"

	<primitive: 'primitiveImageFormatVersion'>
	self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.
	^ ''
]

SmalltalkImage >> imageName
[
	"Answer the full path name for the current image."

	"SmalltalkImage current imageName"

	| str |
	str := self primImageName.
	^ (FilePath pathName: str isEncoded: true) asSqueakPathName
]

SmalltalkImage >> imageName: newName
[
	"Set the the full path name for the current image.  All further snapshots will use this."

	| encoded |
	encoded := (FilePath pathName: newName isEncoded: false) asVmPathName.
	self primImageName: encoded
]

SmalltalkImage >> imagePath
[
	"Answer the full path name for the current image."

	"SmalltalkImage current imageName"

	| str |
	str := self primImagePath.
	^ (FilePath pathName: str isEncoded: true) asSqueakPathName
]

SmalltalkImage >> imagePath: newPath
[
	"Set the the full path name for the current image.  All further snapshots will use this."

	| encoded |
	encoded := (FilePath pathName: newPath isEncoded: false) asVmPathName.
	self primImagePath: encoded
]

SmalltalkImage >> imageSuffix
[
	^ 'image'
]

SmalltalkImage >> includes: element
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals includes: element
]

SmalltalkImage >> includesKey: key
[
	"Answer whether the receiver has a key equal to the argument, key."

	^ globals includesKey: key
]

SmalltalkImage >> informSpaceLeftAfterGarbageCollection
[
	"Do a garbage collection, and report results to the user."

	"SmalltalkImage current informSpaceLeftAfterGarbageCollection"

	self inform: self spaceLeftAfterGarbageCollection
]

SmalltalkImage >> installLowSpaceWatcher
[
	"Start a process to watch for low-space conditions."

	"Smalltalk installLowSpaceWatcher"

	self primSignalAtBytesLeft: 0.	"disable low-space interrupts"
	LowSpaceProcess == nil
		ifFalse: [ LowSpaceProcess terminate ].
	LowSpaceProcess := [ self lowSpaceWatcher ] newProcess.
	LowSpaceProcess priority: Processor lowIOPriority.
	LowSpaceProcess resume
]

SmalltalkImage >> isBigEndian
[
	^ self endianness == #big
]

SmalltalkImage >> isHeadless
[
	"Check if vm were run with headless parameter.
	Different VMs for different platform have different multiple way(s) to indicate that"

	-1000 to: 1000 do: [ :n | (#('display=none' '-headless' '-vm-display-null' '-nodisplay' '--headless' '--vm-display-null' '--nodisplay')
			includes: (self vm getSystemAttribute: n))
			ifTrue: [ ^ true ] ].
	^ false
]

SmalltalkImage >> isInteractive
[
	"Check if vm were run with headless parameter.
	Different VMs for different platform have different multiple way(s) to indicate that"

	"non-headless mode is always interactive"

	self isHeadless
		ifFalse: [ ^ true ].
	-1000 to: 1000 do: [ :n | (#('-interactive' '--interactive') includes: (self vm getSystemAttribute: n))
			ifTrue: [ ^ true ] ].
	^ false
]

SmalltalkImage >> isLittleEndian
[
	^ self endianness == #little
]

SmalltalkImage >> isRoot: oop
[
	"Primitive. Answer whether the object is currently a root for youngSpace."

	<primitive: 'primitiveIsRoot'>
	^ self primitiveFailed
]

SmalltalkImage >> isSelfEvaluating
[
	self == Smalltalk
		ifTrue: [ ^ true ].
	^ super isSelfEvaluating
]

SmalltalkImage >> isYoung: oop
[
	"Primitive. Answer whether the object currently resides in youngSpace."

	<primitive: 'primitiveIsYoung'>
	^ self primitiveFailed
]

SmalltalkImage >> kernelPackageNames
[
	^ #('Announcements-Core' 'Announcements-Core' 'Collections-Abstract' 'Collections-Arithmetic' 'Collections-Arrayed' 'Collections-Atomic' 'Collections-Native' 'Collections-Sequenceable' 'Collections-Stack' 'Collections-Streams' 'Collections-Strings' 'Collections-Support' 'Collections-Text' 'Collections-Traits' 'Collections-Unordered' 'Collections-Weak' 'Compiler' 'Compression' 'Files' 'Graphics-Display Objects' 'Graphics-Primitives' 'Graphics-Transformations' 'Kernel' 'Multilingual-Encodings' 'Multilingual-ImmPlugin' 'Multilingual-Languages' 'Multilingual-TextConversion' 'System-Change Notification' 'System-Changes' 'System-CommandLine' 'System-Clipboard' 'System-FileRegistry' 'System-Finalization' 'System-Localization' 'System-Object Events' 'System-Platforms' 'System-Support' 'Text-Core' 'Traits' 'UIManager' 'Transcript' 'FileSystem-AnsiStreams' 'FileSystem-Core' 'FileSystem-Disk' 'FileSystem-Memory' 'CodeImport' 'Regex-Core' 'SystemProgress' 'System-Announcements' 'Ring-Core-Kernel' 'Ring-Core-Containers' 'Kernel-Pragmas' 'Kernel-Pragmas' 'System-PragmaCollector')
]

SmalltalkImage >> keyAtIdentityValue: anObject ifAbsent: aBlock
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals keyAtIdentityValue: anObject ifAbsent: aBlock
]

SmalltalkImage >> keyAtValue: anObject
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals keyAtValue: anObject
]

SmalltalkImage >> keys
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals keys
]

SmalltalkImage >> keysAndValuesDo: aBlock
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals keysAndValuesDo: aBlock
]

SmalltalkImage >> lastQuitLogPosition
[
	^ LastQuitLogPosition
]

SmalltalkImage >> lastQuitLogPosition: aNumber
[
	"should be only use to ensure the transition from SystemDictionary to SmalltalkImage, then  	be removed"

	LastQuitLogPosition := aNumber
]

SmalltalkImage >> lastUpdateString
[
	"SmalltalkImage current lastUpdateString"

	^ 'Latest update: #' translated , SystemVersion current highestUpdate printString
]

SmalltalkImage >> licenseString
[
	^ 'LICENSE	Licensed under the MIT License with parts under the Apache License.Copyright (c) 2008-2013 The Pharo Project, and ContributorsCopyright (c) 2008-2013 InriaCopyright (c) 1996-2008 Viewpoints Research Institute, and Contributors Copyright (c) 1996 Apple Computer, Inc.Permission is hereby granted, free of charge, to any person obtaining a copy of thissoftware and associated documentation files (the "Software"), to deal in the Softwarewithout restriction, including without limitation the rights to use, copy, modify, merge,publish, distribute, sublicense, and/or sell copies of the Software, and to permit personsto whom the Software is furnished to do so, subject to the following conditions: Theabove copyright notice and this permission notice shall be included in all copies orsubstantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORSOR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR INCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.You may obtain a copy of the Apache License athttp://www.apache.org/licenses/LICENSE-2.0Pharo uses icons by Mark James (http://www.famfamfam.com) under Creative Commons Attribution 2.5 License.'
]

SmalltalkImage >> listBuiltinModule: index
[
	"Return the name of the n-th builtin module.
	This list is not sorted!"

	<primitive: 572>
	^ self primitiveFailed
]

SmalltalkImage >> listBuiltinModules
[
	"SmalltalkImage current listBuiltinModules"

	"Return a list of all builtin modules (e.g., plugins). Builtin plugins are those that are 	compiled with the VM directly, as opposed to plugins residing in an external shared library. 	The list will include all builtin plugins regardless of whether they are currently loaded 
	or not. Note that the list returned is not sorted!"

	| modules index name |
	modules := Array new writeStream.
	index := 1.
	[ true ]
		whileTrue: [ name := self listBuiltinModule: index.
			name ifNil: [ ^ modules contents ].
			modules nextPut: name.
			index := index + 1 ]
]

SmalltalkImage >> listLoadedModule: index
[
	"Return the name of the n-th loaded module.
	This list is not sorted!"

	<primitive: 573>
	^ self primitiveFailed
]

SmalltalkImage >> listLoadedModules
[
	"SmalltalkImage current listLoadedModules"

	"Return a list of all currently loaded modules (e.g., plugins). Loaded modules are those that currently in use (e.g., active). The list returned will contain all currently active modules regardless of whether they're builtin (that is compiled with the VM) or external (e.g., residing in some external shared library). Note that the returned list is not sorted!"

	| modules index name |
	modules := Array new writeStream.
	index := 1.
	[ true ]
		whileTrue: [ name := self listLoadedModule: index.
			name ifNil: [ ^ modules contents ].
			modules nextPut: name.
			index := index + 1 ]
]

SmalltalkImage >> loadModule: aModuleName
[
	"Primitive. Attempt to load a module of the given name.
	Fail if module cannot be found, or cannot be loaded,
	or failed to initialize"

	<primitive: 'primLoadModule' module: '' error: #errorCode>
	^ self primitiveFailed
]

SmalltalkImage >> logChange: aStringOrText
[
	"Write the argument, aString, onto the changes file."

	ChangesLog default logChange: aStringOrText
]

SmalltalkImage >> logDuring: aMonadicBlock
[
	" for safe use, if stream is a file, it needs to be closed after use "

	| logStream |
	[ logStream := self openLog.
	aMonadicBlock value: logStream ]
		ensure: [ self closeLog: logStream ]
]

SmalltalkImage >> logError: errMsg inContext: aContext
[
	" we should think about integrating a toothpick here someday"

	self
		logStdErrorDuring: [ :stderr | "install the line end conversion and force initialize the converter"
			stderr
				nextPutAll: errMsg;
				cr;
				nextPut: Character escape;
				nextPutAll: '[0m'.	"reset the color"
			aContext shortDebugStackOn: stderr ].
	self
		logDuring: [ :logger | logger
				nextPutAll: 'THERE_BE_DRAGONS_HERE';
				cr;
				nextPutAll: errMsg;
				cr.	"just print the error message if no context is given"
			aContext ifNotNil: [ aContext errorReportOn: logger ].	" write some type of separator"
			logger
				nextPutAll: (String new: 79 withAll: $-);
				cr;
				cr ]
]

SmalltalkImage >> logStartUpErrorDuring: aBlock into: aCollection tryDebugger: tryDebugger
[
	"handle errors thrown by the given block and log a freezed version of them in aCollection"

	aBlock
		on: Error , Halt
		do: [ :err | self logStartupError: err into: aCollection tryDebugger: tryDebugger ]
]

SmalltalkImage >> logStartupError: anError into: aCollection tryDebugger: tryDebugger
[
	"try to debug the given error or add a freezed version to aCollection"

	tryDebugger
		ifTrue: [ 
			[ ^ anError debug ]
				on: Error
				do: [ 
					"an error occured during error handling... 				treat the error as a normal startup error "
					 ] ].
	self logError: '==== Startup Error: ' , anError description inContext: anError signalerContext.	"freeze the error"
	aCollection add: anError freeze
]

SmalltalkImage >> logStdErrorDuring: aBlock
[
	| stderr |
	[ "install the line end conversion and force initialize the converter"
	stderr := FileStream stderr
		wantsLineEndConversion: true;
		converter;
		yourself.	"log in red"
	stderr
		nextPut: Character escape;
		nextPutAll: '[31m'.	"rund the loggin block"
	aBlock value: stderr.	"reset the coloring"
	stderr
		nextPut: Character escape;
		nextPutAll: '[0m' ]
		on: Error
		do: [ :e | "we don't care if the logging to stdout fails..."
			 ]
]

SmalltalkImage >> lowSpaceThreshold
[
	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."

	^ 400000	"Enough for JIT compiler"
]

SmalltalkImage >> lowSpaceWatcher
[
	"Wait until the low space semaphore is signalled, then take appropriate
	actions. "

	| free preemptedProcess |
	self garbageCollectMost <= self lowSpaceThreshold
		ifTrue: [ 
			self garbageCollect <= self lowSpaceThreshold
				ifTrue: [ 
					"free space must be above threshold before					starting low space watcher"
					^ Beeper beep ] ].
	self specialObjectsArray at: 23 put: nil.	"process causing low space will be saved here"
	LowSpaceSemaphore := Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.	"enable low space interrupts"
	LowSpaceSemaphore wait.	"wait for a low space condition..."
	self primSignalAtBytesLeft: 0.	"disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess := nil.	"The process that was active at the time of the low space interrupt."
	preemptedProcess := Smalltalk specialObjectsArray at: 23.
	Smalltalk specialObjectsArray at: 23 put: nil.	"Note: user now unprotected until the low space watcher is re-installed"
	self memoryHogs isEmpty
		ifFalse: [ free := self bytesLeft.
			self memoryHogs do: [ :hog | hog freeSomeSpace ].
			self bytesLeft > free
				ifTrue: [ ^ self installLowSpaceWatcher ] ].
	UIManager default lowSpaceWatcherDefaultAction: preemptedProcess
]

SmalltalkImage >> lowSpaceWatcherProcess
[
	^ LowSpaceProcess
]

SmalltalkImage >> maxFilenameLength
[
	^ self vm maxFilenameLength
]

SmalltalkImage >> memoryHogs
[
	"Answer the list of objects to notify with #freeSomeSpace if memory gets full."

	^ MemoryHogs ifNil: [ MemoryHogs := OrderedCollection new ]
]

SmalltalkImage >> metacelloPlatformAttributes
[
	"Returns the tags for the conditional platform loading in Metacello. Pay attention the order is important: from most  to least general."

	"For release integrators, we should not have #'pharo1.3x' **and** #'pharo1.4.x'"

	^ #(#squeakCommon #pharo #'pharo2.x' #'pharo2.0.x')
]

SmalltalkImage >> newSessionObject
[
	"Just answer unique object, which can never be identical to any
previous session object, this is all what we need for detecting session change.
A session object don't needs to carry any state, it just needs to be unique (we have plenty of
other objects in image which can do this for us). "

	^ Object new
]

SmalltalkImage >> newSpecialObjectsArray
[
	"Smalltalk recreateSpecialObjectsArray"

	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "

	"The Special Objects Array is an array of objects used by the Pharo virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."

	| newArray |
	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self globals associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: ByteString.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: Float.
	newArray at: 11 put: MethodContext.
	newArray at: 12 put: nil.	"Was BlockContext"
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: (self specialObjectsArray ifNil: [ Semaphore new ] ifNotNil: [ self specialObjectsArray at: 18 ]).	"(low space Semaphore)"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil.	"This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."
	newArray
		at: 24
		put:
			#(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 nil 0 nil 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."
	newArray at: 25 put: (self primitiveGetSpecialObjectsArray at: 25).
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.	"A 32-element array with up to 32 classes that have compact instances.	 Cog inlines table into machine code class lookup so do not regenerate it."
	newArray at: 29 put: self compactClassesArray.
	newArray at: 30 put: (self specialObjectsArray ifNil: [ Semaphore new ] ifNotNil: [ self specialObjectsArray at: 30 ]).	"(delay Semaphore)"
	newArray at: 31 put: (self specialObjectsArray ifNil: [ Semaphore new ] ifNotNil: [ self specialObjectsArray at: 31 ]).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"
	newArray at: 32 put: (Float new: 2).
	newArray at: 33 put: (LargePositiveInteger new: 4).
	newArray at: 34 put: 0 @ 0.
	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."
	newArray at: 36 put: (self primitiveGetSpecialObjectsArray at: 36).	"Is the prototype MethodContext (unused by the VM)"
	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."
	newArray at: 38 put: (self primitiveGetSpecialObjectsArray at: 38).	"Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"
	newArray at: 39 put: (self primitiveGetSpecialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil.	"Reserved for Mutex in Cog VMs"
	newArray at: 41 put: nil.	"Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"
	newArray
		at: 42
		put:
			(self specialObjectsArray
				ifNil: [ Semaphore new ]
				ifNotNil: [ (self specialObjectsArray at: 42) ifNil: [ Semaphore new ] ]).
	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: [  ]).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: [  ]).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: [  ]).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: [  ]).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: [  ]).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."
	newArray
		at: 52
		put:
			#(nil #'bad receiver' #'bad argument' #'bad index' #'bad number of arguments' #'inappropriate operation' #'unsupported operation' #'no modification' #'insufficient object memory' #'insufficient C memory' #'not found' #'bad method' #'internal error in named primitive machinery' #'object may move').	"nil => generic error"	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: [  ]).
	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: [  ]).	"Weak reference finalization"
	newArray at: 56 put: (self at: #WeakFinalizationList ifAbsent: [  ]).
	^ newArray
]

SmalltalkImage >> okayToProceedEvenIfSpaceIsLow
[
	"Return true if either there is enough memory to do so safely or if the user gives permission after being given fair warning."

	self garbageCollectMost > self lowSpaceThreshold
		ifTrue: [ ^ true ].	"quick"
	self garbageCollect > self lowSpaceThreshold
		ifTrue: [ ^ true ].	"work harder"
	^ self
		confirm:
			'WARNING: There is not enough space to start the low space watcher.If you proceed, you will not be warned again, and the system mayrun out of memory and crash. If you do proceed, you can start thelow space notifier when more space becomes available simply byopening and then closing a debugger (e.g., by hitting Cmd-period.)Do you want to proceed?'
]

SmalltalkImage >> openChanges: changesPath forImage: imageName
[
	"find the changes file by looking in
a) the directory derived from the image name
b) the DefaultDirectory (which will normally be the directory derived from the image name or the SecurityManager's choice)
If an old file is not found in either place, check for a read-only file in the same places. If that fails, return nil"

	| changes fd changesFile changesName |
	changesFile := changesPath asFileReference.
	changesName := changesFile basename.	"look for the changes file or an alias to it in the image directory"
	changesFile exists
		ifTrue: [ changesFile writeStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for the changes in the default directory"
	(changesFile := FileSystem workingDirectory / changesName) exists
		ifTrue: [ changesFile writeStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for read-only changes in the image directory"
	(changesFile := changesPath asFileReference) exists
		ifTrue: [ changesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for read-only changes in the default directory"
	(changesFile := FileSystem workingDirectory / changesName) exists
		ifTrue: [ changesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"failed to open a changes file"
	^ nil
]

SmalltalkImage >> openLog
[
	"This is a _private_ method,
	Because it really belongs to logging facility,
	we should delegate to it at some point "

	^ (FileStream fileNamed: Smalltalk tools debugger logFileName)
		wantsLineEndConversion: true;
		setToEnd;
		yourself
]

SmalltalkImage >> openSourceFiles
[
	self imagePath = LastImagePath
		ifFalse: [ "Reset the author full name to blank when the image gets moved"
			LastImagePath := self imagePath.
			Author fullName: '' ].
	self checkAndOpenSourcesAndChanges.
	SourceFileArray install
]

SmalltalkImage >> openSources: fullSourcesName forImage: imagePath
[
	"We first do a check to see if a compressed version ofthe sources file is present.
Open the .sources file read-only after searching in:
a) the directory where the VM lives
b) the directory where the image came from
c) the DefaultDirectory (which is likely the same as b unless the SecurityManager has changed it).
"

	| sources fd sourcesFile sourcesName |
	sourcesFile := fullSourcesName asFileReference.
	sourcesName := sourcesFile basename.	"look for the sources file or an alias to it in the VM's directory"
	(sourcesFile := self vmDirectory / sourcesName) exists
		ifTrue: [ sourcesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for the sources file or an alias to it in the image directory"
	(sourcesFile := imagePath asFileReference parent / sourcesName) exists
		ifTrue: [ ^ sourcesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for the sources in the current directory"
	(sourcesFile := sourcesName asFileReference) exists
		ifTrue: [ ^ sourcesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].
	^ nil
]

SmalltalkImage >> optionAt: i
[
	"Answer the i-th option of the command line, or nil if not so many options."

	^ self vm optionAt: i
]

SmalltalkImage >> options
[
	"Answer an array with all the command line options."

	"Smalltalk commandLine options"

	^ Array
		streamContents: [ :str | | arg i |
			i := 1.
			[ i > 1000 or: [ (arg := self optionAt: i) == nil ] ] whileFalse: [ str nextPut: arg.
					i := i + 1 ] ]
]

SmalltalkImage >> organization
[
	"Return the organizer for the receiver"

	^ globals organization
]

SmalltalkImage >> os
[
	"Answer the object to query about os."

	^ OSPlatform
]

SmalltalkImage >> platform
[
	"Answer the object to query about os."

	^ OSPlatform
]

SmalltalkImage >> primBytesLeft
[
	"Primitive. Answer the number of bytes available for new object data.
	Not accurate unless preceded by
		Smalltalk garbageCollectMost (for reasonable accuracy), or
		Smalltalk garbageCollect (for real accuracy).
	See Object documentation whatIsAPrimitive."

	<primitive: 112>
	^ 0
]

SmalltalkImage >> primImageName
[
	"Answer the full path name for the current image."

	"Smalltalk imageName"

	<primitive: 121>
	self primitiveFailed
]

SmalltalkImage >> primImageName: newName
[
	"Set the the full path name for the current image.  All further snapshots will use this."

	<primitive: 121>
	^ self primitiveFailed
]

SmalltalkImage >> primImagePath
[
	"Answer the full path name for the current image."

	"Smalltalk imageName"

	<primitive: 121>
	self primitiveFailed
]

SmalltalkImage >> primImagePath: newName
[
	"Set the the full path name for the current image.  All further snapshots will use this."

	<primitive: 121>
	^ self primitiveFailed
]

SmalltalkImage >> primLowSpaceSemaphore: aSemaphore
[
	"Primitive. Register the given Semaphore to be signalled when the
	number of free bytes drops below some threshold. Disable low-space
	interrupts if the argument is nil."

	<primitive: 124>
	self primitiveFailed
]

SmalltalkImage >> primSignalAtBytesLeft: numBytes
[
	"Tell the interpreter the low-space threshold in bytes. When the free
	space falls below this threshold, the interpreter will signal the low-space
	semaphore, if one has been registered.  Disable low-space interrupts if the
	argument is zero.  Fail if numBytes is not an Integer."

	<primitive: 125>
	self primitiveFailed
]

SmalltalkImage >> primitiveGarbageCollect
[
	"Primitive. Reclaims all garbage and answers the number of bytes of available space."

	<primitive: 130>
	^ self primBytesLeft
]

SmalltalkImage >> primitiveGetSpecialObjectsArray
[
	<primitive: 129>
	^ self primitiveFailed
]

SmalltalkImage >> printElementsOn: aStream
[
	aStream nextPutAll: '(lots of globals)'
]

SmalltalkImage >> printOn: aStream
[
	self == Smalltalk
		ifFalse: [ ^ super printOn: aStream ].
	aStream nextPutAll: 'Smalltalk'
]

SmalltalkImage >> privCleanChangeSets
[
	(ChangeSet allChangeSets reject: [ :cs | cs = ChangeSet current ]) do: [ :cs | ChangeSet removeChangeSet: cs ].
	ChangeSet current clear.
	ChangeSet current name: 'Unnamed1'
]

SmalltalkImage >> privCleanGlobals
[
	#(#ActiveEvent #World #ActiveWorld #ActiveHand) do: [ :sym | Smalltalk at: sym put: nil.
			Smalltalk removeKey: sym ]
]

SmalltalkImage >> privCleanMonticello
[
	(Smalltalk classNamed: #MCFileBasedRepository) flushAllCaches.
	(Smalltalk classNamed: #MCDefinition) clearInstances.
	(Smalltalk classNamed: #MCWorkingCopy)
		allInstancesDo: [ :wc | SystemAnnouncer uniqueInstance unsubscribe: wc.
			wc unregister ].
	SystemAnnouncer uniqueInstance
		unsubscribe: (Smalltalk classNamed: #MCPackageManager);
		unsubscribe: (Smalltalk classNamed: #MCWorkingCopy)
]

SmalltalkImage >> privCleanProcesses
[
	UIManager default terminateUIProcess.
	(Process allInstances
		select: [ :p | ({(InputEventFetcher default instVarNamed: #fetcherProcess).
			(Processor activeProcess).
			(WeakArray runningFinalizationProcess).
			(Processor backgroundProcess)} includes: p) not ])
		do: [ :p | p suspend.
			p terminate ].
	Delay startTimerEventLoop
]

SmalltalkImage >> privCleanShutDownList
[
	#(#FreeTypeSettings #FreeTypeCache #FT2Handle #LogicalFont #MCMethodDefinition #InternetConfiguration #TTCFont #CPUWatcher #ProcessBrowser #SecurityManager #CommandHistory #Password #HttpUrl #StrikeFont #PasteUpMorph #Form #ZnServer)
		do: [ :className | Smalltalk removeFromShutDownList: (Smalltalk classNamed: className) ]
]

SmalltalkImage >> privCleanStartUpList
[
	#(#NaturalLanguageTranslator #ShortIntegerArray #ShortRunArray #PasteUpMorph #SecurityManager #FreeTypeFontProvider #UUIDGenerator #ProcessBrowser #CPUWatcher #DateAndTime #HostSystemMenus #MenuIcons #InternetConfiguration #CommandHistory #HostWindowProxy #FreeTypeSettings #UITheme #CodeLoader #ZnServer #MCWorkingCopy #RecentMessageList #EditorFindReplaceDialogWindow #CodeUpdate)
		do: [ :className | Smalltalk removeFromStartUpList: (Smalltalk classNamed: className) ]
]

SmalltalkImage >> privCleanTextConstants
[
	TextConstants TextSharedInformation removeKey: #DefaultTextStyle.
	TextConstants TextSharedInformation removeKey: #DefaultMultiStyle.
	TextConstants TextSharedInformation removeKey: #DefaultFixedTextStyle.
	TextConstants TextSharedInformation removeKey: (Smalltalk classNamed: #StrikeFont) defaultFontKey.
	Smalltalk allClasses select: [ :c | c sharedPools includes: TextConstants ] thenDo: [ :c | c compileAll ]
]

SmalltalkImage >> privCleanUnloadMethods
[
	" remove class unload methods to avoid their calling during removing of this classes "

	#(#Browser #ChangeList #DummySoundSystem #FT2Handle #FileContentsBrowser #GZipReadStream #GZipWriteStream #MCVersionReader #MailComposition #Morph #FreeTypeFontProvider #DefaultExternalDropHandler #FileStream #Form)
		do: [ :className | (Smalltalk at: className) class removeSelector: #unload ]
]

SmalltalkImage >> privRecompileAll
[
	Smalltalk allClassesAndTraits do: [ :classOrTrait | classOrTrait compileAll ]
]

SmalltalkImage >> privSaveImageWithCleanup
[
	" Do not use this method for common image saving. This method is designated for saving the image during the shrinking process in headless images."

	| report |
	(Delay forMilliseconds: 1000) wait.
	Processor yield.
	13 timesRepeat: [ Smalltalk garbageCollect ].	"a magic number (Camillo) "
	[ self snapshot: true andQuit: true ]
		ifError: [ :e | [ report := FileStream forceNewFileNamed: 'PharoDebug.log'.
			report
				nextPutAll: e asString;
				cr ]
				ensure: [ report ifNotNil: [ report close ] ] ]
]

SmalltalkImage >> privShrinkUnicodeTables
[
	#(#GB2312Table #JISX0208Table #KSX1001Table) do: [ :table | UCSTable classPool at: table put: nil ].
	Unicode classPool
		at: #DecimalProperty
		put:
			#(-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 1 2 3 4 5 6 7 8 9 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1).
	Unicode classPool
		at: #GeneralCategory
		put:
			#(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 29 21 21 21 23 21 21 21 22 18 21 25 21 17 21 21 13 13 13 13 13 13 13 13 13 13 21 21 25 25 25 21 21 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 22 21 18 24 16 24 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 22 25 18 25 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 29 21 23 23 23 23 26 26 24 26 5 20 25 17 26 24 26 25 15 15 24 5 26 21 24 15 5 19 15 15 15 21 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 25 9 9 9 9 9 9 9 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 25 5 5 5 5 5 5 5)
]

SmalltalkImage >> privShrinkingProcess
[
	self privShrinkingProcessWith: #()
]

SmalltalkImage >> privShrinkingProcessWith: additionalPackageNames
[
	[ 
	| packages |
	10 timesRepeat: [ (Delay forMilliseconds: 100) wait.
			Processor yield ].
	Author fullName: 'Mr.Shrinker'.
	self privCleanMonticello.
	UIManager default: DummyUIManager new.
	UIManager default progressBarEnabled: false.
	self privCleanProcesses.
	self privCleanGlobals.
	5 timesRepeat: [ Smalltalk garbageCollect ].
	(Smalltalk classNamed: #MCDataStream) initialize.
	Beeper instVarNamed: #default put: nil.
	Smalltalk cleanOutUndeclared.
	5 timesRepeat: [ Smalltalk garbageCollect ].
	Author reset.
	(Smalltalk classNamed: #KMPragmaKeymapBuilder) release.
	self privShrinkUnicodeTables.
	Display newDepth: 1.
	self privCleanStartUpList.
	self privCleanShutDownList.	"    CommandLine removeRegistrationNamed: #BasicCodeLoader.    SimpleCodeLoader register."	"move class Model to different category"
	Object
		subclass: #Model
		instanceVariableNames: 'dependents'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Kernel-Objects'.
	self privCleanTextConstants.
	(Smalltalk classNamed: #SoundService) default: nil.
	(Smalltalk classNamed: #SoundService) unregister: (Smalltalk classNamed: #DummySoundSystem).
	ThreadSafeTranscript install.
	self privCleanUnloadMethods.
	(Smalltalk classNamed: #RPackageOrganizer) unregisterInterestToSystemAnnouncement.
	SystemNavigation new removeAllButPackages: self kernelPackageNames , additionalPackageNames.
	Smalltalk flushClassNameCache.
	3 timesRepeat: [ Smalltalk garbageCollect.
			Symbol compactSymbolTable ].
	Undeclared removeUnreferencedKeys.
	self privRecompileAll.
	self privCleanChangeSets.
	FileServices removeObsolete.
	Object flushEvents.
	(Smalltalk classNamed: #MCDataStream) initialize.
	Locale classPool at: #LocaleChangeListeners put: nil.
	SmalltalkImage classPool at: #Tools put: nil.
	Behavior flushObsoleteSubclasses.
	Smalltalk flushClassNameCache.
	Smalltalk organization removeEmptyCategories.
	WeakArray restartFinalizationProcess.
	ContextPart initializePrimitiveSimulators.
	SmalltalkImage current fixObsoleteReferences.	"UIManager default progressBarEnabled: true."	"Smalltalk condenseChanges."
	Smalltalk saveImageInNewContext ]
		ifError: [ :e | | rep |
			rep := FileStream forceNewFileNamed: 'PharoDebug.log'.
			rep
				nextPutAll: 'PharoKernel shrinking report';
				cr.
			rep
				nextPutAll: 'Error:';
				cr.
			rep
				nextPutAll: e asString;
				cr.
			rep nextPutAll: thisContext stack size asString.
			thisContext stack copy
				withIndexDo: [ :stck :i | [ rep
						nextPutAll: i asString;
						space;
						nextPutAll: stck asString;
						cr ] ifError: [  ] ].
			rep close.
			Smalltalk exitFailure ]
]

SmalltalkImage >> processShutDownList: quitting
[
	"Send #shutDown to each class that needs to wrap up before a snapshot.
	Also void the endianness chace; this can't safely be done on start-up because
	Smalltalk is too late in the start-up sequence."

	EndianCache := nil.
	^ self send: #shutDown: toClassesNamedIn: ShutDownList with: quitting
]

SmalltalkImage >> processStartUpList: resuming
[
	"Send #startUp to each class that needs to run initialization after a snapshot."

	^ self send: #startUp: toClassesNamedIn: StartUpList with: resuming
]

SmalltalkImage >> quitPrimitive
[
	"Primitive. Exit to another operating system on the host machine, if one
	exists. All state changes in the object space since the last snapshot are lost.
	Essential. See Object documentation whatIsAPrimitive."

	<primitive: 113>
	self primitiveFailed
]

SmalltalkImage >> recordStartupStamp
[
	ChangesLog default recordStartupStamp
]

SmalltalkImage >> recreateSpecialObjectsArray
[
	"Smalltalk recreateSpecialObjectsArray"

	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "

	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."

	"Replace the interpreter's reference in one atomic operation"

	self specialObjectsArray becomeForward: self newSpecialObjectsArray
]

SmalltalkImage >> registerExternalObject: anObject
[
	"Register the given object in the external objects array and return its index. If it is already there, just return its index."

	^ ExternalSemaphoreTable registerExternalObject: anObject
]

SmalltalkImage >> removeAllLineFeeds
[
	"Smalltalk removeAllLineFeeds"

	"Scan all methods for source code with lineFeeds.
	Replaces all occurrences of <CR><LF> or <LF> by <CR>.
	When done, offers to display an Inspector containing the message
	names grouped by author initials.
	In this dictionary, the key 'OK' contains the methods that had literals that contained <LF> characters."

	| totalStripped totalOK authors |
	'Scanning sources for LineFeeds.This will take a few minutes...'
		displayProgressFrom: 0
		to: CompiledMethod instanceCount
		during: [ :bar | | n |
			n := 0.
			authors := self removeAllLineFeedsQuietlyCalling: [ (n := n + 1) \\ 100 = 0
						ifTrue: [ bar current: n ] ] ].
	totalStripped := authors inject: 1 into: [ :sum :set | sum + set size ].
	totalOK := (authors at: 'OK') size.
	totalStripped := totalStripped - totalOK.
	self crTrace: totalStripped printString , ' methods stripped of LFs.'.
	self crTrace: totalOK printString , ' methods still correctly contain LFs.'.
	(self confirm: 'Do you want to see the affected methods?')
		ifTrue: [ authors inspect ]
]

SmalltalkImage >> removeAllLineFeedsQuietly
[
	"Smalltalk removeAllLineFeedsQuietly"

	"Scan all methods for source code with lineFeeds.
	Replaces all occurrences of <CR><LF> or <LF> by <CR>.
	Answer a Dictionary keyed by author name containing sets of affected method names,
	as well as (at the key 'OK') a list of methods that still contain LF characters inside literal strings or characters."

	^ self removeAllLineFeedsQuietlyCalling: [  ]
]

SmalltalkImage >> removeAllLineFeedsQuietlyCalling: aBlock
[
	"Smalltalk removeAllLineFeedsQuietly"

	"Scan all methods for source code with lineFeeds.
	Replaces all occurrences of <CR><LF> or <LF> by <CR>.
	Answer a Dictionary keyed by author name containing sets of affected method names,
	as well as (at the key 'OK') a list of methods that still contain LF characters inside literal strings or characters.
	Evaluate aBlock for each method so that status can be updated."

	| authors |
	authors := Dictionary new.
	authors at: 'OK' put: Set new.
	self systemNavigation
		allBehaviorsDo: [ :cls | cls
				selectorsAndMethodsDo: [ :selector :method | | oldStamp newCodeString oldCodeString oldCategory nameString |
					aBlock cull: cls cull: selector.
					oldCodeString := cls sourceCodeAt: selector.
					(oldCodeString includes: Character lf)
						ifTrue: [ newCodeString := oldCodeString withSqueakLineEndings.
							nameString := cls name , '>>' , selector.
							((cls compiledMethodAt: selector) hasLiteralSuchThat: [ :lit | lit asString includes: Character lf ])
								ifTrue: [ (authors at: 'OK') add: nameString ]
								ifFalse: [ oldStamp := method timeStamp copy replaceAll: Character cr with: Character space.
									(authors
										at: (oldStamp copyFrom: 1 to: (oldStamp findFirst: [ :c | c isAlphaNumeric not ]))
										ifAbsentPut: [ Set new ]) add: nameString.
									oldCategory := cls whichCategoryIncludesSelector: selector.
									cls
										compile: newCodeString
										classified: oldCategory
										withStamp: oldStamp
										notifying: nil ] ] ] ].
	^ authors
]

SmalltalkImage >> removeClassNamed: aName
[
	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "

	globals removeClassNamed: aName
]

SmalltalkImage >> removeEmptyMessageCategories
[
	"Smalltalk removeEmptyMessageCategories"

	self garbageCollect.
	(ClassOrganizer allInstances copyWith: SystemOrganization) do: [ :org | org removeEmptyCategories ]
]

SmalltalkImage >> removeFromShutDownList: aClass
[
	ShutDownList remove: aClass name ifAbsent: [  ]
]

SmalltalkImage >> removeFromStartUpList: aClass
[
	StartUpList remove: aClass name ifAbsent: [  ]
]

SmalltalkImage >> removeKey: key
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals removeKey: key
]

SmalltalkImage >> removeKey: key ifAbsent: aBlock
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals removeKey: key ifAbsent: aBlock
]

SmalltalkImage >> removeSelector: descriptor
[
	"Safely remove a selector from a class (or metaclass). If the
	class or the method doesn't exist anymore, never mind and
	answer nil.
	This method should be used instead of 'Class removeSelector:
	#method' to omit global class references."

	| class sel |
	class := self at: descriptor first ifAbsent: [ ^ nil ].
	(descriptor size > 2 and: [ descriptor second == #class ])
		ifTrue: [ class := class class.
			sel := descriptor third ]
		ifFalse: [ sel := descriptor second ].
	^ class removeSelector: sel
]

SmalltalkImage >> renameClass: aClass as: newName
[
	"Rename the class, aClass, to have the title newName."

	^ globals renameClass: aClass as: newName
]

SmalltalkImage >> renameClass: aClass from: oldName
[
	"Rename the class, aClass, to have the title newName."

	^ globals renameClass: aClass from: oldName
]

SmalltalkImage >> renameClassNamed: oldName as: newName
[
	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  "

	| oldClass |
	(oldClass := self at: oldName asSymbol ifAbsent: [ nil ]) == nil
		ifTrue: [ self crTrace: 'Class-rename for ' , oldName , ' ignored because ' , oldName , ' does not exist.'.
			^ self ].
	oldClass rename: newName
]

SmalltalkImage >> renamedClass: aClass from: oldName to: newName
[
	"Inform Smalltalk that aClass has been renamed"

	(Array with: StartUpList with: ShutDownList)
		do: [ :list | | index |
			index := list indexOf: oldName ifAbsent: [ 0 ].
			index > 0
				ifTrue: [ list at: index put: newName ] ]
]

SmalltalkImage >> rootTable
[
	"Primitive. Answer a snapshot of the VMs root table. 
	Keep in mind that the primitive may itself cause GC."

	<primitive: 'primitiveRootTable'>
	^ self primitiveFailed
]

SmalltalkImage >> rootTableAt: index
[
	"Primitive. Answer the nth element of the VMs root table"

	<primitive: 'primitiveRootTableAt'>
	^ nil
]

SmalltalkImage >> saveAs
[
	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."

	self saveAs: self getFileNameFromUser
]

SmalltalkImage >> saveAs: newNameWithoutSuffix
[
	"Results:
		true  when continuing in the new session
		false for the current session "

	newNameWithoutSuffix ifNil: [ ^ self ].
	(SourceFiles at: 2)
		ifNotNil: [ self
				closeSourceFiles;
				saveChangesInFileNamed: (self fullNameForChangesNamed: newNameWithoutSuffix)	"so copying the changes file will always work" ].
	^ self saveImageInFileNamed: (self fullNameForImageNamed: newNameWithoutSuffix)
]

SmalltalkImage >> saveAsNewVersion
[
	"Save the image/changes using the next available version number."

	"SmalltalkImage current saveAsNewVersion"

	| newImageFile newChangesFile |
	newImageFile := self imageFile nextVersion.
	newChangesFile := newImageFile withExtension: self changesSuffix.	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	newChangesFile exists
		ifTrue: [ 
			^ self
				inform:
					'There is already .changes file of the desired name,' , newChangesFile fullName
						,
							'curiously already present, even though there isno corresponding .image file.   Please remedymanually and then repeat your request.' ].	"strip awaay the image extension"
	^ self saveAs: (newImageFile fullName copyUpToLast: $.)
]

SmalltalkImage >> saveChangesInFileNamed: aString
[
	| changesFile |
	changesFile := aString asFileReference.
	changesFile parent ensureDirectory.	"Ensure that the destination file is not the same as the original one"
	Smalltalk changesFile absolutePath = changesFile absolutePath
		ifFalse: [ changesFile deleteIfAbsent: [  ].
			Smalltalk changesFile copyTo: changesFile ].
	self setMacFileInfoOn: changesFile fullName
]

SmalltalkImage >> saveImageInFileNamed: aFile
[
	"Save the image in the given file.
	Unlike #backupImageInFileNamed: this method continues evaluation in the new image after saving.
	Note: This method does not save the .changes file, use #saveAs:"

	| imageFile previousFullImageName |
	imageFile := aFile asFileReference.
	imageFile parent ensureDirectory.
	previousFullImageName := self imagePath.
	^ self
		changeImagePathTo: imageFile fullName;
		closeSourceFiles;
		openSourceFiles;
		snapshot: true andQuit: false	"so SNAPSHOT appears in new changes file"
]

SmalltalkImage >> saveImageInNewContext
[
	" This method is used for saving the Smalltalk image in a new process so the current process with all stack information may be forgotten.
	
	Do not use this method for common image saving. This method is designated for saving the image during the shrinking process in headless images. "

	[ self privSaveImageWithCleanup ] forkAt: 40
]

SmalltalkImage >> saveSession
[
	"Save the current image without quitting and return it resuming status (whether it was restarted or in the same flow)."

	^ self snapshot: true andQuit: false
]

SmalltalkImage >> select: aBlock
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals select: aBlock
]

SmalltalkImage >> send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
[
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is resuming (for #startUp:).
	If any name cannot be found, then remove it from the list."

	| removals errors |
	removals := OrderedCollection new.
	errors := OrderedCollection new.
	startUpOrShutDownList
		do: [ :name | | class |
			class := self at: name ifAbsent: [ nil ].
			class isNil
				ifTrue: [ removals add: name ]
				ifFalse: [ self logStartUpErrorDuring: [ class perform: startUpOrShutDown with: argument ] into: errors tryDebugger: false ] ].	"Remove any obsolete entries, but after the iteration"
	startUpOrShutDownList removeAll: removals.
	^ errors
]

SmalltalkImage >> session
[
	"Answer the current session object.
	Currently, there is no assumptions about what protocol(s) a session object should conform to.
	The only valid use of session object is to compare it using identity comparison, i.e. #== 
	with another session object retrieved before, in order to detect session change. 
	
	A session changes every time image boots from disk. It doesn't changes on snapshot.
	"

	^ session ifNil: [ session := self newSessionObject ]
]

SmalltalkImage >> setMacFileInfoOn: aString
[
	"On Mac, set the file type and creator (noop on other platforms)"

	aString asFileReference setMacType: 'STch' creator: 'FAST'
]

SmalltalkImage >> shortImageName
[
	"Answer the current image name but only that name and not the full path as with imageName."

	"SmalltalkImage current shortImageName"

	^ self imageFile basename
]

SmalltalkImage >> shouldDownloadSourcesFile
[
	"If true, when no sources file can be found, the file will be downloaded.
	The default is false."

	^ self class shouldDownloadSourcesFile
]

SmalltalkImage >> shrinkToKernel
[
	self shrinkToKernelWith: #()
]

SmalltalkImage >> shrinkToKernelWith: additionalPackageNames
[
	"
  WARNING:  THIS METHOD WILL DESTROY YOUR IMAGE

  Use with cation and only on fresh Pharo images 
  "

	[ self privShrinkingProcessWith: additionalPackageNames ] forkAt: 40.
	Processor terminateActive
]

SmalltalkImage >> shutDown
[
	^ Smalltalk closeSourceFiles
]

SmalltalkImage >> shutDownImage: quitting
[
	Object flushDependents.
	Object flushEvents.
	self processShutDownList: quitting
]

SmalltalkImage >> signalLowSpace
[
	"Signal the low-space semaphore to alert the user that space is running low."

	LowSpaceSemaphore signal
]

SmalltalkImage >> size
[
	"Obsoleted."

	self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."
	^ globals size
]

SmalltalkImage >> snapshot: save andQuit: quit
[
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."

	| snapshotResult isNewImage startupErrors |
	self addSnapshotRecord: save andQuit: quit.
	self shutDownImage: quit.
	save
		ifTrue: [ snapshotResult := self snapshotPrimitive.	"<-- PC frozen here on image file"
			isNewImage := snapshotResult == true ]
		ifFalse: [ isNewImage := false ].
	(quit and: [ isNewImage not ])
		ifTrue: [ self quitPrimitive ].	"create a new session object if we're booting"
	isNewImage
		ifTrue: [ session := self newSessionObject ].
	self startupImage: isNewImage snapshotWorked: snapshotResult.	"We return the resuming state, which may be useful for users to know the state of the image"
	^ isNewImage
]

SmalltalkImage >> snapshotPrimitive
[
	"Primitive. Write the current state of the object memory on a file in the
	same format as the Smalltalk-80 release. The file can later be resumed,
	returning you to this exact state. Return normally after writing the file.
	Essential. See Object documentation whatIsAPrimitive."

	<primitive: 97>
	^ nil	"indicates error writing image file"
]

SmalltalkImage >> sourceFileVersionString
[
	^ SourceFileVersionString
]

SmalltalkImage >> sourceFileVersionString: aString
[
	SourceFileVersionString := aString
]

SmalltalkImage >> sourcesFile
[
	"Answer the full path to the version-stable source code"

	^ self vmDirectory / SourceFileVersionString , self sourcesSuffix
]

SmalltalkImage >> sourcesName
[
	"Answer the full path to the version-stable source code"

	^ self sourcesFile fullName
]

SmalltalkImage >> sourcesSuffix
[
	^ 'sources'
]

SmalltalkImage >> spaceLeftAfterGarbageCollection
[
	"Return a string describing the amount of memory available"

	| availInternal availPhysical availTotal |
	self garbageCollect.
	availInternal := self primBytesLeft.
	availPhysical := self bytesLeft: false.
	availTotal := self bytesLeft: true.
	availTotal > (availInternal + 10000)
		ifFalse: [ ^ availInternal asStringWithCommas , ' bytes available' ].	"compensate for mini allocations inbetween"
	^ String
		streamContents: [ :s | availInternal printWithCommasOn: s.
			s
				nextPutAll: ' bytes (internal) ';
				cr.
			availPhysical printWithCommasOn: s.
			s
				nextPutAll: ' bytes (physical) ';
				cr.
			availTotal printWithCommasOn: s.
			s nextPutAll: ' bytes (total)     ' ]
]

SmalltalkImage >> specialNargsAt: anInteger
[
	"Answer the number of arguments for the special selector at: anInteger."

	^ (self specialObjectsArray at: 24) at: anInteger * 2
]

SmalltalkImage >> specialObjectsArray
[
	^ specialObjectsArray ifNil: [ specialObjectsArray := self primitiveGetSpecialObjectsArray ]
]

SmalltalkImage >> specialObjectsArray: anArray
[
	specialObjectsArray := anArray
]

SmalltalkImage >> specialSelectorAt: anInteger
[
	"Answer the special message selector from the interleaved specialSelectors array."

	^ (self specialObjectsArray at: 24) at: anInteger * 2 - 1
]

SmalltalkImage >> specialSelectorSize
[
	"Answer the number of special selectors in the system."

	^ (self specialObjectsArray at: 24) size // 2
]

SmalltalkImage >> specialSelectors
[
	"Used by SystemTracer only."

	^ SpecialSelectors
]

SmalltalkImage >> startupImage: isNewImage snapshotWorked: snapshotResult
[
	| startupErrors |
	self vm setGCParameters.
	deferredStartupActions := nil.
	isNewImage
		ifTrue: [ Smalltalk clearExternalObjects ].
	startupErrors := OrderedCollection new.
	UIManager default
		boot: isNewImage
		during: [ startupErrors addAll: (self processStartUpList: isNewImage).
			isNewImage
				ifTrue: [ self recordStartupStamp ] ].
	startupErrors addAll: (self executeDeferredStartupActions: isNewImage).
	startupErrors isEmpty
		ifFalse: [ self handleStartupErrors: startupErrors ].
	snapshotResult == nil
		ifTrue: [ self error: 'Failed to write image file (disk full?)' ]
]

SmalltalkImage >> systemInformationString
[
	^ String cr , SystemVersion current version , String cr , self lastUpdateString , String cr , String cr , String cr
		, self licenseString
]

SmalltalkImage >> timeStamp: aStream
[
	"Writes system version and current time on stream aStream."

	| dateTime |
	dateTime := Time dateAndTimeNow.
	aStream
		nextPutAll:
			'From ' , self datedVersion , ' [' , self lastUpdateString , '] on ' , (dateTime at: 1) printString , ' at '
				, (dateTime at: 2) printString
]

SmalltalkImage >> traitNames
[
	"Answer a SortedCollection of all traits (not including class-traits) names."

	^ globals traitNames
]

SmalltalkImage >> unbindExternalPrimitives
[
	"Primitive. Force all external primitives to be looked up again afterwards. Since external primitives that have not found are bound for fast failure this method will force the lookup of all primitives again so that after adding some plugin the primitives may be found."

	"Do nothing if the primitive fails for compatibility with older VMs"

	<primitive: 570>
	
]

SmalltalkImage >> unloadModule: aString
[
	"Primitive. Unload the given module.
	This primitive is intended for development only since some
	platform do not implement unloading of DLL's accordingly.
	Also, the mechanism for unloading may not be supported
	on all platforms."

	<primitive: 571>
	^ self primitiveFailed
]

SmalltalkImage >> unregisterExternalObject: anObject
[
	"Unregister the given object in the external objects array. Do nothing if it isn't registered."

	ExternalSemaphoreTable unregisterExternalObject: anObject
]

SmalltalkImage >> verifyChanges
[
	"Smalltalk verifyChanges"

	"Recompile all methods in the changes file."

	self systemNavigation allBehaviorsDo: [ :class | class recompileChanges ]
]

SmalltalkImage >> version
[
	"Answer the version of this release."

	^ SystemVersion current version
]

SmalltalkImage >> veryDeepCopyWith: deepCopier
[
	"Return self.  I can't be copied.  Do not record me."

	
]

SmalltalkImage >> vm
[
	"Answer the object to query about virtual machine."

	^ VirtualMachine
]

SmalltalkImage >> vmBinary
[
	^ self vm binary
]

SmalltalkImage >> vmDirectory
[
	^ self vm directory
]

SmalltalkImage >> wordSize
[
	"Answer the size in bytes of an object pointer or word in the object memory.
	The value does not change for a given image, but may be modified by a SystemTracer
	when converting the image to another format. The value is cached in WordSize to
	avoid the performance overhead of repeatedly consulting the VM."

	"this method is deprecated"

	^ self vm wordSize
]

SmalltalkImage class >> checkChangesFileAvailability
[
	^ CheckChangesFileAvailability ifNil: [ CheckChangesFileAvailability := true ]
]

SmalltalkImage class >> checkChangesFileAvailability: aBoolean
[
	CheckChangesFileAvailability := aBoolean
]

SmalltalkImage class >> checkSourcesFileAvailability
[
	^ CheckSourcesFileAvailability ifNil: [ CheckSourcesFileAvailability := true ]
]

SmalltalkImage class >> checkSourcesFileAvailability: aBoolean
[
	CheckSourcesFileAvailability := aBoolean
]

SmalltalkImage class >> cleanUp
[
	"Flush caches"

	"should probably distribute cleaning to systemDictionary"

	Smalltalk globals flushClassNameCache.
	Undeclared removeUnreferencedKeys
]

SmalltalkImage class >> compilerClass
[
	^ CompilerClass
]

SmalltalkImage class >> compilerClass: aClass
[
	CompilerClass := aClass
]

SmalltalkImage class >> current
[
	^ Smalltalk
]

SmalltalkImage class >> initialize
[
	"SmalltalkImage initialize"

	self initializeStartUpList.
	self initializeShutDownList.
	Smalltalk addToStartUpList: SmalltalkImage
]

SmalltalkImage class >> initializeShutDownList
[
	"SmalltalkImage initializeShutDownList"

	| oldList |
	oldList := ShutDownList.
	ShutDownList := OrderedCollection new.	"These get processed from the bottom up..."
	#(#Delay #DisplayScreen #InputEventFetcher #Form #PasteUpMorph #StrikeFont #Color #SoundPlayer #HttpUrl #Password)
		do: [ :clsName | Smalltalk globals at: clsName ifPresent: [ :cls | Smalltalk addToShutDownList: cls ] ].
	oldList
		ifNotNil: [ oldList
				reverseDo: [ :className | Smalltalk globals at: className ifPresent: [ :theClass | Smalltalk addToShutDownList: theClass ] ] ]
]

SmalltalkImage class >> initializeStartUpList
[
	"SmalltalkImage initializeStartUpList"

	| oldList |
	oldList := StartUpList.
	StartUpList := OrderedCollection new.	"These get processed from the top down..."
	#(#Delay #DisplayScreen #Cursor #InputEventFetcher #ProcessorScheduler #LanguageEnvironment #NaturalLanguageTranslator #ShortIntegerArray #ShortRunArray)
		do: [ :clsName | Smalltalk globals at: clsName ifPresent: [ :cls | Smalltalk addToStartUpList: cls ] ].
	oldList
		ifNotNil: [ oldList
				do: [ :className | Smalltalk globals at: className ifPresent: [ :theClass | Smalltalk addToStartUpList: theClass ] ] ].
	#(#PasteUpMorph) do: [ :clsName | Smalltalk globals at: clsName ifPresent: [ :cls | Smalltalk addToStartUpList: cls ] ]
]

SmalltalkImage class >> new
[
	self error: 'Use current'
]

SmalltalkImage class >> shouldDownloadSourcesFile
[
	"If true, when no sources file can be found, the file will be downloaded.
	The default is false."

	^ ShouldDownloadSourcesFile ifNil: [ ShouldDownloadSourcesFile := false ]
]

SmalltalkImage class >> shouldDownloadSourcesFile: boolean
[
	"Set whether, when no sources file can be found, the file will be downloaded.
	The default is false."

	ShouldDownloadSourcesFile := boolean
]

SmalltalkImage class >> startUp: resuming
[
	ChangesLog default.
	resuming
		ifTrue: [ Smalltalk openSourceFiles ]
]

SmalltalkImage class >> wordSize
[
	^ Smalltalk vm wordSize
]

