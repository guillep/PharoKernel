Class
	name: #SmalltalkImage;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#globals #deferredStartupActions #specialObjectsArray );
	classVariables: #(#CheckSourcesFileAvailability #LastQuitLogPosition #LastImagePath #StartUpList #ShutDownList #EndianCache #CheckChangesFileAvailability #SpecialSelectors #LowSpaceProcess #LowSpaceSemaphore #Tools #SourceFileVersionString #MemoryHogs );
	package: #'System-Support'.

Class SmalltalkImage >> add: aClass toList: startUpOrShutDownList after: predecessor
[
	"Add the name of aClass to the startUp or shutDown list.	Add it after the name of predecessor"
(Smalltalk globals includes: aClass)	ifFalse: [ self error: aClass name , ' cannot be found in Smalltalk dictionary.' ].	"Add after predecessor, moving it if already there."(Smalltalk globals includes: predecessor)	ifFalse: [ self error: predecessor name , ' cannot be found in Smalltalk dictionary.' ].(startUpOrShutDownList includes: predecessor name)	ifFalse: [ self error: predecessor name , ' cannot be found in the list.' ].startUpOrShutDownList remove: aClass name ifAbsent: [  ].startUpOrShutDownList add: aClass name after: predecessor name
]

Class SmalltalkImage >> add: aClass toList: startUpOrShutDownList before: successor
[
	"Add the name of aClass to the startUp or shutDown list.	Add it before the name of successor"
(Smalltalk globals includes: aClass)	ifFalse: [ self error: aClass name , ' cannot be found in Smalltalk dictionary.' ].	"Add before successor, moving it if already there."(Smalltalk globals includes: successor)	ifFalse: [ self error: successor name , ' cannot be found in Smalltalk dictionary.' ].(startUpOrShutDownList includes: successor name)	ifFalse: [ self error: successor name , ' cannot be found in the list.' ].startUpOrShutDownList remove: aClass name ifAbsent: [  ].startUpOrShutDownList add: aClass name before: successor name
]

Class SmalltalkImage >> addDeferredStartupAction: aBlock
[
	"Add the monadic or nulladic block to the list of actions that we will be performed immediately after the startup is totally executed."
deferredStartupActions ifNil: [ deferredStartupActions := OrderedCollection new ].deferredStartupActions add: aBlock
]

Class SmalltalkImage >> addSnapshotRecord: save andQuit: quit
[
	"Originally this code were in #snapshot:andQuit: .	Just moved it to separate method to make caller more readable	and don't look like swiss army knife which tries to do everything by own "
| msg |(SourceFiles at: 2)	ifNotNil: [ 		msg := String			streamContents: [ :s | 				s					nextPutAll: '----';					nextPutAll:							(save									ifTrue: [ 										quit											ifTrue: [ 'QUIT' ]											ifFalse: [ 'SNAPSHOT' ] ]									ifFalse: [ 										quit											ifTrue: [ 'QUIT/NOSAVE' ]											ifFalse: [ 'NOP' ] ]);					nextPutAll: '----';					print: Date dateAndTimeNow;					space;					nextPutAll: self imageFile basename;					nextPutAll: ' priorSource: ';					print: LastQuitLogPosition ].		self assureStartupStampLogged.		save			ifTrue: [ 				LastQuitLogPosition := (SourceFiles at: 2)					setToEnd;					position ].		self logChange: msg.		self traceCr: msg ]
]

Class SmalltalkImage >> addToShutDownList: aClass
[
	"This will add a ref to this class at the BEGINNING of the shutDown list."
	"No-op if already in the list."
(ShutDownList includes: aClass name)	ifFalse: [ ShutDownList addFirst: aClass name ]
]

Class SmalltalkImage >> addToShutDownList: aClass after: predecessor
[
self add: aClass toList: ShutDownList after: predecessor
]

Class SmalltalkImage >> addToShutDownList: aClass before: predecessor
[
self add: aClass toList: ShutDownList before: predecessor
]

Class SmalltalkImage >> addToStartUpList: aClass
[
	"This will add a ref to this class at the END of the startUp list."
	"No-op if already in the list."
(StartUpList includes: aClass name)	ifFalse: [ StartUpList addLast: aClass name ]
]

Class SmalltalkImage >> addToStartUpList: aClass after: predecessor
[
self add: aClass toList: StartUpList after: predecessor
]

Class SmalltalkImage >> addToStartUpList: aClass before: predecessor
[
self add: aClass toList: StartUpList before: predecessor
]

Class SmalltalkImage >> allClasses
[
	"Return all the class defines in the SmalltalkImage"
	"Smalltalk allClasses"
	"May be we could discard this one in the future"
^ globals allClasses
]

Class SmalltalkImage >> allClassesAndTraits
[
	"Return all the classes and traits defined in the Smalltalk SmalltalkImage"
^ globals allClassesAndTraits
]

Class SmalltalkImage >> allClassesAndTraitsDo: aBlock
[
^ globals allClassesAndTraitsDo: aBlock
]

Class SmalltalkImage >> allClassesDo: aBlock
[
	"Evaluate the argument, aBlock, for each class in the system."
globals allClassesDo: aBlock
]

Class SmalltalkImage >> allTraits
[
	"Return all traits defined in the Smalltalk SmalltalkImage"
^ globals allTraits
]

Class SmalltalkImage >> argumentAt: i
[
	"Answer the i-th argument of the command line, or nil if not so many argument."
^ self vm getSystemAttribute: 2 + i
]

Class SmalltalkImage >> arguments
[
	"Answer an array with all the command line arguments.	This does not include imagePath, documentPath nor any option."
	"Smalltalk commandLine arguments"
^ Array	streamContents: [ :str | 		| arg i |		i := 1.		[ i > 998 or: [ (arg := self argumentAt: i) == nil ] ]			whileFalse: [ 				str nextPut: arg.				i := i + 1 ] ]
]

Class SmalltalkImage >> associationAt: key ifAbsent: aBlock
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals associationAt: key ifAbsent: aBlock
]

Class SmalltalkImage >> associationOrUndeclaredAt: key
[
	"return an association or install in undeclared.  Used for mating up ImageSegments."
^ globals associationOrUndeclaredAt: key
]

Class SmalltalkImage >> assureStartupStampLogged
[
	"If there is a startup stamp not yet actually logged to disk, do it now."
ChangesLog default assureStartupStampLogged
]

Class SmalltalkImage >> at: aKey
[
	"Answer the global associated with the key."
^ globals at: aKey
]

Class SmalltalkImage >> at: key ifAbsent: aBlock
[
	"Answer the global associated with the key or, if key isn't found,	answer the result of evaluating aBlock."
^ globals at: key ifAbsent: aBlock
]

Class SmalltalkImage >> at: aKey ifAbsentPut: aBlock
[
	"Return the global at the given key. 	If key is not included in the receiver store the result 	of evaluating aBlock as new value."
^ globals at: aKey ifAbsentPut: aBlock
]

Class SmalltalkImage >> at: key ifPresent: aBlock
[
	"Lookup the given key in the globals. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."
^ globals at: key ifPresent: aBlock
]

Class SmalltalkImage >> at: aKey put: anObject
[
	"Set the global at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."
^ globals at: aKey put: anObject
]

Class SmalltalkImage >> bindingOf: varName
[
	"Answer the binding of some variable resolved in the scope of the receiver"
^ globals bindingOf: varName
]

Class SmalltalkImage >> bytesLeft
[
	"Answer the number of bytes of space available. Does a full garbage collection."
^ self garbageCollect
]

Class SmalltalkImage >> bytesLeft: aBool
[
	"Return the amount of available space. If aBool is true, include possibly available swap space. If aBool is false, include possibly available physical memory. For a report on the largest free block currently availabe within Pharo memory but not counting extra memory use #primBytesLeft."
	<primitive: 112>
^ self primBytesLeft
]

Class SmalltalkImage >> calcEndianness
[
| bytes word blt |"What endian-ness is the current hardware?  The String '1234' will be stored into a machine word.  On BigEndian machines (the Mac), $1 will be the high byte if the word.  On LittleEndian machines (the PC), $4 will be the high byte.""SmalltalkImage current endianness"bytes := #[0 0 0 0].	"(1 2 3 4) or (4 3 2 1)"word := WordArray with: 16r01020304.blt := (BitBlt toForm: (Form new hackBits: bytes)) sourceForm: (Form new hackBits: word).blt combinationRule: Form over.	"store"blt	sourceY: 0;	destY: 0;	height: 1;	width: 4.blt	sourceX: 0;	destX: 0.blt copyBits.	"paste the word into the bytes"bytes first = 1	ifTrue: [ ^ #big ].bytes first = 4	ifTrue: [ ^ #little ].self error: 'Ted is confused'
]

Class SmalltalkImage >> changeImagePathTo: aString
[
self imagePath: aString asSqueakPathName.LastImagePath := self imagePath
]

Class SmalltalkImage >> changesFile
[
	"Answer the file containing the current changes."
^ FileLocator changes
]

Class SmalltalkImage >> changesName
[
	"Answer the name for the changes file corresponding to the image file name."
	"Smalltalk changesName"
^ self changesFile fullName
]

Class SmalltalkImage >> changesSuffix
[
^ 'changes'
]

Class SmalltalkImage >> checkAndOpenSourcesAndChanges
[
	"Open the changes and sources files and install them in SourceFiles. 	Inform the user of problems regarding write permissions or CR/CRLF mixups."
	"Note: SourcesName and imageName are full paths; 	changesName is a  local name."
| sources changes msg wmsg |msg := 'Pharo cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.'.wmsg := 'Pharo cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.sources := self openSources: self sourcesName forImage: LastImagePath.changes := self openChanges: self changesName forImage: LastImagePath.((sources == nil or: [ sources atEnd ]) and: [ self checkSourcesFileAvailability ])	ifTrue: [ 		OSPlatform isMacOS			ifTrue: [ 				msg := msg					,						'Make sure the sources file is not an Alias.' ].		self inform: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , self sourcesName) ].(changes == nil and: [ self checkChangesFileAvailability ])	ifTrue: [ self inform: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , self changesName) ].(self checkChangesFileAvailability and: [ changes notNil ])	ifTrue: [ 		changes isReadOnly			ifTrue: [ self inform: (wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , self changesName) ].		((changes next: 200) includesSubString: String crlf)			ifTrue: [ 				self					inform:						'The changes file named ' , self changesName							,								'has been injured by an unpacking utility.  Crs were changed to CrLfs.Please set the preferences in your decompressing program to "do not convert text files" and unpack the system again.' ] ].SourceFiles := Array with: sources with: changes
]

Class SmalltalkImage >> checkChangesFileAvailability
[
^ self class checkChangesFileAvailability
]

Class SmalltalkImage >> checkSourcesFileAvailability
[
^ self class checkSourcesFileAvailability
]

Class SmalltalkImage >> classNamed: className
[
^ globals classOrTraitNamed: className
]

Class SmalltalkImage >> classNames
[
^ globals classNames
]

Class SmalltalkImage >> classOrTraitNamed: aString
[
	"aString is either a class or trait name or a class or trait name followed by ' class' or 'classTrait' respectively. Answer the class or metaclass it names."
^ globals classOrTraitNamed: aString
]

Class SmalltalkImage >> cleanOutUndeclared
[
Undeclared removeUnreferencedKeys
]

Class SmalltalkImage >> cleanUp
[
	"Smalltalk cleanUp"
	"Gently clean up"
^ self cleanUp: false
]

Class SmalltalkImage >> cleanUp: aggressive
[
	"Clean up. When aggressive is true, this will destroy change sets, etc."
	"Smalltalk cleanUp: false"
	"Smalltalk cleanUp: true"
^ self cleanUp: aggressive except: #()
]

Class SmalltalkImage >> cleanUp: aggressive except: exclusions
[
	"Clean up. When aggressive is true, this will destroy resources, change sets, etc.	Leave out any classes specifically listed in exclusions."
	"Smalltalk cleanUp: true except: {Point . ChangeSet}"
^ self cleanUp: aggressive except: exclusions confirming: aggressive
]

Class SmalltalkImage >> cleanUp: aggressive except: exclusions confirming: aBool
[
	"Clean up. When aggressive is true, this will destroy resources, change sets, etc.	Leave out any classes specifically listed in exclusions."
	"Smalltalk cleanUp: true except: {Point . ChangeSet} 		- will ask for confirmation"
	"SmalltalkImage current cleanUp: true except: {} confirming: false 		- will not ask for confirmation"
| classes |aBool	ifTrue: [ 		"Give the user a chance to bail"		(self			confirm:				'Cleanup will destroy projects, change sets and more.Are you sure you want to proceed?')			ifFalse: [ ^ self ] ].	"Find all classes implementing #cleanUp or cleanUp:"classes := Smalltalk allClasses	select: [ :aClass | (aClass class includesSelector: #cleanUp) or: [ aClass class includesSelector: #cleanUp: ] ].	"Leave out the classes in the exclusion set"classes := classes reject: [ :aClass | exclusions includes: aClass ].	"Arrange classes in superclass order, superclasses before subclasses.	This will ensure that specific cleanup (like MethodDictionary compaction)	will run after generic superclass cleanup (HashedCollection rehashing).	Otherwise generic superclass cleanup might undo specific one (in this	case rehashing will undo a good bit of MD compaction)."classes := Class superclassOrder: classes.	"Run the cleanup code"classes do: [ :aClass | aClass cleanUp: aggressive ] displayingProgress: [ :aClass | 'Cleaning up in ' , aClass name ]
]

Class SmalltalkImage >> clearExternalObjects
[
	"Clear the array of objects that have been registered for use in non-Smalltalk code."
	"Smalltalk clearExternalObjects"
ExternalSemaphoreTable clearExternalObjects
]

Class SmalltalkImage >> closeLog: logger
[
	"This is a _private_ method,	Because it really belongs to logging facility,	we should delegate to it at some point "
logger ifNotNil: [ logger close ]
]

Class SmalltalkImage >> closeSourceFiles
[
	"Shut down the source files if appropriate.  1/29/96 sw: changed so that the closing and nilification only take place if the entry was a FileStream, thus allowing stringified sources to remain in the saved image file"
1 to: 2 do: [ :i | 	((SourceFiles at: i) isKindOf: FileStream)		ifTrue: [ 			(SourceFiles at: i) close.			SourceFiles at: i put: nil ] ]
]

Class SmalltalkImage >> commandLine
[
	"Answer the object to query about command line."
^ self
]

Class SmalltalkImage >> compactClassesArray
[
	"Smalltalk compactClassesArray"
	"Return the array of 31 classes whose instances may be	represented compactly"
^ self specialObjectsArray at: 29
]

Class SmalltalkImage >> condenseChanges
[
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseChanges"
| f file oldChanges |f := FileStream fileNamed: 'ST80.temp'.f	header;	timeStamp.'Condensing Changes File...'	displayProgressFrom: 0	to: self classNames size + self traitNames size	during: [ :bar | 		| count |		count := 0.		self			allClassesAndTraitsDo: [ :classOrTrait | 				bar current: (count := count + 1).				classOrTrait moveChangesTo: f.				classOrTrait putClassCommentToCondensedChangesFile: f.				classOrTrait classSide moveChangesTo: f ] ].self lastQuitLogPosition: f position.f	trailer;	close.CompiledMethod cleanUp.oldChanges := SourceFiles at: 2.oldChanges close.(oldChanges name , '.old') asFileReference delete.(file := oldChanges name asFileReference) renameTo: file basename , '.old'.f name asFileReference renameTo: file basename.self setMacFileInfoOn: oldChanges name.SourceFiles at: 2 put: (FileStream oldFileNamed: oldChanges name)
]

Class SmalltalkImage >> condenseSources
[
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"
| f dir newVersionString |self fixUpProblemsWithAllCategory.	"The above removes any concrete, spurious '-- all --' categories, which mess up the process."dir := FileSystem workingDirectory.newVersionString := UIManager default	request:		'Please designate the versionfor the new source code file...'	initialAnswer: Smalltalk sourceFileVersionString.newVersionString ifNil: [ ^ self ].newVersionString = self sourceFileVersionString	ifTrue: [ ^ self error: 'The new source file must not be the same as the old.' ].Smalltalk sourceFileVersionString: newVersionString.	"Write all sources with fileIndex 1"f := FileStream newFileNamed: Smalltalk sourcesName.f	header;	timeStamp.'Condensing Sources File...'	displayProgressFrom: 0	to: self classNames size + self traitNames size	during: [ :bar | 		| count |		count := 0.		Smalltalk			allClassesAndTraitsDo: [ :classOrTrait | 				bar current: (count := count + 1).				classOrTrait fileOutOn: f moveSource: true toFile: 1 ] ].f	trailer;	close.CompiledMethod cleanUp.	"Make a new empty changes file"self closeSourceFiles.Smalltalk changesFile renameTo: Smalltalk changesFile basename , '.old'.(FileStream newFileNamed: Smalltalk changesName)	header;	timeStamp;	close.self lastQuitLogPosition: 0.self setMacFileInfoOn: Smalltalk image changesName.self setMacFileInfoOn: Smalltalk image sourcesName.self openSourceFiles.self	inform:		'Source files have been rewritten!Check that all is well,and then save/quit.'
]

Class SmalltalkImage >> corePackageNames
[
^ #('Announcements-Help' 'Announcements-Tests-Core' 'Announcements-View' 'AST-Core' 'AST-Semantic' 'AST-Tests-Core' 'AST-Tests-Semantic' 'Balloon' 'BalloonTests' 'CollectionsTests' 'Compatibility' 'CompilerTests' 'CompressionTests' 'Deprecated14' 'DialogItemsChooser' 'EmergencyEvaluator' 'FS-AnsiStreams' 'FS-Core' 'FS-Disk' 'FS-Memory' 'FS-Tests-AnsiStreams' 'FS-Tests-Core' 'FS-Tests-Disk' 'FS-Tests-Memory' 'FS-Zip' 'Finder' 'FixUnderscores' 'FreeType' 'FreeTypeTests' 'Gofer-Core' 'Gofer-Tests' 'Graphics-External' 'Graphics-Files' 'Graphics-Fonts' 'Graphics-Resources' 'Graphics-Support' 'Graphics-Tests' 'Graphics-Text' 'HelpSystem-Core' 'HelpSystem-Tests' 'HostMenus' 'KernelTests' 'MenuRegistration' 'Monticello' 'MonticelloConfigurations' 'MonticelloGUI' 'MonticelloMocks' 'Morphic' 'MorphicTests' 'Multilingual-Display' 'Multilingual-Scanning' 'Multilingual-Tests' 'Network-Kernel' 'Network-MIME' 'Network-MailSending' 'Network-Protocols' 'Network-RFC822' 'Network-RemoteDirectory' 'Network-URI' 'Network-UUID' 'Network-Url' 'NetworkTests' 'PackageInfo' 'Polymorph-EventEnhancements' 'Polymorph-Geometry' 'Polymorph-TaskbarIcons' 'Polymorph-Tools-Diff' 'Polymorph-Widgets' 'RecentSubmissions' 'Refactoring-Changes' 'Refactoring-Core' 'Refactoring-Critics' 'Refactoring-Environment' 'Refactoring-Extensions-Environment' 'Refactoring-Tests-Changes' 'Refactoring-Tests-Core' 'Refactoring-Tests-Critics' 'Refactoring-Tests-Environment' 'Regex-Core' 'Regex-Help' 'Regex-Tests-Core' 'Ring-Core-Containers' 'Ring-Core-Kernel' 'Ring-Tests-Containers' 'Ring-Tests-Kernel' 'SUnit-Core' 'SUnit-Help' 'SUnit-Tests' 'SUnit-UI' 'ScriptLoader14' 'Settings-Compiler' 'Settings-Display' 'Settings-FreeType' 'Settings-Graphics' 'Settings-Kernel' 'Settings-Monticello' 'Settings-Network' 'Settings-Polymorph' 'Settings-System' 'Settings-Tools' 'Shout' 'ShoutTests' 'StratifiedProxy' 'SystemAnnouncements' 'System-Applications' 'System-Download' 'System-FilePackage' 'System-Hashing' 'System-History' 'System-Installers' 'System-Serial Port' 'System-Settings' 'System-Sound' 'System-Text' 'System-Tools' 'Tests' 'Tools' 'ToolsTest' 'Transcript' 'TrueType' 'UI-Basic' 'Zinc-HTTP' 'Zinc-Patch-HTTPSocket' 'Zinc-Tests')
]

Class SmalltalkImage >> createStackOverflow
[
	"For testing the low space handler..."
	"Smalltalk installLowSpaceWatcher; createStackOverflow"
self createStackOverflow	"infinite recursion"
]

Class SmalltalkImage >> datedVersion
[
	"Answer the version of this release."
^ SystemVersion current datedVersion
]

Class SmalltalkImage >> disableModuleLoading
[
	"Primitive. Disable a new module loading mechanism for the rest of current session.	This operation is not reversable.	Any subsequent attempts to load either external or internal module(s) will fail"
	<primitive: 'primitiveDisableModuleLoading' module: ''>

]

Class SmalltalkImage >> do: aBlock
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals do: aBlock
]

Class SmalltalkImage >> endianness
[
EndianCache ifNil: [ EndianCache := self calcEndianness ].^ EndianCache
]

Class SmalltalkImage >> environment
[
	"For conversion from Smalltalk to SystemDictionary"
^ globals
]

Class SmalltalkImage >> executeDeferredStartupActions: resuming
[
	"Execute the deferred actions which where added during startup, resuming is true if the iage was started fresh, false if we just saved an image"
| errors |deferredStartupActions ifNil: [ ^ #() ].errors := OrderedCollection new.deferredStartupActions	do: [ :each | self logStartUpErrorDuring: [ each cull: resuming ] into: errors tryDebugger: self isInteractive ].^ errors
]

Class SmalltalkImage >> exit: exitStatus
[
	"Primitive. Exit to another operating system on the host machine, if one
	exists. All state changes in the object space since the last snapshot are lost.
	Essential. See Object documentation whatIsAPrimitive.
	
	Possible values for exitStatus:
	0:   success
	> 1: error"
	<primitive: 113>
self primitiveFailed
]

Class SmalltalkImage >> exitFailure
[
	"Quit the VM with a failing signal.
	Will lose all current changes."
self exit: 1
]

Class SmalltalkImage >> exitSucess
[
	"Quit the VM with a success signal.
	Will lose all current changes."
self exit: 0
]

Class SmalltalkImage >> exitToDebugger
[
	"Primitive. Enter the machine language debugger, if one exists. Essential.	See Object documentation whatIsAPrimitive."
	<primitive: 114>
self primitiveFailed
]

Class SmalltalkImage >> externalObjects
[
	"Return an array of objects that have been registered for use in non-Smalltalk code. Smalltalk objects should be referrenced by external code only via indirection through this array, thus allowing the objects to move during compaction. This array can be cleared when the VM re-starts, since variables in external code do not survive snapshots. Note that external code should not attempt to access a Smalltalk object, even via this mechanism, while garbage collection is in progress."
	"Smalltalk externalObjects"
^ ExternalSemaphoreTable externalObjects
]

Class SmalltalkImage >> extractMinusParameters
[
	"Returns a dictionary matching parameters beginning by a minus character and the list of the next parameters.	Here is an example: 		I suppose I run pharo with: `pharo myImage.image -minus1 'Hello' -minus2 -minus3 'Hello' 'World'`.		This message will return a citionary with: 			minus1 --> #(Hello)			minus2 --> #()			minus3 --> #('Hello' 'World')"
| args dict str previous previousWithMinus index |dict := Dictionary new.args := OrderedCollection new.previous := previousWithMinus := ''.str := self vm getSystemAttribute: (index := 2).[ str isNil ]	whileFalse: [ 		args add: str.		str := self vm getSystemAttribute: (index := index + 1) ].args ifEmpty: [ ^ dict ].previous := previousWithMinus := args detect: [ :each | each first = $- ].[ args first = previous & args isEmpty not ] whileFalse: [ args removeFirst ].args	do: [ :each | 		each first = $-			ifTrue: [ 				previous first = $-					ifTrue: [ dict at: previous allButFirst put: #() ].				previousWithMinus := each ]			ifFalse: [ 				dict					at: previousWithMinus allButFirst					put: (dict at: previousWithMinus allButFirst ifAbsent: [ #() ]) , (Array with: each) ].		previous := each ].previous first = $-	ifTrue: [ dict at: previous allButFirst put: #() ].^ dict
]

Class SmalltalkImage >> extractParameters
[
| pName value index dict |dict := Dictionary new.index := 3.	"Muss bei 3 starten, da 2 documentName ist"[ pName := self vm getSystemAttribute: index.pName isEmptyOrNil ]	whileFalse: [ 		index := index + 1.		value := self vm getSystemAttribute: index.		value ifNil: [ value := '' ].		dict at: pName asUppercase put: value.		index := index + 1 ].^ dict
]

Class SmalltalkImage >> fileForChangesNamed: aName
[
^ (self imageDirectory resolve: aName) , self changesSuffix
]

Class SmalltalkImage >> fileForImageNamed: aString
[
^ (self imageDirectory resolve: aString) , self imageSuffix
]

Class SmalltalkImage >> fixObsoleteReferences
[
	"SmalltalkImage current fixObsoleteReferences.	SystemNavigation new obsoleteBehaviors size > 0		ifTrue: [ SystemNavigation new obsoleteBehaviors inspect.			self error:'Still have obsolete behaviors. See inspector']"
| informee obsoleteBindings obsName realName realClass |Smalltalk	garbageCollect;	garbageCollect.CompiledMethod allInstances	do: [ :method | 		obsoleteBindings := method literals			select: [ :literal | literal isVariableBinding and: [ literal value isBehavior and: [ literal value isObsolete ] ] ].		obsoleteBindings			do: [ :binding | 				obsName := binding value name.				self					trace: 'Binding: ';					traceCr: obsName.				realName := obsName copyReplaceAll: 'AnObsolete' with: ''.				realClass := Smalltalk globals at: realName asSymbol ifAbsent: [ UndefinedObject ].				binding key: binding key value: realClass ] ].Behavior flushObsoleteSubclasses.Smalltalk	garbageCollect;	garbageCollect
]

Class SmalltalkImage >> fixUpProblemsWithAllCategory
[
	"Moves all methods that are in formally classified a category named '-- all --' into the default 'as yet unclassified' category"
	"Smalltalk fixUpProblemsWithAllCategory"
| methodCount classCount |self flag: #ShouldBeMovedInClassOrganization.methodCount := 0.classCount := 0.self systemNavigation	allBehaviorsDo: [ :aClass | 		| org any |		org := aClass organization.		(org categories includes: #'-- all --')			ifTrue: [ 				any := false.				aClass					selectorsDo: [ :aSelector | 						| aCategory |						aCategory := org categoryOfElement: aSelector.						aCategory = #'-- all --'							ifTrue: [ 								org classify: aSelector under: ClassOrganizer default suppressIfDefault: false.								self crTrace: aClass name , ' >> ' , aSelector.								methodCount := methodCount + 1.								any := true ] ].				any					ifTrue: [ classCount := classCount + 1 ].				org removeEmptyCategories ] ].self	crTrace:		methodCount printString , ' methods in ' , classCount printString			, ' classes moved from "-- all --" to "as yet unclassified"'
]

Class SmalltalkImage >> flushClassNameCache
[
	"Smalltalk flushClassNameCache"
	"Force recomputation of the cached list of class names."
globals flushClassNameCache
]

Class SmalltalkImage >> forceChangesToDisk
[
	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."
| changesFile |changesFile := SourceFiles at: 2.(changesFile isKindOf: FileStream)	ifTrue: [ 		changesFile flush.		changesFile close.		changesFile open: changesFile name forWrite: true.		changesFile setToEnd ]
]

Class SmalltalkImage >> forceTenure
[
	"Primitive. Tell the GC logic to force a tenure on the next increment GC."
	<primitive: 'primitiveForceTenure'>
^ self primitiveFailed
]

Class SmalltalkImage >> forgetModule: aString
[
	"Primitive. If the module named aString is loaded, unloaded. If not, and it is marked an unloadable, unmark it so the VM will try to load it again next time. See comment for #unloadModule:."
	<primitive: 571>
^ self primitiveFailed
]

Class SmalltalkImage >> fullNameForChangesNamed: aName
[
^ (self fileForChangesNamed: aName) fullName
]

Class SmalltalkImage >> fullNameForImageNamed: aString
[
^ (self fileForImageNamed: aString) fullName
]

Class SmalltalkImage >> garbageCollect
[
	"Primitive. Reclaims all garbage and answers the number of bytes of available space."
Object flushDependents.Object flushEvents.^ self primitiveGarbageCollect
]

Class SmalltalkImage >> garbageCollectMost
[
	"Primitive. Reclaims recently created garbage (which is usually most of it) fairly quickly and answers the number of bytes of available space."
	<primitive: 131>
^ self primBytesLeft
]

Class SmalltalkImage >> getFileNameFromUser
[
| newName |newName := UIManager default	request: 'New File Name?' translated	initialAnswer: (self imageFile basename copyUpToLast: Path extensionDelimiter).newName isEmptyOrNil	ifTrue: [ ^ nil ].((self fileForImageNamed: newName) exists or: [ (self fileForChangesNamed: newName) exists ])	ifTrue: [ 		(self confirm: ('{1} already exists. Overwrite?' translated format: {newName}))			ifFalse: [ ^ nil ] ].^ newName
]

Class SmalltalkImage >> globals
[
	"Answer the global SystemDictionary"
^ globals
]

Class SmalltalkImage >> globals: aSystemDictionary
[
	"Sets the system-wide globals"
globals ifNotNil: [ self error: 'Cannot overwrite existing globals' ].globals := aSystemDictionary
]

Class SmalltalkImage >> handleStartupErrors: startupErrors
[
	"Handle the errors produced during startup.
	
	Resume to open a non-interactive debugger on the recorded errors"
self logError: 'Got startup errors: ' inContext: nil.startupErrors do: [ :error | self logError: '    ' , error description inContext: nil ].self isInteractive	ifFalse: [ self exitFailure ]	ifTrue: [ 		| answer |		answer := UIManager default			confirm: 'Got startup errors, proceed to open debuggers'			trueChoice: 'Debug'			falseChoice: 'Cancel'.		answer == true			ifTrue: [ startupErrors do: #debug ] ]
]

Class SmalltalkImage >> hasBindingThatBeginsWith: aString
[
^ globals hasBindingThatBeginsWith: aString
]

Class SmalltalkImage >> hasClassNamed: aString
[
	"Answer whether there is a class of the given name, but don't intern aString if it's not alrady interned."
^ globals hasClassNamed: aString
]

Class SmalltalkImage >> hasSpecialSelector: aLiteral ifTrueSetByte: aBlock
[
	"Some basic messages such as #+ have their own bytecode for speed.	To gain some space, the literal array of compiled methods does not contain such message selectors.	This implies that the cross referencer and other tools have to check if a selector is of the optimized one 	or not by calling this method. This is an optimization when machines were slow and small and it 	may be removed in the future to gain simplicity."
1 to: self specialSelectorSize do: [ :index | 	(self specialSelectorAt: index) == aLiteral		ifTrue: [ 			aBlock value: index + 16rAF.			^ true ] ].^ false
]

Class SmalltalkImage >> image
[
	"Answer the object to query about the current object memory and execution environment."
^ self
]

Class SmalltalkImage >> imageDirectory
[
	"Answer the directory containing the current image."
^ FileLocator imageDirectory
]

Class SmalltalkImage >> imageFile
[
	"Answer the file for the current image."
	"SmalltalkImage current imageName"
^ FileLocator image
]

Class SmalltalkImage >> imageFormatVersion
[
	"Answer an integer identifying the type of image. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required). This invokes an optional primitive	that may not be available on all virtual machines."
	"Smalltalk image imageFormatVersion"
	<primitive: 'primitiveImageFormatVersion'>
self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.^ ''
]

Class SmalltalkImage >> imageName
[
	"Answer the full path name for the current image."
	"SmalltalkImage current imageName"
| str |str := self primImageName.^ (FilePath pathName: str isEncoded: true) asSqueakPathName
]

Class SmalltalkImage >> imageName: newName
[
	"Set the the full path name for the current image.  All further snapshots will use this."
| encoded |encoded := (FilePath pathName: newName isEncoded: false) asVmPathName.self primImageName: encoded
]

Class SmalltalkImage >> imagePath
[
	"Answer the full path name for the current image."
	"SmalltalkImage current imageName"
| str |str := self primImagePath.^ (FilePath pathName: str isEncoded: true) asSqueakPathName
]

Class SmalltalkImage >> imagePath: newPath
[
	"Set the the full path name for the current image.  All further snapshots will use this."
| encoded |encoded := (FilePath pathName: newPath isEncoded: false) asVmPathName.self primImagePath: encoded
]

Class SmalltalkImage >> imageSuffix
[
^ 'image'
]

Class SmalltalkImage >> includes: element
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals includes: element
]

Class SmalltalkImage >> includesKey: key
[
	"Answer whether the receiver has a key equal to the argument, key."
^ globals includesKey: key
]

Class SmalltalkImage >> informSpaceLeftAfterGarbageCollection
[
	"Do a garbage collection, and report results to the user."
	"SmalltalkImage current informSpaceLeftAfterGarbageCollection"
self inform: self spaceLeftAfterGarbageCollection
]

Class SmalltalkImage >> installLowSpaceWatcher
[
	"Start a process to watch for low-space conditions."
	"Smalltalk installLowSpaceWatcher"
self primSignalAtBytesLeft: 0.	"disable low-space interrupts"LowSpaceProcess == nil	ifFalse: [ LowSpaceProcess terminate ].LowSpaceProcess := [ self lowSpaceWatcher ] newProcess.LowSpaceProcess priority: Processor lowIOPriority.LowSpaceProcess resume
]

Class SmalltalkImage >> isBigEndian
[
^ self endianness == #big
]

Class SmalltalkImage >> isHeadless
[
	"Check if vm were run with headless parameter.	Different VMs for different platform have different multiple way(s) to indicate that"
-1000 to: 1000 do: [ :n | 	(#('display=none' '-headless' '-vm-display-null' '-nodisplay') includes: (self vm getSystemAttribute: n))		ifTrue: [ ^ true ] ].^ false
]

Class SmalltalkImage >> isInteractive
[
	"Check if vm were run with headless parameter.	Different VMs for different platform have different multiple way(s) to indicate that"
	"non-headless mode is always interactive"
self isHeadless	ifFalse: [ ^ true ].-1000 to: 1000 do: [ :n | 	(#('-interactive') includes: (self vm getSystemAttribute: n))		ifTrue: [ ^ true ] ].^ false
]

Class SmalltalkImage >> isLittleEndian
[
^ self endianness == #little
]

Class SmalltalkImage >> isRoot: oop
[
	"Primitive. Answer whether the object is currently a root for youngSpace."
	<primitive: 'primitiveIsRoot'>
^ self primitiveFailed
]

Class SmalltalkImage >> isSelfEvaluating
[
self == Smalltalk	ifTrue: [ ^ true ].^ super isSelfEvaluating
]

Class SmalltalkImage >> isYoung: oop
[
	"Primitive. Answer whether the object currently resides in youngSpace."
	<primitive: 'primitiveIsYoung'>
^ self primitiveFailed
]

Class SmalltalkImage >> kernelPackageNames
[
^ #('Announcements-Core' 'Announcements-Core' 'Collections-Abstract' 'Collections-Arithmetic' 'Collections-Arrayed' 'Collections-Atomic' 'Collections-Native' 'Collections-Sequenceable' 'Collections-Stack' 'Collections-Streams' 'Collections-Strings' 'Collections-Support' 'Collections-Text' 'Collections-Traits' 'Collections-Unordered' 'Collections-Weak' 'Compiler' 'Compression' 'Files' 'Graphics-Display Objects' 'Graphics-Primitives' 'Graphics-Transformations' 'Kernel' 'Multilingual-Encodings' 'Multilingual-ImmPlugin' 'Multilingual-Languages' 'Multilingual-TextConversion' 'System-Change Notification' 'System-Changes' 'System-CommandLine' 'System-Clipboard' 'System-FileRegistry' 'System-Finalization' 'System-Localization' 'System-Object Events' 'System-Platforms' 'System-Support' 'Text-Core' 'Traits' 'UIManager' 'Transcript' 'FileSystem-AnsiStreams' 'FileSystem-Core' 'FileSystem-Disk' 'FileSystem-Memory' 'Fuel' 'FuelMetalevel' 'FuelPackageLoader' 'CodeImport' 'FuelFileSystem' 'FuelCommandLineHandler' 'Regex-Core' 'SystemProgress' 'System-Announcements')
]

Class SmalltalkImage >> keyAtIdentityValue: anObject ifAbsent: aBlock
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals keyAtIdentityValue: anObject ifAbsent: aBlock
]

Class SmalltalkImage >> keyAtValue: anObject
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals keyAtValue: anObject
]

Class SmalltalkImage >> keys
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals keys
]

Class SmalltalkImage >> keysAndValuesDo: aBlock
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals keysAndValuesDo: aBlock
]

Class SmalltalkImage >> lastQuitLogPosition
[
^ LastQuitLogPosition
]

Class SmalltalkImage >> lastQuitLogPosition: aNumber
[
	"should be only use to ensure the transition from SystemDictionary to SmalltalkImage, then  	be removed"
LastQuitLogPosition := aNumber
]

Class SmalltalkImage >> lastUpdateString
[
	"SmalltalkImage current lastUpdateString"
^ 'Latest update: #' translated , SystemVersion current highestUpdate printString
]

Class SmalltalkImage >> licenseString
[
^ 'LICENSE	Licensed under the MIT License with parts under the Apache License.Copyright (c) Pharo Project, and Contributors Copyright (c) 1996-2008 ViewpointsResearch Institute, and Contributors Copyright (c) 1996 Apple Computer, Inc.Permission is hereby granted, free of charge, to any person obtaining a copy of thissoftware and associated documentation files (the "Software"), to deal in the Softwarewithout restriction, including without limitation the rights to use, copy, modify, merge,publish, distribute, sublicense, and/or sell copies of the Software, and to permit personsto whom the Software is furnished to do so, subject to the following conditions: Theabove copyright notice and this permission notice shall be included in all copies orsubstantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORSOR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR INCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.You may obtain a copy of the Apache License athttp://www.apache.org/licenses/LICENSE-2.0Pharo uses icons by Mark James (http://www.famfamfam.com) under Creative Commons Attribution 2.5 License.'
]

Class SmalltalkImage >> listBuiltinModule: index
[
	"Return the name of the n-th builtin module.	This list is not sorted!"
	<primitive: 572>
^ self primitiveFailed
]

Class SmalltalkImage >> listBuiltinModules
[
	"SmalltalkImage current listBuiltinModules"
	"Return a list of all builtin modules (e.g., plugins). Builtin plugins are those that are 	compiled with the VM directly, as opposed to plugins residing in an external shared library. 	The list will include all builtin plugins regardless of whether they are currently loaded 	or not. Note that the list returned is not sorted!"
| modules index name |modules := Array new writeStream.index := 1.[ true ]	whileTrue: [ 		name := self listBuiltinModule: index.		name ifNil: [ ^ modules contents ].		modules nextPut: name.		index := index + 1 ]
]

Class SmalltalkImage >> listLoadedModule: index
[
	"Return the name of the n-th loaded module.	This list is not sorted!"
	<primitive: 573>
^ self primitiveFailed
]

Class SmalltalkImage >> listLoadedModules
[
	"SmalltalkImage current listLoadedModules"
	"Return a list of all currently loaded modules (e.g., plugins). Loaded modules are those that currently in use (e.g., active). The list returned will contain all currently active modules regardless of whether they're builtin (that is compiled with the VM) or external (e.g., residing in some external shared library). Note that the returned list is not sorted!"
| modules index name |modules := Array new writeStream.index := 1.[ true ]	whileTrue: [ 		name := self listLoadedModule: index.		name ifNil: [ ^ modules contents ].		modules nextPut: name.		index := index + 1 ]
]

Class SmalltalkImage >> loadModule: aModuleName
[
	"Primitive. Attempt to load a module of the given name.	Fail if module cannot be found, or cannot be loaded,	or failed to initialize"
	<primitive: 'primLoadModule' module: '' error: #errorCode>
^ self primitiveFailed
]

Class SmalltalkImage >> logChange: aStringOrText
[
	"Write the argument, aString, onto the changes file."
ChangesLog default logChange: aStringOrText
]

Class SmalltalkImage >> logDuring: aMonadicBlock
[
	" for safe use, if stream is a file, it needs to be closed after use "
| logStream |[ logStream := self openLog.aMonadicBlock value: logStream ]	ensure: [ self closeLog: logStream ]
]

Class SmalltalkImage >> logError: errMsg inContext: aContext
[
	" we should think about integrating a toothpick here someday"
self	logStdErrorDuring: [ :stderr | 		"install the line end conversion and force initialize the converter"		stderr			nextPutAll: errMsg;			cr;			nextPut: Character escape;			nextPutAll: '[0m'.	"reset the color"		aContext shortDebugStackOn: stderr ].self	logDuring: [ :logger | 		logger			nextPutAll: 'THERE_BE_DRAGONS_HERE';			cr;			nextPutAll: errMsg;			cr.	"just print the error message if no context is given"		aContext ifNotNil: [ aContext errorReportOn: logger ].	" write some type of separator"		logger			nextPutAll: (String new: 79 withAll: $-);			cr;			cr ]
]

Class SmalltalkImage >> logStartUpErrorDuring: aBlock into: aCollection tryDebugger: tryDebugger
[
	"handle errors thrown by the given block and log a freezed version of them in aCollection"
aBlock	on: Error	do: [ :err | self logStartupError: err into: aCollection tryDebugger: tryDebugger ]
]

Class SmalltalkImage >> logStartupError: anError into: aCollection tryDebugger: tryDebugger
[
	"try to debug the given error or add a freezed version to aCollection"
tryDebugger	ifTrue: [ 		[ ^ anError debug ]			on: Error			do: [ 				"an error occured during error handling... treat the error as a normal startup error "				 ] ].self logError: '==== Startup Error: ' , anError description inContext: anError signalerContext.	"freeze the error"aCollection add: anError freeze
]

Class SmalltalkImage >> logStdErrorDuring: aBlock
[
| stderr |[ "install the line end conversion and force initialize the converter"stderr := FileStream stderr	wantsLineEndConversion: true;	converter;	yourself.	"log in red"stderr	nextPut: Character escape;	nextPutAll: '[31m'.	"rund the loggin block"aBlock value: stderr.	"reset the coloring"stderr	nextPut: Character escape;	nextPutAll: '[0m' ]	on: Error	do: [ :e | 		"we don't care if the logging to stdout fails..."		 ]
]

Class SmalltalkImage >> lowSpaceThreshold
[
	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."
^ 400000	"Enough for JIT compiler"
]

Class SmalltalkImage >> lowSpaceWatcher
[
	"Wait until the low space semaphore is signalled, then take appropriate	actions. "
| free preemptedProcess |self garbageCollectMost <= self lowSpaceThreshold	ifTrue: [ 		self garbageCollect <= self lowSpaceThreshold			ifTrue: [ 				"free space must be above threshold before					starting low space watcher"				^ Beeper beep ] ].self specialObjectsArray at: 23 put: nil.	"process causing low space will be saved here"LowSpaceSemaphore := Semaphore new.self primLowSpaceSemaphore: LowSpaceSemaphore.self primSignalAtBytesLeft: self lowSpaceThreshold.	"enable low space interrupts"LowSpaceSemaphore wait.	"wait for a low space condition..."self primSignalAtBytesLeft: 0.	"disable low space interrupts"self primLowSpaceSemaphore: nil.LowSpaceProcess := nil.	"The process that was active at the time of the low space interrupt."preemptedProcess := Smalltalk specialObjectsArray at: 23.Smalltalk specialObjectsArray at: 23 put: nil.	"Note: user now unprotected until the low space watcher is re-installed"self memoryHogs isEmpty	ifFalse: [ 		free := self bytesLeft.		self memoryHogs do: [ :hog | hog freeSomeSpace ].		self bytesLeft > free			ifTrue: [ ^ self installLowSpaceWatcher ] ].UIManager default lowSpaceWatcherDefaultAction: preemptedProcess
]

Class SmalltalkImage >> lowSpaceWatcherProcess
[
^ LowSpaceProcess
]

Class SmalltalkImage >> maxFilenameLength
[
^ self vm maxFilenameLength
]

Class SmalltalkImage >> memoryHogs
[
	"Answer the list of objects to notify with #freeSomeSpace if memory gets full."
^ MemoryHogs ifNil: [ MemoryHogs := OrderedCollection new ]
]

Class SmalltalkImage >> metacelloPlatformAttributes
[
	"Returns the tags for the conditional platform loading in Metacello. Pay attention the order is important: from most  to least general."
	"For release integrators, we should not have #'pharo1.3x' **and** #'pharo1.4.x'"
^ #(#squeakCommon #pharo #'pharo2.x' #'pharo2.0.x')
]

Class SmalltalkImage >> newCompactClassesArray
[
	"Smalltalk compactClassesArray"
	"Return the array of 31 classes whose instances may be	represented compactly"
^ Array	new: 31	streamContents: [ :str | 		self compactClassesArray			do: [ :c | 				(self globals includesKey: c name)					ifTrue: [ str nextPut: (self globals at: c name) ]					ifFalse: [ str nextPut: nil ] ] ]
]

Class SmalltalkImage >> newSpecialObjectsArray
[
	"Smalltalk recreateSpecialObjectsArray"
	"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."
| newArray |newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"newArray at: 1 put: nil.newArray at: 2 put: false.newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"newArray at: 4 put: (self globals associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"newArray at: 5 put: Bitmap.newArray at: 6 put: SmallInteger.newArray at: 7 put: ByteString.newArray at: 8 put: Array.newArray at: 9 put: Smalltalk.newArray at: 10 put: Float.newArray at: 11 put: MethodContext.newArray at: 12 put: nil.	"Was BlockContext"newArray at: 13 put: Point.newArray at: 14 put: LargePositiveInteger.newArray at: 15 put: Display.newArray at: 16 put: Message.newArray at: 17 put: CompiledMethod.newArray at: 18 put: (self specialObjectsArray ifNil: [ Semaphore new ] ifNotNil: [ self specialObjectsArray at: 18 ]).	"(low space Semaphore)"newArray at: 19 put: Semaphore.newArray at: 20 put: Character.newArray at: 21 put: #doesNotUnderstand:.newArray at: 22 put: #cannotReturn:.newArray at: 23 put: nil.	"This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."newArray	at: 24	put:		#(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 nil 0 nil 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."newArray at: 25 put: (self primitiveGetSpecialObjectsArray at: 25).newArray at: 26 put: #mustBeBoolean.newArray at: 27 put: ByteArray.newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"newArray at: 29 put: self newCompactClassesArray.newArray at: 30 put: (self specialObjectsArray ifNil: [ Semaphore new ] ifNotNil: [ self specialObjectsArray at: 30 ]).	"(delay Semaphore)"newArray at: 31 put: (self specialObjectsArray ifNil: [ Semaphore new ] ifNotNil: [ self specialObjectsArray at: 31 ]).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"newArray at: 32 put: (Float new: 2).newArray at: 33 put: (LargePositiveInteger new: 4).newArray at: 34 put: 0 @ 0.newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."newArray at: 36 put: (self primitiveGetSpecialObjectsArray at: 36).	"Is the prototype MethodContext (unused by the VM)"newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."newArray at: 38 put: (self primitiveGetSpecialObjectsArray at: 38).	"Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"newArray at: 39 put: (self primitiveGetSpecialObjectsArray at: 39).	"preserve external semaphores"newArray at: 40 put: nil.	"Reserved for Mutex in Cog VMs"newArray at: 41 put: nil.	"Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"newArray	at: 42	put:		(self specialObjectsArray			ifNil: [ Semaphore new ]			ifNotNil: [ (self specialObjectsArray at: 42) ifNil: [ Semaphore new ] ]).newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."newArray at: 44 put: (self at: #ExternalAddress ifAbsent: [  ]).newArray at: 45 put: (self at: #ExternalStructure ifAbsent: [  ]).newArray at: 46 put: (self at: #ExternalData ifAbsent: [  ]).newArray at: 47 put: (self at: #ExternalFunction ifAbsent: [  ]).newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: [  ]).newArray at: 49 put: #aboutToReturn:through:.newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."newArray	at: 52	put:		#(nil #'bad receiver' #'bad argument' #'bad index' #'bad number of arguments' #'inappropriate operation' #'unsupported operation' #'no modification' #'insufficient object memory' #'insufficient C memory' #'not found' #'bad method' #'internal error in named primitive machinery' #'object may move').	"nil => generic error"	"53 to 55 are for Alien"newArray at: 53 put: (self at: #Alien ifAbsent: [  ]).newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: [  ]).	"Weak reference finalization"newArray at: 56 put: (self at: #WeakFinalizationList ifAbsent: [  ]).^ newArray
]

Class SmalltalkImage >> okayToProceedEvenIfSpaceIsLow
[
	"Return true if either there is enough memory to do so safely or if the user gives permission after being given fair warning."
self garbageCollectMost > self lowSpaceThreshold	ifTrue: [ ^ true ].	"quick"self garbageCollect > self lowSpaceThreshold	ifTrue: [ ^ true ].	"work harder"^ self	confirm:		'WARNING: There is not enough space to start the low space watcher.If you proceed, you will not be warned again, and the system mayrun out of memory and crash. If you do proceed, you can start thelow space notifier when more space becomes available simply byopening and then closing a debugger (e.g., by hitting Cmd-period.)Do you want to proceed?'
]

Class SmalltalkImage >> openChanges: changesPath forImage: imageName
[
	"find the changes file by looking ina) the directory derived from the image nameb) the DefaultDirectory (which will normally be the directory derived from the image name or the SecurityManager's choice)If an old file is not found in either place, check for a read-only file in the same places. If that fails, return nil"
| changes fd changesFile changesName |changesFile := changesPath asFileReference.changesName := changesFile basename.	"look for the changes file or an alias to it in the image directory"changesFile exists	ifTrue: [ changesFile writeStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for the changes in the default directory"(changesFile := FileSystem workingDirectory / changesName) exists	ifTrue: [ changesFile writeStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for read-only changes in the image directory"(changesFile := changesPath asFileReference) exists	ifTrue: [ changesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for read-only changes in the default directory"(changesFile := FileSystem workingDirectory / changesName) exists	ifTrue: [ changesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"failed to open a changes file"^ nil
]

Class SmalltalkImage >> openLog
[
	"This is a _private_ method,	Because it really belongs to logging facility,	we should delegate to it at some point "
^ (FileStream fileNamed: 'PharoDebug.log')	wantsLineEndConversion: true;	setToEnd;	yourself
]

Class SmalltalkImage >> openSourceFiles
[
self imagePath = LastImagePath	ifFalse: [ 		"Reset the author full name to blank when the image gets moved"		LastImagePath := self imagePath.		Author fullName: '' ].self checkAndOpenSourcesAndChanges.SourceFileArray install
]

Class SmalltalkImage >> openSources: fullSourcesName forImage: imagePath
[
	"We first do a check to see if a compressed version ofthe sources file is present.Open the .sources file read-only after searching in:a) the directory where the VM livesb) the directory where the image came fromc) the DefaultDirectory (which is likely the same as b unless the SecurityManager has changed it)."
| sources fd sourcesFile sourcesName |sourcesFile := fullSourcesName asFileReference.sourcesName := sourcesFile basename.	"look for the sources file or an alias to it in the VM's directory"(sourcesFile := self vmDirectory / sourcesName) exists	ifTrue: [ sourcesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for the sources file or an alias to it in the image directory"(sourcesFile := imagePath asFileReference parent / sourcesName) exists	ifTrue: [ ^ sourcesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].	"look for the sources in the current directory"(sourcesFile := sourcesName asFileReference) exists	ifTrue: [ ^ sourcesFile readStream ifNotNilDo: [ :stream | ^ stream ] ].^ nil
]

Class SmalltalkImage >> optionAt: i
[
	"Answer the i-th option of the command line, or nil if not so many options."
^ self vm optionAt: i
]

Class SmalltalkImage >> options
[
	"Answer an array with all the command line options."
	"Smalltalk commandLine options"
^ Array	streamContents: [ :str | 		| arg i |		i := 1.		[ i > 1000 or: [ (arg := self optionAt: i) == nil ] ]			whileFalse: [ 				str nextPut: arg.				i := i + 1 ] ]
]

Class SmalltalkImage >> organization
[
	"Return the organizer for the receiver"
^ globals organization
]

Class SmalltalkImage >> os
[
	"Answer the object to query about os."
^ OSPlatform
]

Class SmalltalkImage >> platform
[
	"Answer the object to query about os."
^ OSPlatform
]

Class SmalltalkImage >> primBytesLeft
[
	"Primitive. Answer the number of bytes available for new object data.	Not accurate unless preceded by		Smalltalk garbageCollectMost (for reasonable accuracy), or		Smalltalk garbageCollect (for real accuracy).	See Object documentation whatIsAPrimitive."
	<primitive: 112>
^ 0
]

Class SmalltalkImage >> primImageName
[
	"Answer the full path name for the current image."
	"Smalltalk imageName"
	<primitive: 121>
self primitiveFailed
]

Class SmalltalkImage >> primImageName: newName
[
	"Set the the full path name for the current image.  All further snapshots will use this."
	<primitive: 121>
^ self primitiveFailed
]

Class SmalltalkImage >> primImagePath
[
	"Answer the full path name for the current image."
	"Smalltalk imageName"
	<primitive: 121>
self primitiveFailed
]

Class SmalltalkImage >> primImagePath: newName
[
	"Set the the full path name for the current image.  All further snapshots will use this."
	<primitive: 121>
^ self primitiveFailed
]

Class SmalltalkImage >> primLowSpaceSemaphore: aSemaphore
[
	"Primitive. Register the given Semaphore to be signalled when the	number of free bytes drops below some threshold. Disable low-space	interrupts if the argument is nil."
	<primitive: 124>
self primitiveFailed
]

Class SmalltalkImage >> primSignalAtBytesLeft: numBytes
[
	"Tell the interpreter the low-space threshold in bytes. When the free	space falls below this threshold, the interpreter will signal the low-space	semaphore, if one has been registered.  Disable low-space interrupts if the	argument is zero.  Fail if numBytes is not an Integer."
	<primitive: 125>
self primitiveFailed
]

Class SmalltalkImage >> primitiveGarbageCollect
[
	"Primitive. Reclaims all garbage and answers the number of bytes of available space."
	<primitive: 130>
^ self primBytesLeft
]

Class SmalltalkImage >> primitiveGetSpecialObjectsArray
[
	<primitive: 129>
^ self primitiveFailed
]

Class SmalltalkImage >> printElementsOn: aStream
[
aStream nextPutAll: '(lots of globals)'
]

Class SmalltalkImage >> printOn: aStream
[
self == Smalltalk	ifFalse: [ ^ super printOn: aStream ].aStream nextPutAll: 'Smalltalk'
]

Class SmalltalkImage >> privCleanChangeSets
[
(ChangeSet allChangeSets reject: [ :cs | cs = ChangeSet current ]) do: [ :cs | ChangeSet removeChangeSet: cs ].ChangeSet current clear.ChangeSet current name: 'Unnamed1'
]

Class SmalltalkImage >> privCleanCore
[
ScriptLoader new cleanUpForProduction
]

Class SmalltalkImage >> privCleanGlobals
[
#(#ActiveEvent #World #ActiveWorld #ActiveHand)	do: [ :sym | 		Smalltalk at: sym put: nil.		Smalltalk removeKey: sym ]
]

Class SmalltalkImage >> privCleanMonticello
[
(Smalltalk classNamed: #MCFileBasedRepository) flushAllCaches.(Smalltalk classNamed: #MCDefinition) clearInstances.(Smalltalk classNamed: #MCWorkingCopy)	allInstancesDo: [ :wc | 		SystemAnnouncer uniqueInstance unsubscribe: wc.		wc unregister ].SystemAnnouncer uniqueInstance	unsubscribe: (Smalltalk classNamed: #MCPackageManager);	unsubscribe: (Smalltalk classNamed: #MCWorkingCopy)
]

Class SmalltalkImage >> privCleanProcesses
[
UIManager default terminateUIProcess.(Process allInstances	select: [ :p | 		({(InputEventFetcher default instVarNamed: #fetcherProcess).		(Processor activeProcess).		(WeakArray runningFinalizationProcess).		(Processor backgroundProcess)} includes: p) not ])	do: [ :p | 		p suspend.		p terminate ].Delay startTimerEventLoop
]

Class SmalltalkImage >> privCleanShutDownList
[
#(#FreeTypeSettings #FreeTypeCache #FT2Handle #LogicalFont #MCMethodDefinition #InternetConfiguration #TTCFont #CPUWatcher #ProcessBrowser #SecurityManager #CommandHistory #Password #HttpUrl #StrikeFont #PasteUpMorph #Form #ZnServer)	do: [ :className | Smalltalk removeFromShutDownList: (Smalltalk classNamed: className) ]
]

Class SmalltalkImage >> privCleanStartUpList
[
#(#NaturalLanguageTranslator #ShortIntegerArray #ShortRunArray #PasteUpMorph #SecurityManager #FreeTypeFontProvider #UUIDGenerator #ProcessBrowser #CPUWatcher #DateAndTime #HostSystemMenus #MenuIcons #InternetConfiguration #CommandHistory #HostWindowProxy #FreeTypeSettings #UITheme #CodeLoader #ZnServer #MCWorkingCopy #RecentMessageList #EditorFindReplaceDialogWindow #CodeUpdate)	do: [ :className | Smalltalk removeFromStartUpList: (Smalltalk classNamed: className) ]
]

Class SmalltalkImage >> privCleanTextConstants
[
TextConstants TextSharedInformation removeKey: #DefaultTextStyle.TextConstants TextSharedInformation removeKey: #DefaultMultiStyle.TextConstants TextSharedInformation removeKey: #DefaultFixedTextStyle.TextConstants TextSharedInformation removeKey: StrikeFont defaultFontKey.Smalltalk allClasses select: [ :c | c sharedPools includes: TextConstants ] thenDo: [ :c | c compileAll ]
]

Class SmalltalkImage >> privCleanUnloadMethods
[
	" remove class unload methods to avoid their calling during removing of this classes "
#(#Browser #ChangeList #ChangeSorter #DummySoundSystem #FT2Handle #FileContentsBrowser #GZipReadStream #GZipWriteStream #MCVersionReader #MailComposition #Morph #FreeTypeFontProvider #DefaultExternalDropHandler #FileStream #Form)	do: [ :className | (Smalltalk at: className) class removeSelector: #unload ]
]

Class SmalltalkImage >> privRecompileAll
[
Smalltalk allClassesAndTraits do: [ :classOrTrait | classOrTrait compileAll ]
]

Class SmalltalkImage >> privSaveImageWithCleanup
[
	" Do not use this method for common image saving. This method is designated for saving the image during the shrinking process in headless images."
| report |(Delay forMilliseconds: 1000) wait.Processor yield.13 timesRepeat: [ Smalltalk garbageCollect ].	"a magic number (Camillo) "[ self snapshot: true andQuit: true ]	ifError: [ :e | 		[ 		report := FileStream forceNewFileNamed: 'PharoDebug.log'.		report			nextPutAll: e asString;			cr ]			ensure: [ report ifNotNil: [ report close ] ] ]
]

Class SmalltalkImage >> privShrinkUnicodeTables
[
#(#GB2312Table #JISX0208Table #KSX1001Table) do: [ :table | UCSTable classPool at: table put: nil ].Unicode classPool	at: #DecimalProperty	put:		#(-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 1 2 3 4 5 6 7 8 9 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1).Unicode classPool	at: #GeneralCategory	put:		#(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 29 21 21 21 23 21 21 21 22 18 21 25 21 17 21 21 13 13 13 13 13 13 13 13 13 13 21 21 25 25 25 21 21 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 22 21 18 24 16 24 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 22 25 18 25 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 29 21 23 23 23 23 26 26 24 26 5 20 25 17 26 24 26 25 15 15 24 5 26 21 24 15 5 19 15 15 15 21 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 25 9 9 9 9 9 9 9 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 25 5 5 5 5 5 5 5)
]

Class SmalltalkImage >> privShrinkingProcess
[
[ | packages |10	timesRepeat: [ 		(Delay forMilliseconds: 100) wait.		Processor yield ].Author fullName: 'Mr.Shrinker'.self privCleanMonticello.UIManager default: DummyUIManager new.UIManager default progressBarEnabled: false.self privCleanProcesses.self privCleanGlobals.5 timesRepeat: [ Smalltalk garbageCollect ].MCDataStream initialize.Beeper instVarNamed: #default put: nil.Smalltalk cleanOutUndeclared.5 timesRepeat: [ Smalltalk garbageCollect ].Author reset.KMPragmaKeymapBuilder release.self privShrinkUnicodeTables.Display newDepth: 1.self privCleanStartUpList.self privCleanShutDownList.	"    CommandLine removeRegistrationNamed: #BasicCodeLoader.    SimpleCodeLoader register."	"move class Model to different category"Object	subclass: #Model	instanceVariableNames: 'dependents'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'.self privCleanTextConstants.SoundService default: nil.SoundService unregister: DummySoundSystem.ThreadSafeTranscript install.self privCleanUnloadMethods.SystemNavigation new removeAllButPackages: self kernelPackageNames.Smalltalk flushClassNameCache.3	timesRepeat: [ 		Smalltalk garbageCollect.		Symbol compactSymbolTable ].Undeclared removeUnreferencedKeys.self privRecompileAll.self privCleanChangeSets.FileServices removeObsolete.DebuggerMethodMap voidMapCache.Object flushEvents.MCDataStream initialize.Locale classPool at: #LocaleChangeListeners put: nil.SmalltalkImage classPool at: #Tools put: nil.Behavior flushObsoleteSubclasses.Smalltalk flushClassNameCache.Smalltalk organization removeEmptyCategories.WeakArray restartFinalizationProcess.	"UIManager default progressBarEnabled: true."	"Smalltalk condenseChanges."Smalltalk saveImageInNewContext ]	ifError: [ :e | 		| rep |		rep := FileStream forceNewFileNamed: 'PharoDebug.log'.		rep			nextPutAll: 'PharoKernel shrinking report';			cr.		rep			nextPutAll: 'Error:';			cr.		rep			nextPutAll: e asString;			cr.		rep nextPutAll: thisContext stack size asString.		thisContext stack copy			withIndexDo: [ :stck :i | 				[ 				rep					nextPutAll: i asString;					space;					nextPutAll: stck asString;					cr ] ifError: [  ] ].		rep close.		Smalltalk exitFailure ]
]

Class SmalltalkImage >> processShutDownList: quitting
[
	"Send #shutDown to each class that needs to wrap up before a snapshot.	Also void the endianness chace; this can't safely be done on start-up because	Smalltalk is too late in the start-up sequence."
EndianCache := nil.^ self send: #shutDown: toClassesNamedIn: ShutDownList with: quitting
]

Class SmalltalkImage >> processStartUpList: resuming
[
	"Send #startUp to each class that needs to run initialization after a snapshot."
^ self send: #startUp: toClassesNamedIn: StartUpList with: resuming
]

Class SmalltalkImage >> quitPrimitive
[
	"Primitive. Exit to another operating system on the host machine, if one	exists. All state changes in the object space since the last snapshot are lost.	Essential. See Object documentation whatIsAPrimitive."
	<primitive: 113>
self primitiveFailed
]

Class SmalltalkImage >> recordStartupStamp
[
ChangesLog default recordStartupStamp
]

Class SmalltalkImage >> recreateSpecialObjectsArray
[
	"Smalltalk recreateSpecialObjectsArray"
	"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."
	"Replace the interpreter's reference in one atomic operation"
self specialObjectsArray becomeForward: self newSpecialObjectsArray
]

Class SmalltalkImage >> registerExternalObject: anObject
[
	"Register the given object in the external objects array and return its index. If it is already there, just return its index."
^ ExternalSemaphoreTable registerExternalObject: anObject
]

Class SmalltalkImage >> removeAllLineFeeds
[
	"Smalltalk removeAllLineFeeds"
	"Scan all methods for source code with lineFeeds.	Replaces all occurrences of <CR><LF> or <LF> by <CR>.	When done, offers to display an Inspector containing the message	names grouped by author initials.	In this dictionary, the key 'OK' contains the methods that had literals that contained <LF> characters."
| totalStripped totalOK authors |'Scanning sources for LineFeeds.This will take a few minutes...'	displayProgressFrom: 0	to: CompiledMethod instanceCount	during: [ :bar | 		| n |		n := 0.		authors := self			removeAllLineFeedsQuietlyCalling: [ 				(n := n + 1) \\ 100 = 0					ifTrue: [ bar current: n ] ] ].totalStripped := authors inject: 1 into: [ :sum :set | sum + set size ].totalOK := (authors at: 'OK') size.totalStripped := totalStripped - totalOK.self crTrace: totalStripped printString , ' methods stripped of LFs.'.self crTrace: totalOK printString , ' methods still correctly contain LFs.'.(self confirm: 'Do you want to see the affected methods?')	ifTrue: [ authors inspect ]
]

Class SmalltalkImage >> removeAllLineFeedsQuietly
[
	"Smalltalk removeAllLineFeedsQuietly"
	"Scan all methods for source code with lineFeeds.	Replaces all occurrences of <CR><LF> or <LF> by <CR>.	Answer a Dictionary keyed by author name containing sets of affected method names,	as well as (at the key 'OK') a list of methods that still contain LF characters inside literal strings or characters."
^ self removeAllLineFeedsQuietlyCalling: [  ]
]

Class SmalltalkImage >> removeAllLineFeedsQuietlyCalling: aBlock
[
	"Smalltalk removeAllLineFeedsQuietly"
	"Scan all methods for source code with lineFeeds.	Replaces all occurrences of <CR><LF> or <LF> by <CR>.	Answer a Dictionary keyed by author name containing sets of affected method names,	as well as (at the key 'OK') a list of methods that still contain LF characters inside literal strings or characters.	Evaluate aBlock for each method so that status can be updated."
| authors |authors := Dictionary new.authors at: 'OK' put: Set new.self systemNavigation	allBehaviorsDo: [ :cls | 		cls			selectorsAndMethodsDo: [ :selector :method | 				| oldStamp newCodeString oldCodeString oldCategory nameString |				aBlock cull: cls cull: selector.				oldCodeString := cls sourceCodeAt: selector.				(oldCodeString includes: Character lf)					ifTrue: [ 						newCodeString := oldCodeString withSqueakLineEndings.						nameString := cls name , '>>' , selector.						((cls compiledMethodAt: selector) hasLiteralSuchThat: [ :lit | lit asString includes: Character lf ])							ifTrue: [ (authors at: 'OK') add: nameString ]							ifFalse: [ 								oldStamp := method timeStamp copy replaceAll: Character cr with: Character space.								(authors									at: (oldStamp copyFrom: 1 to: (oldStamp findFirst: [ :c | c isAlphaNumeric not ]))									ifAbsentPut: [ Set new ]) add: nameString.								oldCategory := cls whichCategoryIncludesSelector: selector.								cls									compile: newCodeString									classified: oldCategory									withStamp: oldStamp									notifying: nil ] ] ] ].^ authors
]

Class SmalltalkImage >> removeClassNamed: aName
[
	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "
globals removeClassNamed: aName
]

Class SmalltalkImage >> removeEmptyMessageCategories
[
	"Smalltalk removeEmptyMessageCategories"
self garbageCollect.(ClassOrganizer allInstances copyWith: SystemOrganization) do: [ :org | org removeEmptyCategories ]
]

Class SmalltalkImage >> removeFromShutDownList: aClass
[
ShutDownList remove: aClass name ifAbsent: [  ]
]

Class SmalltalkImage >> removeFromStartUpList: aClass
[
StartUpList remove: aClass name ifAbsent: [  ]
]

Class SmalltalkImage >> removeKey: key
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals removeKey: key
]

Class SmalltalkImage >> removeKey: key ifAbsent: aBlock
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals removeKey: key ifAbsent: aBlock
]

Class SmalltalkImage >> removeSelector: descriptor
[
	"Safely remove a selector from a class (or metaclass). If the	class or the method doesn't exist anymore, never mind and	answer nil.	This method should be used instead of 'Class removeSelector:	#method' to omit global class references."
| class sel |class := self at: descriptor first ifAbsent: [ ^ nil ].(descriptor size > 2 and: [ descriptor second == #class ])	ifTrue: [ 		class := class class.		sel := descriptor third ]	ifFalse: [ sel := descriptor second ].^ class removeSelector: sel
]

Class SmalltalkImage >> renameClass: aClass as: newName
[
	"Rename the class, aClass, to have the title newName."
^ globals renameClass: aClass as: newName
]

Class SmalltalkImage >> renameClass: aClass from: oldName
[
	"Rename the class, aClass, to have the title newName."
^ globals renameClass: aClass from: oldName
]

Class SmalltalkImage >> renameClassNamed: oldName as: newName
[
	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  "
| oldClass |(oldClass := self at: oldName asSymbol ifAbsent: [ nil ]) == nil	ifTrue: [ 		self crTrace: 'Class-rename for ' , oldName , ' ignored because ' , oldName , ' does not exist.'.		^ self ].oldClass rename: newName
]

Class SmalltalkImage >> renamedClass: aClass from: oldName to: newName
[
	"Inform Smalltalk that aClass has been renamed"
(Array with: StartUpList with: ShutDownList)	do: [ :list | 		| index |		index := list indexOf: oldName ifAbsent: [ 0 ].		index > 0			ifTrue: [ list at: index put: newName ] ]
]

Class SmalltalkImage >> rootTable
[
	"Primitive. Answer a snapshot of the VMs root table. 	Keep in mind that the primitive may itself cause GC."
	<primitive: 'primitiveRootTable'>
^ self primitiveFailed
]

Class SmalltalkImage >> rootTableAt: index
[
	"Primitive. Answer the nth element of the VMs root table"
	<primitive: 'primitiveRootTableAt'>
^ nil
]

Class SmalltalkImage >> saveAs
[
	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."
self saveAs: self getFileNameFromUser
]

Class SmalltalkImage >> saveAs: newName
[
newName ifNil: [ ^ self ].(SourceFiles at: 2)	ifNotNil: [ 		self			closeSourceFiles;			saveChangesInFileNamed: (self fullNameForChangesNamed: newName)	"so copying the changes file will always work" ].^ self saveImageInFileNamed: (self fullNameForImageNamed: newName)
]

Class SmalltalkImage >> saveAsNewVersion
[
	"Save the image/changes using the next available version number."
	"SmalltalkImage current saveAsNewVersion"
| newImageFile newChangesFile |newImageFile := self imageFile nextVersion.newChangesFile := newImageFile withExtension: self changesSuffix.	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"newChangesFile exists	ifTrue: [ 		^ self			inform:				'There is already .changes file of the desired name,' , newChangesFile fullName					,						'curiously already present, even though there isno corresponding .image file.   Please remedymanually and then repeat your request.' ].	"strip awaay the image extension"^ self saveAs: (newImageFile fullName copyUpToLast: $.)
]

Class SmalltalkImage >> saveChangesInFileNamed: aString
[
| changesFile |changesFile := aString asFileReference.changesFile parent ensureDirectory.Smalltalk changesFile copyTo: changesFile.self setMacFileInfoOn: changesFile fullName
]

Class SmalltalkImage >> saveImageInFileNamed: aString
[
| imageFile previousFullImageName |imageFile := aString asFileReference.imageFile parent ensureDirectory.previousFullImageName := self imagePath.^ self	changeImagePathTo: imageFile fullName;	closeSourceFiles;	openSourceFiles;	snapshot: true andQuit: false	"so SNAPSHOT appears in new changes file"
]

Class SmalltalkImage >> saveImageInNewContext
[
	" This method is used for saving the Smalltalk image in a new process so the current process with all stack information may be forgotten.		Do not use this method for common image saving. This method is designated for saving the image during the shrinking process in headless images. "
[ self privSaveImageWithCleanup ] forkAt: 40
]

Class SmalltalkImage >> saveSession
[
	"Save the current image without quitting and return it resuming status (whether it was restarted or in the same flow)."
^ self snapshot: true andQuit: false
]

Class SmalltalkImage >> select: aBlock
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals select: aBlock
]

Class SmalltalkImage >> send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
[
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is resuming (for #startUp:).
	If any name cannot be found, then remove it from the list."
| removals errors |removals := OrderedCollection new.errors := OrderedCollection new.startUpOrShutDownList	do: [ :name | 		| class |		class := self at: name ifAbsent: [ nil ].		class isNil			ifTrue: [ removals add: name ]			ifFalse: [ self logStartUpErrorDuring: [ class perform: startUpOrShutDown with: argument ] into: errors tryDebugger: false ] ].	"Remove any obsolete entries, but after the iteration"startUpOrShutDownList removeAll: removals.^ errors
]

Class SmalltalkImage >> setMacFileInfoOn: aString
[
	"On Mac, set the file type and creator (noop on other platforms)"
aString asFileReference setMacType: 'STch' creator: 'FAST'
]

Class SmalltalkImage >> shortImageName
[
	"Answer the current image name but only that name and not the full path as with imageName."
	"SmalltalkImage current shortImageName"
^ self imageFile basename
]

Class SmalltalkImage >> shrinkToCore
[
| packagesToUnload |packagesToUnload := (ScriptLoader new allCurrentPackages collect: [ :p | p package name ])	copyWithoutAll: Smalltalk kernelPackageNames , Smalltalk corePackageNames.packagesToUnload do: [ :packageName | ScriptLoader new unloadPackageNamed: packageName ].self privCleanCore
]

Class SmalltalkImage >> shrinkToKernel
[
	"	WARNING:	THIS METHOD WILL DESTROY YOUR IMAGE	Use with cation and only on fresh Pharo-Core images 	"
[ self privShrinkingProcess ] forkAt: 40.Processor terminateActive
]

Class SmalltalkImage >> shutDown
[
^ Smalltalk closeSourceFiles
]

Class SmalltalkImage >> shutDownImage: quitting
[
Object flushDependents.Object flushEvents.self processShutDownList: quitting
]

Class SmalltalkImage >> signalLowSpace
[
	"Signal the low-space semaphore to alert the user that space is running low."
LowSpaceSemaphore signal
]

Class SmalltalkImage >> size
[
	"Obsoleted."
self flag: #tobeprecated.	"self deprecated: 'Use Smalltalk globals'."^ globals size
]

Class SmalltalkImage >> snapshot: save andQuit: quit
[
	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
| snapshotResult resuming startupErrors |self addSnapshotRecord: save andQuit: quit.self shutDownImage: quit.save	ifTrue: [ 		snapshotResult := self snapshotPrimitive.	"<-- PC frozen here on image file"		resuming := snapshotResult == true ]	ifFalse: [ resuming := false ].(quit and: [ resuming not ])	ifTrue: [ self quitPrimitive ].self startupImage: resuming snapshotWorked: snapshotResult.	"We return the resuming state, which may be useful for users to know the state of the image"^ resuming
]

Class SmalltalkImage >> snapshotPrimitive
[
	"Primitive. Write the current state of the object memory on a file in the	same format as the Smalltalk-80 release. The file can later be resumed,	returning you to this exact state. Return normally after writing the file.	Essential. See Object documentation whatIsAPrimitive."
	<primitive: 97>
^ nil	"indicates error writing image file"
]

Class SmalltalkImage >> sourceFileVersionString
[
^ SourceFileVersionString
]

Class SmalltalkImage >> sourceFileVersionString: aString
[
SourceFileVersionString := aString
]

Class SmalltalkImage >> sourcesFile
[
	"Answer the full path to the version-stable source code"
^ self vmDirectory / SourceFileVersionString , self sourcesSuffix
]

Class SmalltalkImage >> sourcesName
[
	"Answer the full path to the version-stable source code"
^ self sourcesFile fullName
]

Class SmalltalkImage >> sourcesSuffix
[
^ 'sources'
]

Class SmalltalkImage >> spaceLeftAfterGarbageCollection
[
	"Return a string describing the amount of memory available"
| availInternal availPhysical availTotal |self garbageCollect.availInternal := self primBytesLeft.availPhysical := self bytesLeft: false.availTotal := self bytesLeft: true.availTotal > (availInternal + 10000)	ifFalse: [ ^ availInternal asStringWithCommas , ' bytes available' ].	"compensate for mini allocations inbetween"^ String	streamContents: [ :s | 		s			nextPutAll: availInternal asStringWithCommas , ' bytes (internal) ';			cr.		s			nextPutAll: availPhysical asStringWithCommas , ' bytes (physical) ';			cr.		s nextPutAll: availTotal asStringWithCommas , ' bytes (total)     ' ]
]

Class SmalltalkImage >> specialNargsAt: anInteger
[
	"Answer the number of arguments for the special selector at: anInteger."
^ (self specialObjectsArray at: 24) at: anInteger * 2
]

Class SmalltalkImage >> specialObjectsArray
[
^ specialObjectsArray ifNil: [ specialObjectsArray := self primitiveGetSpecialObjectsArray ]
]

Class SmalltalkImage >> specialObjectsArray: anArray
[
specialObjectsArray := anArray
]

Class SmalltalkImage >> specialSelectorAt: anInteger
[
	"Answer the special message selector from the interleaved specialSelectors array."
^ (self specialObjectsArray at: 24) at: anInteger * 2 - 1
]

Class SmalltalkImage >> specialSelectorSize
[
	"Answer the number of special selectors in the system."
^ (self specialObjectsArray at: 24) size // 2
]

Class SmalltalkImage >> specialSelectors
[
	"Used by SystemTracer only."
^ SpecialSelectors
]

Class SmalltalkImage >> startupImage: resuming snapshotWorked: snapshotResult
[
| startupErrors |self vm setGCParameters.deferredStartupActions := nil.resuming	ifTrue: [ Smalltalk clearExternalObjects ].startupErrors := OrderedCollection new.UIManager default	boot: resuming	during: [ 		startupErrors addAll: (self processStartUpList: resuming).		resuming			ifTrue: [ self recordStartupStamp ] ].startupErrors addAll: (self executeDeferredStartupActions: resuming).startupErrors isEmpty	ifFalse: [ self handleStartupErrors: startupErrors ].snapshotResult == nil	ifTrue: [ self error: 'Failed to write image file (disk full?)' ]
]

Class SmalltalkImage >> systemInformationString
[
^ String cr , SystemVersion current version , String cr , self lastUpdateString , String cr , String cr , String cr	, self licenseString
]

Class SmalltalkImage >> timeStamp: aStream
[
	"Writes system version and current time on stream aStream."
| dateTime |dateTime := Time dateAndTimeNow.aStream	nextPutAll:		'From ' , self datedVersion , ' [' , self lastUpdateString , '] on ' , (dateTime at: 1) printString , ' at '			, (dateTime at: 2) printString
]

Class SmalltalkImage >> traitNames
[
	"Answer a SortedCollection of all traits (not including class-traits) names."
^ globals traitNames
]

Class SmalltalkImage >> unbindExternalPrimitives
[
	"Primitive. Force all external primitives to be looked up again afterwards. Since external primitives that have not found are bound for fast failure this method will force the lookup of all primitives again so that after adding some plugin the primitives may be found."
	"Do nothing if the primitive fails for compatibility with older VMs"
	<primitive: 570>

]

Class SmalltalkImage >> unloadModule: aString
[
	"Primitive. Unload the given module.	This primitive is intended for development only since some	platform do not implement unloading of DLL's accordingly.	Also, the mechanism for unloading may not be supported	on all platforms."
	<primitive: 571>
^ self primitiveFailed
]

Class SmalltalkImage >> unregisterExternalObject: anObject
[
	"Unregister the given object in the external objects array. Do nothing if it isn't registered."
ExternalSemaphoreTable unregisterExternalObject: anObject
]

Class SmalltalkImage >> verifyChanges
[
	"Smalltalk verifyChanges"
	"Recompile all methods in the changes file."
self systemNavigation allBehaviorsDo: [ :class | class recompileChanges ]
]

Class SmalltalkImage >> version
[
	"Answer the version of this release."
^ SystemVersion current version
]

Class SmalltalkImage >> veryDeepCopyWith: deepCopier
[
	"Return self.  I can't be copied.  Do not record me."

]

Class SmalltalkImage >> vm
[
	"Answer the object to query about virtual machine."
^ VirtualMachine
]

Class SmalltalkImage >> vmBinary
[
^ self vm binary
]

Class SmalltalkImage >> vmDirectory
[
^ self vm directory
]

Class SmalltalkImage >> wordSize
[
	"Answer the size in bytes of an object pointer or word in the object memory.	The value does not change for a given image, but may be modified by a SystemTracer	when converting the image to another format. The value is cached in WordSize to	avoid the performance overhead of repeatedly consulting the VM."
	"this method is deprecated"
^ self vm wordSize
]

Metaclass
	name: #SmalltalkImage;
	instanceVariables: #().

Metaclass SmalltalkImage >> checkChangesFileAvailability
[
^ CheckChangesFileAvailability ifNil: [ CheckChangesFileAvailability := true ]
]

Metaclass SmalltalkImage >> checkChangesFileAvailability: aBoolean
[
CheckChangesFileAvailability := aBoolean
]

Metaclass SmalltalkImage >> checkSourcesFileAvailability
[
^ CheckSourcesFileAvailability ifNil: [ CheckSourcesFileAvailability := true ]
]

Metaclass SmalltalkImage >> checkSourcesFileAvailability: aBoolean
[
CheckSourcesFileAvailability := aBoolean
]

Metaclass SmalltalkImage >> cleanUp
[
	"Flush caches"
	"should probably distribute cleaning to systemDictionary"
Smalltalk globals flushClassNameCache.Undeclared removeUnreferencedKeys
]

Metaclass SmalltalkImage >> current
[
^ Smalltalk
]

Metaclass SmalltalkImage >> howToGetClassesNotRegisteredInStartups
[
| classes startClassNames stopClassNames |classes := ((SystemNavigation new allCallsOn: #addToStartUpList:) collect: [ :e | e methodClass ])	, ((SystemNavigation new allCallsOn: #addToStartUpList:after:) collect: [ :e | e methodClass ]).startClassNames := classes collect: [ :n | n instanceSide name ].(Smalltalk class classVarNamed: 'StartUpList') do: [ :s | startClassNames remove: s ifAbsent: [  ] ].classes := ((SystemNavigation ne allCallsOn: #addToShutDownList:) collect: [ :e | e methodClass ])	, ((SystemNavigation new allCallsOn: #addToShutDownList:after:) collect: [ :e | e methodClass ]).stopClassNames := classes collect: [ :n | n instanceSide name ].(Smalltalk class classVarNamed: 'ShutDownList') do: [ :s | stopClassNames remove: s ifAbsent: [  ] ].(startClassNames , stopClassNames) asSet asSortedCollection	remove: #InputEventSensor;	yourself	"do: [:each | (Smalltalk at: each) initialize] does not work because of dependencies"
]

Metaclass SmalltalkImage >> initialize
[
	"SmalltalkImage initialize"
self initializeStartUpList.self initializeShutDownList.Smalltalk addToStartUpList: SmalltalkImage
]

Metaclass SmalltalkImage >> initializeShutDownList
[
	"SmalltalkImage initializeShutDownList"
| oldList |oldList := ShutDownList.ShutDownList := OrderedCollection new.	"These get processed from the bottom up..."#(#Delay #DisplayScreen #InputEventFetcher #Form #PasteUpMorph #StrikeFont #Color #SoundPlayer #HttpUrl #Password)	do: [ :clsName | Smalltalk globals at: clsName ifPresent: [ :cls | Smalltalk addToShutDownList: cls ] ].oldList	ifNotNil: [ 		oldList			reverseDo: [ :className | Smalltalk globals at: className ifPresent: [ :theClass | Smalltalk addToShutDownList: theClass ] ] ]
]

Metaclass SmalltalkImage >> initializeStartUpList
[
	"SmalltalkImage initializeStartUpList"
| oldList |oldList := StartUpList.StartUpList := OrderedCollection new.	"These get processed from the top down..."#(#Delay #DisplayScreen #Cursor #InputEventFetcher #ProcessorScheduler #LanguageEnvironment #NaturalLanguageTranslator #ShortIntegerArray #ShortRunArray)	do: [ :clsName | Smalltalk globals at: clsName ifPresent: [ :cls | Smalltalk addToStartUpList: cls ] ].oldList	ifNotNil: [ 		oldList			do: [ :className | Smalltalk globals at: className ifPresent: [ :theClass | Smalltalk addToStartUpList: theClass ] ] ].#(#PasteUpMorph) do: [ :clsName | Smalltalk globals at: clsName ifPresent: [ :cls | Smalltalk addToStartUpList: cls ] ]
]

Metaclass SmalltalkImage >> new
[
self error: 'Use current'
]

Metaclass SmalltalkImage >> startUp
[
ChangesLog default.Smalltalk openSourceFiles
]

Metaclass SmalltalkImage >> wordSize
[
^ Smalltalk vm wordSize
]

