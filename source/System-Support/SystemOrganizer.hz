Class
	name: #SystemOrganizer;
	superclass: #ClassCategorizer;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#environment );
	classVariables: #();
	package: #'System-Support'.

Class SystemOrganizer >> addCategory: newCategory
[
| r |r := super addCategory: newCategory.SystemAnnouncer uniqueInstance classCategoryAdded: newCategory.^ r
]

Class SystemOrganizer >> categoriesMatching: matchString
[
	"Return all matching categories"
self categories ifNil: [ ^ #() ].^ self categories select: [ :c | matchString match: c ]
]

Class SystemOrganizer >> classesInCategory: category
[
^ (self listAtCategoryNamed: category) collect: [ :className | self environment at: className ]
]

Class SystemOrganizer >> commentInventory: categoryName
[
	"SystemOrganization commentInventory: 'Morphic*'"
| classes commentedClasses |classes := OrderedCollection new.self categories	withIndexCollect: [ :cat :idx | 		(categoryName match: cat)			ifTrue: [ classes addAll: (self listAtCategoryNumber: idx) ]			ifFalse: [ nil ] ].commentedClasses := classes select: [ :catCls | (self environment at: catCls) hasComment ].^ 'There are ' , classes size asString , ' classes in ' , categoryName , ' of which ' , commentedClasses size asString	, ' have comments and ' , (classes size - commentedClasses size) asString , ' do not yet have comments.'
]

Class SystemOrganizer >> environment
[
^ environment ifNil: [ environment := Smalltalk globals ]
]

Class SystemOrganizer >> environment: aSystemDictionary
[
environment := aSystemDictionary
]

Class SystemOrganizer >> fileOut
[
	"SystemOrganization fileOut"
| internalStream |internalStream := (String new: 30000) writeStream.internalStream	nextPutAll: 'SystemOrganization changeFromCategorySpecs: #(';	cr;	print: SystemOrganization;	nextPutAll: ')!';	cr.	"ends with a cr"FileStream	writeSourceCodeFrom: internalStream	baseName: 'SystemOrganization.st' asFileReference nextVersion basename	isSt: true
]

Class SystemOrganizer >> fileOutCategory: category
[
	"Store on the file named category (a string) concatenated with '.st' all the 	classes associated with the category."
| internalStream |internalStream := (String new: 1000) writeStream.self fileOutCategory: category on: internalStream initializing: true.^ FileStream writeSourceCodeFrom: internalStream baseName: category isSt: true
]

Class SystemOrganizer >> fileOutCategory: category on: aFileStream
[
	"Store on the file associated with aFileStream, all the classes associated 	with the category and any requested shared pools."
^ self fileOutCategory: category on: aFileStream initializing: true
]

Class SystemOrganizer >> fileOutCategory: category on: aFileStream initializing: aBool
[
	"Store on the file associated with aFileStream, all the traits and classes associated 	with the category and any requested shared pools in the right order."
| first poolSet tempClass classes traits |traits := self orderedTraitsIn: category.classes := self superclassOrder: category.poolSet := Set new.classes do: [ :class | class sharedPools do: [ :eachPool | poolSet add: eachPool ] ].poolSet size > 0	ifTrue: [ 		tempClass := Class new.		tempClass shouldFileOutPools			ifTrue: [ 				poolSet := poolSet select: [ :aPool | tempClass shouldFileOutPool: (Smalltalk globals keyAtIdentityValue: aPool) ].				poolSet do: [ :aPool | tempClass fileOutPool: aPool onFileStream: aFileStream ] ] ].first := true.traits , classes	do: [ :each | 		first			ifTrue: [ first := false ]			ifFalse: [ 				aFileStream					cr;					nextPut: Character newPage;					cr ].		each			fileOutOn: aFileStream			moveSource: false			toFile: 0			initializing: false ].aBool	ifTrue: [ classes do: [ :cls | cls fileOutInitializerOn: aFileStream ] ]
]

Class SystemOrganizer >> includesCategory: aString
[
	"Return all matching categories"
self categories ifNil: [ ^ #() ].^ self categories includes: aString
]

Class SystemOrganizer >> initialize
[
super initialize.categoryArray := Array new.categoryStops := Array new.elementArray := Array new
]

Class SystemOrganizer >> orderedTraitsIn: category
[
	"Answer an OrderedCollection containing references to the traits in the 	category whose name is the argument, category (a string). The traits 	are ordered so they can be filed in."
| behaviors traits |behaviors := (self listAtCategoryNamed: category asSymbol) collect: [ :title | self environment at: title ].traits := behaviors reject: [ :each | each isBehavior ].traits := traits	asSortedCollection: [ :t1 :t2 | (t2 traitComposition allTraits includes: t1) or: [ (t1 traitComposition allTraits includes: t2) not ] ].^ traits asArray
]

Class SystemOrganizer >> removeCategoriesMatching: matchString
[
	"Remove all matching categories with their classes"
(self categoriesMatching: matchString) do: [ :c | self removeSystemCategory: c ]
]

Class SystemOrganizer >> removeCategory: category
[
| r |r := super removeCategory: category.	"If the category we try to remove is the default one, due to cleansing, we don't have to announce it since it is not a valid category for a Class"category = Default	ifFalse: [ SystemAnnouncer uniqueInstance classCategoryRemoved: category ].^ r
]

Class SystemOrganizer >> removeMissingClasses
[
	"Remove any class names that are no longer in the Smalltalk dictionary. Used for cleaning up after garbage collecting user-generated classes."
	"SystemOrganization removeMissingClasses"
elementArray copy	do: [ :el | 		(self environment includesKey: el)			ifFalse: [ self removeElement: el ] ]
]

Class SystemOrganizer >> removeSystemCategory: category
[
	"remove all the classes and traits associated with the category"
(self orderedTraitsIn: category) , (self superclassOrder: category) reverseDo: [ :each | each removeFromSystem ].self removeCategory: category
]

Class SystemOrganizer >> renameCategory: oldCatString toBe: newCatString
[
| r |r := super renameCategory: oldCatString toBe: newCatString.SystemAnnouncer uniqueInstance classCategoryRenamedFrom: oldCatString to: newCatString.^ r
]

Class SystemOrganizer >> superclassOrder: category
[
	"Answer an OrderedCollection containing references to the classes in the 	category whose name is the argument, category (a string). The classes 	are ordered with superclasses first so they can be filed in."
| behaviors classes |behaviors := (self listAtCategoryNamed: category asSymbol) collect: [ :title | self environment at: title ].classes := behaviors select: [ :each | each isBehavior ].^ Class superclassOrder: classes
]

Class SystemOrganizer >> uncommentedClassesIn: categoryName
[
	"SystemOrganization uncommentedClassesIn: 'Morphic*'"
| classes |classes := OrderedCollection new.self categories	withIndexCollect: [ :cat :idx | 		(categoryName match: cat)			ifTrue: [ classes addAll: (self listAtCategoryNumber: idx) ]			ifFalse: [ nil ] ].^ (classes collect: [ :clsName | self environment at: clsName ] thenSelect: [ :cls | cls hasComment not ]) asArray
]

Metaclass
	name: #SystemOrganizer;
	instanceVariables: #().

Metaclass SystemOrganizer >> cleanUp: agressive
[
	"Remove empty categories when cleaning aggressively"
agressive	ifTrue: [ SystemOrganization removeEmptyCategories ]
]

Metaclass SystemOrganizer >> default
[
	"look in the environment that the receiver organizes for the associated organization"
^ self environment organization
]

