Class
	name: #Set;
	superclass: #ClassHashedCollection;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #();
	classVariables: #();
	package: #'Collections-Unordered'.

Class Set >> = aSet
[
self == aSet	ifTrue: [ ^ true ].	"stop recursion"(aSet isKindOf: Set)	ifFalse: [ ^ false ].self size = aSet size	ifFalse: [ ^ false ].self	do: [ :each | 		(aSet includes: each)			ifFalse: [ ^ false ] ].^ true
]

Class Set >> add: newObject
[
	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."
| index |index := self scanFor: newObject.(array at: index) ifNil: [ self atNewIndex: index put: newObject asSetElement ].^ newObject
]

Class Set >> add: newObject withOccurrences: anInteger
[
^ self add: newObject
]

Class Set >> asSet
[
^ self
]

Class Set >> atRandom: aGenerator
[
	"Answer a random element of the receiver. Uses aGenerator which    should be kept by the user in a variable and used every time. Use    this instead of #atRandom for better uniformity of random numbers because 	only you use the generator. Causes an error if self has no elements."
| rand |self emptyCheck.rand := aGenerator nextInt: self size.self	doWithIndex: [ :each :ind | 		ind == rand			ifTrue: [ ^ each ] ].^ self errorEmptyCollection
]

Class Set >> collect: aBlock
[
	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."
| newSet |newSet := Set new: self size.array do: [ :each | each ifNotNil: [ newSet add: (aBlock value: each enclosedSetElement) ] ].^ newSet
]

Class Set >> copyWithout: oldElement
[
	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."
^ self copy	remove: oldElement ifAbsent: [  ];	yourself
]

Class Set >> difference: aCollection
[
	"Answer the set theoretic difference of two collections. Optimized version for Sets where no intermediate Set is necessary"
| set |set := self copy.aCollection do: [ :each | set remove: each ifAbsent: [  ] ].^ set
]

Class Set >> do: aBlock
[
tally = 0	ifTrue: [ ^ self ].1 to: array size do: [ :index | 	| each |	(each := array at: index) ifNotNil: [ aBlock value: each enclosedSetElement ] ]
]

Class Set >> fixCollisionsFrom: start
[
	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"
| element index |index := start.[ (element := array at: (index := index \\ array size + 1)) == nil ]	whileFalse: [ 		| newIndex |		(newIndex := self scanFor: element enclosedSetElement) = index			ifFalse: [ array swap: index with: newIndex ] ]
]

Class Set >> grow
[
	"Grow the elements array and reinsert the old elements"
| oldElements |oldElements := array.array := Array new: (HashTableSizes atLeast: oldElements size * 2).tally := 0.oldElements	do: [ :each | 		each == nil			ifFalse: [ self noCheckAdd: each enclosedSetElement ] ]
]

Class Set >> includes: anObject
[
^ (array at: (self findElementOrNil: anObject)) ~~ nil
]

Class Set >> integrityCheck
[
	"test that objects hashes mathing their positions stored in set's array,	answer true if everything ok, false otherwise			Set allSubInstances select: [:badSet |		badSet integrityCheck not ]	"
array	withIndexDo: [ :elem :i | 		elem			ifNotNil: [ 				(self scanFor: elem) == i					ifFalse: [ ^ false ] ] ].^ true
]

Class Set >> intersection: aCollection
[
	"Answer the set theoretic intersection of two collections.	Optimized version for Sets where no intermediate Set is necessary"
| outputSet |outputSet := self class new.aCollection	do: [ :each | 		((self includes: each) and: [ (outputSet includes: each) not ])			ifTrue: [ outputSet add: each ] ].^ outputSet
]

Class Set >> isHealthy
[
	"Test that object hashes match their positions stored in set's array,	answer true if everything ok, false otherwise		Set allSubInstances select: [:badSet |		badSet isHealthy not ]	"
array	withIndexDo: [ :elem :i | 		elem			ifNotNil: [ 				(self scanFor: elem) == i					ifFalse: [ ^ false ] ] ].^ true
]

Class Set >> like: anObject
[
	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties.	Note, use #like:ifAbsent: if you need to match against nil as element"
^ self like: anObject ifAbsent: [ nil ]
]

Class Set >> like: anObject ifAbsent: aBlock
[
	"Answer an object in the receiver that is equal to anObject,	or evaluate the block if not found. Relies heavily on hash properties"
| element |element := array at: (self scanFor: anObject).^ element ifNil: [ aBlock value ] ifNotNil: [ element enclosedSetElement ]
]

Class Set >> noCheckAdd: anObject
[
	"This method should be deprecated"
array at: (self findElementOrNil: anObject) put: anObject asSetElement.tally := tally + 1
]

Class Set >> noCheckNoGrowFillFrom: anArray
[
	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."
1 to: anArray size do: [ :index | (anArray at: index) ifNotNil: [ :object | array at: (self scanForEmptySlotFor: object enclosedSetElement) put: object ] ]
]

Class Set >> occurrencesOf: anObject
[
^ (self includes: anObject)	ifTrue: [ 1 ]	ifFalse: [ 0 ]
]

Class Set >> postCopy
[
super postCopy.array := array copy
]

Class Set >> rehash
[
| newSelf |newSelf := self species new: self size.self do: [ :each | newSelf noCheckAdd: each ].array := newSelf array
]

Class Set >> remove: oldObject ifAbsent: aBlock
[
| index |index := self findElementOrNil: oldObject.(array at: index) == nil	ifTrue: [ ^ aBlock value ].array at: index put: nil.tally := tally - 1.self fixCollisionsFrom: index.^ oldObject
]

Class Set >> scanFor: anObject
[
	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."
| index start |index := start := anObject hash \\ array size + 1.[ | element |((element := array at: index) == nil or: [ element enclosedSetElement = anObject ])	ifTrue: [ ^ index ].(index := index \\ array size + 1) = start ] whileFalse.self errorNoFreeSpace
]

Class Set >> select: aBlock
[
	"Use copyEmpty instead of self species new to give subclasses a chance to initialize additional inst vars."
	"Note: this code could be moved to super"
| newCollection |newCollection := self copyEmpty.self	do: [ :each | 		(aBlock value: each)			ifTrue: [ newCollection add: each ] ].^ newCollection
]

Class Set >> union: aCollection
[
	"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all."
^ self copy	addAll: aCollection;	yourself
]

Class Set >> withArray: anArray
[
	"private -- for use only in copy"
	"I want to get a conflict"
array := anArray
]

Metaclass
	name: #Set;
	instanceVariables: #().

Metaclass Set >> new
[
^ self basicNew	initialize: 5;	yourself
]

Metaclass Set >> newFrom: aCollection
[
	"Answer an instance of me containing the same elements as aCollection."
| newCollection |newCollection := self new: aCollection size.newCollection addAll: aCollection.^ newCollection	"	Set newFrom: {1. 2. 3}	{1. 2. 3} as: Set"
]

Metaclass Set >> sizeFor: nElements
[
	"Large enough size to hold nElements with some slop (see fullCheck)"
^ HashTableSizes atLeast: nElements * 4 // 3
]

