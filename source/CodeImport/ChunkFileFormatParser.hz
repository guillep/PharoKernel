ChunkFileFormatParser
	instanceVariables: #(#readStream #parsedDeclarations #nextChar );
	package: #CodeImport.

ChunkFileFormatParser >> addDeclaration: aDeclaration
[
	parsedDeclarations add: aDeclaration
]

ChunkFileFormatParser >> initialize
[
	parsedDeclarations := OrderedCollection new
]

ChunkFileFormatParser >> isChunkEnd
[
	nextChar := readStream next.
	^ nextChar isNil or: [ nextChar = self terminatorMark and: [ readStream peek ~= self terminatorMark ] ]
]

ChunkFileFormatParser >> isNextChunkMetaData
[
	"If the next chunk starts with $!, it will be an expression that after evaluation returns an object who knows how to read some metadata. 
	I.e. A chunk for comment reading should be something like:
	
	!SomeClass commentStamp: '<historical>' prior: 0!
	
	The object returned by the expression of that tag must understand #scanFrom:
	"

	^ readStream peekFor: $!
]

ChunkFileFormatParser >> isNextStyleChunk
[
	"Style chunks are between $] and $["

	^ readStream peek == $]
]

ChunkFileFormatParser >> next
[
	"If the char we read previously is a terminator mark, it is scaping the next one, so we skip it"

	nextChar = self terminatorMark
		ifTrue: [ readStream next ].
	^ nextChar
]

ChunkFileFormatParser >> nextChunk
[
	| out |
	out := (String new: 1000) writeStream.
	readStream skipSeparators.
	[ self isChunkEnd ] whileFalse: [ out nextPut: self next ].
	^ out contents
]

ChunkFileFormatParser >> parseClassOrganization: classOrganizationPreamble
[
	"The comment preable is an array with the following structure:
	If instance side method:
	#(#CodeImportTestCaseTestClass #reorganize)
	
	if class side:
	
	#(#CodeImportTestCaseTestClass #class #reorganize)
	"

	| behaviorName isMeta |
	behaviorName := classOrganizationPreamble first.
	isMeta := classOrganizationPreamble second ~= #reorganize.
	self addDeclaration: (ClassOrganizationDeclaration contents: self nextChunk behaviorName: behaviorName isMeta: isMeta)
]

ChunkFileFormatParser >> parseCommentDeclaration: commentPreamble
[
	"The comment preable is an array with the following structure:
	If instance side method:
	#(#CodeImportTestCaseTestClass #commentStamp: '<historical>' #prior: 0)
	
	if class side:
	
	#(#CodeImportTestCaseTestClass #class #commentStamp: '<historical>' #prior: 0)
	allButFirst:
	"

	| behaviorName isMeta stamp |
	behaviorName := commentPreamble first asSymbol.
	isMeta := commentPreamble second ~= #commentStamp:.
	stamp := isMeta
		ifTrue: [ commentPreamble at: 4 ]
		ifFalse: [ commentPreamble at: 3 ].
	self
		addDeclaration:
			(ClassCommentDeclaration
				contents: self nextChunk
				behaviorName: behaviorName
				isMeta: isMeta
				stamp: stamp)
]

ChunkFileFormatParser >> parseDeclarations
[
	[ readStream atEnd ] whileFalse: [ self parseNextDeclaration ].
	^ parsedDeclarations
]

ChunkFileFormatParser >> parseMethodDeclarations: methodsPreamble
[
	| behaviorName isMeta category stamp methodSource |
	"The method preable is an array with the following structure:	If instance side method:		#(#CodeImportTestCaseTestClass #methodsFor: 'some protocol' #stamp: 'GuillermoPolito 5/2/2012 13:35')		if class side:		#(#CodeImportTestCaseTestClass #class #methodsFor: 'some protocol' #stamp: 'GuillermoPolito 5/2/2012 13:35')		Sometimes there is no timestamp:		#(#CodeImportTestCaseTestClass #methodsFor: 'some protocol')		"
	behaviorName := methodsPreamble first.
	isMeta := methodsPreamble second ~= #methodsFor:.
	category := isMeta
		ifTrue: [ methodsPreamble at: 4 ]
		ifFalse: [ methodsPreamble at: 3 ].
	stamp := ''.
	methodsPreamble size > 4
		ifTrue: [ stamp := isMeta
				ifTrue: [ methodsPreamble at: 6 ]
				ifFalse: [ methodsPreamble at: 5 ] ].
	[ methodSource := self nextChunk.
	methodSource notEmpty ]
		whileTrue: [ self
				addDeclaration:
					(MethodDeclaration
						contents: methodSource
						behaviorName: behaviorName asSymbol
						isMeta: isMeta
						category: category
						stamp: stamp) ]
]

ChunkFileFormatParser >> parseNextDeclaration
[
	| isMetadata nextChunk |
	readStream skipSeparators.
	self isNextStyleChunk
		ifTrue: [ self addDeclaration: (StyleDeclaration contents: self readUpToEndOfStyleChunk).
			^ self ].
	isMetadata := self isNextChunkMetaData.
	nextChunk := self nextChunk.
	isMetadata
		ifFalse: [ self addDeclaration: (DoItDeclaration contents: nextChunk) ]
		ifTrue: [ | substrings |
			substrings := nextChunk parseLiterals.
			(substrings includes: 'methodsFor:')
				ifTrue: [ ^ self parseMethodDeclarations: substrings ].
			(substrings includes: 'commentStamp:')
				ifTrue: [ ^ self parseCommentDeclaration: substrings ].
			(substrings includes: 'reorganize')
				ifTrue: [ ^ self parseClassOrganization: substrings ] ]
]

ChunkFileFormatParser >> readStream: aReadStream
[
	readStream := aReadStream
]

ChunkFileFormatParser >> readUpToEndOfStyleChunk
[
	"Style chunks are between $] and $["

	^ readStream upTo: $[
]

ChunkFileFormatParser >> terminatorMark
[
	^ $!
]

ChunkFileFormatParser class >> for: aReadStream
[
	^ self new
		readStream: aReadStream;
		yourself
]

