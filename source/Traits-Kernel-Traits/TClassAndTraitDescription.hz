Trait named: #TClassAndTraitDescription
	package: #'Traits-Kernel-Traits'.TClassAndTraitDescription >> acceptsLoggingOfCompilation
[
	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself
	Weird name is so that it will come lexically before #compile, so that a clean build can make it through."

	^ true
]

TClassAndTraitDescription >> addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor
[
	| priorMethodOrNil oldProtocol newProtocol |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [ nil ].
	self addSelectorSilently: selector withMethod: compiledMethod.
	oldProtocol := self organization categoryOfElement: selector.
	SystemAnnouncer uniqueInstance suspendAllWhile: [ self organization classify: selector under: category ].
	newProtocol := self organization categoryOfElement: selector.
	priorMethodOrNil isNil
		ifTrue: [ SystemAnnouncer uniqueInstance
				methodAdded: compiledMethod
				selector: selector
				inProtocol: category
				class: self
				requestor: requestor ]
		ifFalse: [ SystemAnnouncer uniqueInstance
				methodChangedFrom: priorMethodOrNil
				to: compiledMethod
				selector: selector
				inClass: self
				oldProtocol: oldProtocol
				newProtocol: newProtocol
				requestor: requestor ]
]

TClassAndTraitDescription >> addSelector: selector withMethod: compiledMethod notifying: requestor
[
	| priorMethodOrNil |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [ nil ].
	self addSelectorSilently: selector withMethod: compiledMethod.
	priorMethodOrNil isNil
		ifTrue: [ SystemAnnouncer uniqueInstance
				methodAdded: compiledMethod
				selector: selector
				inClass: self
				requestor: requestor ]
		ifFalse: [ SystemAnnouncer uniqueInstance
				methodChangedFrom: priorMethodOrNil
				to: compiledMethod
				selector: selector
				inClass: self
				requestor: requestor ]
]

TClassAndTraitDescription >> addSelectorSilently: selector withMethod: compiledMethod
[
	super addSelectorSilently: selector withMethod: compiledMethod.
	self instanceSide noteAddedSelector: selector meta: self isMeta
]

TClassAndTraitDescription >> allMethodsInCategory: aName
[
	self explicitRequirement
]

TClassAndTraitDescription >> applyChangesOfNewTraitCompositionReplacing: oldComposition
[
	| changedSelectors oldMethodDict |
	oldMethodDict := self methodDict copy.
	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.
	self noteRecategorizedSelectors: changedSelectors oldComposition: oldComposition.
	self noteChangesFrom: oldMethodDict.
	^ changedSelectors
]

TClassAndTraitDescription >> classComment: aString
[
	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."

	^ self classComment: aString stamp: '<historical>'
]

TClassAndTraitDescription >> classComment: aString stamp: aStamp
[
	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."

	| ptr header file oldCommentRemoteStr oldComment oldStamp |
	oldComment := self organization classComment.
	oldStamp := self organization commentStamp.
	(aString isKindOf: RemoteString)
		ifTrue: [ SystemAnnouncer uniqueInstance
				class: self
				oldComment: oldComment
				newComment: aString string
				oldStamp: oldStamp
				newStamp: aStamp.
			^ self organization classComment: aString stamp: aStamp ].
	oldCommentRemoteStr := self organization commentRemoteStr.
	aString size = 0 & oldCommentRemoteStr isNil
		ifTrue: [ ^ self organization classComment: nil ].	"never had a class comment, no need to write empty string out"
	ptr := oldCommentRemoteStr ifNil: [ 0 ] ifNotNil: [ oldCommentRemoteStr sourcePointer ].
	SourceFiles
		ifNotNil: [ (file := SourceFiles at: 2)
				ifNotNil: [ file
						setToEnd;
						cr;
						nextPut: $!.	"directly"	"Should be saying (file command: 'H3') for HTML, but ignoring it here"
					header := String
						streamContents: [ :strm | strm
								nextPutAll: self name;
								nextPutAll: ' commentStamp: '.
							aStamp storeOn: strm.
							strm
								nextPutAll: ' prior: ';
								nextPutAll: ptr printString ].
					file nextChunkPut: header ] ].
	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.
	SystemAnnouncer uniqueInstance
		class: self
		oldComment: oldComment
		newComment: aString
		oldStamp: oldStamp
		newStamp: aStamp
]

TClassAndTraitDescription >> comment
[
	"Answer the receiver's comment. (If missing, supply a template) "

	| aString |
	aString := self instanceSide organization classComment.
	aString isEmpty
		ifFalse: [ ^ aString ].
	^ self classCommentBlank
]

TClassAndTraitDescription >> comment: aStringOrText
[
	"Set the receiver's comment to be the argument, aStringOrText."

	self instanceSide classComment: aStringOrText
]

TClassAndTraitDescription >> comment: aStringOrText stamp: aStamp
[
	"Set the receiver's comment to be the argument, aStringOrText."

	self instanceSide classComment: aStringOrText stamp: aStamp
]

TClassAndTraitDescription >> commentStamp: changeStamp
[
	self organization commentStamp: changeStamp.
	^ self commentStamp: changeStamp prior: 0
]

TClassAndTraitDescription >> commentStamp: changeStamp prior: indexAndOffset
[
	"Prior source link ignored when filing in."

	^ ClassCommentReader new setClass: self category: #Comment changeStamp: changeStamp
]

TClassAndTraitDescription >> compile: code classified: heading
[
	"Compile the argument, code, as source code in the context of the 
	receiver and install the result in the receiver's method dictionary under 
	the classification indicated by the second argument, heading. nil is to be 
	notified if an error occurs. The argument code is either a string or an 
	object that converts to a string or a PositionableStream on an object that 
	converts to a string."

	^ self compile: code classified: heading notifying: nil
]

TClassAndTraitDescription >> compile: text classified: category notifying: requestor
[
	| stamp |
	stamp := self acceptsLoggingOfCompilation
		ifTrue: [ Author changeStamp ]
		ifFalse: [ nil ].
	^ self
		compile: text
		classified: category
		withStamp: stamp
		notifying: requestor
]

TClassAndTraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor
[
	^ self
		compile: text
		classified: category
		withStamp: changeStamp
		notifying: requestor
		logSource: self acceptsLoggingOfCompilation
]

TClassAndTraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
	| methodAndNode |
	methodAndNode := self
		compile: text asString
		classified: category
		notifying: requestor
		trailer: self defaultMethodTrailer
		ifFail: [ ^ nil ].
	logSource
		ifTrue: [ self
				logMethodSource: methodAndNode node sourceCode
				forMethodWithNode: methodAndNode
				inCategory: category
				withStamp: changeStamp
				notifying: requestor ].
	self
		addAndClassifySelector: methodAndNode selector
		withMethod: methodAndNode method
		inProtocol: category
		notifying: requestor.
	self instanceSide noteCompilationOf: methodAndNode selector meta: self isClassSide.
	^ methodAndNode selector
]

TClassAndTraitDescription >> compile: code notifying: requestor
[
	"Refer to the comment in Behavior|compile:notifying:."

	^ self compile: code classified: ClassOrganizer default notifying: requestor
]

TClassAndTraitDescription >> compileSilently: code
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."

	^ self compileSilently: code classified: '' notifying: nil
]

TClassAndTraitDescription >> compileSilently: code classified: category
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."

	^ self compileSilently: code classified: category notifying: nil
]

TClassAndTraitDescription >> compileSilently: code classified: category notifying: requestor
[
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."

	^ SystemAnnouncer uniqueInstance suspendAllWhile: [ self compile: code classified: category notifying: requestor ]
]

TClassAndTraitDescription >> copy: sel from: class
[
	"Install the method associated with the first argument, sel, a message 
	selector, found in the method dictionary of the second argument, class, 
	as one of the receiver's methods. Classify the message under -As yet not 
	classified-."

	self copy: sel from: class classified: nil
]

TClassAndTraitDescription >> copy: sel from: class classified: cat
[
	"Install the method associated with the first arugment, sel, a message 
	selector, found in the method dictionary of the second argument, class, 
	as one of the receiver's methods. Classify the message under the third 
	argument, cat."

	| code category |
	"Useful when modifying an existing class"
	code := class sourceCodeAt: sel.
	code
		ifNotNil: [ cat ifNil: [ category := class organization categoryOfElement: sel ] ifNotNil: [ category := cat ].
			(self includesLocalSelector: sel)
				ifTrue: [ code asString = (self sourceCodeAt: sel) asString
						ifFalse: [ self error: self name , ' ' , sel , ' will be redefined if you proceed.' ] ].
			self compile: code classified: category ]
]

TClassAndTraitDescription >> copyAll: selArray from: class
[
	"Install all the methods found in the method dictionary of the second 
	argument, class, as the receiver's methods. Classify the messages under 
	-As yet not classified-."

	self copyAll: selArray from: class classified: nil
]

TClassAndTraitDescription >> copyAll: selArray from: class classified: cat
[
	"Install all the methods found in the method dictionary of the second 
	argument, class, as the receiver's methods. Classify the messages under 
	the third argument, cat."

	selArray do: [ :s | (class includesLocalSelector: s)
				ifTrue: [ self copy: s from: class classified: cat ] ]
]

TClassAndTraitDescription >> copyAllCategoriesFrom: aClass
[
	"Specify that the categories of messages for the receiver include all of 
	those found in the class, aClass. Install each of the messages found in 
	these categories into the method dictionary of the receiver, classified 
	under the appropriate categories."

	aClass organization categories do: [ :cat | self copyCategory: cat from: aClass ]
]

TClassAndTraitDescription >> copyCategory: cat from: class
[
	"Specify that one of the categories of messages for the receiver is cat, as 
	found in the class, class. Copy each message found in this category."

	self copyCategory: cat from: class classified: cat
]

TClassAndTraitDescription >> copyCategory: cat from: aClass classified: newCat
[
	"Specify that one of the categories of messages for the receiver is the 
	third argument, newCat. Copy each message found in the category cat in 
	class aClass into this new category."

	self copyAll: (aClass organization listAtCategoryNamed: cat) from: aClass classified: newCat
]

TClassAndTraitDescription >> copyMethodDictionaryFrom: donorClass
[
	"Copy the method dictionary of the donor class over to the receiver"

	self methodDict: donorClass copyOfMethodDictionary.
	self organization: donorClass organization deepCopy
]

TClassAndTraitDescription >> correspondingForTest
[
	"Return the unit test that correspond to me. If it does not exist, it returns myself. 
	 Return the tested class if sent to a class"

	| className |
	className := (self inheritsFrom: TestCase)
		ifTrue: [ self name copyReplaceAll: 'Test' with: '' ]
		ifFalse: [ self name , 'Test' ].
	^ Smalltalk at: className asSymbol ifAbsent: [ self ]
]

TClassAndTraitDescription >> definition
[
	"Answer a String that defines the receiver"

	^ String
		streamContents: [ :stream | stream nextPutAll: self class name.
			stream
				nextPutAll: ' named: ';
				store: self name.
			stream
				cr;
				tab;
				nextPutAll: 'uses: ';
				nextPutAll: self traitCompositionString.
			stream
				cr;
				tab;
				nextPutAll: 'category: ';
				store: self category asString ]
]

TClassAndTraitDescription >> doneCompiling
[
	"A ClassBuilder has finished the compilation of the receiver.
	This message is a notification for a class that needs to do some
	cleanup / reinitialization after it has been recompiled."

	
]

TClassAndTraitDescription >> duringTestCompileSilently: code
[
	^ Author
		useAuthor: 'TestsAuthor'
		during: [ [ self
				compile: code
				classified: ''
				withStamp: nil
				notifying: nil
				logSource: true ]
				fuelValueWithoutNotifications ]
]

TClassAndTraitDescription >> duringTestCompileSilently: code classified: aCategory
[
	^ Author
		useAuthor: 'TestsAuthor'
		during: [ SystemAnnouncer uniqueInstance
				suspendAllWhile: [ self
						compile: code
						classified: aCategory
						withStamp: nil
						notifying: nil
						logSource: true ] ]
]

TClassAndTraitDescription >> errorCategoryName
[
	self error: 'Category name must be a String'
]

TClassAndTraitDescription >> fileOutCategory: catName
[
	| internalStream |
	internalStream := (String new: 1000) writeStream.
	internalStream
		header;
		timeStamp.
	self
		fileOutCategory: catName
		on: internalStream
		moveSource: false
		toFile: 0.
	internalStream trailer.
	^ FileStream writeSourceCodeFrom: internalStream baseName: self name , '-' , catName isSt: true
]

TClassAndTraitDescription >> fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the receiver's category, aString, onto aFileStream. If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.sources file, and should only write one preamble per method category."

	| selectors |
	aFileStream cr.
	selectors := self selectorsToFileOutCategory: aSymbol.	"Overridden to preserve author stamps in sources file regardless"
	selectors
		do: [ :sel | self
				printMethodChunk: sel
				withPreamble: true
				on: aFileStream
				moveSource: moveSource
				toFile: fileIndex ].
	^ self
]

TClassAndTraitDescription >> fileOutChangedMessages: aSet on: aFileStream
[
	"File a description of the messages of the receiver that have been 
	changed (i.e., are entered into the argument, aSet) onto aFileStream."

	self
		fileOutChangedMessages: aSet
		on: aFileStream
		moveSource: false
		toFile: 0
]

TClassAndTraitDescription >> fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the messages of this class that have been 
	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.changes file, and should only write a preamble for every method."

	| org |
	(org := self organization) categories
		do: [ :cat | | sels |
			sels := (org listAtCategoryNamed: cat) select: [ :sel | aSet includes: sel ].
			sels
				do: [ :sel | self
						printMethodChunk: sel
						withPreamble: true
						on: aFileStream
						moveSource: moveSource
						toFile: fileIndex ] ]
]

TClassAndTraitDescription >> fileOutMethod: selector
[
	"Write source code of a single method on a file.  Make up a name for the file."

	| internalStream |
	internalStream := (String new: 1000) writeStream.
	self fileOutMethod: selector on: internalStream.
	FileStream
		writeSourceCodeFrom: internalStream
		baseName: self name , '-' , (selector copyReplaceAll: ':' with: '')
		isSt: true
]

TClassAndTraitDescription >> fileOutMethod: selector on: aStream
[
	selector == #Comment
		ifTrue: [ ^ self inform: 'Sorry, cannot file out class comment in isolation.' ].
	(self includesSelector: selector)
		ifFalse: [ ^ self error: 'Selector ' , selector asString , ' not found' ].
	aStream
		header;
		timeStamp.
	self
		printMethodChunk: selector
		withPreamble: true
		on: aStream
		moveSource: false
		toFile: 0
]

TClassAndTraitDescription >> fileOutOn: aFileStream
[
	"File a description of the receiver on aFileStream."

	self fileOutOn: aFileStream moveSource: false toFile: 0
]

TClassAndTraitDescription >> fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex
[
	"File a description of the receiver on aFileStream. If the boolean 
	argument, moveSource, is true, then set the trailing bytes to the position 
	of aFileStream and to fileIndex in order to indicate where to find the 
	source code."

	aFileStream nextChunkPut: self definition.
	self organization
		putCommentOnFile: aFileStream
		numbered: fileIndex
		moveSource: moveSource
		forClass: self.
	self organization categories
		do: [ :heading | self
				fileOutCategory: heading
				on: aFileStream
				moveSource: moveSource
				toFile: fileIndex ]
]

TClassAndTraitDescription >> fileOutOrganizationOn: aFileStream
[
	"File a description of the receiver's organization on aFileStream."

	aFileStream
		cr;
		nextPut: $!.
	aFileStream
		nextChunkPut: self name , ' reorganize';
		cr.
	aFileStream
		nextChunkPut: self organization stringForFileOut;
		cr
]

TClassAndTraitDescription >> hasComment
[
	"return whether this class truly has a comment other than the default"

	| org |
	org := self instanceSide organization.
	^ org classComment isEmptyOrNil not
]

TClassAndTraitDescription >> isClassSide
[
	^ self == self classSide
]

TClassAndTraitDescription >> isInstanceSide
[
	^ self isClassSide not
]

TClassAndTraitDescription >> isMeta
[
	^ self isClassSide
]

TClassAndTraitDescription >> localMethods
[
	"returns the methods of classes including the ones of the traits that the class uses"

	^ self methods select: [ :each | self includesLocalSelector: each selector ]
]

TClassAndTraitDescription >> methods
[
	"returns the methods of classes including the ones of the traits that the class uses"

	^ self methodDict values
]

TClassAndTraitDescription >> methodsFor: categoryName
[
	"Answer a ClassCategoryReader for compiling the messages in the category, categoryName, of the receiver."

	^ ClassCategoryReader new setClass: self category: categoryName asSymbol	"(False methodsFor: 'logical operations') inspect"
]

TClassAndTraitDescription >> methodsFor: aString priorSource: sourcePosition inFile: fileIndex
[
	"Prior source pointer ignored when filing in."

	^ self methodsFor: aString
]

TClassAndTraitDescription >> methodsFor: categoryName stamp: changeStamp
[
	^ self methodsFor: categoryName stamp: (Author fixStamp: changeStamp) prior: 0
]

TClassAndTraitDescription >> methodsFor: categoryName stamp: changeStamp prior: indexAndOffset
[
	"Prior source link ignored when filing in."

	^ ClassCategoryReader new setClass: self category: categoryName asSymbol changeStamp: changeStamp	"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"
]

TClassAndTraitDescription >> methodsInCategory: aName
[
	"Answer a list of the methods of the receiver that are in category named aName"

	| aColl |
	aColl := Set
		withAll:
			(aName = ClassOrganizer allCategory
				ifTrue: [ self organization allMethodSelectors ]
				ifFalse: [ self organization listAtCategoryNamed: aName ]).
	^ aColl asArray sort
]

TClassAndTraitDescription >> moveChangesTo: newFile
[
	"Used in the process of condensing changes, this message requests that 
	the source code of all methods of the receiver that have been changed 
	should be moved to newFile."

	| changes |
	changes := self selectors select: [ :sel | (self compiledMethodAt: sel) fileIndex > 1 ].
	self
		fileOutChangedMessages: changes
		on: newFile
		moveSource: true
		toFile: 2
]

TClassAndTraitDescription >> noteAddedSelector: aSelector meta: isMeta
[
	"A hook allowing some classes to react to adding of certain selectors"

	
]

TClassAndTraitDescription >> noteCompilationOf: aSelector meta: isMeta
[
	"A hook allowing some classes to react to recompilation of certain selectors"

	
]

TClassAndTraitDescription >> noteRecategorizedSelector: aSymbol from: oldCategoryOrNil to: newCategoryOrNil
[
	| changedCategories |
	changedCategories := self
		updateOrganizationSelector: aSymbol
		oldCategory: oldCategoryOrNil
		newCategory: newCategoryOrNil.
	changedCategories
		do: [ :each | (self organization isEmptyCategoryNamed: each)
				ifTrue: [ self organization removeCategory: each ] ]
]

TClassAndTraitDescription >> noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition
[
	aCollection
		do: [ :each | | oldCategory newCategory |
			oldCategory := self organization categoryOfElement: each.
			newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.
			self noteRecategorizedSelector: each from: oldCategory to: newCategory ]
]

TClassAndTraitDescription >> notifyOfRecategorizedSelector: element from: oldCategory to: newCategory
[
	SystemAnnouncer uniqueInstance
		selector: element
		recategorizedFrom: oldCategory
		to: newCategory
		inClass: self
]

TClassAndTraitDescription >> printCategoryChunk: categoryName on: aFileStream
[
	^ self printCategoryChunk: categoryName withStamp: '' on: aFileStream
]

TClassAndTraitDescription >> printCategoryChunk: category on: aFileStream priorMethod: priorMethod
[
	^ self
		printCategoryChunk: category
		on: aFileStream
		withStamp: Author changeStamp
		priorMethod: priorMethod
]

TClassAndTraitDescription >> printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod
[
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

	"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream
		cr;
		nextPut: $!.
	aFileStream
		nextChunkPut:
			(String
				streamContents: [ :strm | strm
						nextPutAll: self name;
						nextPutAll: ' methodsFor: ';
						print: category asString.
					(changeStamp ~~ nil and: [ changeStamp size > 0 or: [ priorMethod ~~ nil ] ])
						ifTrue: [ strm
								nextPutAll: ' stamp: ';
								print: changeStamp ].
					priorMethod ~~ nil
						ifTrue: [ strm
								nextPutAll: ' prior: ';
								print: priorMethod sourcePointer ] ])
]

TClassAndTraitDescription >> printCategoryChunk: categoryName withStamp: changeStamp on: aFileStream
[
	^ self
		printCategoryChunk: categoryName
		on: aFileStream
		withStamp: changeStamp
		priorMethod: nil
]

TClassAndTraitDescription >> printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
[
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."

	| preamble method oldPos newPos sourceFile endPos |
	doPreamble
		ifTrue: [ preamble := self name , ' methodsFor: ' , (self organization categoryOfElement: selector) asString printString ]
		ifFalse: [ preamble := '' ].
	method := self methodDict
		at: selector
		ifAbsent: [ outStream
				nextPutAll: selector;
				cr.
			outStream
				tab;
				nextPutAll: '** ERROR!  THIS SCRIPT IS MISSING ** ' translated;
				cr;
				cr.
			outStream nextPutAll: '  '.
			^ outStream ].
	((method fileIndex = 0 or: [ (SourceFiles at: method fileIndex) == nil ]) or: [ (oldPos := method filePosition) = 0 ])
		ifTrue: [ "The source code is not accessible.  We must decompile..."
			preamble size > 0
				ifTrue: [ outStream
						cr;
						nextPut: $!;
						nextChunkPut: preamble;
						cr ].
			outStream nextChunkPut: method decompileString ]
		ifFalse: [ sourceFile := SourceFiles at: method fileIndex.
			preamble size > 0
				ifTrue: [ "Copy the preamble"
					outStream copyPreamble: preamble from: sourceFile at: oldPos ]
				ifFalse: [ sourceFile position: oldPos ].	"Copy the method chunk"
			newPos := outStream position.
			outStream copyMethodChunkFrom: sourceFile.
			sourceFile skipSeparators.	"The following chunk may have ]style["
			sourceFile peek == $]
				ifTrue: [ outStream
						cr;
						copyMethodChunkFrom: sourceFile ].
			moveSource
				ifTrue: [ "Set the new method source pointer"
					endPos := outStream position.
					method setSourcePosition: newPos inFile: fileIndex ] ].
	preamble size > 0
		ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream cr
]

TClassAndTraitDescription >> printOn: aStream
[
	aStream nextPutAll: self name
]

TClassAndTraitDescription >> putClassCommentToCondensedChangesFile: aFileStream
[
	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."

	| header aStamp aCommentRemoteStr |
	self isMeta
		ifTrue: [ ^ self ].	"bulletproofing only"
	((aCommentRemoteStr := self organization commentRemoteStr) isNil or: [ aCommentRemoteStr sourceFileNumber = 1 ])
		ifTrue: [ ^ self ].
	aFileStream
		cr;
		nextPut: $!.
	header := String
		streamContents: [ :strm | strm
				nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
			(aStamp := self organization commentStamp ifNil: [ '<historical>' ]) storeOn: strm.
			strm nextPutAll: ' prior: 0' ].
	aFileStream nextChunkPut: header.
	aFileStream cr.
	self organization
		classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream)
		stamp: aStamp
]

TClassAndTraitDescription >> reformatAll
[
	"Reformat all methods in this class.
	Leaves old code accessible to version browsing"

	self selectorsDo: [ :sel | self reformatMethodAt: sel ]
]

TClassAndTraitDescription >> reformatMethodAt: selector
[
	| newCodeString method |
	newCodeString := self prettyPrinterClass format: (self sourceCodeAt: selector) in: self notifying: nil.
	method := self compiledMethodAt: selector.
	method
		putSource: newCodeString
		fromParseNode: nil
		class: self
		category: (self organization categoryOfElement: selector)
		inFile: 2
		priorMethod: method
]

TClassAndTraitDescription >> removeCategory: aString
[
	"Remove each of the messages categorized under aString in the method 
	dictionary of the receiver. Then remove the category aString."

	| categoryName |
	categoryName := aString asSymbol.
	(self organization listAtCategoryNamed: categoryName) do: [ :sel | self removeSelector: sel ].
	self organization removeCategory: categoryName
]

TClassAndTraitDescription >> removeSelector: selector
[
	"Remove the message whose selector is given from the method 
	dictionary of the receiver, if it is there. Answer nil otherwise."

	| priorMethod priorProtocol origin |
	priorMethod := self compiledMethodAt: selector ifAbsent: [ ^ nil ].
	origin := priorMethod origin.
	priorProtocol := self whichCategoryIncludesSelector: selector.
	super removeSelector: selector.
	SystemAnnouncer uniqueInstance
		suspendAllWhile: [ self updateOrganizationSelector: selector oldCategory: priorProtocol newCategory: nil ].
	SystemAnnouncer uniqueInstance
		methodRemoved: priorMethod
		selector: selector
		inProtocol: priorProtocol
		class: self
		origin: origin
]

TClassAndTraitDescription >> reorganize
[
	"During fileIn, !Rectangle reorganize! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"

	^ self organization
]

TClassAndTraitDescription >> selectorsToFileOutCategory: aSymbol
[
	^ aSymbol asString = ClassOrganizer allCategory
		ifTrue: [ self organization allMethodSelectors ]
		ifFalse: [ self organization listAtCategoryNamed: aSymbol ]
]

TClassAndTraitDescription >> storeOn: aStream
[
	"Classes and Metaclasses have global names."

	aStream nextPutAll: self name
]

TClassAndTraitDescription >> uncategorizedMethods
[
	^ self methodsInCategory: ClassOrganizer default
]

TClassAndTraitDescription >> updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil
[
	| changedCategories composition |
	changedCategories := IdentitySet new.
	composition := self hasTraitComposition
		ifTrue: [ self traitComposition ]
		ifFalse: [ TraitComposition new ].
	(composition methodDescriptionsForSelector: aSymbol)
		do: [ :each | | effectiveCategory sel currentCategory |
			sel := each selector.
			(self includesLocalSelector: sel)
				ifFalse: [ currentCategory := self organization categoryOfElement: sel.
					effectiveCategory := each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.
					effectiveCategory isNil
						ifTrue: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
							self organization removeElement: sel ]
						ifFalse: [ ((currentCategory isNil or: [ currentCategory == ClassOrganizer ambiguous or: [ currentCategory == oldCategoryOrNil ] ])
								and: [ currentCategory ~~ effectiveCategory ])
								ifTrue: [ currentCategory ifNotNil: [ changedCategories add: currentCategory ].
									self organization classify: sel under: effectiveCategory suppressIfDefault: false ] ] ] ].
	^ changedCategories
]

TClassAndTraitDescription >> wantsChangeSetLogging
[
	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism."

	^ true
]

TClassAndTraitDescription >> wantsRecompilationProgressReported
[
	"Answer whether the receiver would like progress of its recompilation reported interactively to the user."

	^ true
]

TClassAndTraitDescription >> whichCategoryIncludesSelector: aSelector
[
	"Answer the category of the argument, aSelector, in the organization of 
	the receiver, or answer nil if the receiver does not inlcude this selector."

	(self includesSelector: aSelector)
		ifTrue: [ ^ self organization categoryOfElement: aSelector ]
		ifFalse: [ ^ nil ]
]

TClassAndTraitDescription >> zapOrganization
[
	"Remove the organization of this class by message categories.
	This is typically done to save space in small systems.  Classes and methods
	created or filed in subsequently will, nonetheless, be organized"

	self organization: nil.
	self isClassSide
		ifFalse: [ self classSide zapOrganization ]
]

