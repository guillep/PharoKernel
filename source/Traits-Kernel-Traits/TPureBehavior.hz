Trait named: #TPureBehavior
	package: #'Traits-Kernel-Traits'.TPureBehavior >> >> selector
[
	"Answer the compiled method associated with the argument, selector (a 
	Symbol), a message selector in the receiver's method dictionary. If the 
	selector is not in the dictionary, create an error notification."

	^ self compiledMethodAt: selector
]

TPureBehavior >> addExclusionOf: aSymbol to: aTrait
[
	self setTraitComposition: (self traitComposition copyWithExclusionOf: aSymbol to: aTrait)
]

TPureBehavior >> addSelector: selector withMethod: compiledMethod
[
	^ self addSelector: selector withMethod: compiledMethod notifying: nil
]

TPureBehavior >> addSelector: selector withMethod: compiledMethod notifying: requestor
[
	^ self addSelectorSilently: selector withMethod: compiledMethod
]

TPureBehavior >> addSelectorSilently: selector withMethod: compiledMethod
[
	self methodDictAddSelectorSilently: selector withMethod: compiledMethod.
	self registerLocalSelector: selector
]

TPureBehavior >> addToComposition: aTrait
[
	self setTraitComposition: (self traitComposition copyTraitExpression
				add: aTrait;
				yourself)
]

TPureBehavior >> addTraitSelector: aSymbol withMethod: aCompiledMethod
[
	"Add aMethod with selector aSymbol to my
	methodDict. aMethod must not be defined locally."

	| source methodAndNode |
	[ (self includesLocalSelector: aSymbol) not ] assert.
	self ensureLocalSelectors.
	source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.
	methodAndNode := self
		compile: source
		classified: aCompiledMethod category
		notifying: nil
		trailer: self defaultMethodTrailer
		ifFail: [ ^ nil ].
	methodAndNode method
		putSource: source
		fromParseNode: methodAndNode node
		inFile: 2
		withPreamble: [ :f | f
				cr;
				nextPut: $!;
				nextChunkPut: 'Trait method';
				cr ].
	self basicAddSelector: aSymbol withMethod: methodAndNode method
]

TPureBehavior >> allSelectors
[
	self explicitRequirement
]

TPureBehavior >> applyChangesOfNewTraitCompositionReplacing: oldComposition
[
	| changedSelectors |
	changedSelectors := self traitComposition changedSelectorsComparedTo: oldComposition.
	changedSelectors isEmpty
		ifFalse: [ self noteChangedSelectors: changedSelectors ].
	self traitComposition isEmpty
		ifTrue: [ self purgeLocalSelectors ].
	^ changedSelectors
]

TPureBehavior >> basicAddSelector: selector withMethod: compiledMethod
[
	"Add the message selector with the corresponding compiled method to the 
	receiver's method dictionary.
	Do this without sending system change notifications"

	| oldMethodOrNil |
	oldMethodOrNil := self lookupSelector: selector.
	self methodDict at: selector put: compiledMethod.
	compiledMethod methodClass: self.
	compiledMethod selector: selector.	"Now flush the method cache, when we add a method"
	oldMethodOrNil ifNotNil: [ oldMethodOrNil flushCache ]
]

TPureBehavior >> basicLocalSelectors
[
	self explicitRequirement
]

TPureBehavior >> basicLocalSelectors: aSetOrNil
[
	self explicitRequirement
]

TPureBehavior >> basicRemoveSelector: selector
[
	"Assuming that the argument, selector (a Symbol), is a message selector 
	in my method dictionary, remove it and its method."

	| oldMethod |
	oldMethod := self methodDict at: selector ifAbsent: [ ^ self ].
	self methodDict removeKey: selector.	"Now flush the method cache"
	oldMethod flushCache
]

TPureBehavior >> canUnderstand: selector
[
	"Answer whether the receiver can respond to the message whose selector 
	is the argument."

	^ self classAndMethodFor: selector do: [ :c :m | m isProvided ] ifAbsent: [ false ]
]

TPureBehavior >> canZapMethodDictionary
[
	"Return true if it is safe to zap the method dictionary on #obsolete"

	^ true
]

TPureBehavior >> changeRecordsAt: selector
[
	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."

	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"

	^ ChangeSet
		scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [ ^ nil ])
		class: self
		meta: self isMeta
		category: (self whichCategoryIncludesSelector: selector)
		selector: selector
]

TPureBehavior >> classAndMethodFor: aSymbol do: binaryBlock ifAbsent: absentBlock
[
	"Looks up the selector aSymbol in this class/trait. If it is found, binaryBlock is evaluated
	with this class/trait and the associated method. Otherwise absentBlock is evaluated.
	Note that this implementation is very simple because PureBehavior does not know
	about inheritance (cf. implementation in Behavior)"

	^ binaryBlock value: self value: (self compiledMethodAt: aSymbol ifAbsent: [ ^ absentBlock value ])
]

TPureBehavior >> compiledMethodAt: selector
[
	"Answer the compiled method associated with the argument, selector (a 
	Symbol), a message selector in the receiver's method dictionary. If the 
	selector is not in the dictionary, create an error notification."

	^ self methodDict at: selector
]

TPureBehavior >> compiledMethodAt: selector ifAbsent: aBlock
[
	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"

	^ self methodDict at: selector ifAbsent: [ aBlock value ]
]

TPureBehavior >> compress
[
	"Compact the method dictionary of the receiver."

	self methodDict rehash
]

TPureBehavior >> copyOfMethodDictionary
[
	"Return a copy of the receiver's method dictionary"

	^ self methodDict copy
]

TPureBehavior >> deepCopy
[
	"Classes should only be shallowCopied or made anew."

	^ self shallowCopy
]

TPureBehavior >> deregisterLocalSelector: aSymbol
[
	self basicLocalSelectors notNil
		ifTrue: [ self basicLocalSelectors remove: aSymbol ifAbsent: [  ] ]
]

TPureBehavior >> emptyMethodDictionary
[
	^ MethodDictionary new
]

TPureBehavior >> ensureLocalSelectors
[
	"Ensures that the instance variable localSelectors is effectively used to maintain
	the set of local selectors.
	This method must be called before any non-local selectors are added to the
	method dictionary!"

	self basicLocalSelectors isNil
		ifTrue: [ self basicLocalSelectors: self selectors asSet ]
]

TPureBehavior >> environment
[
	"Return the environment in which the receiver is visible"

	^ Smalltalk globals
]

TPureBehavior >> firstCommentAt: selector
[
	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."

	| someComments |
	someComments := self commentsAt: selector.
	^ someComments isEmpty
		ifTrue: [ '' ]
		ifFalse: [ someComments first ]	"Behavior firstCommentAt: #firstCommentAt:"
]

TPureBehavior >> firstPrecodeCommentFor: selector
[
	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"

	| parser source tree |
	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"
	(#(#Comment #Definition #Hierarchy) includes: selector)
		ifTrue: [ "Not really a selector"
			^ nil ].
	source := self sourceCodeAt: selector asSymbol ifAbsent: [ ^ nil ].
	parser := self parserClass new.
	tree := parser
		parse: source readStream
		class: self
		noPattern: false
		context: nil
		notifying: nil
		ifFail: [ ^ nil ].
	^ (tree comment ifNil: [ ^ nil ]) first
]

TPureBehavior >> flattenDown: aTrait
[
	| selectors |
	[ self hasTraitComposition and: [ self traitComposition allTraits includes: aTrait ] ] assert.
	selectors := (self traitComposition transformationOfTrait: aTrait) selectors.
	self basicLocalSelectors: self basicLocalSelectors , selectors.
	self removeFromComposition: aTrait
]

TPureBehavior >> flattenDownAllTraits
[
	self traitComposition allTraits do: [ :each | self flattenDown: each ].
	[ self traitComposition isEmpty ] assert.
	self traitComposition: nil
]

TPureBehavior >> formalHeaderPartsFor: aSelector
[
	"popeye"

	"olive oil"

	"RELAX!  The warning you may have just seen about possibly having a bad source file does not apply here, because this method *intends* to have its source code start with a comment.
	This method returns a collection giving the parts in the formal declaration for aSelector.  This parse is in support of schemes in which adjutant properties of a method can be declared via special comments secreted in the formal header
	The result will have
     	3 elements for a simple, argumentless selector.
		5 elements for a single-argument selector
		9 elements for a two-argument selector
		13 elements for a three-argument, selector
		etc...

	The syntactic elements are:

		1		comment preceding initial selector fragment

		2		first selector fragment
		3		comment following first selector fragment  (nil if selector has no arguments)

        ----------------------  (ends here for, e.g., #copy)

		4		first formal argument
		5		comment following first formal argument (nil if selector has only one argument)

        ----------------------  (ends here for, e.g., #copyFrom:)

		6		second keyword
		7		comment following second keyword
		8		second formal argument
		9		comment following second formal argument (nil if selector has only two arguments)

         ----------------------  (ends here for, e.g., #copyFrom:to:)

	Any nil element signifies an absent comment.
	NOTE: The comment following the final formal argument is *not* successfully retrieved by this method in its current form, though it can be obtained, if needed, by other means (e.g. calling #firstPrecodeCommentFor:).  Thus, the *final* element in the structure returned by this method is always going to be nil."

	^ Scanner new scanMessageParts: (self methodHeaderFor: aSelector)	"	Behavior class formalHeaderPartsFor: #formalHeaderPartsFor:"
]

TPureBehavior >> formalParametersAt: aSelector
[
	"Return the names of the arguments used in this method."

	| source |
	source := self sourceCodeAt: aSelector ifAbsent: [ ^ #() ].	"for now"
	^ self parserClass new parseParameterNames: source
]

TPureBehavior >> hasMethods
[
	"Answer whether the receiver has any methods in its method dictionary."

	^ self methodDict notEmpty
]

TPureBehavior >> hasTraitComposition
[
	self explicitRequirement
]

TPureBehavior >> includesBehavior: aBehavior
[
	^ self == aBehavior
]

TPureBehavior >> includesLocalSelector: aSymbol
[
	^ self basicLocalSelectors isNil
		ifTrue: [ self includesSelector: aSymbol ]
		ifFalse: [ self localSelectors includes: aSymbol ]
]

TPureBehavior >> includesSelector: aSymbol
[
	"Answer whether the message whose selector is the argument is in the 
	method dictionary of the receiver's class."

	^ self methodDict includesKey: aSymbol
]

TPureBehavior >> isAliasSelector: aSymbol
[
	"Return true if the selector aSymbol is an alias defined
	in my or in another composition somewhere deeper in 
	the tree of traits compositions."

	^ (self includesLocalSelector: aSymbol) not
		and: [ self hasTraitComposition and: [ self traitComposition isAliasSelector: aSymbol ] ]
]

TPureBehavior >> isDisabledSelector: selector
[
	^ self classAndMethodFor: selector do: [ :c :m | m isDisabled ] ifAbsent: [ false ]
]

TPureBehavior >> isLocalAliasSelector: aSymbol
[
	"Return true if the selector aSymbol is an alias defined
	in my trait composition."

	^ (self includesLocalSelector: aSymbol) not
		and: [ self hasTraitComposition and: [ self traitComposition isLocalAliasSelector: aSymbol ] ]
]

TPureBehavior >> literalScannedAs: scannedLiteral notifying: requestor
[
	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).
	If scannedLiteral is not an association, answer it.
	Else, if it is of the form:
		nil->#NameOfMetaclass
	answer nil->theMetaclass, if any has that name, else report an error.
	Else, if it is of the form:
		#NameOfGlobalVariable->anythiEng
	answer the global, class, or pool association with that nameE, if any, else
	add it to Undeclared a answer the new Association."

	| key value |
	scannedLiteral isVariableBinding
		ifFalse: [ ^ scannedLiteral ].
	key := scannedLiteral key.
	value := scannedLiteral value.
	key isNil
		ifTrue: [ "###<metaclass soleInstance name>"
			(self bindingOf: value)
				ifNotNil: [ :assoc | (assoc value isKindOf: Behavior)
						ifTrue: [ ^ nil -> assoc value class ] ].
			requestor notify: 'No such metaclass'.
			^ false ].
	key isSymbol
		ifTrue: [ "##<global var name>"
			(self bindingOf: key) ifNotNil: [ :assoc | ^ assoc ].
			Undeclared at: key put: nil.
			^ Undeclared bindingOf: key ].
	requestor notify: '## must be followed by a non-local variable name'.
	^ false	"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"
]

TPureBehavior >> localSelectors
[
	"Return a set of selectors defined locally.
	The instance variable is lazily initialized. If it is nil then there
	are no non-local selectors"

	^ self basicLocalSelectors isNil
		ifTrue: [ self selectors asSet ]
		ifFalse: [ self basicLocalSelectors ]
]

TPureBehavior >> longPrintOn: aStream
[
	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  But, not useful for a class with a method dictionary."

	aStream
		nextPutAll: '<<too complex to show>>';
		cr
]

TPureBehavior >> lookupSelector: selector
[
	^ self explicitRequirement
]

TPureBehavior >> methodDict
[
	^ self explicitRequirement
]

TPureBehavior >> methodDict: aDictionary
[
	^ self explicitRequirement
]

TPureBehavior >> methodDictAddSelectorSilently: selector withMethod: compiledMethod
[
	self basicAddSelector: selector withMethod: compiledMethod
]

TPureBehavior >> methodDictionary
[
	"Convenience"

	^ self methodDict
]

TPureBehavior >> methodDictionary: aDictionary
[
	self methodDict: aDictionary
]

TPureBehavior >> methodHeaderFor: selector
[
	"Answer the string corresponding to the method header for the given selector"

	| sourceString parser |
	sourceString := self ultimateSourceCodeAt: selector ifAbsent: [ self standardMethodHeaderFor: selector ].
	(parser := self parserClass new) parseSelector: sourceString.
	^ sourceString asString copyFrom: 1 to: (parser endOfLastToken min: sourceString size)	"Behavior methodHeaderFor: #methodHeaderFor: "
]

TPureBehavior >> methodsDo: aBlock
[
	"Evaluate aBlock for all the compiled methods in my method dictionary."

	^ self methodDict valuesDo: aBlock
]

TPureBehavior >> name
[
	^ self explicitRequirement
]

TPureBehavior >> noteChangedSelectors: aCollection
[
	"Start update of my methodDict (after changes to traits in traitComposition
	or after a local method was removed from my methodDict). The argument 
	is a collection of method selectors that may have been changed. Most of the time
	aCollection only holds one selector. But when there are aliases involved 
	there may be several method changes that have to be propagated to users."

	| affectedSelectors |
	affectedSelectors := IdentitySet new.
	aCollection do: [ :selector | affectedSelectors addAll: (self updateMethodDictionarySelector: selector) ].
	self notifyUsersOfChangedSelectors: affectedSelectors.
	^ affectedSelectors
]

TPureBehavior >> notifyUsersOfChangedSelector: aSelector
[
	self notifyUsersOfChangedSelectors: (Array with: aSelector)
]

TPureBehavior >> notifyUsersOfChangedSelectors: aCollection
[
	
]

TPureBehavior >> obsolete
[
	"Invalidate and recycle local methods,
	e.g., zap the method dictionary if can be done safely."

	self canZapMethodDictionary
		ifTrue: [ self methodDict: self emptyMethodDictionary ].
	self hasTraitComposition
		ifTrue: [ self traitComposition traits do: [ :each | each removeUser: self ] ]
]

TPureBehavior >> postCopy
[
	super postCopy.
	self methodDictionary: self copyOfMethodDictionary
]

TPureBehavior >> purgeLocalSelectors
[
	self basicLocalSelectors: nil
]

TPureBehavior >> registerLocalSelector: aSymbol
[
	self basicLocalSelectors notNil
		ifTrue: [ self basicLocalSelectors add: aSymbol ]
]

TPureBehavior >> removeAlias: aSymbol of: aTrait
[
	self setTraitComposition: (self traitComposition copyWithoutAlias: aSymbol of: aTrait)
]

TPureBehavior >> removeFromComposition: aTrait
[
	self setTraitComposition: (self traitComposition copyTraitExpression removeFromComposition: aTrait)
]

TPureBehavior >> removeSelector: aSelector
[
	"Assuming that the argument, selector (a Symbol), is a message selector 
	in my method dictionary, remove it and its method.
	
	If the method to remove will be replaced by a method from my trait composition,
	the current method does not have to be removed because we mark it as non-local.
	If it is not identical to the actual method from the trait it will be replaced automatically
	by #noteChangedSelectors:.
	
	This is useful to avoid bootstrapping problems when moving methods to a trait
	(e.g., from TPureBehavior to TMethodDictionaryBehavior). Manual moving (implementing
	the method in the trait and then remove it from the class) does not work if the methods
	themselves are used for this process (such as compiledMethodAt:, includesLocalSelector: or
	addTraitSelector:withMethod:)"

	| changeFromLocalToTraitMethod |
	changeFromLocalToTraitMethod := (self includesLocalSelector: aSelector)
		and: [ self hasTraitComposition and: [ self traitComposition includesMethod: aSelector ] ].
	changeFromLocalToTraitMethod
		ifFalse: [ self basicRemoveSelector: aSelector ]
		ifTrue: [ self ensureLocalSelectors ].
	self deregisterLocalSelector: aSelector.
	self noteChangedSelectors: (Array with: aSelector)
]

TPureBehavior >> removeSelectorSilently: selector
[
	"Remove selector without sending system change notifications"

	^ SystemAnnouncer uniqueInstance suspendAllWhile: [ self removeSelector: selector ]
]

TPureBehavior >> removeTraitSelector: aSymbol
[
	[ (self includesLocalSelector: aSymbol) not ] assert.
	self basicRemoveSelector: aSymbol
]

TPureBehavior >> selectors
[
	"Answer a Set of all the message selectors specified in the receiver's 
	method dictionary."

	^ self methodDict keys
]

TPureBehavior >> selectorsAndMethodsDo: selectorAndMethodBlock
[
	"Evaluate selectorAndMethodBlock with two arguments for each selector/method pair in my method dictionary."

	^ self methodDict keysAndValuesDo: selectorAndMethodBlock
]

TPureBehavior >> selectorsDo: selectorBlock
[
	"Evaluate selectorBlock for all the message selectors in my method dictionary."

	^ self methodDict keysDo: selectorBlock
]

TPureBehavior >> selectorsWithArgs: numberOfArgs
[
	"Return all selectors defined in this class that take this number of arguments.  Could use String.keywords.  Could see how compiler does this."

	| list |
	list := OrderedCollection new.
	self
		selectorsDo: [ :aSel | | num |
			num := aSel count: [ :char | char == $: ].
			num = 0
				ifTrue: [ aSel last isLetter
						ifFalse: [ num := 1 ] ].
			num = numberOfArgs
				ifTrue: [ list add: aSel ] ].
	^ list
]

TPureBehavior >> setTraitComposition: aTraitComposition
[
	| oldComposition |
	(self hasTraitComposition not and: [ aTraitComposition isEmpty ])
		ifTrue: [ ^ self ].
	aTraitComposition assertValidUser: self.
	oldComposition := self traitComposition.
	self traitComposition: aTraitComposition.
	self applyChangesOfNewTraitCompositionReplacing: oldComposition.
	oldComposition traits do: [ :each | each removeUser: self ].
	aTraitComposition traits do: [ :each | each addUser: self ]
]

TPureBehavior >> setTraitCompositionFrom: aTraitExpression
[
	^ self setTraitComposition: aTraitExpression asTraitComposition
]

TPureBehavior >> sourceCodeAt: selector
[
	^ (self methodDict at: selector) sourceCode
]

TPureBehavior >> sourceCodeAt: selector ifAbsent: aBlock
[
	^ (self methodDict at: selector ifAbsent: [ ^ aBlock value ]) sourceCode
]

TPureBehavior >> spaceUsed
[
	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."

	| space |
	space := 0.
	self
		methodsDo: [ :method | space := space + 16.	"dict and org'n space"
			space := space + (method size + 6).	"hdr + avg pad"
			method
				literalsDo: [ :lit | (lit isMemberOf: Array)
						ifTrue: [ space := space + ((lit size + 1) * 4) ].
					(lit isMemberOf: Float)
						ifTrue: [ space := space + 12 ].
					(lit isMemberOf: ByteString)
						ifTrue: [ space := space + (lit size + 6) ].
					(lit isMemberOf: LargeNegativeInteger)
						ifTrue: [ space := space + ((lit size + 1) * 4) ].
					(lit isMemberOf: LargePositiveInteger)
						ifTrue: [ space := space + ((lit size + 1) * 4) ] ] ].
	^ space
]

TPureBehavior >> standardMethodHeaderFor: aSelector
[
	| args |
	args := (1 to: aSelector numArgs) collect: [ :i | 'arg' , i printString ].
	args size = 0
		ifTrue: [ ^ aSelector asString ].
	args size = 1
		ifTrue: [ ^ aSelector , ' arg1' ].
	^ String
		streamContents: [ :s | (aSelector findTokens: ':')
				with: args
				do: [ :tok :arg | s
						nextPutAll: tok;
						nextPutAll: ': ';
						nextPutAll: arg;
						nextPutAll: ' ' ] ]
]

TPureBehavior >> storeLiteral: aCodeLiteral on: aStream
[
	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName
	 or ###MetaclassSoleInstanceName format if appropriate"

	| key value |
	aCodeLiteral isVariableBinding
		ifFalse: [ aCodeLiteral storeOn: aStream.
			^ self ].
	key := aCodeLiteral key.
	(key isNil and: [ (value := aCodeLiteral value) isMemberOf: Metaclass ])
		ifTrue: [ aStream
				nextPutAll: '###';
				nextPutAll: value soleInstance name.
			^ self ].
	(key isSymbol and: [ (self bindingOf: key) notNil ])
		ifTrue: [ aStream
				nextPutAll: '##';
				nextPutAll: key.
			^ self ].
	aCodeLiteral storeOn: aStream
]

TPureBehavior >> thoroughHasSelectorReferringTo: literal special: specialFlag byte: specialByte
[
	"Answer true if any of my methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	self
		methodsDo: [ :method | ((method hasLiteralThorough: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])
				ifTrue: [ ^ true ] ].
	^ false
]

TPureBehavior >> thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte
[
	"Answer a set of selectors whose methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	| selectors |
	selectors := IdentitySet new.
	self
		selectorsAndMethodsDo: [ :sel :method | ((method hasLiteralThorough: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])
				ifTrue: [ selectors add: sel ] ].
	^ selectors
]

TPureBehavior >> traitComposition
[
	"Return my trait composition. Manipulating the composition does not
	effect changes automatically. Use #setTraitComposition: to do this but
	note, that you have to make a copy of the old trait composition before
	changing it because only the difference between the new and the old
	composition is updated."

	^ self explicitRequirement
]

TPureBehavior >> traitComposition: aTraitComposition
[
	^ self explicitRequirement
]

TPureBehavior >> traitCompositionIncludes: aTrait
[
	^ self == aTrait or: [ self hasTraitComposition and: [ self traitComposition allTraits includes: aTrait ] ]
]

TPureBehavior >> traitCompositionString
[
	^ self hasTraitComposition
		ifTrue: [ self traitComposition asString ]
		ifFalse: [ '{}' ]
]

TPureBehavior >> traitOrClassOfSelector: aSymbol
[
	"Return the trait or the class which originally defines the method aSymbol
	or return self if locally defined or if it is a conflict marker method.
	This is primarly used by Debugger to determin the behavior in which a recompiled
	method should be put. If a conflict method is recompiled it should be put into
	the class, thus return self. Also see TraitComposition>>traitProvidingSelector:"

	((self includesLocalSelector: aSymbol) or: [ self hasTraitComposition not ])
		ifTrue: [ ^ self ].
	^ (self traitComposition traitProvidingSelector: aSymbol) ifNil: [ self ]
]

TPureBehavior >> traitTransformations
[
	^ self traitComposition transformations
]

TPureBehavior >> traits
[
	"Returns a collection of all traits used by the receiver"

	^ self traitComposition traits
]

TPureBehavior >> traitsProvidingSelector: aSymbol
[
	| result |
	result := OrderedCollection new.
	self hasTraitComposition
		ifFalse: [ ^ result ].
	(self traitComposition methodDescriptionsForSelector: aSymbol)
		do: [ :methodDescription | methodDescription selector = aSymbol
				ifTrue: [ result addAll: (methodDescription locatedMethods collect: [ :each | each methodClass ]) ] ].
	^ result
]

TPureBehavior >> ultimateSourceCodeAt: selector ifAbsent: aBlock
[
	"Return the source code at selector"

	^ self sourceCodeAt: selector ifAbsent: aBlock
]

TPureBehavior >> updateMethodDictionarySelector: aSymbol
[
	"A method with selector aSymbol in myself or my traitComposition has been changed.
	Do the appropriate update to my methodDict (remove or update method) and
	return all affected selectors of me so that my useres get notified."

	| modifiedSelectors descriptions oldProtocol |
	modifiedSelectors := IdentitySet new.
	descriptions := self traitComposition methodDescriptionsForSelector: aSymbol.
	descriptions
		do: [ :methodDescription | | effectiveMethod selector |
			selector := methodDescription selector.
			(self includesLocalSelector: selector)
				ifFalse: [ methodDescription isEmpty
						ifTrue: [ self removeTraitSelector: selector.
							modifiedSelectors add: selector ]
						ifFalse: [ effectiveMethod := methodDescription effectiveMethod.
							self addTraitSelector: selector withMethod: effectiveMethod.	"If the method was not categorized yet, we categorize it "
							oldProtocol := self organization categoryOfElement: selector.
							(oldProtocol isNil or: [ oldProtocol = ClassOrganizer default ])
								ifTrue: [ self organization classify: selector under: methodDescription effectiveMethodCategory ].
							modifiedSelectors add: selector ] ] ].
	^ modifiedSelectors
]

TPureBehavior >> whichSelectorsReferTo: literal
[
	"Answer a Set of selectors whose methods access the argument as a
literal."

	| special byte |
	special := Smalltalk hasSpecialSelector: literal ifTrueSetByte: [ :b | byte := b ].
	^ self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."
]

TPureBehavior >> whichSelectorsReferTo: literal special: specialFlag byte: specialByte
[
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |
	who := IdentitySet new.
	self
		selectorsAndMethodsDo: [ :sel :method | ((method hasLiteral: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])
				ifTrue: [ (literal isVariableBinding not or: [ method literals allButLast includes: literal ])
						ifTrue: [ who add: sel ] ] ].
	^ who
]

TPureBehavior >> withAllSubclassesDo: aBlock
[
	| temp |
	temp := self allSubclassesDo: aBlock.
	aBlock value: self
]

TPureBehavior >> withAllSuperclasses
[
	"Answer an OrderedCollection of the receiver and the receiver's 
	superclasses. The first element is the receiver, 
	followed by its superclass; the last element is Object."

	| temp |
	temp := self allSuperclasses.
	temp addFirst: self.
	^ temp
]

