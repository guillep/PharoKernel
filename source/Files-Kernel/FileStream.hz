FileStream
	superclass: #ReadWriteStream;
	instanceVariables: #(#rwmode );
	classVariables: #(#Stdin #Stdout #TheStdioHandles #StdioFiles #Stderr );
	package: #'Files-Kernel'.

FileStream >> asBinaryOrTextStream
[
	"I can switch between binary and text data"

	^ self
]

FileStream >> ascii
[
	"Set this file to ascii (text) mode."

	self subclassResponsibility
]

FileStream >> atEnd
[
	"Answer true if the current position is >= the end of file position."

	self subclassResponsibility
]

FileStream >> binary
[
	"Set this file to binary mode."

	self subclassResponsibility
]

FileStream >> close
[
	"Close this file."

	self subclassResponsibility
]

FileStream >> closed
[
	"Answer true if this file is closed."

	self subclassResponsibility
]

FileStream >> contents
[
	"Return the contents of the receiver. Do not close or otherwise touch the receiver. Return data in whatever mode the receiver is in (e.g., binary or text)."

	| s savePos |
	savePos := self position.
	self position: 0.
	s := self next: self size.
	self position: savePos.
	^ s
]

FileStream >> contentsOfEntireFile
[
	"Read all of the contents of the receiver."

	| s binary |
	self readOnly.
	binary := self isBinary.
	self reset.	"erases knowledge of whether it is binary"
	binary
		ifTrue: [ self binary ].
	s := self next: self size.
	self close.
	^ s
]

FileStream >> directoryEntry
[
	^ (self directory / self localName) entry
]

FileStream >> file
[
	"Answer the file for the page the receiver is streaming over."

	self subclassResponsibility
]

FileStream >> flush
[
	"When writing, flush the current buffer out to disk."

	self subclassResponsibility
]

FileStream >> localName
[
	^ self name asFileReference basename
]

FileStream >> longPrintOn: aStream
[
	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."

	
]

FileStream >> longPrintOn: aStream limitedTo: sizeLimit indent: indent
[
	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."

	aStream cr
]

FileStream >> mimeTypes
[
	^ self name asFileReference mimeTypes
]

FileStream >> name
[
	"Answer the name of the file for the page the receiver is streaming over."

	self subclassResponsibility
]

FileStream >> next
[
	(position >= readLimit and: [ self atEnd ])
		ifTrue: [ ^ nil ]
		ifFalse: [ ^ collection at: (position := position + 1) ]
]

FileStream >> next: anInteger
[
	| newCollection howManyRead increment |
	newCollection := self collectionSpecies new: anInteger.
	howManyRead := 0.
	[ howManyRead < anInteger ]
		whileTrue: [ self atEnd
				ifTrue: [ howManyRead + 1 to: anInteger do: [ :i | newCollection at: i put: self next ].
					^ newCollection ].
			increment := readLimit - position min: anInteger - howManyRead.
			newCollection
				replaceFrom: howManyRead + 1
				to: (howManyRead := howManyRead + increment)
				with: collection
				startingAt: position + 1.
			position := position + increment ].
	^ newCollection
]

FileStream >> nextPut: aByte
[
	"1/31/96 sw: subclassResponsibility"

	self subclassResponsibility
]

FileStream >> nextPutAll: aCollection
[
	"1/31/96 sw: made subclass responsibility"

	self subclassResponsibility
]

FileStream >> position
[
	"Answer the current character position in the file."

	self subclassResponsibility
]

FileStream >> position: pos
[
	"Set the current character position in the file to pos."

	self subclassResponsibility
]

FileStream >> printOn: aStream
[
	super printOn: aStream.
	aStream nextPutAll: ' on '.
	self file printOn: aStream
]

FileStream >> readOnly
[
	"Set this file's mode to read-only."

	self subclassResponsibility
]

FileStream >> readOnlyStream
[
	^ self readOnly
]

FileStream >> readWrite
[
	"Set this file's mode to read-write."

	self subclassResponsibility
]

FileStream >> reopen
[
	"Ensure that the receiver is open, re-open it if necessary."

	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."

	self subclassResponsibility
]

FileStream >> reset
[
	"Set the current character position to the beginning of the file."

	self subclassResponsibility
]

FileStream >> setToEnd
[
	"Set the current character position to the end of the File. The same as
	self position: self size."

	self subclassResponsibility
]

FileStream >> size
[
	"Answer the size of the file in characters."

	self subclassResponsibility
]

FileStream >> skip: n
[
	"Set the character position to n characters from the current position.
	Error if not enough characters left in the file."

	self subclassResponsibility
]

FileStream >> text
[
	"Set this file to text (ascii) mode."

	self ascii
]

FileStream >> truncate: pos
[
	"Truncate file to pos"

	self subclassResponsibility
]

FileStream class >> concreteStream
[
	"Who should we really direct class queries to?  "

	^ MultiByteFileStream
]

FileStream class >> convertCRtoLF: fileName
[
	"Convert the given file to LF line endings. Put the result in a file with the extention '.lf'"

	| in out c justPutCR |
	in := (self readOnlyFileNamed: fileName) binary.
	out := (self newFileNamed: fileName , '.lf') binary.
	justPutCR := false.
	[ in atEnd ]
		whileFalse: [ c := in next.
			c = 10
				ifTrue: [ out nextPut: 13.
					justPutCR := true ]
				ifFalse: [ (justPutCR and: [ c = 10 ])
						ifFalse: [ out nextPut: c ].
					justPutCR := false ] ].
	in close.
	out close
]

FileStream class >> detectFile: aBlock do: anotherBlock
[
	^ aBlock value ifNil: [ nil ] ifNotNil: [ :file | [ anotherBlock value: file ]
				ensure: [ file close ] ]
]

FileStream class >> fileIn: fullName
[
	"File in the entire contents of the file specified by the name provided"

	| ff fn |
	fullName ifNil: [ ^ Beeper beep ].
	fn := fullName asFileReference.
	fn := (Smalltalk hasClassNamed: #GZipReadStream)
		ifTrue: [ (Smalltalk classNamed: #GZipReadStream) uncompressedFileName: fn fullName ]
		ifFalse: [ fn fullName ].
	ff := self readOnlyFileNamed: fn.
	ff fileIn
]

FileStream class >> fileNamed: fileName
[
	^ self concreteStream fileNamed: (self fullName: fileName)
]

FileStream class >> fileNamed: fileName do: aBlock
[
	"Returns the result of aBlock."

	^ self detectFile: [ self fileNamed: fileName ] do: aBlock
]

FileStream class >> flushAndVoidStdioFiles
[
	StdioFiles
		ifNotNil: [ StdioFiles
				do: [ :file | file
						ifNotNil: [ file isReadOnly
								ifFalse: [ [ file flush ]
										on: Error
										do: [ :ex | "care less"
											 ] ] ] ].
			self voidStdioFiles ]
]

FileStream class >> forceNewFileNamed: fileName
[
	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, delete it without asking before creating the new file."

	^ self concreteStream forceNewFileNamed: fileName
]

FileStream class >> forceNewFileNamed: fileName do: aBlock
[
	"Returns the result of aBlock."

	^ self detectFile: [ self forceNewFileNamed: fileName ] do: aBlock
]

FileStream class >> fullName: fileName
[
	^ fileName asFileReference fullName
]

FileStream class >> initialize
[
	TheStdioHandles := Array new: 3.	"original comment was: the intent being before: AutoStart"
	Smalltalk
		addToStartUpList: self after: DiskStore;
		addToShutDownList: self after: DiskStore
]

FileStream class >> isAFileNamed: fName
[
	"return whether a file exists with the given name"

	^ self concreteStream isAFileNamed: (self fullName: fName)
]

FileStream class >> isSourceFileSuffix: suffix
[
	^ FileStream sourceFileSuffixes includes: suffix
]

FileStream class >> new
[
	^ self basicNew
]

FileStream class >> newFileNamed: fileName
[
	^ self concreteStream newFileNamed: (self fullName: fileName)
]

FileStream class >> newFileNamed: fileName do: aBlock
[
	"Returns the result of aBlock."

	^ self detectFile: [ self newFileNamed: fileName ] do: aBlock
]

FileStream class >> newForStdio
[
	"This is a hook for subclasses to initialize themselves properly."

	^ self new
]

FileStream class >> oldFileNamed: fileName
[
	^ self concreteStream oldFileNamed: (self fullName: fileName)
]

FileStream class >> oldFileNamed: fileName do: aBlock
[
	"Returns the result of aBlock."

	^ self detectFile: [ self oldFileNamed: fileName ] do: aBlock
]

FileStream class >> oldFileOrNoneNamed: fileName
[
	"If the file exists, answer a read-only FileStream on it. If it doesn't, answer nil."

	| fullName |
	fullName := self fullName: fileName.
	^ (self concreteStream isAFileNamed: fullName)
		ifTrue: [ self concreteStream readOnlyFileNamed: fullName ]
		ifFalse: [ nil ]
]

FileStream class >> readOnlyFileNamed: fileName
[
	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)
]

FileStream class >> readOnlyFileNamed: fileName do: aBlock
[
	"Open the existing file with the given name for read-only access and pass it as argument to aBlock.
	Returns the result of aBlock."

	^ self detectFile: [ self readOnlyFileNamed: fileName ] do: aBlock
]

FileStream class >> removeLineFeeds: fullName
[
	| fileContents |
	fileContents := ((FileStream readOnlyFileNamed: fullName) wantsLineEndConversion: true) contentsOfEntireFile.
	(FileStream newFileNamed: fullName)
		nextPutAll: fileContents;
		close
]

FileStream class >> requestDropStream: dropIndex
[
	"Request a read-only stream for some file that was dropped onto the application"

	^ self concreteStream new requestDropStream: dropIndex
]

FileStream class >> shutDown: quitting
[
	quitting
		ifTrue: [ self flushAndVoidStdioFiles ]
]

FileStream class >> sourceFileSuffixes
[
	^ #('st' 'cs')
]

FileStream class >> standardIOStreamNamed: moniker forWrite: forWrite
[
	"Create if necessary and store default stdin, stdout and other files based on the their names"

	| index |
	self flag: #todo.	"This is an ugly hack, while waiting for a real fix for windows. There  several problems with this approach, but it allow us to run tests, etc."
	OSPlatform isWin32
		ifTrue: [ [ ^ MultiByteFileStream forceNewFileNamed: moniker asString ]
				on: CannotDeleteFileException
				do: [ "HACK: if the image is opened a second time windows barks about the already opened locked file"
					^ MultiByteFileStream
						forceNewFileNamed: moniker asString , '_' , (Random new nextInt: SmallInteger maxVal) asString ] ].
	index := #(#stdin #stdout #stderr) identityIndexOf: moniker.
	^ ((StdioFiles ifNil: [ StdioFiles := Array new: 3 ]) at: index)
		ifNil: [ StdioFiles
				at: index
				put:
					((TheStdioHandles at: index)
						ifNil: [ ^ self error: moniker , ' is unavailable' ]
						ifNotNil: [ :handle | MultiByteFileStream newForStdio openOnHandle: handle name: moniker forWrite: forWrite ]) ]
]

FileStream class >> startUp: resuming
[
	resuming
		ifTrue: [ self voidStdioFiles.
			[ TheStdioHandles := self stdioHandles ]
				on: Error
				do: [ :ex | TheStdioHandles isArray
						ifFalse: [ TheStdioHandles := Array new: 3 ] ] ]
]

FileStream class >> stderr
[
	^ Stderr ifNil: [ Stderr := self standardIOStreamNamed: #stderr forWrite: true ]
]

FileStream class >> stdin
[
	^ Stdin
		ifNil: [ Stdin := self standardIOStreamNamed: #stdin forWrite: false.
			Stdin
				disableReadBuffering;
				yourself ]
]

FileStream class >> stdioHandles
[
	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: #ec>
	self primitiveFailed
]

FileStream class >> stdout
[
	^ Stdout ifNil: [ Stdout := self standardIOStreamNamed: #stdout forWrite: true ]
]

FileStream class >> unload
[
	FileServices unregisterFileReader: self
]

FileStream class >> voidStdioFiles
[
	Stdin := Stdout := Stderr := StdioFiles := nil
]

FileStream class >> writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag
[
	| extension converter fileName |
	extension := stOrCsFlag
		ifTrue: [ '.st' ]
		ifFalse: [ '.cs' ].
	converter := aStream contents isAsciiString
		ifTrue: [ MacRomanTextConverter new ]
		ifFalse: [ UTF8TextConverter new ].
	fileName := baseName , extension.
	fileName := FileSystem disk checkName: fileName fixErrors: true.
	[ FileStream
		newFileNamed: fileName
		do: [ :fileStream | (converter isMemberOf: UTF8TextConverter)
				ifTrue: [ fileStream binary.
					UTF8TextConverter writeBOMOn: fileStream ].
			fileStream
				text;
				converter: converter;
				nextPutAll: aStream contents;
				close ] ]
		on: Abort
		do: [ :e |  ]
]

