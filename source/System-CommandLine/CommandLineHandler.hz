CommandLineHandler
	instanceVariables: #(#commandLine #session #stdout #stderr );
	package: #'System-CommandLine'.

CommandLineHandler >> << aString
[<< aString
	^ self stdout
		nextPutAll: aString;
		yourself
]

CommandLineHandler >> activate
[activate
	self subclassResponsibility
]

CommandLineHandler >> activateHelp
[activateHelp
	"Default help implementation, running #help if the only argument is --help "

	((self hasOption: 'help') and: [ self arguments size = 1 ])
		ifTrue: [ self help.
			^ true ].
	^ false
]

CommandLineHandler >> activateHelpWithoutArguments
[activateHelpWithoutArguments
	"Default help implementation, running #help if the there is no argument or a single one which is --help "

	((self hasOption: 'help') or: [ self arguments isEmpty ])
		ifTrue: [ self help.
			^ true ].
	^ false
]

CommandLineHandler >> allHandlers
[allHandlers
	^ CommandLineHandler allHandlers
]

CommandLineHandler >> argumentAt: anInteger
[argumentAt: anInteger
	^ self commandLine argumentAt: anInteger
]

CommandLineHandler >> arguments
[arguments
	^ self commandLine arguments
]

CommandLineHandler >> commandLine
[commandLine
	^ commandLine
]

CommandLineHandler >> commandLine: aCommandLine
[commandLine: aCommandLine
	commandLine := aCommandLine
]

CommandLineHandler >> commandName
[commandName
	^ self class commandName
]

CommandLineHandler >> description
[description
	^ self class description
]

CommandLineHandler >> exitFailure
[exitFailure
	^ self exitFailure: 'Command line handler failed'
]

CommandLineHandler >> exitFailure: aMessage
[exitFailure: aMessage
	self hasSessionChanged
		ifTrue: [ ^ self ].
	Exit signalFailure: aMessage
]

CommandLineHandler >> exitSuccess
[exitSuccess
	self hasSessionChanged
		ifTrue: [ ^ self ].
	Exit signalSuccess
]

CommandLineHandler >> hasArguments
[hasArguments
	^ self commandLine hasArguments
]

CommandLineHandler >> hasOption: aString
[hasOption: aString
	^ self commandLine hasOption: aString
]

CommandLineHandler >> hasSessionChanged
[hasSessionChanged
	"check whether the session has changed since the commandline handler as been created"

	^ session ~~ Smalltalk session
]

CommandLineHandler >> help
[help
	"This is a crude default help implementation."

	self printHelp.
	Smalltalk isInteractive
		ifFalse: [ self exitSuccess ]
]

CommandLineHandler >> initialize
[initialize
	super initialize.
	session := Smalltalk session.
	self
		initializeStdout;
		initializeStderr
]

CommandLineHandler >> initializeStderr
[initializeStderr
	"install the line end conversion and initialize the converter"

	FileStream stderr
		wantsLineEndConversion: true;
		converter.
	stderr := VTermOutputDriver stderr
]

CommandLineHandler >> initializeStdout
[initializeStdout
	"install the line end conversion and initialize the converter"

	FileStream stdout
		wantsLineEndConversion: true;
		converter.
	stdout := VTermOutputDriver stdout
]

CommandLineHandler >> optionAt: aString
[optionAt: aString
	^ self commandLine optionAt: aString
]

CommandLineHandler >> optionAt: aString ifAbsent: absentBlock
[optionAt: aString ifAbsent: absentBlock
	^ self commandLine optionAt: aString ifAbsent: absentBlock
]

CommandLineHandler >> optionAt: aString ifPresent: absentBlock
[optionAt: aString ifPresent: absentBlock
	^ self commandLine optionAt: aString ifPresent: absentBlock
]

CommandLineHandler >> optionAt: aString ifPresent: presentBlock ifAbsent: absentBlock
[optionAt: aString ifPresent: presentBlock ifAbsent: absentBlock
	^ self commandLine optionAt: aString ifPresent: presentBlock ifAbsent: absentBlock
]

CommandLineHandler >> printHelp
[printHelp
	self stderr
		nextPutAll: self class comment;
		lf
]

CommandLineHandler >> quit
[quit
	self exitSuccess
]

CommandLineHandler >> stderr
[stderr
	^ stderr
]

CommandLineHandler >> stdout
[stdout
	^ stdout
]

CommandLineHandler class >> activateWith: aCommandLine
[activateWith: aCommandLine
	^ self new
		commandLine: (self prepareSubcommand: aCommandLine);
		activate
]

CommandLineHandler class >> allHandlers
[allHandlers
	^ self allSubclasses reject: [ :handler | handler isAbstract ]
]

CommandLineHandler class >> commandLine: aCommandLine
[commandLine: aCommandLine
	^ self new
		commandLine: aCommandLine;
		yourself
]

CommandLineHandler class >> commandName
[commandName
	" Overwrite this method to provide a short name for this command handler.
	You may pass the commandName as first argument to the image to select this handler"

	^ self name
]

CommandLineHandler class >> description
[description
	"This method should return a short one-line description of the command"

	^ nil
]

CommandLineHandler class >> isAbstract
[isAbstract
	^ self = CommandLineHandler
]

CommandLineHandler class >> isResponsibleFor: aCommandLineArguments
[isResponsibleFor: aCommandLineArguments
	^ aCommandLineArguments includesSubCommand: self commandName
]

CommandLineHandler class >> prepareSubcommand: commandLineArguments
[prepareSubcommand: commandLineArguments
	"strip the subcommand name from the arguments"

	commandLineArguments
		withFirstArgument: [ :arg | arg = self commandName
				ifTrue: [ ^ commandLineArguments copySubcommand ] ].	"not a subcommand hence we keep the same args"
	^ commandLineArguments
]

CommandLineHandler class >> priority
[priority
	^ 0
]

CommandLineHandler class >> selectHandlersFor: aCommandLine
[selectHandlersFor: aCommandLine
	^ self allHandlers select: [ :handlerClass | handlerClass isResponsibleFor: aCommandLine ]
]

