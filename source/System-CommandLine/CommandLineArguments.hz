CommandLineArguments
	instanceVariables: #(#arguments );
	package: #'System-CommandLine'.

CommandLineArguments class
	instanceVariables: #(#singleton ).

CommandLineArguments >> allFilesWithExtension: anExtension
[allFilesWithExtension: anExtension
	^ self arguments select: [ :arg | arg endsWith: anExtension ]
]

CommandLineArguments >> argumentAt: index
[argumentAt: index
	^ arguments at: index
]

CommandLineArguments >> arguments
[arguments
	^ arguments
]

CommandLineArguments >> commandLineArguments
[commandLineArguments
	"self commandLineArguments"

	| documentPath args |
	args := OrderedCollection withAll: Smalltalk arguments.
	documentPath := Smalltalk vm documentPath.
	documentPath isEmptyOrNil
		ifFalse: [ args addFirst: documentPath ].
	^ args
]

CommandLineArguments >> copySubcommand
[copySubcommand
	"return a new copy of this CommandLine without the first arguments"

	^ self class withArguments: arguments allButFirst
]

CommandLineArguments >> hasArguments
[hasArguments
	^ arguments size > 0
]

CommandLineArguments >> hasFileWithExtension: aFileExtension
[hasFileWithExtension: aFileExtension
	"return true if the first argument has the given file extension"

	^ self arguments anySatisfy: [ :arg | arg endsWith: aFileExtension ]
]

CommandLineArguments >> hasOption: aString
[hasOption: aString
	| option |
	option := (aString size = 1
		ifTrue: [ '-' ]
		ifFalse: [ '--' ]) , aString.
	(self arguments includes: option)
		ifTrue: [ ^ true ].
	option := option , '='.
	^ self arguments anySatisfy: [ :arg | arg beginsWith: option ]
]

CommandLineArguments >> includesSubCommand: aName
[includesSubCommand: aName
	self withFirstArgument: [ :arg | arg = aName
				ifTrue: [ ^ true ] ].
	^ false
]

CommandLineArguments >> initialize
[initialize
	| documentPath |
	arguments := OrderedCollection withAll: Smalltalk arguments.
	documentPath := Smalltalk vm documentPath.
	documentPath isEmptyOrNil
		ifFalse: [ arguments addFirst: documentPath ]
]

CommandLineArguments >> initializeWithArguments: aCollection
[initializeWithArguments: aCollection
	super initialize.
	arguments := aCollection
]

CommandLineArguments >> longOptionAt: aString
[longOptionAt: aString
	^ self longOptionAt: aString ifAbsent: [ Error signal: 'Could not find long-form option: ' , aString ]
]

CommandLineArguments >> longOptionAt: aString ifAbsent: absentBlock
[longOptionAt: aString ifAbsent: absentBlock
	| optionStart |
	optionStart := '--' , aString , '='.
	^ self arguments
		detect: [ :arg | arg beginsWith: optionStart ]
		ifFound: [ :option | (option splitOn: '=') second ]
		ifNone: absentBlock
]

CommandLineArguments >> optionAt: aString
[optionAt: aString
	^ self optionAt: aString ifAbsent: [ Error signal: 'Could not find option ' , aString ]
]

CommandLineArguments >> optionAt: aString ifAbsent: absentBlock
[optionAt: aString ifAbsent: absentBlock
	^ aString size = 1
		ifTrue: [ self shortOptionAt: aString ifAbsent: absentBlock ]
		ifFalse: [ self longOptionAt: aString ifAbsent: absentBlock ]
]

CommandLineArguments >> optionAt: aString ifPresent: presentBlock
[optionAt: aString ifPresent: presentBlock
	| option |
	option := self optionAt: aString ifAbsent: [ ^ self ].
	^ presentBlock value: option
]

CommandLineArguments >> optionAt: aString ifPresent: presentBlock ifAbsent: absentBlock
[optionAt: aString ifPresent: presentBlock ifAbsent: absentBlock
	| option |
	option := self optionAt: aString ifAbsent: [ ^ absentBlock value ].
	^ presentBlock value: option
]

CommandLineArguments >> shortOptionAt: aString
[shortOptionAt: aString
	^ self shortOptionAt: aString ifAbsent: [ Error signal: 'Could not find short-form option: ' , aString ]
]

CommandLineArguments >> shortOptionAt: aString ifAbsent: absentBlock
[shortOptionAt: aString ifAbsent: absentBlock
	| index |
	index := (arguments indexOf: '-' , aString) + 1.
	^ (index <= 1 or: [ index > arguments size ])
		ifFalse: [ arguments at: index ]
		ifTrue: absentBlock
]

CommandLineArguments >> withFirstArgument: aBlock
[withFirstArgument: aBlock
	self arguments ifEmpty: [ ^ self ].
	^ aBlock value: self arguments first
]

CommandLineArguments class >> default
[default
	^ singleton ifNil: [ singleton := self new initialize ]
]

CommandLineArguments class >> withArguments: aCollection
[withArguments: aCollection
	^ self basicNew
		initializeWithArguments: aCollection;
		yourself
]

