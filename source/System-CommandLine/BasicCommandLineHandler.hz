BasicCommandLineHandler
	superclass: #CommandLineHandler;
	package: #'System-CommandLine'.

BasicCommandLineHandler >> activate
activate
	[ self handleArgument: (self arguments ifEmpty: [ '' ] ifNotEmpty: [ :arguments | arguments first ]) ]
		on: Exit
		do: [ :exit | ^ self handleExit: exit ]

BasicCommandLineHandler >> activateSubCommand: aCommandLinehandler
activateSubCommand: aCommandLinehandler
	[ aCommandLinehandler activateWith: commandLine ]
		on: Exit
		do: [ :exit | ^ self handleExit: exit for: aCommandLinehandler ].	"the return value of this method is used to check if the subcommand was successfull"
	^ aCommandLinehandler

BasicCommandLineHandler >> copyright
copyright
	self stdout
		nextPutAll: Smalltalk licenseString;
		cr.
	self quit

BasicCommandLineHandler >> default
default
	^ self
		help;
		exitSuccess

BasicCommandLineHandler >> error
error
	self arguments size = 1
		ifTrue: [ (self arguments first beginsWith: '-')
				ifTrue: [ self << 'Invalid option: ' ]
				ifFalse: [ self << 'Invalid sub command: ' ] ]
		ifFalse: [ self << 'Invalid arguments: "' ].
	(self << (' ' join: self arguments))
		nextPutAll: '"';
		cr.
	self printHelp.
	self exitFailure

BasicCommandLineHandler >> handleArgument: aString
handleArgument: aString
	"give priority to subcommands"

	self handleSubcommand == self
		ifFalse: [ ^ self ].	"check for default options"
	aString ifEmpty: [ ^ self default ].
	aString = '--version'
		ifTrue: [ ^ self version ].
	aString = '--help'
		ifTrue: [ ^ self help ].
	aString = '--list'
		ifTrue: [ ^ self list ].
	aString = '--copyright'
		ifTrue: [ ^ self copyright ].
	aString = '--no-quit'
		ifTrue: [ ^ self noQuit ].	"none of the previous options matched hence we output an error message"
	self error

BasicCommandLineHandler >> handleEmptyArguments
handleEmptyArguments
	Smalltalk isHeadless
		ifFalse: [ ^ self ].
	self help

BasicCommandLineHandler >> handleExit: exit
handleExit: exit
	^ self handleExit: exit for: self

BasicCommandLineHandler >> handleExit: exit for: aCommandLinehandler
handleExit: exit for: aCommandLinehandler
	Smalltalk isInteractive
		ifFalse: [ ^ exit pass ].
	exit isSuccess
		ifFalse: [ ^ Error signal: exit messageText ].
	self inform: aCommandLinehandler name , ' successfully finished'.	"for failing subcommands return self which is used to check if the subcommand failed"
	exit isSuccess
		ifTrue: [ ^ aCommandLinehandler ]

BasicCommandLineHandler >> handleSubcommand
handleSubcommand
	"check if there is an active subcommand"

	| handlers |
	handlers := self selectHandlers.	"If there is no handler, use myself"
	handlers ifEmpty: [ ^ self ].
	^ self activateSubCommand: handlers first

BasicCommandLineHandler >> initialize
initialize
	super initialize.
	commandLine := CommandLineArguments new

BasicCommandLineHandler >> list
list
	| handlers shortNames maxShortNameSize |
	self stdout
		nextPutAll: 'Currently installed Command Line Handlers:';
		lf.
	handlers := self allHandlers reject: [ :cls | cls includesBehavior: BasicCommandLineHandler ].
	shortNames := handlers collect: #commandName.
	maxShortNameSize := (shortNames detectMax: [ :name | name size ]) size.
	handlers
		do: [ :handler | self stdout
				nextPutAll: '    ';
				nextPutAll: (handler commandName padRightTo: maxShortNameSize);
				nextPutAll: '    ';
				nextPutAll: (handler description ifNil: [ '--' ]);
				lf ].
	self quit

BasicCommandLineHandler >> noQuit
noQuit
	"Nothing to be done, unlike the other commands the image continues running"

	

BasicCommandLineHandler >> selectHandlers
selectHandlers
	| handlers |
	handlers := (self subCommandsRoot selectHandlersFor: commandLine) copyWithout: self class.
	handlers := handlers sort: [ :a :b | a priority >= b priority ].
	^ handlers

BasicCommandLineHandler >> selectedHandler
selectedHandler
	^ self selectHandlers ifEmpty: [ nil ] ifNotEmpty: [ :handlers | handlers first ]

BasicCommandLineHandler >> subCommandsRoot
subCommandsRoot
	^ CommandLineHandler

BasicCommandLineHandler >> version
version
	self stdout
		nextPutAll: 'Image: ';
		print: SystemVersion current;
		cr;
		nextPutAll: 'VM:    ';
		nextPutAll: Smalltalk vm version;
		cr.
	self quit

BasicCommandLineHandler class >> commandName
commandName
	^ ''

BasicCommandLineHandler class >> description
description
	^ 'basic responsible for the default options and activating other commands'

BasicCommandLineHandler class >> initialize
initialize
	"hook into the startup list"

	Smalltalk addToStartUpList: self

BasicCommandLineHandler class >> isResponsibleFor: aCommandLine
isResponsibleFor: aCommandLine
	"I do not match ever, because my activation is manual"

	^ false

BasicCommandLineHandler class >> priority
priority
	"Lowest priority"

	^ Float infinity negated

BasicCommandLineHandler class >> startUp: resuming
startUp: resuming
	"only handle when lauching a new image"

	resuming
		ifFalse: [ ^ self ].
	Smalltalk addDeferredStartupAction: [ self new activate ]

