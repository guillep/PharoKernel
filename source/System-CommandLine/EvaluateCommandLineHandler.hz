EvaluateCommandLineHandler
	superclass: #STCommandLineHandler;
	package: #'System-CommandLine'.

EvaluateCommandLineHandler >> activate
[
	self activateHelp
		ifTrue: [ ^ self ].
	self arguments ifEmpty: [ ^ self evaluateStdIn ].
	self evaluateArguments.
	(self hasOption: 'save')
		ifTrue: [ ^ Smalltalk snapshot: true andQuit: (self hasOption: 'no-quit') not ].
	(self hasOption: 'no-quit')
		ifFalse: [ self quit ]
]

EvaluateCommandLineHandler >> argumentString
[
	| arguments skipArguments |
	"Now this is ugly... Coral would be nice here! Basically we strip skipArguments if, and only if they appear at the beginning of arguments"
	skipArguments := #('--no-quit' '--save' '-e').
	arguments := (skipArguments includes: self arguments first)
		ifFalse: [ self arguments ]
		ifTrue: [ (self arguments size >= 2 and: [ skipArguments includes: self arguments second ])
				ifTrue: [ self arguments allButFirst: 2 ]
				ifFalse: [ self arguments allButFirst ] ].
	^ arguments joinUsing: Character space
]

EvaluateCommandLineHandler >> evaluate: aStream
[
	| result exceptionClassToUse |
	"workaround to make old Compiler unloadable"
	exceptionClassToUse := Smalltalk compilerClass == OpalCompiler
		ifTrue: [ OCSemanticWarning ]
		ifFalse: [ Smalltalk globals at: #ParserNotification ].
	[ result := Smalltalk evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ self stdout
				print: result;
				lf ] ]
		on: Error , ParserNotification
		do: [ :error | self handleError: error ]
]

EvaluateCommandLineHandler >> evaluateArguments
[
	| argumentString |
	argumentString := self argumentString.
	argumentString ifEmpty: [ ^ self ].
	self evaluate: argumentString
]

EvaluateCommandLineHandler >> evaluateStdIn
[
	| stdin |
	stdin := FileStream stdin ifNil: [ ^ self ].
	stdin atEnd
		ifTrue: [ ^ self ].
	self flag: #todo.	"the whole compilation machinery does not work with stdin directly, hence we load everything a buffer first"
	self
		evaluate:
			(String streamContents: [ :s | [ stdin atEnd ] whileFalse: [ stdin next ifNotNil: [ :char | s nextPut: char ] ] ])
]

EvaluateCommandLineHandler class >> commandName
[
	^ 'eval'
]

EvaluateCommandLineHandler class >> description
[
	^ 'Directly evaluates passed in one line scripts'
]

EvaluateCommandLineHandler class >> isResponsibleFor: commandLineArguments
[
	"directly handle top-level -e and --evaluate options"

	commandLineArguments withFirstArgument: [ :arg | (#('-e' '--evaluate') includes: arg)
				ifTrue: [ ^ true ] ].
	^ commandLineArguments includesSubCommand: self commandName
]

