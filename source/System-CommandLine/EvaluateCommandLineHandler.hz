Class
	name: #EvaluateCommandLineHandler;
	superclass: #ClassBasicCodeLoader;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #();
	classVariables: #();
	package: #'System-CommandLine'.

Class EvaluateCommandLineHandler >> activate
[
self arguments ifEmpty: [ ^ self evaluateStdIn ].self evaluateArguments.self quit
]

Class EvaluateCommandLineHandler >> evaluate: aStream
[
[ self stdout	print: (Compiler evaluate: aStream);	cr ]	on: Error , ParserNotification	do: [ :e | self handleError: e ]
]

Class EvaluateCommandLineHandler >> evaluateArguments
[
| args |args := self arguments joinUsing: Character space.args ifEmpty: [ ^ self ].self evaluate: args
]

Class EvaluateCommandLineHandler >> evaluateStdIn
[
| stdin |stdin := FileStream stdin ifNil: [ ^ self ].stdin atEnd	ifTrue: [ ^ self ].self flag: #todo.	"the whole compilation machinery does not work with stdin directly, hence we load everything a buffer first"self	evaluate:		(String streamContents: [ :s | [ stdin atEnd ] whileFalse: [ stdin next ifNotNilDo: [ :char | s nextPut: char ] ] ])
]

Metaclass
	name: #EvaluateCommandLineHandler;
	instanceVariables: #().

Metaclass EvaluateCommandLineHandler >> commandName
[
^ 'eval'
]

Metaclass EvaluateCommandLineHandler >> description
[
^ 'directly evaluates passed in one line scripts'
]

Metaclass EvaluateCommandLineHandler >> isResponsibleFor: commandLineArguments
[
	"directly handle top-level -e and --evaluate options"
commandLineArguments	withFirstArgument: [ :arg | 		(#('-e' '--evaluate') includes: arg)			ifTrue: [ ^ true ] ].^ commandLineArguments includesSubCommand: self commandName
]

