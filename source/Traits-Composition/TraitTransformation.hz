Class
	name: #TraitTransformation;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#subject );
	classVariables: #();
	package: #'Traits-Composition'.

Class TraitTransformation >> + aTraitOrTraitComposition
[
	"Use double dispatch to avoid having nested composition in cases where	parenthesis are used, such as T1 + (T2 + T3)"
^ aTraitOrTraitComposition addOnTheLeft: self
]

Class TraitTransformation >> - anArray
[
TraitCompositionException signal: 'Invalid trait exclusion. Exclusions have to be specified after aliases.'
]

Class TraitTransformation >> @ anArrayOfAssociations
[
TraitCompositionException signal: 'Invalid trait exclusion. Aliases have to be specified before exclusions.'
]

Class TraitTransformation >> addCompositionOnLeft: aTraitComposition
[
^ aTraitComposition add: self
]

Class TraitTransformation >> addExclusionOf: aSymbol
[
^ self - {aSymbol}
]

Class TraitTransformation >> addOnTheLeft: aTraitExpression
[
^ TraitComposition with: aTraitExpression with: self
]

Class TraitTransformation >> aliasesForSelector: aSymbol
[
	"Return a collection of alias selectors that are defined in this transformation."
^ self subject aliasesForSelector: aSymbol
]

Class TraitTransformation >> allAliasesDict
[
	"Return a dictionary with all alias associations that are defined in this transformation."
^ self subject allAliasesDict
]

Class TraitTransformation >> allSelectors
[
^ self subclassResponsibility
]

Class TraitTransformation >> asTraitComposition
[
^ TraitComposition with: self
]

Class TraitTransformation >> changedSelectorsComparedTo: aTraitTransformation
[
| selectors otherSelectors changedSelectors aliases otherAliases |selectors := self allSelectors asIdentitySet.otherSelectors := aTraitTransformation allSelectors asIdentitySet.changedSelectors := IdentitySet	withAll: ((selectors difference: otherSelectors) union: (otherSelectors difference: selectors)).aliases := self allAliasesDict.otherAliases := aTraitTransformation allAliasesDict.aliases	keysAndValuesDo: [ :key :value | 		value ~~ (otherAliases at: key ifAbsent: [ nil ])			ifTrue: [ changedSelectors add: key ] ].otherAliases	keysAndValuesDo: [ :key :value | 		value ~~ (aliases at: key ifAbsent: [ nil ])			ifTrue: [ changedSelectors add: key ] ].^ changedSelectors
]

Class TraitTransformation >> collectMethodsFor: aSelector into: methodDescription
[
	"Collect instances of LocatedMethod into methodDescription	for each method that has the selector aSelector and is not excluded	or for which aSelector is an alias."
self subclassResponsibility
]

Class TraitTransformation >> copy
[
self error: 'should not be called'.^ super copy
]

Class TraitTransformation >> copyTraitExpression
[
^ self shallowCopy	subject: self subject copyTraitExpression;	yourself
]

Class TraitTransformation >> isEmpty
[
self subclassResponsibility
]

Class TraitTransformation >> isMeta
[
^ self subject isMeta
]

Class TraitTransformation >> normalized
[
^ self isEmpty	ifFalse: [ 		self subject: self subject normalized.		self ]	ifTrue: [ self subject normalized ]
]

Class TraitTransformation >> postCopy
[
super postCopy.subject := subject copy
]

Class TraitTransformation >> printOn: aStream
[
aStream print: self subject
]

Class TraitTransformation >> removeAlias: aSymbol
[
self subject removeAlias: aSymbol
]

Class TraitTransformation >> selectors
[
^ self allSelectors
]

Class TraitTransformation >> sourceCodeTemplate
[
^ self subject sourceCodeTemplate
]

Class TraitTransformation >> subject
[
^ subject
]

Class TraitTransformation >> subject: aTraitTransformation
[
subject := aTraitTransformation
]

Class TraitTransformation >> theNonMetaClass
[
^ self subject theNonMetaClass
]

Class TraitTransformation >> trait
[
^ self subject trait
]

Class TraitTransformation >> traitTransformations
[
^ {subject}
]

Metaclass
	name: #TraitTransformation;
	instanceVariables: #().

