Class
	name: #TraitComposition;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#transformations );
	classVariables: #();
	package: #'Traits-Composition'.

Class TraitComposition >> + aTraitExpression
[
^ aTraitExpression addCompositionOnLeft: self
]

Class TraitComposition >> - anArray
[
	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"
self transformations addLast: self transformations removeLast - anArray
]

Class TraitComposition >> @ anArrayOfAssociations
[
	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"
self transformations addLast: self transformations removeLast @ anArrayOfAssociations
]

Class TraitComposition >> add: aTraitTransformation
[
self errorIfNotAddable: aTraitTransformation.self transformations addLast: aTraitTransformation
]

Class TraitComposition >> addCompositionOnLeft: aTraitComposition
[
self transformations do: [ :each | aTraitComposition add: each ].^ aTraitComposition
]

Class TraitComposition >> addOnTheLeft: aTrait
[
self errorIfNotAddable: aTrait.self transformations addFirst: aTrait
]

Class TraitComposition >> allTraits
[
^ self traits	gather: [ :trait | 		trait hasTraitComposition			ifTrue: [ trait traitComposition allTraits copyWith: trait ]			ifFalse: [ Array with: trait ] ]
]

Class TraitComposition >> asTraitComposition
[
^ self
]

Class TraitComposition >> assertValidUser: aBehavior
[
	"Assert that this trait composition set for aBehavior	does not introduce a cycle."
(self allTraits includes: aBehavior)	ifTrue: [ TraitCompositionException signal: 'Cycle in compositions:  The composition (in)directly includes this trait!' ]
]

Class TraitComposition >> changedSelectorsComparedTo: oldComposition
[
| changedSelectors traits |changedSelectors := IdentitySet new.traits := self traits asIdentitySet	addAll: oldComposition traits asIdentitySet;	yourself.traits	do: [ :each | 		| oldTransformation newTransformation |		newTransformation := self transformationOfTrait: each.		oldTransformation := oldComposition transformationOfTrait: each.		(newTransformation isNil or: [ oldTransformation isNil ])			ifTrue: [ changedSelectors addAll: each selectors ]			ifFalse: [ changedSelectors addAll: (newTransformation changedSelectorsComparedTo: oldTransformation) ] ].^ changedSelectors
]

Class TraitComposition >> copy
[
self error: 'should not be called'.^ super copy
]

Class TraitComposition >> copyTraitExpression
[
| newCopy |newCopy := self shallowCopy.newCopy transformations: (self transformations collect: [ :each | each copyTraitExpression ]).^ newCopy
]

Class TraitComposition >> copyWithExclusionOf: aSymbol to: aTrait
[
| composition transformation |composition := self copyTraitExpression.transformation := composition transformationOfTrait: aTrait.^ composition	remove: transformation;	add: (transformation addExclusionOf: aSymbol);	yourself
]

Class TraitComposition >> copyWithoutAlias: aSymbol of: aTrait
[
| composition transformation |composition := self copyTraitExpression.transformation := composition transformationOfTrait: aTrait.^ composition	remove: transformation;	add: (transformation removeAlias: aSymbol);	normalizeTransformations;	yourself
]

Class TraitComposition >> errorIfNotAddable: aTraitTransformation
[
(self includesTrait: aTraitTransformation trait)	ifTrue: [ ^ TraitCompositionException signal: 'Trait ' , aTraitTransformation trait asString , ' already in composition' ]
]

Class TraitComposition >> includesMethod: aSelector
[
^ (self methodDescriptionForSelector: aSelector) isEmpty not
]

Class TraitComposition >> includesTrait: aTrait
[
^ self traits includes: aTrait
]

Class TraitComposition >> initialize
[
super initialize.transformations := OrderedCollection new
]

Class TraitComposition >> isAliasSelector: aSymbol
[
	"Return true if the selector aSymbol is an alias defined	in this or in another composition somewhere deeper in 	the tree of traits compositions."
| methodDescription |methodDescription := (self methodDescriptionsForSelector: aSymbol) detect: [ :each | each selector = aSymbol ].^ methodDescription isAliasSelector
]

Class TraitComposition >> isEmpty
[
^ self transformations isEmpty
]

Class TraitComposition >> isLocalAliasSelector: aSymbol
[
	"Return true if the selector aSymbol is an alias defined	in this composition."
| methodDescription |methodDescription := (self methodDescriptionsForSelector: aSymbol) detect: [ :each | each selector = aSymbol ].^ methodDescription isLocalAliasSelector
]

Class TraitComposition >> methodDescriptionForSelector: aSymbol
[
	"Return a TraitMethodDescription for the selector aSymbol."
| description |description := TraitMethodDescription selector: aSymbol.self transformations do: [ :each | each collectMethodsFor: aSymbol into: description ].^ description
]

Class TraitComposition >> methodDescriptionsForSelector: aSymbol
[
	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."
| selectors collection |selectors := IdentitySet with: aSymbol.self transformations do: [ :each | selectors addAll: (each aliasesForSelector: aSymbol) ].collection := OrderedCollection new: selectors size.selectors do: [ :each | collection add: (self methodDescriptionForSelector: each) ].^ collection
]

Class TraitComposition >> normalizeTransformations
[
self transformations: (self transformations collect: [ :each | each normalized ])
]

Class TraitComposition >> notEmpty
[
^ self isEmpty not
]

Class TraitComposition >> postCopy
[
super postCopy.transformations := transformations collect: [ :each | each copy ]
]

Class TraitComposition >> printOn: aStream
[
self transformations isEmptyOrNil	ifFalse: [ self transformations do: [ :each | aStream print: each ] separatedBy: [ aStream nextPutAll: ' + ' ] ]	ifTrue: [ aStream nextPutAll: '{}' ]
]

Class TraitComposition >> printString
[
^ String streamContents: [ :stream | self printOn: stream ]
]

Class TraitComposition >> remove: aTransformation
[
self transformations remove: aTransformation
]

Class TraitComposition >> removeFromComposition: aTrait
[
self remove: (self transformationOfTrait: aTrait)
]

Class TraitComposition >> size
[
^ transformations size
]

Class TraitComposition >> traitProvidingSelector: aSymbol
[
	"Return the trait which originally provides the method aSymbol or return nil	if trait composition does not provide this selector or there is a conflict.	Take aliases into account. Return the trait which the aliased method is defined in."
| methodDescription locatedMethod |methodDescription := self methodDescriptionForSelector: aSymbol.(methodDescription isProvided not or: [ methodDescription isConflict ])	ifTrue: [ ^ nil ].locatedMethod := methodDescription providedLocatedMethod.^ locatedMethod methodClass traitOrClassOfSelector: locatedMethod selector
]

Class TraitComposition >> traits
[
^ self transformations collect: [ :each | each trait ]
]

Class TraitComposition >> transformationOfTrait: aTrait
[
	"Return the transformation which holds aTrait	or nil if this composition doesn't include aTrait."
^ self transformations detect: [ :each | each trait = aTrait ] ifNone: [ nil ]
]

Class TraitComposition >> transformations
[
^ transformations
]

Class TraitComposition >> transformations: aCollection
[
transformations := aCollection
]

Metaclass
	name: #TraitComposition;
	instanceVariables: #().

Metaclass TraitComposition >> with: aTraitTransformation
[
^ self new	add: aTraitTransformation;	yourself
]

Metaclass TraitComposition >> with: aTraitTransformation with: anotherTraitTransformation
[
^ self new	add: aTraitTransformation;	add: anotherTraitTransformation;	yourself
]

