ChangeRecord
	instanceVariables: #(#file #position #type #class #category #meta #stamp );
	package: #'System-Changes'.

ChangeRecord >> category
[
	^ category
]

ChangeRecord >> classIncludesSelector
[
	| aClass |
	^ (aClass := self methodClass) notNil and: [ aClass includesSelector: self methodSelector ]
]

ChangeRecord >> commentClass
[
	| commentClass |
	type == #classComment
		ifFalse: [ ^ nil ].
	(Smalltalk includesKey: class asSymbol)
		ifFalse: [ ^ nil ].
	commentClass := Smalltalk at: class asSymbol.
	^ meta
		ifTrue: [ commentClass class ]
		ifFalse: [ commentClass ]
]

ChangeRecord >> file: f position: p type: t
[
	file := f.
	position := p.
	type := t
]

ChangeRecord >> file: f position: p type: t class: c category: cat meta: m stamp: s
[
	self file: f position: p type: t.
	class := c.
	category := cat.
	meta := m.
	stamp := s
]

ChangeRecord >> fileIn
[
	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."

	Cursor read
		showWhile: [ | methodClass s |
			(methodClass := self methodClass) notNil
				ifTrue: [ methodClass
						compile: self text
						classified: category
						withStamp: stamp
						notifying: nil ].
			type == #doIt
				ifTrue: [ ((s := self string) beginsWith: '----')
						ifFalse: [ self class compiler evaluate: s ] ].
			type == #classComment
				ifTrue: [ (Smalltalk globals at: class asSymbol) comment: self text stamp: stamp ] ]
]

ChangeRecord >> fileIndex
[
	^ (SourceFiles collect: [ :sf | sf name ]) indexOf: file name ifAbsent: [ ^ nil ]
]

ChangeRecord >> fileName
[
	^ (file ifNotNil: [ file name ]) ifNil: [ '<no file>' ]
]

ChangeRecord >> fileOutOn: aFileStream
[
	"File the receiver out on the given file stream"

	| aString |
	type == #method
		ifTrue: [ aFileStream nextPut: $!.
			aString := class asString , (meta
						ifTrue: [ ' class methodsFor: ' ]
						ifFalse: [ ' methodsFor: ' ])
				, category asString printString.
			stamp ifNotNil: [ aString := aString , ' stamp: ''' , stamp , '''' ].
			aFileStream nextChunkPut: aString.
			aFileStream cr ].
	type == #preamble
		ifTrue: [ aFileStream nextPut: $! ].
	type == #classComment
		ifTrue: [ aFileStream nextPut: $!.
			aFileStream nextChunkPut: class asString , ' commentStamp: ' , stamp storeString.
			aFileStream cr ].
	aFileStream nextChunkPut: self string.
	type == #method
		ifTrue: [ aFileStream nextChunkPut: ' ' ].
	aFileStream cr
]

ChangeRecord >> isMetaClassChange
[
	^ meta
]

ChangeRecord >> isMethodDefinedInImage
[
	"answer whether the method represented by the receiver is present in the image"

	^ self type = #method and: [ self classIncludesSelector ]
]

ChangeRecord >> isMethodNotDefinedInImage
[
	"answer whether the method represented by the receiver is not present in the image.
	pay attention is it not just isMethodDefinedInImage not"

	| aClass |
	^ self type = #method
		and: [ (aClass := self methodClass) isNil or: [ (aClass includesSelector: self methodSelector) not ] ]
]

ChangeRecord >> isUnchangedMethod
[
	^ self isMethodDefinedInImage
		and: [ self string withBlanksCondensed = (self methodClass sourceCodeAt: self methodSelector) asString withBlanksCondensed ]
]

ChangeRecord >> methodClass
[
	| methodClass |
	type == #method
		ifFalse: [ ^ nil ].
	(Smalltalk globals includesKey: class asSymbol)
		ifFalse: [ ^ nil ].
	methodClass := Smalltalk globals at: class asSymbol.
	^ meta
		ifTrue: [ methodClass class ]
		ifFalse: [ methodClass ]
]

ChangeRecord >> methodClassName
[
	^ class
]

ChangeRecord >> methodSelector
[
	^ type == #method
		ifTrue: [ (Smalltalk globals at: class ifAbsent: [ Object ]) compiler parseSelector: self string ]
]

ChangeRecord >> position
[
	^ position
]

ChangeRecord >> stamp
[
	^ stamp
]

ChangeRecord >> stamp: threePartString
[
	stamp := threePartString
]

ChangeRecord >> string
[
	| string |
	file openReadOnly.
	file position: position.
	string := file nextChunk.
	file close.
	^ string
]

ChangeRecord >> text
[
	| text |
	^ file
		ifNil: [ '' ]
		ifNotNil: [ file openReadOnly.
			file position: position.
			text := file nextChunkText.
			file close.
			text ]
]

ChangeRecord >> timeStamp
[
	"Answer a TimeStamp that corresponds to my (text) stamp"

	| tokens |
	tokens := self stamp findTokens: Character separators.
	^ tokens size > 2
		ifTrue: [ [ | time date |
			date := Date fromString: (tokens at: tokens size - 1).
			time := Time fromString: tokens last.
			DateAndTime date: date time: time ]
				on: Error
				do: [ :ex | ex return: DateAndTime new ] ]
		ifFalse: [ DateAndTime new ]
]

ChangeRecord >> type
[
	^ type
]

