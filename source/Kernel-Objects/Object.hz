Object
	superclass: #ProtoObject;
	classVariables: #(#DependentsFields );
	package: #'Kernel-Objects'.

Object >> -> anObject
[
	"Answer an Association between self and anObject"

	^ Association basicNew key: self value: anObject
]

Object >> = anObject
[
	"Answer whether the receiver and the argument represent the same 
	object. If = is redefined in any subclass, consider also redefining the 
	message hash."

	^ self == anObject
]

Object >> acceptDroppingMorph: transferMorph event: evt inMorph: dstListMorph
[
	^ false
]

Object >> actAsExecutor
[
	"Prepare the receiver to act as executor for any resources associated with it"

	self breakDependents
]

Object >> actionForEvent: anEventSelector
[
	"Answer the action to be evaluated when <anEventSelector> has been triggered."

	| actions |
	actions := self actionMap at: anEventSelector asSymbol ifAbsent: [ nil ].
	actions ifNil: [ ^ nil ].
	^ actions asMinimalRepresentation
]

Object >> actionForEvent: anEventSelector ifAbsent: anExceptionBlock
[
	"Answer the action to be evaluated when <anEventSelector> has been triggered."

	| actions |
	actions := self actionMap at: anEventSelector asSymbol ifAbsent: [ nil ].
	actions ifNil: [ ^ anExceptionBlock value ].
	^ actions asMinimalRepresentation
]

Object >> actionMap
[
	^ EventManager actionMapFor: self
]

Object >> actionSequenceForEvent: anEventSelector
[
	^ (self actionMap at: anEventSelector asSymbol ifAbsent: [ ^ WeakActionSequence new ]) asActionSequence
]

Object >> actionsDo: aBlock
[
	self actionMap do: aBlock
]

Object >> adaptToFloat: rcvr andCompare: selector
[
	"If I am involved in comparison with a Float.
	Default behaviour is to process comparison as any other selectors."

	^ self adaptToFloat: rcvr andSend: selector
]

Object >> adaptToFloat: rcvr andSend: selector
[
	"If no method has been provided for adapting an object to a Float,
	then it may be adequate to simply adapt it to a number."

	^ self adaptToNumber: rcvr andSend: selector
]

Object >> adaptToFraction: rcvr andCompare: selector
[
	"If I am involved in comparison with a Fraction.
	Default behaviour is to process comparison as any other selectors."

	^ self adaptToFraction: rcvr andSend: selector
]

Object >> adaptToFraction: rcvr andSend: selector
[
	"If no method has been provided for adapting an object to a Fraction,
	then it may be adequate to simply adapt it to a number."

	^ self adaptToNumber: rcvr andSend: selector
]

Object >> adaptToInteger: rcvr andCompare: selector
[
	"If I am involved in comparison with an Integer.
	Default behaviour is to process comparison as any other selectors."

	^ self adaptToInteger: rcvr andSend: selector
]

Object >> adaptToInteger: rcvr andSend: selector
[
	"If no method has been provided for adapting an object to a Integer,
	then it may be adequate to simply adapt it to a number."

	^ self adaptToNumber: rcvr andSend: selector
]

Object >> addDependent: anObject
[
	"Make the given object one of the receiver's dependents."

	| dependents |
	dependents := self dependents.
	(dependents includes: anObject)
		ifFalse: [ self myDependents: (dependents copyWithDependent: anObject) ].
	^ anObject
]

Object >> addModelItemsToWindowMenu: aMenu
[
	"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic window.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself."

	
]

Object >> addModelMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph
[
	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"

	
]

Object >> as: aSimilarClass
[
	"Create an object of class aSimilarClass that has similar contents to the receiver."

	^ aSimilarClass newFrom: self
]

Object >> asActionSequence
[
	^ WeakActionSequence with: self
]

Object >> asLink
[
	"Answer a string that represents the receiver."

	^ ValueLink value: self
]

Object >> asOrderedCollection
[
	"Answer an OrderedCollection with the receiver as its only element."

	^ OrderedCollection with: self
]

Object >> asSetElement
[
	"Answer an object, which can be put into a Set as element , wrapped
	by one of SetElement instance, if necessary. 
	Default implementation is to answer self"

	
]

Object >> asString
[
	"Answer a string that represents the receiver."

	^ self printString
]

Object >> asStringOrText
[
	"Answer a string that represents the receiver."

	^ self asString
]

Object >> assert: aBlock
[
	"Throw an assertion error if aBlock does not evaluates to true."

	aBlock value
		ifFalse: [ AssertionFailure signal: 'Assertion failed' ]
]

Object >> assert: aBlock description: aString
[
	"Throw an assertion error if aBlock does not evaluates to true."

	aBlock value
		ifFalse: [ AssertionFailure signal: aString ]
]

Object >> assert: aBlock descriptionBlock: descriptionBlock
[
	"Throw an assertion error if aBlock does not evaluate to true."

	aBlock value
		ifFalse: [ AssertionFailure signal: descriptionBlock value asString ]
]

Object >> at: index
[
	"Primitive. Assumes receiver is indexable. Answer the value of an 
	indexable element in the receiver. Fail if the argument index is not an 
	Integer or is out of bounds. Essential. See Object documentation 
	whatIsAPrimitive. Read the class comment for a discussion about that the fact
	that the index can be a float."

	<primitive: 60>
	index isInteger
		ifTrue: [ self class isVariable
				ifTrue: [ self errorSubscriptBounds: index ]
				ifFalse: [ self errorNotIndexable ] ].
	index isNumber
		ifTrue: [ ^ self at: index asInteger ]
		ifFalse: [ self errorNonIntegerIndex ]
]

Object >> at: index modify: aBlock
[
	"Replace the element of the collection with itself transformed by the block"

	^ self at: index put: (aBlock value: (self at: index))
]

Object >> at: index put: value
[
	"Primitive. Assumes receiver is indexable. Store the argument value in 
	the indexable element of the receiver indicated by index. Fail if the 
	index is not an Integer or is out of bounds. Or fail if the value is not of 
	the right type for this kind of collection. Answer the value that was 
	stored. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 61>
	index isInteger
		ifTrue: [ self class isVariable
				ifTrue: [ (index >= 1 and: [ index <= self size ])
						ifTrue: [ self errorImproperStore ]
						ifFalse: [ self errorSubscriptBounds: index ] ]
				ifFalse: [ self errorNotIndexable ] ].
	index isNumber
		ifTrue: [ ^ self at: index asInteger put: value ]
		ifFalse: [ self errorNonIntegerIndex ]
]

Object >> basicAt: index
[
	"Primitive. Assumes receiver is indexable. Answer the value of an 
	indexable element in the receiver. Fail if the argument index is not an 
	Integer or is out of bounds. Essential. Do not override in a subclass. See 
	Object documentation whatIsAPrimitive."

	<primitive: 60>
	index isInteger
		ifTrue: [ self errorSubscriptBounds: index ].
	index isNumber
		ifTrue: [ ^ self basicAt: index asInteger ]
		ifFalse: [ self errorNonIntegerIndex ]
]

Object >> basicAt: index put: value
[
	"Primitive. Assumes receiver is indexable. Store the second argument 
	value in the indexable element of the receiver indicated by index. Fail 
	if the index is not an Integer or is out of bounds. Or fail if the value is 
	not of the right type for this kind of collection. Answer the value that 
	was stored. Essential. Do not override in a subclass. See Object 
	documentation whatIsAPrimitive."

	<primitive: 61>
	index isInteger
		ifTrue: [ (index >= 1 and: [ index <= self size ])
				ifTrue: [ self errorImproperStore ]
				ifFalse: [ self errorSubscriptBounds: index ] ].
	index isNumber
		ifTrue: [ ^ self basicAt: index asInteger put: value ]
		ifFalse: [ self errorNonIntegerIndex ]
]

Object >> basicSize
[
	"Primitive. Answer the number of indexable variables in the receiver. 
	This value is the same as the largest legal subscript. Essential. Do not 
	override in any subclass. See Object documentation whatIsAPrimitive."

	"The number of indexable fields of fixed-length objects is 0"

	<primitive: 62>
	^ 0
]

Object >> becomeForward: otherObject
[
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger."

	(Array with: self) elementsForwardIdentityTo: (Array with: otherObject)
]

Object >> becomeForward: otherObject copyHash: copyHash
[
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger."

	(Array with: self) elementsForwardIdentityTo: (Array with: otherObject) copyHash: copyHash
]

Object >> bindingOf: aString
[
	^ nil
]

Object >> breakDependents
[
	"Remove all of the receiver's dependents."

	self myDependents: nil
]

Object >> canDiscardEdits
[
	"Answer true if none of the views on this model has unaccepted edits that matter."

	self dependents do: [ :each | each canDiscardEdits
				ifFalse: [ ^ false ] ] without: self.
	^ true
]

Object >> caseError
[
	"Report an error from an in-line or explicit case statement."

	self error: 'Case not found (' , self printString , '), and no otherwise clause'
]

Object >> caseOf: aBlockAssociationCollection
[
	"The elements of aBlockAssociationCollection are associations between blocks.
	 Answer the evaluated value of the first association in aBlockAssociationCollection
	 whose evaluated key equals the receiver.  If no match is found, report an error."

	^ self caseOf: aBlockAssociationCollection otherwise: [ self caseError ]	"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z"	"| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z"	"The following are compiled in-line:"	"#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}"	"#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}"
]

Object >> caseOf: aBlockAssociationCollection otherwise: aBlock
[
	"The elements of aBlockAssociationCollection are associations between blocks.
	 Answer the evaluated value of the first association in aBlockAssociationCollection
	 whose evaluated key equals the receiver.  If no match is found, answer the result
	 of evaluating aBlock."

	aBlockAssociationCollection associationsDo: [ :assoc | assoc key value = self
				ifTrue: [ ^ assoc value value ] ].
	^ aBlock value	"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"	"| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"	"The following are compiled in-line:"	"#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"	"#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"
]

Object >> changed
[
	"Receiver changed in a general way; inform all the dependents by 
	sending each dependent an update: message."

	self changed: self
]

Object >> changed: aParameter
[
	"Receiver changed. The change is denoted by the argument aParameter. 
	Usually the argument is a Symbol that is part of the dependent's change 
	protocol. Inform all of the dependents."

	self dependents do: [ :aDependent | aDependent update: aParameter ]
]

Object >> changed: anAspect with: anObject
[
	"Receiver changed. The change is denoted by the argument anAspect. 
	Usually the argument is a Symbol that is part of the dependent's change 
	protocol. Inform all of the dependents. Also pass anObject for additional information."

	self dependents do: [ :aDependent | aDependent update: anAspect with: anObject ]
]

Object >> class
[
	"Primitive. Answer the object which is the receiver's class. Essential. See 
	Object documentation whatIsAPrimitive."

	<primitive: 111>
	self primitiveFailed
]

Object >> className
[
	"Answer a string characterizing the receiver's class, for use in list views for example"

	^ self class name asString
]

Object >> complexContents
[
	^ self
]

Object >> confirm: aString orCancel: cancelBlock
[
	"Put up a yes/no/cancel menu with caption aString. Answer true if  
	the response is yes, false if no. If cancel is chosen, evaluate  
	cancelBlock. This is a modal question--the user must respond yes or no."

	^ UIManager default confirm: aString orCancel: cancelBlock
]

Object >> contentsChanged
[
	self changed: #contents
]

Object >> copy
[
	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy. Copy is a template method in the sense of Design Patterns. So do not override it. Override postCopy instead. Pay attention that normally you should call postCopy of your superclass too."

	^ self shallowCopy postCopy
]

Object >> copyFrom: anotherObject
[
	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "

	<primitive: 168>
	| mine his |
	mine := self class allInstVarNames.
	his := anotherObject class allInstVarNames.
	1 to: (mine size min: his size) do: [ :ind | (mine at: ind) = (his at: ind)
			ifTrue: [ self instVarAt: ind put: (anotherObject instVarAt: ind) ] ].
	self class isVariable & anotherObject class isVariable
		ifTrue: [ 1 to: (self basicSize min: anotherObject basicSize) do: [ :ind | self basicAt: ind put: (anotherObject basicAt: ind) ] ]
]

Object >> copySameFrom: otherObject
[
	"Copy to myself all instance variables named the same in otherObject.
	This ignores otherObject's control over its own inst vars."

	| myInstVars otherInstVars |
	myInstVars := self class allInstVarNames.
	otherInstVars := otherObject class allInstVarNames.
	myInstVars
		doWithIndex: [ :each :index | | match |
			(match := otherInstVars indexOf: each) > 0
				ifTrue: [ self instVarAt: index put: (otherObject instVarAt: match) ] ].
	1 to: (self basicSize min: otherObject basicSize) do: [ :i | self basicAt: i put: (otherObject basicAt: i) ]
]

Object >> crLog
[
	self crTrace: self printString
]

Object >> crLog: aString
[
	"Log the argument. Use self log: instead of Transcript cr; show: "

	Transcript
		cr;
		show: aString
]

Object >> crTrace
[
	self crTrace: self printString
]

Object >> crTrace: aString
[
	"Log the argument. Use self crTrace: instead of Transcript cr; show: "

	Transcript
		cr;
		show: aString
]

Object >> createActionMap
[
	^ IdentityDictionary new
]

Object >> deepCopy
[
	"Answer a copy of the receiver with its own copy of each instance variable. deepCopy does a deep copy. It should never be overridden and only be used if you want to get these very specific semantics.
It doesn't handle cycles, #veryDeepCopy does. In the future we will make it handle cycles and deprecate veryDeepCopy"

	| newObject class index |
	class := self class.
	class == Object
		ifTrue: [ ^ self ].
	class isVariable
		ifTrue: [ index := self basicSize.
			newObject := class basicNew: index.
			[ index > 0 ] whileTrue: [ newObject basicAt: index put: (self basicAt: index) deepCopy.
					index := index - 1 ] ]
		ifFalse: [ newObject := class basicNew ].
	index := class instSize.
	[ index > 0 ] whileTrue: [ newObject instVarAt: index put: (self instVarAt: index) deepCopy.
			index := index - 1 ].
	^ newObject
]

Object >> dependents
[
	"Answer a collection of objects that are 'dependent' on the receiver;
	 that is, all objects that should be notified if the receiver changes."

	^ self myDependents ifNil: [ #() ]
]

Object >> deprecated: anExplanationString
[
	"this is not itself deprecated, but a compatibility method for old-style deprecation"

	(Deprecation
		method: thisContext sender method
		explanation: anExplanationString
		on: 'unknown'
		in: 'unknown') signal
]

Object >> deprecated: anExplanationString on: date in: version
[
	"Warn that the sending method has been deprecated"

	(Deprecation
		method: thisContext sender method
		explanation: anExplanationString
		on: date
		in: version) signal
]

Object >> doesNotUnderstand: aMessage
[
	"Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."

	"Testing: (3 activeProcess)"

	| exception resumeValue |
	(exception := MessageNotUnderstood new)
		message: aMessage;
		receiver: self.
	resumeValue := exception signal.
	^ exception reachedDefaultHandler
		ifTrue: [ aMessage sentTo: self ]
		ifFalse: [ resumeValue ]
]

Object >> dpsTrace: reportObject
[
	Transcript myDependents isNil
		ifTrue: [ ^ self ].
	self dpsTrace: reportObject levels: 1 withContext: thisContext	" nil dpsTrace: 'sludder'. "
]

Object >> dpsTrace: reportObject levels: anInt
[
	self dpsTrace: reportObject levels: anInt withContext: thisContext	"(1 to: 3) do: [:int | nil dpsTrace: int levels: 5.]"
]

Object >> dpsTrace: reportObject levels: anInt withContext: currentContext
[
	| reportString context displayCount |
	reportString := (reportObject respondsTo: #asString)
		ifTrue: [ reportObject asString ]
		ifFalse: [ reportObject printString ].
	(Smalltalk globals at: #Decompiler ifAbsent: [ nil ])
		ifNil: [ Transcript
				cr;
				show: reportString ]
		ifNotNil: [ context := currentContext.
			displayCount := anInt > 1.
			1 to: anInt do: [ :count | Transcript cr.
				displayCount
					ifTrue: [ Transcript show: count printString , ': ' ].
				reportString notNil
					ifTrue: [ Transcript show: context home class name , '/' , context sender selector , ' (' , reportString , ')'.
						context := context sender.
						reportString := nil ]
					ifFalse: [ (context notNil and: [ (context := context sender) notNil ])
							ifTrue: [ Transcript show: context receiver class name , '/' , context selector ] ] ]	"Transcript cr" ]
]

Object >> dragPassengerFor: item inMorph: dragSource
[
	^ item
]

Object >> dragTransferType
[
	^ nil
]

Object >> dragTransferTypeForMorph: dragSource
[
	^ nil
]

Object >> enclosedSetElement
[
	"The receiver is included into a set as an element. 
	Since some objects require wrappers (see SetElement) to be able to be included into a Set,
	a set sends this message to its element to make sure it getting real object,
	instead of its wrapper.
	Only SetElement instance or its subclasses allowed to answer something different than receiver itself"

	
]

Object >> error
[
	"Throw a generic Error exception."

	^ self error: 'Error!'
]

Object >> error: aString
[
	"Throw a generic Error exception."

	^ Error new signal: aString
]

Object >> errorImproperStore
[
	"Create an error notification that an improper store was attempted."

	self error: 'Improper store into indexable object'
]

Object >> errorNonIntegerIndex
[
	"Create an error notification that an improper object was used as an index."

	self error: 'only integers should be used as indices'
]

Object >> errorNotIndexable
[
	"Create an error notification that the receiver is not indexable."

	self error: ('Instances of {1} are not indexable' translated format: {(self class name)})
]

Object >> errorSubscriptBounds: index
[
	"Create an error notification that an improper integer was used as an index."

	SubscriptOutOfBounds signalFor: index
]

Object >> executor
[
	"Return an object which can act as executor for finalization of the receiver"

	^ self shallowCopy actAsExecutor
]

Object >> explicitRequirement
[
	self error: 'Explicitly required method'
]

Object >> finalizationRegistry
[
	"Answer the finalization registry associated with the receiver."

	^ WeakRegistry default
]

Object >> finalize
[
	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."

	
]

Object >> fullPrintString
[
	"Answer a String whose characters are a description of the receiver."

	^ String streamContents: [ :s | self printOn: s ]
]

Object >> haltIfNil
[
	
]

Object >> handles: exception
[
	"This method exists in case a non exception class is the first arg in an on:do: (for instance using a exception class that is not loaded). We prefer this to raising an error during error handling itself. Also, semantically it makes sense that the exception handler is not active if its exception class is not loaded"

	^ false
]

Object >> hasActionForEvent: anEventSelector
[
	"Answer true if there is an action associated with anEventSelector"

	^ (self actionForEvent: anEventSelector) notNil
]

Object >> hasActionsWithReceiver: anObject
[
	^ self actionMap keys
		anySatisfy: [ :eachEventSelector | (self actionSequenceForEvent: eachEventSelector) anySatisfy: [ :anAction | anAction receiver == anObject ] ]
]

Object >> hasLiteralSuchThat: testBlock
[
	"This is the end of the imbedded structure path so return false."

	^ false
]

Object >> hasMultipleExecutors
[
	"All objects, except ObjectFinalizerCollection instances should answer false to this message"

	^ false
]

Object >> hash
[
	"Answer a SmallInteger whose value is related to the receiver's identity.
	May be overridden, and should be overridden in any classes that define = "

	^ self identityHash
]

Object >> ifNil: nilBlock ifNotNilDo: aBlock
[
	"Evaluate aBlock with the receiver as its argument."

	^ aBlock value: self
]

Object >> ifNotNilDo: aBlock
[
	"Evaluate the given block with the receiver as its argument."

	^ aBlock value: self
]

Object >> ifNotNilDo: aBlock ifNil: nilBlock
[
	"Evaluate aBlock with the receiver as its argument."

	^ aBlock value: self
]

Object >> in: aBlock
[
	"Evaluate the given block with the receiver as its argument."

	^ aBlock value: self
]

Object >> instVarAt: index
[
	"Primitive. Answer a fixed variable in an object. The numbering of the 
	variables corresponds to the named instance variables. Fail if the index 
	is not an Integer or is not the index of a fixed variable. Essential. See 
	Object documentation whatIsAPrimitive."

	"Access beyond fixed variables."

	<primitive: 73>
	^ self basicAt: index - self class instSize
]

Object >> instVarAt: anInteger put: anObject
[
	"Primitive. Store a value into a fixed variable in the receiver. The 
	numbering of the variables corresponds to the named instance variables. 
	Fail if the index is not an Integer or is not the index of a fixed variable. 
	Answer the value stored as the result. Using this message violates the 
	principle that each object has sovereign control over the storing of 
	values into its instance variables. Essential. See Object documentation 
	whatIsAPrimitive."

	"Access beyond fixed fields"

	<primitive: 74>
	^ self basicAt: anInteger - self class instSize put: anObject
]

Object >> instVarNamed: aString
[
	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "

	^ self instVarAt: (self class instVarIndexFor: aString asString ifAbsent: [ self error: 'no such inst var' ])
]

Object >> instVarNamed: aString put: aValue
[
	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "

	^ self
		instVarAt: (self class instVarIndexFor: aString asString ifAbsent: [ self error: 'no such inst var' ])
		put: aValue
]

Object >> is: aSymbol
[
	"A means for cleanly replacing all isXXX like methods.
	Please use judiciously!
	Suggested by Igor Stasenko at
	http://lists.squeakfoundation.org/pipermail/squeak-dev/2009-June/136793.html.
	all isXXX should be converted following the pattern
	
	ColorForm>>isColorForm 
			^ true
	Object>>isColorForm 
			^ false 
	is: aSymbol
		^ aSymbol = #ColorForm or: [ super is: aSymbol ]"

	^ false
]

Object >> isArray
[
	^ false
]

Object >> isBehavior
[
	"Return true if the receiver is a behavior.
	Note: Do not override in any class except behavior."

	^ false
]

Object >> isBlock
[
	^ false
]

Object >> isCharacter
[
	^ false
]

Object >> isClosure
[
	^ false
]

Object >> isCollection
[
	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"

	^ false
]

Object >> isColor
[
	"Answer true if receiver is a Color. False by default."

	^ false
]

Object >> isColorForm
[
	^ false
]

Object >> isCompiledMethod
[
	^ false
]

Object >> isComplex
[
	"Answer true if receiver is a Complex number. False by default."

	^ false
]

Object >> isComposedBy: aTrait
[
	"Answers if this object includes trait aTrait into its composition"

	^ self class isComposedBy: aTrait
]

Object >> isContext
[
	^ false
]

Object >> isDictionary
[
	^ false
]

Object >> isFloat
[
	"Overridden to return true in Float, natch"

	^ false
]

Object >> isForm
[
	^ false
]

Object >> isFraction
[
	"Answer true if the receiver is a Fraction."

	^ false
]

Object >> isHeap
[
	^ false
]

Object >> isInteger
[
	"Overridden to return true in Integer."

	^ false
]

Object >> isInterval
[
	^ false
]

Object >> isKindOf: aClass
[
	"Answer whether the class, aClass, is a superclass or class of the receiver."

	self class == aClass
		ifTrue: [ ^ true ]
		ifFalse: [ ^ self class inheritsFrom: aClass ]
]

Object >> isLiteral
[
	"Answer whether the receiver has a literal text form recognized by the 
	compiler."

	^ false
]

Object >> isMemberOf: aClass
[
	"Answer whether the receiver is an instance of the class, aClass."

	^ self class == aClass
]

Object >> isMessageSend
[
	^ false
]

Object >> isMethodProperties
[
	^ false
]

Object >> isMorph
[
	^ false
]

Object >> isMorphicEvent
[
	^ false
]

Object >> isMorphicModel
[
	"Return true if the receiver is a morphic model"

	^ false
]

Object >> isNumber
[
	"Overridden to return true in Number, natch"

	^ false
]

Object >> isPoint
[
	"Overridden to return true in Point."

	^ false
]

Object >> isRectangle
[
	^ false
]

Object >> isSelfEvaluating
[
	^ self isLiteral
]

Object >> isStream
[
	"Return true if the receiver responds to the stream protocol"

	^ false
]

Object >> isString
[
	"Overridden to return true in String, natch"

	^ false
]

Object >> isSymbol
[
	^ false
]

Object >> isSystemWindow
[
	"answer whatever the receiver is a SystemWindow"

	^ false
]

Object >> isText
[
	^ false
]

Object >> isThisEverCalled
[
	^ self isThisEverCalled: thisContext sender printString
]

Object >> isThisEverCalled: msg
[
	"Send this message, with some useful printable argument, from methods or branches of methods which you believe are never reached."

	Halt halt: 'This is indeed called: ' , msg printString
]

Object >> isTrait
[
	^ false
]

Object >> isVariableBinding
[
	"Return true if I represent a literal variable binding"

	^ false
]

Object >> literalEqual: other
[
	^ self class == other class and: [ self = other ]
]

Object >> log: aString
[
	"Log the argument. Use self log: instead of Transcript show: "

	Transcript show: aString
]

Object >> logCr
[
	self logCr: self printString
]

Object >> logCr: aString
[
	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr "

	Transcript
		show: aString;
		cr
]

Object >> logCrTab: aString
[
	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr ; tab"

	Transcript
		show: aString;
		cr;
		tab
]

Object >> logEntry
[
	Transcript
		show: 'Entered ' , thisContext sender printString;
		cr
]

Object >> logExecution
[
	Transcript
		show: 'Executing ' , thisContext sender printString;
		cr
]

Object >> logExit
[
	Transcript
		show: 'Exited ' , thisContext sender printString;
		cr
]

Object >> longPrintOn: aStream
[
	"Append to the argument, aStream, the names and values of all 
	of the receiver's instance variables."

	self class allInstVarNames
		doWithIndex: [ :title :index | aStream
				nextPutAll: title;
				nextPut: $:;
				space;
				tab;
				print: (self instVarAt: index);
				cr ]
]

Object >> longPrintOn: aStream limitedTo: sizeLimit indent: indent
[
	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  Limit is the length limit for each inst var."

	self class allInstVarNames
		doWithIndex: [ :title :index | indent timesRepeat: [ aStream tab ].
			aStream
				nextPutAll: title;
				nextPut: $:;
				space;
				tab;
				nextPutAll: ((self instVarAt: index) printStringLimitedTo: (sizeLimit - 3 - title size max: 1));
				cr ]
]

Object >> longPrintString
[
	"Answer a String whose characters are a description of the receiver."

	| str |
	str := String streamContents: [ :aStream | self longPrintOn: aStream ].	"Objects without inst vars should return something"
	^ str isEmpty
		ifTrue: [ self printString , String cr ]
		ifFalse: [ str ]
]

Object >> longPrintStringLimitedTo: aLimitValue
[
	"Answer a String whose characters are a description of the receiver."

	| str |
	str := String streamContents: [ :aStream | self longPrintOn: aStream limitedTo: aLimitValue indent: 0 ].	"Objects without inst vars should return something"
	^ str isEmpty
		ifTrue: [ self printString , String cr ]
		ifFalse: [ str ]
]

Object >> modelSleep
[
	"A window with me as model is being exited or collapsed or closed.
	Default response is no-op"

	
]

Object >> modelWakeUp
[
	"A window with me as model is being entered or expanded.  Default response is no-op"

	
]

Object >> modelWakeUpIn: aWindow
[
	"A window with me as model is being entered or expanded.  Default response is no-op"

	self modelWakeUp
]

Object >> mustBeBoolean
[
	"Catches attempts to test truth of non-Booleans.  This message is sent from the VM.  The sending context is rewound to just before the jump causing this exception."

	^ self mustBeBooleanIn: thisContext sender
]

Object >> mustBeBooleanIn: context
[
	"context is the where the non-boolean error occurred. Rewind context to before jump then raise error."

	| proceedValue |
	context skipBackBeforeJump.
	proceedValue := NonBooleanReceiver new
		object: self;
		signal: 'proceed for truth.'.
	^ proceedValue ~~ false
]

Object >> myDependents
[
	"Private. Answer a list of all the receiver's dependents."

	^ DependentsFields at: self ifAbsent: [  ]
]

Object >> myDependents: aCollectionOrNil
[
	"Private. Set (or remove) the receiver's dependents list."

	aCollectionOrNil
		ifNil: [ DependentsFields removeKey: self ifAbsent: [  ] ]
		ifNotNil: [ DependentsFields at: self put: aCollectionOrNil ]
]

Object >> name
[
	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  "

	^ self printString
]

Object >> nominallyUnsent: aSelectorSymbol
[
	"From within the body of a method which is not formally sent within the system, but which you intend to have remain in the system (for potential manual invocation, or for documentation, or perhaps because it's sent by commented-out-code that you anticipate uncommenting out someday, send this message, with the selector itself as the argument.

This will serve two purposes:

	(1)  The method will not be returned by searches for unsent selectors (because it, in a manner of speaking, sends itself).
	(2)	You can locate all such methods by browsing senders of #nominallyUnsent:"

	false
		ifTrue: [ self flag: #nominallyUnsent: ]	"So that this method itself will appear to be sent"
]

Object >> notNil
[
	"Coerces nil to false and everything else to true."

	^ true
]

Object >> notYetImplemented
[
	"Announce that this message is not yet implemented"

	NotYetImplemented signalFor: thisContext sender selector
]

Object >> noteSelectionIndex: anInteger for: aSymbol
[
	"backstop"

	
]

Object >> notify: aString
[
	"Create and schedule a Notifier with the argument as the message in 
	order to request confirmation before a process can proceed."

	Warning signal: aString
]

Object >> notify: aString at: location
[
	"Create and schedule a Notifier with the argument as the message in 
	order to request confirmation before a process can proceed. Subclasses can
	override this and insert an error message at location within aString."

	self notify: aString	"nil notify: 'confirmation message' at: 12"
]

Object >> okToChange
[
	"Allows a controller to ask this of any model"

	^ true
]

Object >> pointsOnlyWeaklyTo: anObject
[
	"Assume, we already know that receiver points to an object,
	answer true if receiver points only weakly to it "

	self class isWeak
		ifFalse: [ ^ false ].
	1 to: self class instSize do: [ :i | (self instVarAt: i) == anObject
			ifTrue: [ ^ false ] ].
	^ true
]

Object >> postCopy
[
	"I'm a hook method in the sense of Design Patterns TemplateHook/Methods. I'm called by copy. self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"

	^ self
]

Object >> primitiveChangeClassTo: anObject
[
	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.
	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).
	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."

	<primitive: 115>
	self primitiveFailed
]

Object >> primitiveFail
[
	"primitiveFail may be invoked by certain methods whose code is translated in C. In such a case primitiveFail and not primitiveFailed
	 should be invoked. The reason is that this code is translated to C by VMMaker. #primitiveFail is 
	implemented in Interpreter of VMMaker."

	^ self primitiveFailed
]

Object >> primitiveFailed
[
	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."

	self primitiveFailed: thisContext sender selector
]

Object >> primitiveFailed: selector
[
	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."

	PrimitiveFailed signalFor: selector
]

Object >> printOn: aStream
[
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver."

	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel
						ifTrue: [ 'an ' ]
						ifFalse: [ 'a ' ]);
		nextPutAll: title
]

Object >> printString
[
	"Answer a String whose characters are a description of the receiver. 
	If you want to print without a character limit, use fullPrintString."

	^ self printStringLimitedTo: 50000
]

Object >> printStringLimitedTo: limit
[
	"Answer a String whose characters are a description of the receiver.
	If you want to print without a character limit, use fullPrintString."

	| limitedString |
	limitedString := String streamContents: [ :s | self printOn: s ] limitedTo: limit.
	limitedString size < limit
		ifTrue: [ ^ limitedString ].
	^ limitedString , '...etc...'
]

Object >> printWithClosureAnalysisOn: aStream
[
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver."

	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel
						ifTrue: [ 'an ' ]
						ifFalse: [ 'a ' ]);
		nextPutAll: title
]

Object >> putOn: aStream
[
	^ aStream nextPut: self
]

Object >> readFromString: aString
[
	"Create an object based on the contents of aString."

	^ self readFrom: aString readStream
]

Object >> refersToLiteral: literal
[
	"Answer true if literal is identical to any literal in this array, even if imbedded in further structures.  This is the end of the imbedded structure path so return false."

	^ false
]

Object >> refusesToAcceptCode
[
	"Answer whether the receiver is a code-bearing instrument which at the moment refuses to allow its contents to be submitted"

	^ false
]

Object >> release
[
	"Remove references to objects that may refer to the receiver. This message 
	should be overridden by subclasses with any cycles, in which case the 
	subclass should also include the expression super release."

	self releaseActionMap
]

Object >> releaseActionMap
[
	EventManager releaseActionMapFor: self
]

Object >> removeAction: anAction forEvent: anEventSelector
[
	self removeActionsSatisfying: [ :action | action = anAction ] forEvent: anEventSelector
]

Object >> removeActionsForEvent: anEventSelector
[
	| map |
	map := self actionMap.
	map removeKey: anEventSelector asSymbol ifAbsent: [  ].
	map isEmpty
		ifTrue: [ self releaseActionMap ]
]

Object >> removeActionsSatisfying: aBlock
[
	self actionMap keys do: [ :eachEventSelector | self removeActionsSatisfying: aBlock forEvent: eachEventSelector ]
]

Object >> removeActionsSatisfying: aOneArgBlock forEvent: anEventSelector
[
	self
		setActionSequence:
			((self actionSequenceForEvent: anEventSelector) reject: [ :anAction | aOneArgBlock value: anAction ])
		forEvent: anEventSelector
]

Object >> removeActionsWithReceiver: anObject
[
	self actionMap copy
		keysDo: [ :eachEventSelector | self removeActionsSatisfying: [ :anAction | anAction receiver == anObject ] forEvent: eachEventSelector ]
]

Object >> removeActionsWithReceiver: anObject forEvent: anEventSelector
[
	self removeActionsSatisfying: [ :anAction | anAction receiver == anObject ] forEvent: anEventSelector
]

Object >> removeDependent: anObject
[
	"Remove the given object as one of the receiver's dependents."

	| dependents |
	dependents := self dependents reject: [ :each | each == anObject ].
	self myDependents: (dependents isEmpty
				ifFalse: [ dependents ]).
	^ anObject
]

Object >> requirement
[
	self error: 'Implicitly required method'
]

Object >> respondsTo: aSymbol
[
	"Answer whether the method dictionary of the receiver's class contains 
	aSymbol as a message selector."

	^ self class canUnderstand: aSymbol
]

Object >> retryWithGC: execBlock until: testBlock
[
	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."

	| blockValue |
	blockValue := execBlock value.
	(testBlock value: blockValue)
		ifTrue: [ ^ blockValue ].
	Smalltalk garbageCollectMost.
	blockValue := execBlock value.
	(testBlock value: blockValue)
		ifTrue: [ ^ blockValue ].
	Smalltalk garbageCollect.
	^ execBlock value
]

Object >> setActionSequence: actionSequence forEvent: anEventSelector
[
	| action |
	action := actionSequence asMinimalRepresentation.
	action == nil
		ifTrue: [ self removeActionsForEvent: anEventSelector ]
		ifFalse: [ self updateableActionMap at: anEventSelector asSymbol put: action ]
]

Object >> shallowCopy
[
	"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method."

	<primitive: 148>
	| class newObject index |
	class := self class.
	class isVariable
		ifTrue: [ index := self basicSize.
			newObject := class basicNew: index.
			[ index > 0 ] whileTrue: [ newObject basicAt: index put: (self basicAt: index).
					index := index - 1 ] ]
		ifFalse: [ newObject := class basicNew ].
	index := class instSize.
	[ index > 0 ] whileTrue: [ newObject instVarAt: index put: (self instVarAt: index).
			index := index - 1 ].
	^ newObject
]

Object >> shouldBeImplemented
[
	"Announce that this message should be implemented"

	ShouldBeImplemented signalFor: thisContext sender selector
]

Object >> shouldBePrintedAsLiteral
[
	^ self isLiteral
]

Object >> shouldNotImplement
[
	"Announce that, although the receiver inherits this message, 
	it should not implement it."

	ShouldNotImplement signalFor: thisContext sender selector
]

Object >> size
[
	"Primitive. Answer the number of indexable variables in the receiver. 
	This value is the same as the largest legal subscript. Essential. See Object 
	documentation whatIsAPrimitive."

	<primitive: 62>
	self class isVariable
		ifFalse: [ self errorNotIndexable ].
	^ 0
]

Object >> sizeInMemory
[
	"Answer the number of bytes consumed by this instance including object header."

	| contentBytes |
	contentBytes := Smalltalk wordSize.	"base header"
	contentBytes := contentBytes + (self class instSize * Smalltalk wordSize).	"instance vars"
	self class isVariable
		ifTrue: [ | bytesPerElement |
			"indexed elements"
			bytesPerElement := self class isBytes
				ifTrue: [ 1 ]
				ifFalse: [ 4 ].
			contentBytes := contentBytes + (self basicSize * bytesPerElement) ].
	contentBytes > 255
		ifTrue: [ contentBytes := contentBytes + (2 * Smalltalk wordSize) ]
		ifFalse: [ self class isCompact
				ifFalse: [ contentBytes := contentBytes + Smalltalk wordSize ] ].
	^ contentBytes
]

Object >> someObject
[
	"Primitive. Answer the first object in the enumeration of all
	 objects."

	<primitive: 138>
	self primitiveFailed
]

Object >> species
[
	"Answer the preferred class for reconstructing the receiver.  For example, 
	collections create new collections whenever enumeration messages such as 
	collect: or select: are invoked.  The new kind of collection is determined by 
	the species of the original collection.  Species and class are not always the 
	same.  For example, the species of Interval is Array."

	<primitive: 111>
	^ self class
]

Object >> stepAt: millisecondClockValue in: aWindow
[
	^ self stepIn: aWindow
]

Object >> stepIn: aWindow
[
	^ self step
]

Object >> stepTime
[
	^ 1000	"milliseconds -- default backstop for objects serving as models of system windows"
]

Object >> stepTimeIn: aSystemWindow
[
	^ 1000	"milliseconds -- default backstop for objects serving as models of system windows"
]

Object >> storeAt: offset inTempFrame: aContext
[
	"This message had to get sent to an expression already on the stack
	as a Block argument being accessed by the debugger.
	Just re-route it to the temp frame."

	^ aContext tempAt: offset put: self
]

Object >> storeOn: aStream
[
	"Append to the argument aStream a sequence of characters that is an 
	expression whose evaluation creates an object similar to the receiver."

	aStream nextPut: $(.
	self class isVariable
		ifTrue: [ aStream
				nextPutAll: '(' , self class name , ' basicNew: ';
				store: self basicSize;
				nextPutAll: ') ' ]
		ifFalse: [ aStream nextPutAll: self class name , ' basicNew' ].
	1 to: self class instSize do: [ :i | aStream
			nextPutAll: ' instVarAt: ';
			store: i;
			nextPutAll: ' put: ';
			store: (self instVarAt: i);
			nextPut: $; ].
	1 to: self basicSize do: [ :i | aStream
			nextPutAll: ' basicAt: ';
			store: i;
			nextPutAll: ' put: ';
			store: (self basicAt: i);
			nextPut: $; ].
	aStream nextPutAll: ' yourself)'
]

Object >> storeString
[
	"Answer a String representation of the receiver from which the receiver 
	can be reconstructed."

	^ String streamContents: [ :s | self storeOn: s ]
]

Object >> subclassResponsibility
[
	"This message sets up a framework for the behavior of the class' subclasses.
	Announce that the subclass should have implemented this message."

	SubclassResponsibility signalFor: thisContext sender selector
]

Object >> toFinalizeSend: aSelector to: aFinalizer with: aResourceHandle
[
	"When I am finalized (e.g., garbage collected) close the associated resource handle by sending aSelector to the appropriate finalizer (the guy who knows how to get rid of the resource).
	WARNING: Neither the finalizer nor the resource handle are allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."

	self == aFinalizer
		ifTrue: [ self error: 'I cannot finalize myself' ].
	self == aResourceHandle
		ifTrue: [ self error: 'I cannot finalize myself' ].
	^ self finalizationRegistry
		add: self
		executor: (ObjectFinalizer new receiver: aFinalizer selector: aSelector argument: aResourceHandle)
]

Object >> trace
[
	self trace: self printString
]

Object >> trace: aString
[
	"Log the argument. Use self trace: instead of Transcript show: "

	Transcript show: aString
]

Object >> traceCr
[
	self traceCr: self printString
]

Object >> traceCr: aString
[
	"Log the argument. Use self traceCr: 'something' instead of Transcript show: 'something'  ; cr "

	Transcript
		show: aString;
		cr
]

Object >> traitConflict
[
	self error: 'A class or trait does not properly resolve a conflict between multiple traits it uses.'
]

Object >> triggerEvent: anEventSelector
[
	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."

	^ (self actionForEvent: anEventSelector) value
]

Object >> triggerEvent: anEventSelector ifNotHandled: anExceptionBlock
[
	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."

	^ (self actionForEvent: anEventSelector ifAbsent: [ ^ anExceptionBlock value ]) value
]

Object >> triggerEvent: anEventSelector with: anObject
[
	^ self triggerEvent: anEventSelector withArguments: (Array with: anObject)
]

Object >> triggerEvent: anEventSelector with: anObject ifNotHandled: anExceptionBlock
[
	^ self triggerEvent: anEventSelector withArguments: (Array with: anObject) ifNotHandled: anExceptionBlock
]

Object >> triggerEvent: anEventSelector withArguments: anArgumentList
[
	^ (self actionForEvent: anEventSelector) valueWithArguments: anArgumentList
]

Object >> triggerEvent: anEventSelector withArguments: anArgumentList ifNotHandled: anExceptionBlock
[
	^ (self actionForEvent: anEventSelector ifAbsent: [ ^ anExceptionBlock value ]) valueWithArguments: anArgumentList
]

Object >> update: aParameter
[
	"Receive a change notice from an object of whom the receiver is a 
	dependent. The default behavior is to do nothing; a subclass might want 
	to change itself in some way."

	^ self
]

Object >> update: anAspect with: anObject
[
	"Receive a change notice from an object of whom the receiver is a 
	dependent. The default behavior is to call update:,
	which by default does nothing; a subclass might want 
	to change itself in some way."

	^ self update: anAspect
]

Object >> updateableActionMap
[
	^ EventManager updateableActionMapFor: self
]

Object >> value
[
	^ self
]

Object >> valueWithArguments: aSequenceOfArguments
[
	^ self
]

Object >> veryDeepCopy
[
	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy."

	| copier new |
	copier := DeepCopier new initialize: 4096.	"self initialDeepCopierSize"
	new := self veryDeepCopyWith: copier.
	copier references associationsDo: [ :assoc | assoc value veryDeepFixupWith: copier ].
	copier fixDependents.
	^ new
]

Object >> veryDeepCopyWith: deepCopier
[
	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."

	| class index sub subAss new sup has mine |
	deepCopier references at: self ifPresent: [ :newer | ^ newer ].	"already did him"
	class := self class.
	class isMeta
		ifTrue: [ ^ self ].	"a class"
	new := self shallowCopy.
	deepCopier references at: self put: new.	"remember"
	(class isVariable and: [ class isPointers ])
		ifTrue: [ index := self basicSize.
			[ index > 0 ]
				whileTrue: [ sub := self basicAt: index.
					(subAss := deepCopier references associationAt: sub ifAbsent: [ nil ])
						ifNil: [ new basicAt: index put: (sub veryDeepCopyWith: deepCopier) ]
						ifNotNil: [ new basicAt: index put: subAss value ].
					index := index - 1 ] ].	"Ask each superclass if it wants to share (weak copy) any inst vars"
	new veryDeepInner: deepCopier.	"does super a lot"	"other superclasses want all inst vars deep copied"
	sup := class.
	index := class instSize.
	[ has := sup compiledMethodAt: #veryDeepInner: ifAbsent: [ nil ].
	has := has ifNil: [ false ] ifNotNil: [ true ].
	mine := sup instVarNames.
	has
		ifTrue: [ index := index - mine size ]
		ifFalse: [ 1 to: mine size do: [ :xx | sub := self instVarAt: index.
				(subAss := deepCopier references associationAt: sub ifAbsent: [ nil ])
					ifNil: [ new instVarAt: index put: (sub veryDeepCopyWith: deepCopier) ]
					ifNotNil: [ new instVarAt: index put: subAss value ].	"use association, not value, so nil is an exceptional value"
				index := index - 1 ] ].	"skip inst vars"
	(sup := sup superclass) == nil ]
		whileFalse.
	(new isKindOf: HashedCollection)
		ifTrue: [ new rehash ].	"force Sets and Dictionaries to rehash"
	^ new
]

Object >> veryDeepFixupWith: deepCopier
[
	"I have no fields and no superclass.  Catch the super call."

	"avoid to use me we will deprecate it in the future"

	
]

Object >> veryDeepInner: deepCopier
[
	"No special treatment for inst vars of my superclasses.  Override when some need to be weakly copied.  Object>>veryDeepCopyWith: will veryDeepCopy any inst var whose class does not actually define veryDeepInner:"

	"avoid to use me we will deprecate it in the future"

	
]

Object >> wantsDiffFeedback
[
	"Answer whether the receiver, serving as the model of a text-bearing entity, would like for 'diffs' green pane-border feedback to be shown"

	^ false
]

Object >> wantsDroppedMorph: aMorph event: anEvent inMorph: destinationLM
[
	^ false
]

Object >> wantsSteps
[
	"Overridden by morphic classes whose instances want to be stepped,
	or by model classes who want their morphic views to be stepped."

	^ false
]

Object >> wantsStepsIn: aSystemWindow
[
	^ self wantsSteps
]

Object >> when: anEventSelector evaluate: anAction
[
	| actions |
	actions := self actionSequenceForEvent: anEventSelector.
	(actions includes: anAction)
		ifTrue: [ ^ self ].
	self setActionSequence: (actions copyWith: anAction) forEvent: anEventSelector
]

Object >> when: anEventSelector send: aMessageSelector to: anObject
[
	self when: anEventSelector evaluate: (WeakMessageSend receiver: anObject selector: aMessageSelector)
]

Object >> when: anEventSelector send: aMessageSelector to: anObject with: anArg
[
	self
		when: anEventSelector
		evaluate: (WeakMessageSend receiver: anObject selector: aMessageSelector arguments: (Array with: anArg))
]

Object >> when: anEventSelector send: aMessageSelector to: anObject withArguments: anArgArray
[
	self
		when: anEventSelector
		evaluate: (WeakMessageSend receiver: anObject selector: aMessageSelector arguments: anArgArray)
]

Object >> windowIsClosing
[
	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."

	
]

Object >> withoutListWrapper
[
	^ self
]

Object >> yourself
[
	"Answer self."

	^ self
]

Object >> ~= anObject
[
	"Answer whether the receiver and the argument do not represent the 
	same object."

	^ self = anObject == false
]

Object class >> flushDependents
[
	DependentsFields keysAndValuesDo: [ :key :dep | key ifNotNil: [ key removeDependent: nil ] ].
	DependentsFields finalizeValues
]

Object class >> flushEvents
[
	"Object flushEvents"

	EventManager flushEvents
]

Object class >> howToModifyPrimitives
[
	"You are allowed to write methods which specify primitives, but please use 
	caution.  If you make a subclass of a class which contains a primitive method, 
	the subclass inherits the primitive.  The message which is implemented 
	primitively may be overridden in the subclass (E.g., see at:put: in String's 
	subclass Symbol).  The primitive behavior can be invoked using super (see 
	Symbol string:). 
	 
	A class which attempts to mimic the behavior of another class without being 
	its subclass may or may not be able to use the primitives of the original class.  
	In general, if the instance variables read or written by a primitive have the 
	same meanings and are in the same fields in both classes, the primitive will 
	work.  

	For certain frequently used 'special selectors', the compiler emits a 
	send-special-selector bytecode instead of a send-message bytecode.  
	Special selectors were created because they offer two advantages.  Code 
	which sends special selectors compiles into fewer bytes than normal.  For 
	some pairs of receiver classes and special selectors, the interpreter jumps 
	directly to a primitive routine without looking up the method in the class.  
	This is much faster than a normal message lookup. 
	 
	A selector which is a special selector solely in order to save space has a 
	normal behavior.  Methods whose selectors are special in order to 
	gain speed contain the comment, 'No Lookup'.  When the interpreter 
	encounters a send-special-selector bytecode, it checks the class of the 
	receiver and the selector.  If the class-selector pair is a no-lookup pair, 
	then the interpreter swiftly jumps to the routine which implements the 
	corresponding primitive.  (A special selector whose receiver is not of the 
	right class to make a no-lookup pair, is looked up normally).  The pairs are 
	listed below.  No-lookup methods contain a primitive number specification, 
	<primitive: xx>, which is redundant.  Since the method is not normally looked 
	up, deleting the primitive number specification cannot prevent this 
	primitive from running.  If a no-lookup primitive fails, the method is looked 
	up normally, and the expressions in it are executed. 
	 
	No Lookup pairs of (class, selector) 
	 
	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 
	SmallInteger with any of		=  ~=  >  <  >=  <= 
	Any class with					== 
	Any class with 					@ 
	Point with either of				x y 
	ContextPart with					blockCopy: 
	BlockContext with either of 		value value:
	"

	self error: 'comment only'
]

Object class >> initialize
[
	"Object initialize"

	DependentsFields ifNil: [ self initializeDependentsFields ]
]

Object class >> initializeDependentsFields
[
	"Object initialize"

	DependentsFields := WeakIdentityKeyDictionary new
]

Object class >> newFrom: aSimilarObject
[
	"Create an object that has similar contents to aSimilarObject. If the classes have any instance varaibles with the same names, copy them across. If this is bad for a class, override this method."

	^ (self isVariable
		ifTrue: [ self basicNew: aSimilarObject basicSize ]
		ifFalse: [ self basicNew ]) copySameFrom: aSimilarObject
]

Object class >> reInitializeDependentsFields
[
	"Object reInitializeDependentsFields"

	| oldFields |
	oldFields := DependentsFields.
	DependentsFields := WeakIdentityKeyDictionary new.
	oldFields keysAndValuesDo: [ :obj :deps | deps do: [ :d | obj addDependent: d ] ]
]

Object class >> whatIsAPrimitive
[
	"Some messages in the system are responded to primitively. A primitive   
	response is performed directly by the interpreter rather than by evaluating   
	expressions in a method. The methods for these messages indicate the   
	presence of a primitive response by including <primitive: xx> before the   
	first expression in the method.   
	  
	Primitives exist for several reasons. Certain basic or 'primitive' 
	operations cannot be performed in any other way. Smalltalk without 
	primitives can move values from one variable to another, but cannot add two 
	SmallIntegers together. Many methods for arithmetic and comparison 
	between numbers are primitives. Some primitives allow Smalltalk to 
	communicate with I/O devices such as the disk, the display, and the keyboard. 
	Some primitives exist only to make the system run faster; each does the same 
	thing as a certain Smalltalk method, and its implementation as a primitive is 
	optional.  
	  
	When the Smalltalk interpreter begins to execute a method which specifies a 
	primitive response, it tries to perform the primitive action and to return a 
	result. If the routine in the interpreter for this primitive is successful, 
	it will return a value and the expressions in the method will not be evaluated. 
	If the primitive routine is not successful, the primitive 'fails', and the 
	Smalltalk expressions in the method are executed instead. These 
	expressions are evaluated as though the primitive routine had not been 
	called.  
	  
	The Smalltalk code that is evaluated when a primitive fails usually 
	anticipates why that primitive might fail. If the primitive is optional, the 
	expressions in the method do exactly what the primitive would have done (See 
	Number @). If the primitive only works on certain classes of arguments, the 
	Smalltalk code tries to coerce the argument or appeals to a superclass to find 
	a more general way of doing the operation (see SmallInteger +). If the 
	primitive is never supposed to fail, the expressions signal an error (see 
	SmallInteger asFloat).  
	  
	Each method that specifies a primitive has a comment in it. If the primitive is 
	optional, the comment will say 'Optional'. An optional primitive that is not 
	implemented always fails, and the Smalltalk expressions do the work 
	instead.  
	 
	If a primitive is not optional, the comment will say, 'Essential'. Some 
	methods will have the comment, 'No Lookup'. See Object 
	howToModifyPrimitives for an explanation of special selectors which are 
	not looked up.  
	  
	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 
	in Float, the primitive constructs and returns a 16-bit 
	LargePositiveInteger when the result warrants it. Returning 16-bit 
	LargePositiveIntegers from these primitives instead of failing is 
	optional in the same sense that the LargePositiveInteger arithmetic 
	primitives are optional. The comments in the SmallInteger primitives say, 
	'Fails if result is not a SmallInteger', even though the implementor has the 
	option to construct a LargePositiveInteger. For further information on 
	primitives, see the 'Primitive Methods' part of the chapter on the formal 
	specification of the interpreter in the Smalltalk book."

	self error: 'comment only'
]

