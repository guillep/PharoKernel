LimitingLineStreamWrapper
	instanceVariables: #(#stream #line #limitingBlock #position );
	package: #'Collections-Streams'.

LimitingLineStreamWrapper >> atEnd
atEnd
	^ line isNil or: [ limitingBlock value: line ]

LimitingLineStreamWrapper >> close
close
	^ stream close

LimitingLineStreamWrapper >> delimiter: aString
delimiter: aString
	"Set limitBlock to check for a delimiting string. Be unlimiting if nil"

	self
		limitingBlock:
			(aString
				caseOf: {([ nil ] -> [ [ :aLine | false ] ]).
					([ '' ] -> [ [ :aLine | aLine size = 0 ] ])}
				otherwise: [ [ :aLine | aLine beginsWith: aString ] ])

LimitingLineStreamWrapper >> lastLineRead
lastLineRead
	"Return line last read. At stream end, this is the boundary line or nil"

	^ line

LimitingLineStreamWrapper >> limitingBlock: aBlock
limitingBlock: aBlock
	"The limitingBlock is evaluated with a line to check if this line terminates the stream"

	limitingBlock := aBlock.
	self updatePosition

LimitingLineStreamWrapper >> linesUpToEnd
linesUpToEnd
	| elements ln |
	elements := OrderedCollection new.
	[ (ln := self nextLine) isNil ] whileFalse: [ elements add: ln ].
	^ elements

LimitingLineStreamWrapper >> next
next
	"Provide character-based access"

	position ifNil: [ ^ nil ].
	position < line size
		ifTrue: [ ^ line at: (position := position + 1) ].
	line := stream nextLine.
	self updatePosition.
	^ Character cr

LimitingLineStreamWrapper >> nextLine
nextLine
	| thisLine |
	self atEnd
		ifTrue: [ ^ nil ].
	thisLine := line.
	line := stream nextLine.
	^ thisLine

LimitingLineStreamWrapper >> peekLine
peekLine
	self atEnd
		ifTrue: [ ^ nil ].
	^ line

LimitingLineStreamWrapper >> printOn: aStream
printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: ' on '.
	stream printOn: aStream

LimitingLineStreamWrapper >> setStream: aStream delimiter: aString
setStream: aStream delimiter: aString
	stream := aStream.
	line := stream nextLine.
	self delimiter: aString	"sets position"

LimitingLineStreamWrapper >> skipThisLine
skipThisLine
	line := stream nextLine.
	self updatePosition

LimitingLineStreamWrapper >> upToEnd
upToEnd
	^ String
		streamContents: [ :strm | | ln |
			[ (ln := self nextLine) isNil ] whileFalse: [ strm
						nextPutAll: ln;
						cr ] ]

LimitingLineStreamWrapper >> updatePosition
updatePosition
	"Call this before doing character-based access"

	position := self atEnd
		ifFalse: [ 0 ]

LimitingLineStreamWrapper class >> example1
example1
	"LimitingLineStreamWrapper example1"

	"Separate chunks of text delimited by a special string"

	| inStream msgStream messages |
	inStream := self exampleStream.
	msgStream := LimitingLineStreamWrapper on: inStream delimiter: 'From '.
	messages := OrderedCollection new.
	[ inStream atEnd ] whileFalse: [ msgStream skipThisLine.
			messages add: msgStream upToEnd ].
	^ messages

LimitingLineStreamWrapper class >> example2
example2
	"LimitingLineStreamWrapper example2"

	"Demo nesting wrappers - get header lines from some messages"

	| inStream msgStream headers headerStream |
	inStream := self exampleStream.
	msgStream := LimitingLineStreamWrapper on: inStream delimiter: 'From '.
	headers := OrderedCollection new.
	[ inStream atEnd ]
		whileFalse: [ msgStream skipThisLine.	"Skip From"
			headerStream := LimitingLineStreamWrapper on: msgStream delimiter: ''.
			headers add: headerStream linesUpToEnd.
			[ msgStream nextLine isNil ] whileFalse	"Skip Body" ].
	^ headers

LimitingLineStreamWrapper class >> exampleStream
exampleStream
	^ 'From me@somewhereFrom: meTo: youSubject: TestTestFrom you@elsewhereFrom: youTo: meSubject: Re: testokay' readStream

LimitingLineStreamWrapper class >> on: aStream delimiter: aString
on: aStream delimiter: aString
	^ self new setStream: aStream delimiter: aString

