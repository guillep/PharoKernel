Class
	name: #MultiByteBinaryOrTextStream;
	superclass: #ClassReadWriteStream;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#isBinary #converter );
	classVariables: #();
	package: #'Collections-Streams'.

Class MultiByteBinaryOrTextStream >> asBinaryOrTextStream
[
^ self
]

Class MultiByteBinaryOrTextStream >> ascii
[
isBinary := false
]

Class MultiByteBinaryOrTextStream >> basicNext
[
^ super next
]

Class MultiByteBinaryOrTextStream >> basicNext: anInteger
[
^ super next: anInteger
]

Class MultiByteBinaryOrTextStream >> basicNext: n into: aString
[
^ super next: n into: aString
]

Class MultiByteBinaryOrTextStream >> basicNextInto: aString
[
^ super nextInto: aString
]

Class MultiByteBinaryOrTextStream >> basicNextPut: char
[
^ super nextPut: char
]

Class MultiByteBinaryOrTextStream >> basicNextPutAll: aString
[
^ super nextPutAll: aString
]

Class MultiByteBinaryOrTextStream >> basicPeek
[
^ super peek
]

Class MultiByteBinaryOrTextStream >> basicPosition
[
^ super position
]

Class MultiByteBinaryOrTextStream >> basicPosition: pos
[
^ super position: pos
]

Class MultiByteBinaryOrTextStream >> binary
[
isBinary := true
]

Class MultiByteBinaryOrTextStream >> contents
[
| ret state |state := converter saveStateOf: self.ret := self upToEnd.converter restoreStateOf: self with: state.^ ret
]

Class MultiByteBinaryOrTextStream >> converter
[
converter ifNil: [ converter := self class defaultConverter ].^ converter
]

Class MultiByteBinaryOrTextStream >> converter: aConverter
[
converter := aConverter
]

Class MultiByteBinaryOrTextStream >> guessConverter
[
^ (self originalContents includesSubString: #[27 36] asString)	ifTrue: [ CompoundTextConverter new ]	ifFalse: [ self class defaultConverter ]
]

Class MultiByteBinaryOrTextStream >> isBinary
[
^ isBinary
]

Class MultiByteBinaryOrTextStream >> next
[
| n |n := self converter nextFromStream: self.n ifNil: [ ^ nil ].isBinary	and: [ 		n isCharacter			ifTrue: [ ^ n asciiValue ] ].^ n
]

Class MultiByteBinaryOrTextStream >> next: anInteger
[
| multiString |"self halt."self isBinary	ifTrue: [ ^ (super next: anInteger) asByteArray ].multiString := WideString new: anInteger.1 to: anInteger do: [ :index | 	| character |	(character := self next)		ifNotNil: [ multiString at: index put: character ]		ifNil: [ 			multiString := multiString copyFrom: 1 to: index - 1.			^ multiString ] ].^ multiString
]

Class MultiByteBinaryOrTextStream >> nextDelimited: terminator
[
| out ch pos |out := (String new: 1000) writeStream.self atEnd	ifTrue: [ ^ '' ].pos := self position.self next = terminator	ifFalse: [ 		"absorb initial terminator"		self position: pos ].[ (ch := self next) == nil ]	whileFalse: [ 		ch = terminator			ifTrue: [ 				self peek = terminator					ifTrue: [ self next	"skip doubled terminator" ]					ifFalse: [ ^ out contents	"terminator is not doubled; we're done!" ] ].		out nextPut: ch ].^ out contents
]

Class MultiByteBinaryOrTextStream >> nextMatchAll: aColl
[
| save |save := converter saveStateOf: self.aColl	do: [ :each | 		self next = each			ifFalse: [ 				converter restoreStateOf: self with: save.				^ false ] ].^ true
]

Class MultiByteBinaryOrTextStream >> nextPut: aCharacter
[
^ aCharacter isInteger	ifTrue: [ super nextPut: aCharacter asCharacter ]	ifFalse: [ self converter nextPut: aCharacter toStream: self ]
]

Class MultiByteBinaryOrTextStream >> nextPutAll: aCollection
[
^ self isBinary	ifTrue: [ super nextPutAll: aCollection ]	ifFalse: [ aCollection do: [ :each | self nextPut: each ] ]
]

Class MultiByteBinaryOrTextStream >> padToEndWith: aChar
[
	"We don't have pages, so we are at the end, and don't need to pad."

]

Class MultiByteBinaryOrTextStream >> peek
[
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
| next pos |self atEnd	ifTrue: [ ^ nil ].pos := self position.next := self next.self position: pos.^ next
]

Class MultiByteBinaryOrTextStream >> peekFor: item
[
| next state |"self atEnd ifTrue: [^ false]. -- SFStream will give nil"state := converter saveStateOf: self.(next := self next) == nil	ifTrue: [ ^ false ].item = next	ifTrue: [ ^ true ].converter restoreStateOf: self with: state.^ false
]

Class MultiByteBinaryOrTextStream >> reset
[
super reset.isBinary ifNil: [ isBinary := false ].collection class == ByteArray	ifTrue: [ 		"Store as String and convert as needed."		collection := collection asString.		isBinary := true ].self converter	"ensure that we have a converter."
]

Class MultiByteBinaryOrTextStream >> setConverterForCode
[
| current |current := converter saveStateOf: self.self position: 0.self binary.(self next: 3) = #[239 187 191]	ifTrue: [ self converter: UTF8TextConverter new ]	ifFalse: [ self converter: MacRomanTextConverter new ].converter restoreStateOf: self with: current.self text
]

Class MultiByteBinaryOrTextStream >> setEncoderForSourceCodeNamed: streamName
[
| l |l := streamName asLowercase.((l endsWith: 'cs') or: [ (l endsWith: 'st') or: [ (l endsWith: 'st.gz') or: [ l endsWith: 'st.gz' ] ] ])	ifTrue: [ 		self converter: MacRomanTextConverter new.		^ self ].self converter: UTF8TextConverter new
]

Class MultiByteBinaryOrTextStream >> setFileTypeToObject
[
	"do nothing.  We don't have a file type"

]

Class MultiByteBinaryOrTextStream >> skipSeparators
[
[ self atEnd ]	whileFalse: [ 		self basicNext isSeparator			ifFalse: [ ^ self position: self position - 1 ] ]
]

Class MultiByteBinaryOrTextStream >> skipSeparatorsAndPeekNext
[
	"A special function to make nextChunk fast"
| peek pos |[ self atEnd ]	whileFalse: [ 		pos := self position.		(peek := self next) isSeparator			ifFalse: [ 				self position: pos.				^ peek ] ]
]

Class MultiByteBinaryOrTextStream >> text
[
isBinary := false
]

Class MultiByteBinaryOrTextStream >> upTo: delim
[
| out ch |out := (String new: 1000) writeStream.self atEnd	ifTrue: [ ^ '' ].[ (ch := self next) isNil ]	whileFalse: [ 		ch = delim			ifTrue: [ ^ out contents	"terminator is not doubled; we're done!" ].		out nextPut: ch ].^ out contents
]

Class MultiByteBinaryOrTextStream >> upToEnd
[
| newStream element newCollection |newCollection := self isBinary	ifTrue: [ ByteArray new: 100 ]	ifFalse: [ String new: 100 ].newStream := newCollection writeStream.[ (element := self next) notNil ] whileTrue: [ newStream nextPut: element ].^ newStream contents
]

Metaclass
	name: #MultiByteBinaryOrTextStream;
	instanceVariables: #().

Metaclass MultiByteBinaryOrTextStream >> defaultConverter
[
^ Latin1TextConverter new
]

Metaclass MultiByteBinaryOrTextStream >> on: aCollection encoding: encodingName
[
| aTextConverter |encodingName isNil	ifTrue: [ aTextConverter := TextConverter default ]	ifFalse: [ aTextConverter := TextConverter newForEncoding: encodingName ].^ (self on: aCollection) converter: aTextConverter
]

Metaclass MultiByteBinaryOrTextStream >> with: aCollection encoding: encodingName
[
| aTextConverter |encodingName isNil	ifTrue: [ aTextConverter := TextConverter default ]	ifFalse: [ aTextConverter := TextConverter newForEncoding: encodingName ].^ (self with: aCollection) converter: aTextConverter
]

