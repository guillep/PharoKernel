RPackage
	instanceVariables: #(#classDefinedSelectors #metaclassDefinedSelectors #classExtensionSelectors #metaclassExtensionSelectors #classes #name #classTags );
	classVariables: #(#PackageGlobalOrganizer );
	package: #'RPackage-Core'.

RPackage >> <= aRPackage
[
	^ self name <= aRPackage name
]

RPackage >> addClass: aClass
[
	"TODO: deprecate system category / replace this with a direct call to moveClass:fromPackage:toTag:"

	"This does two things:
		- make sure the class tag for ourselves exists
		- change the class category as appropriate.
			(and by cascade, ensure systemClassRecategorizedAction: is called)."

	aClass category: (self addClassTag: self categoryName) categoryName
]

RPackage >> addClassDefinition: aClass
[
	"Add only the class definition of aClass, as a class defined by the receiver. The term classdefinition denotes the fact that we do not treat its methods. aClass methods are not added to the package. aClass can be either a class or a metaclass"

	self addClassDefinitionName: aClass theNonMetaClass name
]

RPackage >> addClassDefinition: aClass toClassTag: aSymbol
[
	"Tags the class aClass with the tag aSymbol"

	self addClassDefinitionName: aClass name toClassTag: aSymbol
]

RPackage >> addClassDefinitionName: aClassName
[
	"aClassName should only be a class (and not a metaclass name)"

	| aClassNameSymbol |
	('* class' match: aClassName)
		ifTrue: [ ^ self error: 'no metaclass name' ].
	aClassNameSymbol := aClassName asSymbol.
	(classes includes: aClassNameSymbol)
		ifTrue: [ ^ self ].
	classes add: aClassNameSymbol.
	self extendedMethodsShouldBecomeDefinedWhenAddingClassName: aClassNameSymbol.
	self registerClassName: aClassNameSymbol
]

RPackage >> addClassDefinitionName: aClassName toClassTag: aSymbol
[
	"Tags the class aClass with the tag aSymbol"

	(self addClassTag: aSymbol) addClassNamed: aClassName
]

RPackage >> addClassTag: aSymbol
[
	"Add the class tag from the receiver, if already added do nothing."

	| tagName |
	"strip package name if needed"
	tagName := self toTagName: aSymbol.
	^ self
		classTagNamed: tagName
		ifAbsent: [ self class organizer validateCanBeAddedPackage: self tagName: tagName.
			self basicAddClassTag: tagName ]
]

RPackage >> addMethod: aCompiledMethod
[
	"Add the method to the receiver as a defined method if the class is  defined in it, else as an extension."

	| methodClass |
	methodClass := aCompiledMethod methodClass.
	(self includesClass: methodClass)
		ifTrue: [ methodClass isMeta
				ifTrue: [ (metaclassDefinedSelectors at: methodClass theNonMetaClass name ifAbsentPut: [ Set new ]) add: aCompiledMethod selector ]
				ifFalse: [ (classDefinedSelectors at: methodClass name ifAbsentPut: [ Set new ]) add: aCompiledMethod selector ] ]
		ifFalse: [ methodClass isMeta
				ifTrue: [ (metaclassExtensionSelectors at: methodClass theNonMetaClass name ifAbsentPut: [ Set new ])
						add: aCompiledMethod selector ]
				ifFalse: [ (classExtensionSelectors at: methodClass name ifAbsentPut: [ Set new ]) add: aCompiledMethod selector ].	"we added a method extension so the receiver is an extending package of the class"
			self organizer registerExtendingPackage: self forClass: methodClass ].
	^ aCompiledMethod
]

RPackage >> addSelector: aSelector ofClassName: aClassName
[
	"Add the method to the receiver. If the class is not locally defined in that package then the method is defined as a method extension: ie extending another package. Note that this method does not add the method to the class, it just records in the package that the method is packaged."

	(self includesClassNamed: aClassName)
		ifFalse: [ (classExtensionSelectors at: aClassName asSymbol ifAbsentPut: [ Set new ]) add: aSelector ]
		ifTrue: [ (classDefinedSelectors at: aClassName asSymbol ifAbsentPut: [ Set new ]) add: aSelector ].
	^ aSelector
]

RPackage >> addSelector: aSelector ofMetaclassName: aClassName
[
	"Add the method to the receiver. If the class is not locally defined in that package then the method is defined as a method extension: ie extending another package. Note that this method does not add the method to the class, it just records in the package that the method is packaged. aClassName is the sole instance class name and not its metaclass one: i.e. adding Point class>>new is done as addSelector: #new ofMetaclassName: #Point"

	(self includesClassNamed: aClassName)
		ifFalse: [ (metaclassExtensionSelectors at: aClassName asSymbol ifAbsentPut: [ Set new ]) add: aSelector ]
		ifTrue: [ (metaclassDefinedSelectors at: aClassName asSymbol ifAbsentPut: [ Set new ]) add: aSelector ].
	^ aSelector
]

RPackage >> allOverriddenMethodsDo: aBlock
[
	"Evaluates aBlock with all the overridden methods in the system"

	^ ProtoObject withAllSubclassesDo: [ :class | self overriddenMethodsInClass: class do: aBlock ]
]

RPackage >> basicAddClassTag: tagName
[
	| packageTag |
	packageTag := RPackageTag package: self name: tagName.
	classTags add: packageTag.
	packageTag ensureSystemCategory.
	^ packageTag
]

RPackage >> basicImportClass: aClass
[
	"Add the class definition and all the selectors which are not extensions of other packages. If the class had an extension to us, then all methods in that extension are moved to 'as yet unclassified' and the extension protocol is deleted (should I use silently or not?)."

	"Note: Protocol defaultName is #'as yet unclassified'"

	"Question: should we check that for each extension, there is a real package behind or not?"

	| protocols |
	self addClassDefinition: aClass.
	aClass organization realCategories
		do: [ :each | (self isYourClassExtension: each)
				ifTrue: [ aClass organization renameCategory: each toBe: Protocol defaultName ] ].
	protocols := aClass organization realCategories reject: [ :each | each first = $* ].
	protocols do: [ :each | self importProtocol: each forClass: aClass ]
]

RPackage >> basicRemoveSelector: aSelector ofClassName: aClassName
[
	"Remove the method in the package but does not propagate to the class itself.  Note that this method does not remove the method from the class, it just records in the package that the method is not in the package anymore."

	(self includesClassNamed: aClassName)
		ifFalse: [ (classExtensionSelectors at: aClassName ifAbsent: [ ^ Set new ]) remove: aSelector ]
		ifTrue: [ (classDefinedSelectors at: aClassName ifAbsent: [ ^ Set new ]) remove: aSelector ]
]

RPackage >> basicRemoveSelector: aSelector ofMetaclassName: aClassName
[
	"Remove the method in the package. Note that this method does not remove the method from the class, it just records in the package that the method is not in the package anymore. aClassName is the sole instance class name and not its metaclass one: i.e. adding Point class>>new is done as removeSelector: #new ofMetaclassName: #Point"

	(self includesClassNamed: aClassName)
		ifFalse: [ (metaclassExtensionSelectors at: aClassName ifAbsent: [ ^ Set new ]) remove: aSelector ]
		ifTrue: [ (metaclassDefinedSelectors at: aClassName ifAbsent: [ ^ Set new ]) remove: aSelector ]
]

RPackage >> basicRemoveTag: tag
[
	classTags remove: tag
]

RPackage >> category: categoryName matches: prefix
[
	"self default category: 'Compression-Archives' matches: 'Compression'"

	"self default category: 'Compression' matches: 'Compression-Archives'"

	"self default category: 'Compression' matches: 'Compression'"

	"self default category: 'Compression-Arh' matches: 'Compression'"

	| prefixSize catSize |
	categoryName ifNil: [ ^ false ].
	catSize := categoryName size.
	prefixSize := prefix size.
	catSize < prefixSize
		ifTrue: [ ^ false ].
	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1
		ifFalse: [ ^ false ].
	^ (categoryName at: prefix size + 1 ifAbsent: [ ^ true ]) = $-
]

RPackage >> categoryName
[
	^ self name
]

RPackage >> changeRecordForOverriddenMethod: aMethodDefinition
[
	^ SourceFiles
		changeRecordsFor: aMethodDefinition
		detect: [ :protocol | self includesMethodCategory: protocol ofClass: aMethodDefinition actualClass ]
]

RPackage >> classDefinedSlicesDo: aBlock
[
	"This method iterates over the defined class and their associated selectors. a slice is a class * list of selectors. aBlock will be applied to all the extensions slices of the receiver. aBlok first argument is the class and the second argument a list of method selectors"

	classDefinedSelectors keysAndValuesDo: aBlock
]

RPackage >> classExtensionSelectors
[
	^ classExtensionSelectors
]

RPackage >> classExtensionSlicesDo: aBlock
[
	"This method iterates over the class extensions and their associated selectors. A slice is a class * list of selectors. aBlock will be applied to all the extensions slices of the receiver. aBlock first argument is the class and the second argument a list of method selectors"

	classExtensionSelectors keysAndValuesDo: aBlock
]

RPackage >> classNamesAndExtensionSelectorsDo: aBlock
[
	"Iterate over the extended methods grouped by classes and apply the argument.
	The block will be passed a class name and each individual selectors.
	Only classes with methods are paired with their methods"

	classExtensionSelectors
		keysAndValuesDo: [ :classSymbol :methods | methods do: [ :sel | aBlock value: classSymbol value: sel ] ].
	metaclassExtensionSelectors
		keysAndValuesDo: [ :classSymbol :methods | methods do: [ :sel | aBlock value: (classSymbol , '_class') asSymbol value: sel ] ]
]

RPackage >> classNamesForClassTag: aSymbol
[
	"Returns the classes tagged using aSymbol"

	^ (self classTagNamed: aSymbol ifAbsent: [ ^ #() ]) classNames
]

RPackage >> classTagCategoryNames
[
	^ (Set with: self packageName) , (self classTags collect: #categoryName)
]

RPackage >> classTagForClass: aClass
[
	^ self classTagNamed: (self toTagName: aClass category) ifAbsent: [ nil ]
]

RPackage >> classTagNamed: aSymbol
[
	^ classTags detect: [ :each | each name = aSymbol ]
]

RPackage >> classTagNamed: aSymbol ifAbsent: aBlock
[
	^ classTags detect: [ :each | each name = aSymbol ] ifNone: aBlock
]

RPackage >> classTagNamed: aSymbol ifPresent: aBlock
[
	^ classTags detect: [ :each | each name = aSymbol ] ifFound: [ :tag | aBlock cull: tag ] ifNone: [ nil ]
]

RPackage >> classTags
[
	"Returns the tags of the receiver"

	^ classTags
]

RPackage >> classes
[
	"Return all the classes"

	^ self definedClasses , self extendedClasses
]

RPackage >> classesAndMetaClasses
[
	"Return a Set with all classes and metaclasses belonging to this package"

	self flag: #stef.	"only used by goferCleanUp"
	^ OrderedCollection new
		addAll: self definedClasses;
		addAll: (self definedClasses collect: [ :each | each classSide ]);
		yourself
]

RPackage >> classesForClassTag: aSymbol
[
	"Returns the classes tagged using aSymbol"

	^ (self classTagNamed: (self toTagName: aSymbol) ifAbsent: [ ^ #() ]) classes
]

RPackage >> coreCategoriesForClass: aClass
[
	self flag: #stef.	"only used by goferCleanUp"
	^ aClass organization realCategories reject: [ :cat | self isForeignClassExtension: cat ]
]

RPackage >> definedClassNames
[
	"Return the class names having methods defined in the receiver."

	^ classes
]

RPackage >> definedClasses
[
	| definedClasses |
	definedClasses := Set new.
	classes do: [ :each | Smalltalk globals at: each ifPresent: [ :aClass | definedClasses add: aClass ] ].
	^ definedClasses
]

RPackage >> definedClassesDo: aBlock
[
	classDefinedSelectors keysDo: aBlock.
	metaclassDefinedSelectors keysDo: aBlock
]

RPackage >> definedMethodsBecomeExtendedForClass: aClassName
[
	"the package may contain defined methods and their class is removed to the receiver. The status of such methods should now be extended"

	"Precondition: aClassName is in the defined list"

	| ext |
	(classDefinedSelectors keys includes: aClassName)
		ifFalse: [ ^ self ].
	ext := classDefinedSelectors at: aClassName.
	classDefinedSelectors
		removeKey: aClassName
		ifAbsent: [ self reportBogusBehaviorOf: #definedMethodsBecomeExtendedForClass: ].
	(classExtensionSelectors keys includes: aClassName)
		ifTrue: [ self error: aClassName , ' should not be defined in extension' ].	"we should remove this check later"
	classExtensionSelectors at: aClassName put: ext
]

RPackage >> definedMethodsBecomeExtendedForMetaclass: aClassName
[
	"the package may contain defined methods and their class is removed to the receiver. The status of such methods should now be extended"

	"Precondition: aClassName is in the defined list"

	| ext |
	(metaclassDefinedSelectors keys includes: aClassName)
		ifFalse: [ ^ self ].
	ext := metaclassDefinedSelectors at: aClassName.
	metaclassDefinedSelectors
		removeKey: aClassName
		ifAbsent: [ self reportBogusBehaviorOf: #definedMethodsBecomeExtendedForMetaclass: ].
	(metaclassExtensionSelectors keys includes: aClassName)
		ifTrue: [ self error: aClassName , ' should not be defined in extension' ].	"we should remove this check later"
	metaclassDefinedSelectors at: aClassName put: ext
]

RPackage >> definedMethodsForClass: aClass
[
	^ (self definedSelectorsForClass: aClass) asOrderedCollection collect: [ :each | aClass >> each ]
]

RPackage >> definedMethodsShouldBecomeExtensionWhenRemovingClass: aClassName
[
	"the package may contain defined methods and their class is removed from the receiver. The status of such methods should now be extensions"

	self definedMethodsBecomeExtendedForClass: aClassName.
	self definedMethodsBecomeExtendedForMetaclass: aClassName
]

RPackage >> definedSelectorsForClass: aClass
[
	^ aClass isMeta
		ifTrue: [ metaclassDefinedSelectors at: aClass theNonMetaClass originalName ifAbsent: [ #() ] ]
		ifFalse: [ classDefinedSelectors at: aClass originalName ifAbsent: [ #() ] ]
]

RPackage >> definesClass: aClass
[
	"Returns true if the class, aClass, is one of the locally defined classes"

	"should be probably removed since this is the same as includesClass: or the inverse"

	^ self includesClass: aClass
]

RPackage >> definesOrExtendsClass: aClass
[
	"Returns true whether the class, aClass, is one of the locally defined classes of the receiver or 
	if the receiver extends such class (that is defined in another package)"

	| canonizedName |
	canonizedName := aClass theNonMetaClass name.
	^ (classes includes: canonizedName) or: [ self extendedClassNames includes: canonizedName ]
]

RPackage >> demoteToRPackageNamed: aString
[
	| newRPackage |
	self unregister.
	newRPackage := self class organizer packageNamed: aString ifAbsent: [ (self class named: aString) register ].
	newRPackage importPackage: self.
	newRPackage classes do: [ :each | SystemAnnouncer uniqueInstance classRepackaged: each from: self to: newRPackage ]
]

RPackage >> extendedClassNames
[
	"Return the name of the classes which are extended by the receiver package. if a metaclass is extended, just get its sole instance class name."

	^ classExtensionSelectors keys union: metaclassExtensionSelectors keys
]

RPackage >> extendedClasses
[
	"Return classes and metaclasses that are extended in the receiver. They represent the classes of method extensions"

	^ (metaclassExtensionSelectors keys
		select: [ :each | Smalltalk globals includesKey: each ]
		thenCollect: [ :each | (Smalltalk globals at: each) theMetaClass ])
		union:
			(classExtensionSelectors keys
				select: [ :each | Smalltalk globals includesKey: each ]
				thenCollect: [ :each | Smalltalk globals at: each ])
]

RPackage >> extendedMethodsBecomeDefinedForClass: aClassName
[
	"the package may contain extension methods and their class is added to the receiver. The status of such methods should now be defined"

	"Precondition: aClassName is in the defined list"

	| ext |
	(classExtensionSelectors keys includes: aClassName)
		ifFalse: [ ^ self ].
	ext := classExtensionSelectors at: aClassName.
	classExtensionSelectors
		removeKey: aClassName
		ifAbsent: [ self reportBogusBehaviorOf: #extendedMethodsBecomeDefinedForClass: ].
	(classDefinedSelectors keys includes: aClassName)
		ifTrue: [ self error: aClassName , ' should not be defined in extension' ].	"we should remove this check later"
	classDefinedSelectors at: aClassName put: ext
]

RPackage >> extendedMethodsBecomeDefinedForMetaclass: aClassName
[
	"the package may contain extension methods and their class is added to the receiver. The status of such methods should now be defined"

	"Precondition: aClassName is in the defined list"

	| ext |
	(metaclassExtensionSelectors keys includes: aClassName)
		ifFalse: [ ^ self ].
	ext := metaclassExtensionSelectors at: aClassName.
	metaclassExtensionSelectors
		removeKey: aClassName
		ifAbsent: [ self reportBogusBehaviorOf: #extendedMethodsBecomeDefinedForMetaclass: ].
	(metaclassDefinedSelectors keys includes: aClassName)
		ifTrue: [ self error: aClassName , ' should not be defined in extension' ].	"we should remove this check later"
	metaclassDefinedSelectors at: aClassName put: ext
]

RPackage >> extendedMethodsShouldBecomeDefinedWhenAddingClassName: aClassName
[
	"the package may contain extension methods and their class is added to the receiver. The status of such methods should now be defined"

	"Precondition: aClassName is in the defined list"

	self extendedMethodsBecomeDefinedForClass: aClassName.
	self extendedMethodsBecomeDefinedForMetaclass: aClassName
]

RPackage >> extendsClass: aClass
[
	"Returns true if the receiver extends aClass (that is defined in another package)"

	| canonizedName |
	canonizedName := aClass theNonMetaClass name.
	^ self extendedClassNames includes: canonizedName
]

RPackage >> extensionCategoriesForClass: aClass
[
	self flag: #stef.	"only used by goferCleanUp and PackageEnvironment of RB"
	^ aClass organization realCategories select: [ :cat | self isYourClassExtension: cat ]
]

RPackage >> extensionClasses
[
	self flag: #stef.	"only used by RB and Gofer"
	^ self extendedClasses
]

RPackage >> extensionMethods
[
	"Extension methods are methods defined on classes that are not defined in the receiver"

	| allExtensionMethods |
	allExtensionMethods := OrderedCollection new.
	classExtensionSelectors
		keysAndValuesDo: [ :classSymbol :methods | methods do: [ :selector | allExtensionMethods add: (Smalltalk at: classSymbol) >> selector ] ].
	metaclassExtensionSelectors
		keysAndValuesDo: [ :classSymbol :methods | methods do: [ :selector | allExtensionMethods add: (Smalltalk at: classSymbol) theMetaClass >> selector ] ].
	^ allExtensionMethods
]

RPackage >> extensionMethodsForClass: aClass
[
	"Change the set of extensions selectors to an Array to avoid compiled methods collisions in the resulting set."

	^ (self extensionSelectorsForClass: aClass) asArray collect: [ :each | aClass >> each ]
]

RPackage >> extensionSelectors
[
	"Extension methods are methods defined on classes that are not defined in the receiver"

	| classSels |
	classSels := Set new.
	classExtensionSelectors values do: [ :each | classSels addAll: each ].
	metaclassExtensionSelectors values do: [ :each | classSels addAll: each ].
	^ classSels
]

RPackage >> extensionSelectorsForClass: aClass
[
	^ aClass isMeta
		ifTrue: [ metaclassExtensionSelectors at: aClass theNonMetaClass originalName ifAbsent: [ #() ] ]
		ifFalse: [ classExtensionSelectors at: aClass originalName ifAbsent: [ #() ] ]
]

RPackage >> extensionsForTag: aRPackageTag
[
	^ self extensionMethods
		select: [ :extensionMethod | | category |
			category := extensionMethod protocol allButFirst.
			self category: category matches: aRPackageTag categoryName ]
]

RPackage >> fileOut
[
	| internalStream |
	internalStream := (String new: 1000) writeStream.
	self classTags do: [ :each | SystemOrganization fileOutCategory: each categoryName on: internalStream ].
	classExtensionSelectors
		keysAndValuesDo: [ :className :selectors | selectors
				do: [ :selector | | extendedClass |
					extendedClass := Smalltalk globals classNamed: className.
					extendedClass fileOutMethod: selector on: internalStream ] ].
	^ FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true
]

RPackage >> importClass: aClass
[
	"import a class already created but not attached to a package to the receiver. 
	Handle also *- convention. Methods defined in *category are not added to the package.
	Pay attention that it will not import anything from the metaClass side"

	self basicImportClass: aClass.
	self basicImportClass: aClass theMetaClass.
	self addClassDefinition: aClass toClassTag: (self toTagName: aClass category)
]

RPackage >> importClass: aClass inTag: aTag
[
	"import a class already created but not attached to a package to the receiver. 
	Handle also *- convention. Methods defined in *category are not added to the package.
	Pay attention that it will not import anything from the metaClass side"

	self basicImportClass: aClass.
	self basicImportClass: aClass theMetaClass.
	self addClassDefinition: aClass toClassTag: aTag name
]

RPackage >> importPackage: anRPackage
[
	anRPackage definedClasses do: [ :className | self importClass: className ].	"new rpackage inherits the extentions"
	classExtensionSelectors := classExtensionSelectors , anRPackage classExtensionSelectors.
	metaclassExtensionSelectors := metaclassExtensionSelectors , anRPackage metaclassExtensionSelectors
]

RPackage >> importProtocol: aProtocol forClass: aClass
[
	"import all the methods of a protocol as defined in the receiver."

	(aClass organization listAtCategoryNamed: aProtocol) do: [ :each | self addMethod: aClass >> each ]
]

RPackage >> includesClass: aClass
[
	"Returns true if the receiver includes aClass in the classes that are defined within it: only class definition are considered - not class extensions"

	^ self includesClassNamed: aClass theNonMetaClass name
]

RPackage >> includesClassNamed: aSymbol
[
	"Returns true if the receiver includes class named aSymbol in the classes that are defined within it: only class definition are considered - not class extensions"

	^ classes includes: aSymbol asSymbol
]

RPackage >> includesClassTagNamed: aString
[
	^ self classTags anySatisfy: [ :each | each name = aString ]
]

RPackage >> includesDefinedSelector: aSelector ofClass: aClass
[
	"Return true if the receiver includes the method of selector aSelector. Only checks methods defined in this package"

	| sels |
	sels := self definedSelectorsForClass: aClass.
	^ sels includes: aSelector
]

RPackage >> includesDefinedSelector: aSelector ofClassName: aClassName
[
	"Return true if the receiver includes the method of selector aSelector. Only checks methods defined (not extended by other packages or package extensions)"

	| sels |
	sels := classDefinedSelectors at: aClassName ifAbsent: [ ^ false ].
	^ sels includes: aSelector
]

RPackage >> includesDefinedSelector: aSelector ofMetaclassName: aClassName
[
	"Return true if the receiver includes the method of selector aSelector. Only checks methods defined (not extended by other packages or package extensions)"

	| sels |
	sels := metaclassDefinedSelectors at: aClassName ifAbsent: [ ^ false ].
	^ sels includes: aSelector
]

RPackage >> includesExtensionSelector: aSelector ofClass: aClass
[
	"Return true if the receiver includes the method of selector aSelector. Only checks methods extending other packages"

	| sels |
	sels := self extensionSelectorsForClass: aClass.
	^ sels includes: aSelector
]

RPackage >> includesExtensionSelector: aSelector ofClassName: aClassName
[
	"Return true if the receiver includes the method of selector aSelector. Only checks methods extending other packages"

	| sels |
	sels := classExtensionSelectors at: aClassName ifAbsent: [ ^ false ].
	^ sels includes: aSelector
]

RPackage >> includesExtensionSelector: aSelector ofMetaclassName: aClassName
[
	"Return true if the receiver includes the method of selector aSelector. Only checks methods extending other packages"

	| sels |
	sels := metaclassExtensionSelectors at: aClassName ifAbsent: [ ^ false ].
	^ sels includes: aSelector
]

RPackage >> includesMethod: aSymbol ofClass: aClass
[
	self flag: #stef.	"only used by RB"
	self flag: #cyrille.	"looks like a bogus implementation because category have nothing to do with the fact that a method is in package or not."	"CD: Indeed, it looks strange. 	With RPackage we have 'includesSelector:ofClass:. I guess it should return the same result (?)'	"
	aClass ifNil: [ ^ false ].
	^ self includesMethodCategory: ((aClass organization categoryOfElement: aSymbol) ifNil: [ ' ' ]) ofClass: aClass
]

RPackage >> includesMethodCategory: categoryName ofClass: aClass
[
	^ (self isYourClassExtension: categoryName)
		or: [ (self includesClass: aClass) and: [ (self isForeignClassExtension: categoryName) not ] ]
]

RPackage >> includesMethodReference: aMethodRef
[
	self flag: 'includesMethod:ofClass: is not implemented for RPackage. Should fine fine a corresponding one '.
	self flag: #stef.	"We can inline this one and replace it by selector and others."
	^ self includesMethod: aMethodRef selector ofClass: aMethodRef actualClass	"^ self includesDefinedSelector: aMethodRef selector ofClass: aMethodRef actualClass"
]

RPackage >> includesSelector: aSelector ofClass: aClass
[
	"Return true if the receiver includes the method of selector aSelector. Checks methods defined locally as well as extending other packages"

	^ aClass isMeta
		ifTrue: [ self includesSelector: aSelector ofMetaclassName: aClass theNonMetaClass name ]
		ifFalse: [ self includesSelector: aSelector ofClassName: aClass name ]
]

RPackage >> includesSelector: aSelector ofClassName: aClassName
[
	"Return true if the receiver includes the method of selector aSelector. Checks methods defined locally as well as extending other packages"

	^ (self includesDefinedSelector: aSelector ofClassName: aClassName)
		or: [ self includesExtensionSelector: aSelector ofClassName: aClassName ]
]

RPackage >> includesSelector: aSelector ofMetaclassName: aClassName
[
	"Return true if the receiver includes the method of selector aSelector. Checks methods defined locally as well as extending other packages"

	^ (self includesDefinedSelector: aSelector ofMetaclassName: aClassName)
		or: [ self includesExtensionSelector: aSelector ofMetaclassName: aClassName ]
]

RPackage >> includesSystemCategory: categoryName
[
	^ self category: categoryName matches: self systemCategoryPrefix
]

RPackage >> initialize
[
	super initialize.
	classes := Set new.
	metaclassExtensionSelectors := Dictionary new.
	classExtensionSelectors := Dictionary new.
	classDefinedSelectors := Dictionary new.
	metaclassDefinedSelectors := Dictionary new.
	classTags := Set new
]

RPackage >> isDefault
[
	"Return whether the receiver is the default package, i.e. the one used when nothing else is specified."

	^ self name = self class defaultPackageName
]

RPackage >> isForeignClassExtension: categoryName
[
	^ categoryName first = $* and: [ (self isYourClassExtension: categoryName) not ]
]

RPackage >> isOverrideCategory: aString
[
	^ aString endsWith: '-override'
]

RPackage >> isOverrideOfYourMethod: aMethodReference
[
	"Answers true if the argument overrides a method in this package"

	^ (self isYourClassExtension: aMethodReference category) not
		and: [ (self changeRecordForOverriddenMethod: aMethodReference) notNil ]
]

RPackage >> isYourClassExtension: categoryName
[
	^ categoryName notNil and: [ self category: categoryName asLowercase matches: self methodCategoryPrefix ]
]

RPackage >> linesOfCode
[
	"An approximate measure of lines of code.
	Includes comments, but excludes blank lines."

	^ self methods inject: 0 into: [ :sum :each | sum + each linesOfCode ]
]

RPackage >> metaclassDefinedSlicesDo: aBlock
[
	"This method iterates over the defined class and their associated selectors. a slice is a class * list of selectors. aBlock will be applied to all the extensions slices of the receiver. aBlok first argument is the class and the second argument a list of method selectors"

	metaclassDefinedSelectors keysAndValuesDo: aBlock
]

RPackage >> metaclassExtensionSelectors
[
	^ metaclassExtensionSelectors
]

RPackage >> metaclassExtensionSlicesDo: aBlock
[
	"This method iterates over the metaclass extensions and their associated selectors. A slice is a class * list of selectors. aBlock will be applied to all the extensions slices of the receiver. aBlok first argument is the class and second argument a list of selectors"

	metaclassExtensionSelectors keysAndValuesDo: aBlock
]

RPackage >> methodCategoryPrefix
[
	^ '*' , self name asLowercase
]

RPackage >> methodReferences
[
	^ self methods
		collect: [ :each | each methodReference ]
		thenSelect: [ :each | each isValid and: [ each isLocalSelector ] ]
]

RPackage >> methods
[
	| methods |
	methods := OrderedCollection new.
	metaclassExtensionSelectors
		keysAndValuesDo: [ :key :val | val do: [ :sel | methods add: (Smalltalk at: key) theMetaClass >> sel ] ].
	classExtensionSelectors keysAndValuesDo: [ :key :val | val do: [ :sel | methods add: (Smalltalk at: key) >> sel ] ].
	metaclassDefinedSelectors
		keysAndValuesDo: [ :key :val | val do: [ :sel | methods add: (Smalltalk at: key) theMetaClass >> sel ] ].
	classDefinedSelectors keysAndValuesDo: [ :key :val | val do: [ :sel | methods add: (Smalltalk at: key) >> sel ] ].
	^ methods
]

RPackage >> methodsForClass: aClass
[
	"Returns all compiled methods for a class in the receiver without distinction of extensions or not"

	^ (self includesClass: aClass)
		ifFalse: [ self extensionMethodsForClass: aClass ]
		ifTrue: [ self definedMethodsForClass: aClass ]
]

RPackage >> methodsInCategory: aString ofClass: aClass do: aBlock
[
	((aClass organization listAtCategoryNamed: aString) ifNil: [ ^ self ])
		do: [ :sel | aBlock value: (self referenceForMethod: sel ofClass: aClass) ]
]

RPackage >> moveClass: aClass fromPackage: oldPackage toTag: aTag
[
	oldPackage removeClass: aClass.
	self importClass: aClass inTag: aTag.
	SystemAnnouncer uniqueInstance classRepackaged: aClass from: oldPackage to: self
]

RPackage >> moveClass: aClass toTag: aTag
[
	"TODO: deprecate system categories / replace this with a direct call to moveClass:fromPackage:toTag:"

	"This change the class category as appropriate.
		(and by cascade, ensure systemClassRecategorizedAction: is called)."

	aClass category: aTag categoryName
]

RPackage >> name
[
	^ name
]

RPackage >> name: aSymbol
[
	name := aSymbol asSymbol
]

RPackage >> orderedClasses
[
	| tmp |
	tmp := self definedClasses asArray sort: [ :a :b | a name <= b name ].
	tmp := tmp , (self extendedClasses asArray sort: [ :a :b | a name <= b name ]).
	^ tmp collect: [ :e | e theNonMetaClass ]
]

RPackage >> organizer
[
	^ self class organizer
]

RPackage >> overriddenMethods
[
	^ Array streamContents: [ :stream | self overriddenMethodsDo: [ :each | stream nextPut: each ] ]
]

RPackage >> overriddenMethodsDo: aBlock
[
	"Enumerates the methods the receiver contains which have been overridden by other packages"

	^ self allOverriddenMethodsDo: [ :ea | (self isOverrideOfYourMethod: ea)
				ifTrue: [ aBlock value: ea ] ]
]

RPackage >> overriddenMethodsInClass: aClass do: aBlock
[
	"Evaluates aBlock with the overridden methods in aClass"

	^ self overrideCategoriesForClass: aClass do: [ :cat | self methodsInCategory: cat ofClass: aClass do: aBlock ]
]

RPackage >> overrideCategoriesForClass: aClass do: aBlock
[
	"Evaluates aBlock with all the *foo-override categories in aClass"

	^ aClass organization categories do: [ :cat | (self isOverrideCategory: cat)
				ifTrue: [ aBlock value: cat ] ]
]

RPackage >> packageName
[
	^ name
]

RPackage >> packages
[
	"Compatibility with monticello and old PackageInfo"

	^ self classTags
]

RPackage >> printOn: aStream
[
	super printOn: aStream.
	aStream nextPut: $(.
	aStream nextPutAll: self name.
	aStream nextPut: $)
]

RPackage >> referenceForMethod: aSymbol ofClass: aClass
[
	^ (aClass >> aSymbol) asRingDefinition
]

RPackage >> register
[
	self organizer registerPackage: self
]

RPackage >> registerClass: aClass
[
	"Private method that declares the mapping between a class and its package."

	self organizer registerPackage: self forClass: aClass
]

RPackage >> registerClassName: aClassNameSymbol
[
	"Private method that declares the mapping between a class and its package."

	self organizer registerPackage: self forClassName: aClassNameSymbol
]

RPackage >> removeAllMethodsFromClassNamed: aClassNameSymbol
[
	"Remove all the methods (defined and extensions) that are related to class aClassNameSymbol. aClassNameSymbol is the name of a class and not a metaclass - see class comment."

	classDefinedSelectors removeKey: aClassNameSymbol ifAbsent: [ nil ].
	classExtensionSelectors removeKey: aClassNameSymbol ifAbsent: [ nil ].
	metaclassDefinedSelectors removeKey: aClassNameSymbol ifAbsent: [ nil ].
	metaclassExtensionSelectors removeKey: aClassNameSymbol ifAbsent: [ nil ]
]

RPackage >> removeClass: aClass
[
	"Remove the class and all its methods from the receiver. If we have a protocol which looks like an extension of us, rename it to 'as yet unclassified' to avoid breaking things afterwards."

	aClass organization realCategories
		do: [ :each | (self isYourClassExtension: each)
				ifTrue: [ aClass organization renameCategory: each toBe: Protocol defaultName ] ].
	(self definedMethodsForClass: aClass instanceSide) do: [ :aCompiledMethod | self removeMethod: aCompiledMethod ].	"we also have also have to remove methods from class side"
	(self definedMethodsForClass: aClass classSide) do: [ :aCompiledMethod | self removeMethod: aCompiledMethod ].
	self removeClassDefinitionWithoutCheckingMethods: aClass.
	self removeClassTagsForClassNamed: aClass name
]

RPackage >> removeClassDefinition: aClass
[
	"Remove the class definition from the package but not its methods."

	^ self removeClassDefinitionName: aClass theNonMetaClass originalName
]

RPackage >> removeClassDefinition: aClass fromClassTag: aSymbol
[
	"Detags the class aClass with the tag aSymbol"

	self removeClassDefinitionName: aClass name fromClassTag: aSymbol
]

RPackage >> removeClassDefinitionName: aClassName
[
	"remove the class definition from the package but not its method"

	| removed aClassNameSymbol |
	('* class' match: aClassName)
		ifTrue: [ ^ self error: 'no metaclass name' ].
	aClassNameSymbol := aClassName asSymbol.	"clean up class tags"
	classTags do: [ :tag | tag removeClassNamed: aClassName ].
	(classTags select: #isEmpty) do: [ :eachTag | self basicRemoveTag: eachTag ].	"remove the class definition"
	removed := classes remove: aClassNameSymbol ifAbsent: [ nil ].
	removed
		ifNotNil: [ self definedMethodsShouldBecomeExtensionWhenRemovingClass: aClassName.
			self unregisterClassName: aClassNameSymbol ]
]

RPackage >> removeClassDefinitionName: aClassName fromClassTag: aSymbol
[
	"Detags the class aClass with the tag aSymbol"

	| tag |
	tag := self classTagNamed: (self toTagName: aSymbol) ifAbsent: [ ^ self ].
	tag removeClassNamed: aClassName.
	tag isEmpty
		ifTrue: [ self basicRemoveTag: tag ]
]

RPackage >> removeClassDefinitionNamed: aClassNameSymbol
[
	"aClassNameSymbol should be the name of a class and not a metaclass to be coherent with the class invariant that classes are only class names and not metaclass ones. 
	
	This method removes the class definition from the receiver and its organizer"

	| removed |
	removed := classes remove: aClassNameSymbol ifAbsent: [ nil ].
	removed ifNotNil: [ self unregisterClassName: aClassNameSymbol ]
]

RPackage >> removeClassDefinitionWithoutCheckingMethods: aClass
[
	"Same than 'removeClassDefinition', excepts that it does not make any check to set defined methods as extensions"

	| removed aClassName |
	aClassName := aClass theNonMetaClass name.
	removed := classes remove: aClassName ifAbsent: [ nil ].
	removed ifNotNil: [ self unregisterClass: aClass ]
]

RPackage >> removeClassNamed: className
[
	self removeClassDefinitionName: className.
	self removeAllMethodsFromClassNamed: className.
	self removeClassTagsForClassNamed: className
]

RPackage >> removeClassTag: aSymbol
[
	"Remove the class tag from the receiver."

	self basicRemoveTag: (self classTagNamed: (self toTagName: aSymbol) ifAbsent: [ ^ self ])
]

RPackage >> removeClassTagsForClassNamed: aString
[
	(self classTags select: [ :eachTag | eachTag hasClassNamed: aString ])
		do: [ :eachTag | self removeClassDefinitionName: aString fromClassTag: eachTag name ]
]

RPackage >> removeClassesMatchingTag: aTag
[
	aTag classes do: [ :class | self removeClassDefinition: class ]
]

RPackage >> removeDefinedMethod: aCompiledMethod forClass: aClass
[
	"Remove the method to the receiver as a defined method."

	self flag: #cyrille.	"no need for this method since we have removeMethod and normally 	given a compiledMethod and a package we know if it is extending or not the package."	"CD: Indeed, I changed the code where this method was called (removeClass:) , and it does not raise more errors when running the tests.There is no longer senders of this method"
	aClass isMeta
		ifTrue: [ (metaclassDefinedSelectors at: aClass theNonMetaClass name ifAbsent: [ ^ nil ]) remove: aCompiledMethod selector ]
		ifFalse: [ (classDefinedSelectors at: aClass name ifAbsent: [ ^ nil ]) remove: aCompiledMethod selector ].
	^ aCompiledMethod
]

RPackage >> removeMethod: aCompiledMethod
[
	"Remove the method to the receiver as a defined method."

	| methodClass |
	methodClass := aCompiledMethod methodClass.
	methodClass isMeta
		ifTrue: [ self removeSelector: aCompiledMethod selector ofMetaclassName: methodClass theNonMetaClass originalName ]
		ifFalse: [ self removeSelector: aCompiledMethod selector ofClassName: methodClass originalName ].
	^ aCompiledMethod
]

RPackage >> removeMethods: aCollection
[
	aCollection do: [ :each | self removeMethod: each ]
]

RPackage >> removeSelector: aSelector ofClassName: aClassName
[
	"Remove the method in the package but does not propagate to the class itself.  Note that this method does not remove the method from the class, it just records in the package that the method is not in the package anymore."

	self basicRemoveSelector: aSelector ofClassName: aClassName.
	(classExtensionSelectors at: aClassName ifAbsent: [ #() ])
		ifEmpty: [ classExtensionSelectors removeKey: aClassName ifAbsent: [  ] ].
	(classDefinedSelectors at: aClassName ifAbsent: [ #() ])
		ifEmpty: [ classDefinedSelectors removeKey: aClassName ifAbsent: [  ] ].
	((metaclassExtensionSelectors at: aClassName ifAbsent: [ #() ]) isEmpty
		and: [ (classExtensionSelectors at: aClassName ifAbsent: [ #() ]) isEmpty ])
		ifTrue: [ self organizer unregisterExtendingPackage: self forClassName: aClassName ]
]

RPackage >> removeSelector: aSelector ofMetaclassName: aClassName
[
	"Remove the method in the package. Note that this method does not remove the method from the class, it just records in the package that the method is not in the package anymore. aClassName is the sole instance class name and not its metaclass one: i.e. adding Point class>>new is done as removeSelector: #new ofMetaclassName: #Point"

	self basicRemoveSelector: aSelector ofMetaclassName: aClassName.
	(metaclassExtensionSelectors at: aClassName ifAbsent: [ #() ])
		ifEmpty: [ metaclassExtensionSelectors removeKey: aClassName ifAbsent: [  ] ].
	(metaclassDefinedSelectors at: aClassName ifAbsent: [ #() ])
		ifEmpty: [ metaclassDefinedSelectors removeKey: aClassName ifAbsent: [  ] ].
	((metaclassExtensionSelectors at: aClassName ifAbsent: [ #() ]) isEmpty
		and: [ (classExtensionSelectors at: aClassName ifAbsent: [ #() ]) isEmpty ])
		ifTrue: [ self organizer unregisterExtendingPackage: self forClassName: aClassName ]
]

RPackage >> renameExtensionsPrefixedWith: oldName to: newName
[
	| protocols |
	protocols := self extensionMethods collect: [ :each | each origin organization protocolNamed: each protocol ] as: Set.
	protocols do: [ :each | each rename: '*' , newName , (each name allButFirst: oldName size + 1) ]
]

RPackage >> renameTagsPrefixedWith: oldName to: newName
[
	| oldPrefix newPrefix |
	oldName ifNil: [ ^ self ].
	self classTagNamed: oldName ifPresent: [ :tag | tag renameTo: newName category: newName ].
	oldPrefix := oldName , '-'.
	newPrefix := newName , '-'.
	(self classTags select: [ :each | each categoryName beginsWith: oldPrefix ])
		do: [ :each | each renameTo: each name category: newPrefix , each name ]
]

RPackage >> renameTo: aSymbol
[
	| oldName newName oldCategoryNames |
	oldName := self name.
	newName := aSymbol asSymbol.
	(self organizer includesPackageNamed: aSymbol)
		ifTrue: [ RPackageConflictError signal: ('A package named {1} already exists' format: {aSymbol}) ].
	oldCategoryNames := (self classTags collect: #categoryName as: Set)
		add: self categoryName;
		yourself.
	self name: aSymbol.
	SystemAnnouncer uniqueInstance
		suspendAllWhile: [ self definedClasses do: [ :each | each category: newName , (each category allButFirst: oldName size) ].
			oldCategoryNames do: [ :each | SystemOrganizer default removeCategory: each ] ].
	self renameTagsPrefixedWith: oldName to: newName.
	self renameExtensionsPrefixedWith: oldName to: newName.
	self organizer
		basicUnregisterPackageNamed: oldName;
		basicRegisterPackage: self.
	SystemAnnouncer uniqueInstance announce: (RPackageRenamed to: self oldName: oldName newName: newName)
]

RPackage >> reportBogusBehaviorOf: aSelector
[
	self
		logCr:
			'RPackage log: Something wrong around ' , aSelector asString
				, 'since the removeKey: is called on not present information.'
]

RPackage >> selectors
[
	| sel |
	sel := Set new.
	metaclassExtensionSelectors valuesDo: [ :each | sel addAll: each ].
	classExtensionSelectors valuesDo: [ :each | sel addAll: each ].
	metaclassDefinedSelectors valuesDo: [ :each | sel addAll: each ].
	classDefinedSelectors valuesDo: [ :each | sel addAll: each ].
	^ sel
]

RPackage >> selectorsForClass: aClass
[
	"Returns all selectors for a class in the receiver without distinction of extensions or not"

	^ (self includesClass: aClass)
		ifFalse: [ self extensionSelectorsForClass: aClass ]
		ifTrue: [ self definedSelectorsForClass: aClass ]
]

RPackage >> systemCategories
[
	"(RPackageOrganizer default packageNamed: 'HelpSystem-Core' asSymbol) systemCategories"

	"(PackageInfo named: 'HelpSystem-Core' asSymbol) systemCategories"

	^ self systemOrganization categories select: [ :cat | self includesSystemCategory: cat ]
]

RPackage >> systemCategoryPrefix
[
	^ self name
]

RPackage >> systemOrganization
[
	^ Smalltalk globals organization
]

RPackage >> toTagName: aSymbol
[
	^ (aSymbol beginsWith: self name , '-')
		ifTrue: [ (aSymbol allButFirst: self name size + 1) asSymbol ]
		ifFalse: [ aSymbol ]
]

RPackage >> unregister
[
	self organizer unregisterPackage: self
]

RPackage >> unregisterClass: aClass
[
	"Private method that declares the mapping between a class and its package."

	self organizer unregisterPackage: self forClass: aClass
]

RPackage >> unregisterClassName: aClassNameSymbol
[
	"Private method that declares the mapping between a class and its package."

	self organizer unregisterPackage: self forClassName: aClassNameSymbol
]

RPackage >> updateDefinedClassNamed: oldString withNewName: newString
[
	"this method should only be used with class names , and not metaclass names"

	(oldString substrings size > 1 or: [ newString substrings size > 1 ])
		ifTrue: [ Error signal: 'You should not use metaclass names' ].	"=> update the 'classDefinedSelectors' dictionary (replace the old key by the new one)       => update the 'metaclassDefinedSelectors' dictionary (replace the old key by the new one)"
	classes remove: oldString.
	classes add: newString.	"Don't forget that class tags also register the classes names."
	self classTags do: [ :aTag | aTag updateDefinedClassNamed: oldString withNewName: newString ].
	self flag: #cyrille.	"what happens if this is a metaclass: it breaks the invariant of the package"	"worse so far the second block below breaks"	"the name of the method should be updateDefinedClassNamed: withNewName:"	"CD: i only use this method when a class is renamed in the system (systemClassRenamedActionFrom:). Normally we are not able to rename a metaclass in the system (?) so we should never end up in a case with metaclass names ?  "
	(classDefinedSelectors at: oldString ifAbsent: [ nil ])
		ifNotNil: [ classDefinedSelectors at: newString put: (classDefinedSelectors at: oldString).
			classDefinedSelectors
				removeKey: oldString
				ifAbsent: [ self reportBogusBehaviorOf: #updateDefinedClassNamed:withNewName: ] ].
	(metaclassDefinedSelectors at: oldString ifAbsent: [ nil ])
		ifNotNil: [ metaclassDefinedSelectors at: newString put: (metaclassDefinedSelectors at: oldString).
			metaclassDefinedSelectors
				removeKey: oldString
				ifAbsent: [ self reportBogusBehaviorOf: #updateDefinedClassNamed:withNewName: ] ]
]

RPackage >> updateDefinedSelector: oldSelector inClass: aClass withNewSelector: newSelector
[
	aClass isMeta
		ifTrue: [ (metaclassDefinedSelectors at: aClass instanceSide name asSymbol) remove: oldSelector.
			(metaclassDefinedSelectors at: aClass instanceSide name asSymbol) add: newSelector ]
		ifFalse: [ (classDefinedSelectors at: aClass name asSymbol) remove: oldSelector.
			(classDefinedSelectors at: aClass name asSymbol) add: newSelector ]
]

RPackage >> updateExtensionForClassNamed: oldString withNewName: newString
[
	"=> update the 'classExtensionsSelectors' dictionary (replace the old key by the new one)
        => update the 'metaclassclassExtensionsSelectors' dictionary (replace the old key by the new one)"

	"classes remove: oldString.
	classes add: newString."

	(metaclassExtensionSelectors at: oldString ifAbsent: [ nil ])
		ifNotNil: [ metaclassExtensionSelectors at: newString put: (metaclassExtensionSelectors at: oldString).
			metaclassExtensionSelectors
				removeKey: oldString
				ifAbsent: [ self reportBogusBehaviorOf: #updateExtensionForClassNamed:withNewName: ] ].
	(classExtensionSelectors at: oldString ifAbsent: [ nil ])
		ifNotNil: [ classExtensionSelectors at: newString put: (classExtensionSelectors at: oldString).
			classExtensionSelectors
				removeKey: oldString
				ifAbsent: [ self reportBogusBehaviorOf: #updateExtensionForClassNamed:withNewName: ] ]
]

RPackage >> updateExtensionSelector: oldSelector inClass: aClass withNewSelector: newSelector
[
	aClass isMeta
		ifTrue: [ (metaclassExtensionSelectors at: aClass instanceSide name asSymbol) remove: oldSelector.
			(metaclassExtensionSelectors at: aClass instanceSide name asSymbol) add: newSelector ]
		ifFalse: [ (classExtensionSelectors at: aClass name asSymbol) remove: oldSelector.
			(classExtensionSelectors at: aClass name asSymbol) add: newSelector ]
]

RPackage >> updateSelector: oldSelector inClass: aClass withNewSelector: newSelector
[
	"here we check if the old seletor is defined in the package or if it is an extension. Then we dispatch the work to the corresponding method.
	For one specific class, a selector is either a defined selector or an extension selector, there is no way to have a couple of class->selector present in both dictionary"

	(self includesDefinedSelector: oldSelector ofClass: aClass)
		ifTrue: [ ^ self updateDefinedSelector: oldSelector inClass: aClass withNewSelector: newSelector ].
	(self includesExtensionSelector: oldSelector ofClass: aClass)
		ifTrue: [ ^ self updateExtensionSelector: oldSelector inClass: aClass withNewSelector: newSelector ]
]

RPackage class >> defaultPackageName
[
	^ #_UnpackagedPackage
]

RPackage class >> help
[
	<wikiStyleHelp: 'RPackage'>
	| stream |
	stream := String new writeStream.
	stream
		nextPut: $!;
		nextPutAll: self name asString;
		cr;
		nextPutAll: self comment;
		cr;
		nextPut: $!;
		nextPutAll: self packageOrganizerClass name asString;
		cr;
		nextPutAll: self packageOrganizerClass comment.
	^ stream contents
]

RPackage class >> initialize
[
	"self initialize"

	super initialize.	"Ensure the organizer will be the RPackageOrganizer default"
	self organizer: nil
]

RPackage class >> named: aString
[
	| newPackage |
	newPackage := self new
		name: aString;
		yourself.
	^ newPackage
]

RPackage class >> organizer
[
	^ PackageGlobalOrganizer ifNil: [ RPackageOrganizer default ]
]

RPackage class >> organizer: aPackageOrganizer
[
	PackageGlobalOrganizer := aPackageOrganizer
]

RPackage class >> packageOrganizerClass
[
	^ RPackageOrganizer
]

RPackage class >> withOrganizer: aNewOrganizer do: aBlock
[
	"Perform an action locally to aNewOrganizer. Does not impact any other organizers."

	| old |
	[ old := self organizer.
	old unregister.
	self organizer: aNewOrganizer.
	aNewOrganizer register.
	aBlock cull: aNewOrganizer ]
		ensure: [ self organizer: old.
			old register.
			aNewOrganizer unregister ]
]

