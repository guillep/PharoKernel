FLIteratingCluster
	superclass: #FLCluster;
	instanceVariables: #(#objects #references );
	package: #'Fuel-Clusters'.

FLIteratingCluster >> add: anObject traceWith: aAnalysis
[
	"Add an object to the cluster and trace references."

	objects addIfNotPresent: anObject ifPresentDo: [ ^ self ].
	self
		referencesOf: anObject
		do: [ :aChild | | actual |
			actual := aChild fuelReplacement.
			self addReferenceFrom: anObject to: actual.
			aAnalysis trace: actual ]
]

FLIteratingCluster >> addReferenceFrom: anObject to: anotherObject
[
	| list |
	list := self references at: anObject ifAbsent: [ nil ].
	list ifNil: [ self references at: anObject put: (list := OrderedCollection new) ].
	list add: anotherObject
]

FLIteratingCluster >> addReferencesFrom: anObject to: aCollection
[
	aCollection do: [ :ref | self addReferenceFrom: anObject to: ref ]
]

FLIteratingCluster >> clusterMaterializeStepWith: aMaterialization
[
	super clusterMaterializeStepWith: aMaterialization.
	objects := Array new: aMaterialization decoder nextEncodedPositiveInteger
]

FLIteratingCluster >> clusterSerializeStepWith: aSerialization
[
	super clusterSerializeStepWith: aSerialization.
	aSerialization encoder encodePositiveInteger: objects size
]

FLIteratingCluster >> initializeAnalyzing
[
	super initializeAnalyzing.
	objects := self newAnalyzingCollection
]

FLIteratingCluster >> materializeInstanceWith: aDecoder
[
	"Hook method that each subclass should customize for its special way of materializing"

	^ self subclassResponsibility
]

FLIteratingCluster >> materializeInstancesStepWith: aDecoder
[
	1 to: objects size do: [ :index | objects at: index put: (self materializeInstanceWith: aDecoder) ]
]

FLIteratingCluster >> newAnalyzingCollection
[
	"Answer a collection for the objects that correspond to this cluster."

	^ FLLargeIdentitySet new
]

FLIteratingCluster >> objects
[
	^ objects
]

FLIteratingCluster >> printNameOn: aStream
[
	super printOn: aStream
]

FLIteratingCluster >> printOn: aStream
[
	self printNameOn: aStream.
	aStream nextPutAll: '->'.
	objects printElementsOn: aStream
]

FLIteratingCluster >> references
[
	^ references ifNil: [ references := FLLargeIdentityDictionary new ]
]

FLIteratingCluster >> referencesOf: anObject do: aBlock
[
	"Evaluate a block with each object referenced by anObject"

	
]

FLIteratingCluster >> registerIndexesOn: aDictionary
[
	self objects do: [ :instance | aDictionary at: instance put: aDictionary size + 1 ]
]

FLIteratingCluster >> serializeInstance: anObject with: anEncoder
[
	"Hook method that each subclass should customize for its special way of serializing"

	
]

FLIteratingCluster >> serializeInstancesStepWith: anEncoder
[
	objects do: [ :instance | self serializeInstance: instance with: anEncoder ]
]

