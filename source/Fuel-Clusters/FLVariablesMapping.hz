FLVariablesMapping
	instanceVariables: #(#mapping #theClass #notIgnoredVariables #references );
	package: #'Fuel-Clusters'.

FLVariablesMapping >> initializeAnalyzing
[
	notIgnoredVariables := self instanceVariableNamesToSerialize.
	mapping := notIgnoredVariables collect: [ :name | theClass instVarIndexFor: name ]
]

FLVariablesMapping >> initializeMaterializingFrom: aDecoder
[
	notIgnoredVariables := (1 to: aDecoder nextEncodedByte) collect: [ :index | aDecoder nextEncodedString ].
	mapping := notIgnoredVariables collect: [ :name | theClass instVarIndexFor: name ifAbsent: [ nil ] ]
]

FLVariablesMapping >> initializeWithClass: aClass
[
	self initialize.
	theClass := aClass
]

FLVariablesMapping >> initializeWithClass: aClass references: aCollection
[
	self initialize.
	theClass := aClass.
	references := aCollection
]

FLVariablesMapping >> instanceVariableNamesToSerialize
[
	| ignoredInstanceVariableNames instanceVariableNamesToSerialize |
	ignoredInstanceVariableNames := theClass fuelIgnoredInstanceVariableNames.
	instanceVariableNamesToSerialize := OrderedCollection new.
	theClass
		instanceVariableNamesDo: [ :name | (ignoredInstanceVariableNames includes: name)
				ifFalse: [ instanceVariableNamesToSerialize add: name ] ].
	^ instanceVariableNamesToSerialize
]

FLVariablesMapping >> map: sourceName to: destinationName
[
	| indexOfVariableToMap |
	indexOfVariableToMap := notIgnoredVariables indexOf: sourceName.
	indexOfVariableToMap > 0
		ifTrue: [ mapping
				at: indexOfVariableToMap
				put: (theClass instVarIndexFor: destinationName ifAbsent: [ self error: 'Bad variable destination.' ]) ]
]

FLVariablesMapping >> materializeReferencesOf: anObject with: aDecoder
[
	mapping
		do: [ :index | | reference |
			reference := aDecoder nextEncodedReference.
			index ifNotNil: [ anObject instVarAt: index put: reference ] ]
]

FLVariablesMapping >> references
[
	^ references
]

FLVariablesMapping >> referencesOf: anObject do: aBlock
[
	mapping do: [ :index | aBlock value: (anObject instVarAt: index) ]
]

FLVariablesMapping >> serializeOn: anEncoder
[
	anEncoder encodeByte: notIgnoredVariables size.
	notIgnoredVariables do: [ :name | anEncoder encodeString: name ]
]

FLVariablesMapping >> serializeReferencesOf: anObject with: anEncoder
[
	(self references at: anObject ifAbsent: [ ^ self ]) do: [ :value | anEncoder encodeReferenceTo: value ]
]

FLVariablesMapping class >> materializing: aClass from: aDecoder
[
	^ self basicNew
		initializeWithClass: aClass;
		initializeMaterializingFrom: aDecoder;
		yourself
]

FLVariablesMapping class >> newAnalyzing: anAnalysis references: aCollection
[
	^ self basicNew
		initializeWithClass: anAnalysis references: aCollection;
		initializeAnalyzing;
		yourself
]

