FLSerializer
	instanceVariables: #(#analyzer #serializationFactory #signature #version #stream #header );
	package: #'Fuel-Core'.

FLSerializer >> addPostMaterializationAction: aCleanBlockClosure
[
	header addPostMaterializationAction: aCleanBlockClosure
]

FLSerializer >> addPreMaterializationAction: aCleanBlockClosure
[
	header addPreMaterializationAction: aCleanBlockClosure
]

FLSerializer >> analyzer
[
	analyzer isNil
		ifTrue: [ analyzer := self defaultAnalyzer ].
	^ analyzer
]

FLSerializer >> analyzer: anObject
[
	analyzer := anObject
]

FLSerializer >> at: key putAdditionalObject: anObject
[
	"This is useful if we want to attach objects to a package that will also be serialized. The way they are stored is key-value."

	header at: key putAdditionalObject: anObject
]

FLSerializer >> defaultAnalyzer
[
	^ FLAnalyzer newDefault
]

FLSerializer >> encodeHeaderWith: anEncoder
[
	"todo: fix how header is encoded"

	anEncoder encodeByte: (header isEmpty
				ifTrue: [ 0 ]
				ifFalse: [ 1 ]).
	header isEmpty
		ifFalse: [ self class newDefault serializationFactory value: header value: anEncoder ]
]

FLSerializer >> encodeSignatureWith: anEncoder
[
	anEncoder encodeBytes: self signature asByteArray
]

FLSerializer >> encodeVersionWith: anEncoder
[
	anEncoder encodeUint16: self version
]

FLSerializer >> fuelAccept: aGeneralMapper
[
	^ aGeneralMapper visitSubstitution: self by: nil
]

FLSerializer >> header
[
	^ header
]

FLSerializer >> initialize
[
	super initialize.
	self signature: self class defaultSignature.
	self version: self class currentVersion.
	header := FLHeader new
]

FLSerializer >> serializationFactory
[
	^ serializationFactory ifNil: [ self setDefaultSerialization.
			serializationFactory ]
]

FLSerializer >> serialize: anObject
[
	"Serialize the graph starting at the root object received and answers the FLSerialization object"

	^ self serialize: anObject on: stream
]

FLSerializer >> serialize: anObject on: aStream
[
	"Serialize the graph starting at the root object received and answers the FLSerialization object"

	FLEncoder
		on: aStream
		globalEnvironment: self analyzer globalEnvironment
		do: [ :anEncoder | self encodeSignatureWith: anEncoder.
			self encodeVersionWith: anEncoder.
			self encodeHeaderWith: anEncoder.
			^ self serializationFactory value: anObject value: anEncoder ]
]

FLSerializer >> serialize: anObject toFileNamed: aFilename
[
	"Serialize the graph starting at the root object received and answers the FLSerialization object"

	StandardFileStream
		forceNewFileNamed: aFilename
		do: [ :aFileStream | aFileStream binary.
			self serialize: anObject on: aFileStream ]
]

FLSerializer >> setDefaultSerialization
[
	^ serializationFactory := [ :anObject :anEncoder | (FLSerialization with: anEncoder root: anObject analyzer: self analyzer)
		run;
		yourself ]
]

FLSerializer >> signature
[
	^ signature
]

FLSerializer >> signature: anObject
[
	signature := anObject
]

FLSerializer >> stream: aStream
[
	stream := aStream
]

FLSerializer >> version
[
	^ version
]

FLSerializer >> version: anObject
[
	version := anObject
]

FLSerializer class >> currentVersion
[
	"If you change this method, you should also create a version in ConfigurationOfFuel and FLMaterializer >> currentVersion"

	^ 19
]

FLSerializer class >> defaultSignature
[
	^ 'FUEL'
]

FLSerializer class >> newDefault
[
	^ self newLight
]

FLSerializer class >> newLight
[
	^ self new
]

FLSerializer class >> on: aStream
[
	^ self newLight
		stream: aStream;
		yourself
]

FLSerializer class >> serialize: anObject on: aStream
[
	self newDefault serialize: anObject on: aStream
]

FLSerializer class >> serialize: anObject toFileNamed: aFilename
[
	self newDefault serialize: anObject toFileNamed: aFilename
]

FLSerializer class >> serializeToByteArray: anObject
[
	"No stream is needed by the user. An internal in-memory stream will be used. This method returns a ByteArray representing the serialization"

	| aStream |
	aStream := WriteStream on: (ByteArray new: 100).
	self newDefault serialize: anObject on: aStream.
	^ aStream contents
]

