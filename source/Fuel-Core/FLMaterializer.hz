Class
	name: #FLMaterializer;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#materializationFactory #signature #version #migrations );
	classVariables: #();
	package: #'Fuel-Core'.

Class FLMaterializer >> fuelAccept: aGeneralMapper
[
^ aGeneralMapper visitSubstitution: self by: nil
]

Class FLMaterializer >> initialize
[
super initialize.self setDefaultMaterialization.self signature: self class defaultSignature.self version: self class currentVersion.migrations := Dictionary new
]

Class FLMaterializer >> materializationFactory
[
^ materializationFactory
]

Class FLMaterializer >> materializeFrom: aStream
[
| aDecoder materialization header |aDecoder := FLDecoder on: aStream migrations: migrations.self verifySignatureFrom: aDecoder.self verifyVersionFrom: aDecoder.	"Here I cannot use #materializeFrom: again because I will end up in an infinitive loop. Therefore, I use #materializationFactory."header := (FLMaterializer newDefault materializationFactory value: aDecoder) root.header executePreMaterializationActions.materialization := materializationFactory value: aDecoder.	"This is useful because when the user materialize something, what it is answered is the materialization objet, and not the materializer. Hence, it is difficult to query the header (like asking the additionalObjects) because materializer is lost. Therefore, we also set the header to the materialization."materialization header: header.	"This is useful because the postMaterializationActions may need to have access to the state of the materialization, for example, to the root"header materialization: materialization.header executePostMaterializationActions.^ materialization
]

Class FLMaterializer >> materializeHeaderFrom: aStream
[
| aDecoder materialization header |aDecoder := FLDecoder on: aStream migrations: migrations.self verifySignatureFrom: aDecoder.self verifyVersionFrom: aDecoder.^ (materializationFactory value: aDecoder) root
]

Class FLMaterializer >> migrateClassNamed: aSymbol toClass: aClass
[
self migrateClassNamed: aSymbol toClass: aClass variables: #()
]

Class FLMaterializer >> migrateClassNamed: aSymbol toClass: aClass variables: aDictionary
[
migrations at: aSymbol put: (FLMigration fromClassNamed: aSymbol toClass: aClass variables: aDictionary)
]

Class FLMaterializer >> migrateClassNamed: aSymbol variables: aDictionary
[
self migrateClassNamed: aSymbol toClass: (Smalltalk globals at: aSymbol) variables: aDictionary
]

Class FLMaterializer >> setDefaultMaterialization
[
materializationFactory := [ :aDecoder | (FLMaterialization with: aDecoder)	run;	yourself ]
]

Class FLMaterializer >> signature
[
^ signature
]

Class FLMaterializer >> signature: anObject
[
signature := anObject
]

Class FLMaterializer >> verifySignatureFrom: aDecoder
[
| streamSignature |streamSignature := ByteArray new: self signature size.aDecoder nextEncodedBytesInto: streamSignature.self signature asByteArray = streamSignature	ifFalse: [ FLBadSignature signalCurrentSignature: self signature streamSignature: streamSignature ]
]

Class FLMaterializer >> verifyVersionFrom: aDecoder
[
| streamVersion |streamVersion := aDecoder nextEncodedUint16.self version = streamVersion	ifFalse: [ FLBadVersion signalCurrentVersion: self version streamVersion: streamVersion ]
]

Class FLMaterializer >> version
[
^ version
]

Class FLMaterializer >> version: anObject
[
version := anObject
]

Metaclass
	name: #FLMaterializer;
	instanceVariables: #().

Metaclass FLMaterializer >> currentVersion
[
	"If you change this method, you should also create a version in ConfigurationOfFuel and FLSerializer >> currentVersion"
^ 18
]

Metaclass FLMaterializer >> defaultSignature
[
^ 'FUEL'
]

Metaclass FLMaterializer >> materializationFromFileNamed: aFilename
[
^ StandardFileStream oldFileNamed: aFilename do: [ :aFileStream | self newDefault materializeFrom: aFileStream binary ]
]

Metaclass FLMaterializer >> materializationHeaderFromFileNamed: aFilename
[
^ StandardFileStream	oldFileNamed: aFilename	do: [ :aFileStream | self newDefault materializeHeaderFrom: aFileStream binary ]
]

Metaclass FLMaterializer >> materializeFromByteArray: byteArray
[
^ (self newDefault materializeFrom: byteArray readStream) root
]

Metaclass FLMaterializer >> materializeFromFileNamed: aFilename
[
^ (self materializationFromFileNamed: aFilename) root
]

Metaclass FLMaterializer >> materializeHeaderFromFileNamed: aFilename
[
^ self materializationHeaderFromFileNamed: aFilename
]

Metaclass FLMaterializer >> newDefault
[
^ self new
]

