AbstractFileReference
	package: #'FileSystem-Core'.

AbstractFileReference >> , extension
[
	^ self withPath: self path , extension
]

AbstractFileReference >> / aString
[
	^ self withPath: self path / aString
]

AbstractFileReference >> <= other
[
	^ self path <= other path
]

AbstractFileReference >> absolutePath
[
	"Returns the absolute path"

	^ self subclassResponsibility
]

AbstractFileReference >> allChildren
[
	"Return all the files and folders recursively nested in the receiver"

	^ CollectVisitor breadthFirst: self resolve collect: [ :entry | entry reference ]
]

AbstractFileReference >> allDirectories
[
	"Return all the directories recursively nested in the receiver."

	^ (SelectVisitor breadthFirst: self resolve select: [ :entry | entry isDirectory ]) collect: [ :each | each reference ]
]

AbstractFileReference >> allEntries
[
	^ CollectVisitor breadthFirst: self resolve
]

AbstractFileReference >> allFiles
[
	"Return all the files (not directories) recursively nested in the receiver."

	^ (SelectVisitor breadthFirst: self resolve select: [ :entry | entry isFile ]) collect: [ :each | each reference ]
]

AbstractFileReference >> asAbsolute
[
	self subclassResponsibility
]

AbstractFileReference >> asFileReference
[
	self subclassResponsibility
]

AbstractFileReference >> asPathWith: anObject
[
	^ self resolve asPathWith: anObject
]

AbstractFileReference >> asResolvedBy: anObject
[
	^ anObject resolveReference: self
]

AbstractFileReference >> base
[
	"Returns the base of the basename, i.e. /foo/gloops.taz base is 'gloops'"

	^ self fullPath base
]

AbstractFileReference >> basename
[
	"Returns the basename, i.e. /foo/gloops.taz basename is 'gloops.taz'"

	^ self fullPath basename
]

AbstractFileReference >> basenameWithIndicator
[
	"Returns the basename with the indicator appended, i.e. /foo/gloops.taz basenameWithIndicator is 'gloops.taz', whereras /foo basenameWithIndicator is 'foo/'"

	^ self basename , self indicator
]

AbstractFileReference >> basenameWithoutExtension
[
	"Returns the basename, i.e. /foo/gloops.taz basenameWithoutExtension is 'gloops'"

	^ self fullPath basenameWithoutExtension
]

AbstractFileReference >> childGeneratorBlock: doBlock matching: patterns
[
	"
	FileDirectory default fileNamesMatching: '*'
	FileDirectory default fileNamesMatching: '*.image;*.changes'
	"

	| files reference |
	files := Set new.
	reference := self resolve.
	(patterns findTokens: ';' , String crlf)
		do: [ :pattern | doBlock value: reference value: [ :basename | (pattern match: basename)
						ifTrue: [ files add: self / basename ] ] ].
	^ files asOrderedCollection
]

AbstractFileReference >> childNames
[
	^ self children collect: #basename
]

AbstractFileReference >> children
[
	"Answer an array containing references to the direct children of this reference."

	| reference |
	reference := self resolve.
	^ (reference fileSystem childNamesAt: reference path) collect: [ :aName | self / aName ]
]

AbstractFileReference >> childrenMatching: patterns
[
	"
	FileSystem disk workingDirectory childrenMatching: '*'
	FileSystem disk workingDirectory childrenMatching: '*.image;*.changes'
	"

	^ self
		childGeneratorBlock: [ :reference :aBlock | reference fileSystem childNamesAt: reference path do: aBlock ]
		matching: patterns
]

AbstractFileReference >> contains: anObject
[
	"Return true if anObject is in a subfolder of me"

	^ anObject isContainedBy: self resolve
]

AbstractFileReference >> containsPath: aPath
[
	^ self fullPath containsPath: aPath
]

AbstractFileReference >> contents
[
	self readStreamDo: [ :stream | ^ stream contents ]
]

AbstractFileReference >> copyAllTo: aResolvable
[
	"Performs a deep copy of the receiver, to a location specified by the argument. If the receiver is a file, the file will be copied; if a directory, the directory and its contents will be copied recursively. The argument must be a reference that doesn't exist; it will be created by the copy."

	CopyVisitor copy: self resolve asAbsolute to: aResolvable resolve
]

AbstractFileReference >> copyTo: aReference
[
	^ self resolve copyTo: aReference resolve
]

AbstractFileReference >> copyWithPath: newPath
[
	self subclassResponsibility
]

AbstractFileReference >> createDirectory
[
	"Create a new repository and raise an error if the directory already exist."

	self resolve createDirectory
]

AbstractFileReference >> creationTime
[
	^ self resolve creationTime
]

AbstractFileReference >> delete
[
	"Delete the receiver, does raise an error if it is not present."

	^ self resolve delete
]

AbstractFileReference >> deleteAll
[
	"Delete this directory and all children of it, raise an error if the file does not exist."

	DeleteVisitor delete: self resolve
]

AbstractFileReference >> deleteAllChildren
[
	"delete all children of the receiver, raise an error if the receiver does not exist"

	self children do: [ :aReference | aReference deleteAll ]
]

AbstractFileReference >> deleteIfAbsent: aBlock
[
	"Delete the receiver, when it does not exist evaluate the block"

	self resolve deleteIfAbsent: aBlock
]

AbstractFileReference >> directories
[
	"Return all the directories (by opposition to files) contained in the receiver"

	| reference |
	reference := self resolve.
	^ (reference fileSystem directoryNamesAt: reference path) collect: [ :aName | self withPath: self path / aName ]
]

AbstractFileReference >> directoriesMatching: patterns
[
	"
	FileSystem disk workingDirectory directoriesMatching: '*'
	FileSystem disk workingDirectory directoriesMatching: 'package-cache'
	"

	^ self
		childGeneratorBlock: [ :reference :aBlock | reference fileSystem directoryNamesAt: reference path do: aBlock ]
		matching: patterns
]

AbstractFileReference >> directoryNames
[
	^ self directories collect: #basename
]

AbstractFileReference >> ensureCreateDirectory
[
	"Verifies that the directory does not exist and only creates if necessary. Do not remove files contained if they exist."

	^ self resolve ensureCreateDirectory
]

AbstractFileReference >> ensureCreateFile
[
	"Create if necessary a file for the receiver."

	self writeStream close
]

AbstractFileReference >> ensureDelete
[
	"Delete the file and does not raise exception if it does not exist contrary to delete"

	self deleteIfAbsent: [  ]
]

AbstractFileReference >> ensureDeleteAll
[
	"Delete this directory and all children of it, and does not raise an error if the file does not exist."

	self exists
		ifFalse: [ ^ self ].
	self deleteAll
]

AbstractFileReference >> ensureDeleteAllChildren
[
	"delete all children of the receiver and does not raise an error if the receiver does not exist"

	self exists
		ifFalse: [ ^ self ].
	self deleteAllChildren
]

AbstractFileReference >> entries
[
	^ self resolve entries
]

AbstractFileReference >> entry
[
	^ self resolve entry
]

AbstractFileReference >> exists
[
	^ self resolve exists
]

AbstractFileReference >> extension
[
	^ self fullPath extension
]

AbstractFileReference >> extensions
[
	"#('foo' 'foo.tar' 'foo.tar.gz' 'foo.1.tar' 'foo.1.tar.gz') collect: [:thing| thing extensions] => #(#() #('tar') #('tar' 'gz') #('1' 'tar') #('1' 'tar' 'gz'))"

	^ self fullPath extensions
]

AbstractFileReference >> fileNames
[
	^ self files collect: #basename
]

AbstractFileReference >> fileSystem
[
	^ self resolve fileSystem
]

AbstractFileReference >> files
[
	"Return all the files (as opposed to folders) contained in the receiver"

	| reference |
	reference := self resolve.
	^ (reference fileSystem fileNamesAt: reference path) collect: [ :aName | self withPath: self path / aName ]
]

AbstractFileReference >> filesMatching: patterns
[
	"
	FileSystem disk workingDirectory filesMatching: '*'
	FileSystem disk workingDirectory filesMatching: '*.image;*.changes'
	"

	^ self
		childGeneratorBlock: [ :reference :aBlock | reference fileSystem fileNamesAt: reference path do: aBlock ]
		matching: patterns
]

AbstractFileReference >> fullName
[
	^ self resolve fullName
]

AbstractFileReference >> fullNameWithIndicator
[
	"Returns the basename with the indicator appended, i.e. /foo/gloops.taz basenameWithIndicator is '/foo/gloops.taz', whereras /foo basenameWithIndicator is '/foo/'"

	^ self fullName , self indicator
]

AbstractFileReference >> fullPath
[
	"Returns the absolute path, better use absolutePath"

	^ self subclassResponsibility
]

AbstractFileReference >> glob: aBlock
[
	^ SelectVisitor breadthFirst: self resolve select: aBlock
]

AbstractFileReference >> hasChildren
[
	^ self resolve hasChildren
]

AbstractFileReference >> hasDirectories
[
	^ self resolve hasDirectories
]

AbstractFileReference >> hasFiles
[
	^ self resolve hasFiles
]

AbstractFileReference >> hash
[
	"Hash is reimplemented because #= is reimplemented"

	^ self path hash
]

AbstractFileReference >> humanReadableSize
[
	^ self size humanReadableSIByteSize
]

AbstractFileReference >> ifFile: fBlock ifDirectory: dBlock ifAbsent: aBlock
[
	^ self isFile
		ifTrue: fBlock
		ifFalse: [ self isDirectory
				ifTrue: dBlock
				ifFalse: aBlock ]
]

AbstractFileReference >> indicator
[
	"Returns a string indicating the type of reference:
	- '?' for a non existing reference',
	- '/' for a directory,
	- the empty string for a file."

	"When this framework gets more complete, it is possible to extend this behavior with the following indicators (taken from unix ls utility):
	- '*' for a regular file that is executable
	- '@' for a symbolic link
	- '|' for FIFOs
	- '=' for sockets
	- '>' for doors"

	^ self exists
		ifTrue: [ self isDirectory
				ifTrue: [ '/' ]
				ifFalse: [ '' ] ]
		ifFalse: [ '?' ]
]

AbstractFileReference >> isAbsolute
[
	self subclassResponsibility
]

AbstractFileReference >> isChildOf: anObject
[
	^ self parent = anObject
]

AbstractFileReference >> isContainedBy: anObject
[
	"DoubleDispatch helper for #contains:"

	^ anObject containsReference: self resolve
]

AbstractFileReference >> isDirectory
[
	^ self resolve isDirectory
]

AbstractFileReference >> isFile
[
	^ self resolve isFile
]

AbstractFileReference >> isReadable
[
	^ self resolve isReadable
]

AbstractFileReference >> isRelative
[
	self subclassResponsibility
]

AbstractFileReference >> isRoot
[
	^ self resolve isRoot
]

AbstractFileReference >> isWritable
[
	^ self resolve isWritable
]

AbstractFileReference >> macTypeAndCreator
[
	^ self resolve macTypeAndCreator
]

AbstractFileReference >> makeRelative: anObject
[
	^ anObject relativeToReference: self resolve
]

AbstractFileReference >> mimeTypes
[
	^ self resolve mimeTypes
]

AbstractFileReference >> modificationTime
[
	^ self resolve modificationTime
]

AbstractFileReference >> moveTo: aReference
[
	"Move the receiver in the location passed as argument.
	
	(FileSystem disk workingDirectory / 'paf' ) ensureCreateFile.
	(FileSystem disk workingDirectory / 'fooFolder') ensureCreateDirectory. 
	(FileSystem disk workingDirectory / 'paf' ) moveTo: (FileSystem disk workingDirectory / 'fooFolder' / 'paf')
	"

	^ self resolve moveTo: aReference
]

AbstractFileReference >> nextVersion
[
	^ self resolve nextVersion
]

AbstractFileReference >> openWritable: aBoolean
[
	^ self resolve openWritable: aBoolean
]

AbstractFileReference >> parent
[
	^ self withPath: self path parent
]

AbstractFileReference >> pathSegments
[
	^ self fullPath segments
]

AbstractFileReference >> pathString
[
	^ self resolve pathString
]

AbstractFileReference >> permissions
[
	"Return the FileSystemPermission for this node"

	^ self resolve permissions
]

AbstractFileReference >> readStream
[
	self subclassResponsibility
]

AbstractFileReference >> readStreamDo: aBlock
[
	| stream |
	stream := self readStream.
	^ [ aBlock value: stream ]
		ensure: [ stream close ]
]

AbstractFileReference >> readStreamDo: doBlock ifAbsent: absentBlock
[
	^ self isFile
		ifTrue: [ self readStreamDo: doBlock ]
		ifFalse: absentBlock
]

AbstractFileReference >> readStreamIfAbsent: absentBlock
[
	^ self isFile
		ifTrue: [ self readStream ]
		ifFalse: absentBlock
]

AbstractFileReference >> relativeTo: landmark
[
	"Answer a new path relative to landmark."

	"parent/child/grandChild relativeTo: parent returns child/grandChild
	(Filesystem disk / 'griffle' / 'plonk' / 'nurp') relativeTo: (Filesystem disk / 'griffle') 
	returns plonk/nurp"

	^ landmark makeRelative: self resolve
]

AbstractFileReference >> relativeToPath: landmarkPath
[
	^ self fullPath relativeTo: landmarkPath
]

AbstractFileReference >> relativeToReference: landmarkReference
[
	"Return the path of the receiver relative to landmarkReference."

	^ self fullPath relativeTo: landmarkReference path
]

AbstractFileReference >> renameTo: newBasename
[
	self subclassResponsibility
]

AbstractFileReference >> resolve
[
	^ self subclassResponsibility
]

AbstractFileReference >> resolve: anObject
[
	^ anObject asResolvedBy: self
]

AbstractFileReference >> resolvePath: aPath
[
	^ self withPath: (self path resolvePath: aPath)
]

AbstractFileReference >> resolveReference: aReference
[
	^ aReference isAbsolute
		ifTrue: [ aReference ]
		ifFalse: [ self withPath: aReference path ]
]

AbstractFileReference >> resolveString: aString
[
	self subclassResponsibility
]

AbstractFileReference >> size
[
	^ self resolve size
]

AbstractFileReference >> streamWritable: writable do: aBlock
[
	^ writable
		ifTrue: [ self writeStreamDo: aBlock ]
		ifFalse: [ self readStreamDo: aBlock ]
]

AbstractFileReference >> uri
[
	"Convert my path into a file:// type url. For odd characters use %20 notation."

	^ self asUrl
]

AbstractFileReference >> withExtension: aString
[
	^ self withPath: (self path withExtension: aString)
]

AbstractFileReference >> withPath: newPath
[
	^ self path == newPath
		ifTrue: [ self ]
		ifFalse: [ self copyWithPath: newPath ]
]

AbstractFileReference >> writeStream
[
	self subclassResponsibility
]

AbstractFileReference >> writeStreamDo: aBlock
[
	| stream |
	stream := self writeStream.
	^ [ aBlock value: stream ]
		ensure: [ stream close ]
]

AbstractFileReference >> writeStreamDo: doBlock ifPresent: presentBlock
[
	^ self isFile
		ifTrue: presentBlock
		ifFalse: [ self writeStreamDo: doBlock ]
]

AbstractFileReference >> writeStreamIfPresent: presentBlock
[
	^ self isFile
		ifTrue: presentBlock
		ifFalse: [ self writeStream ]
]

