FileReference
	superclass: #AbstractFileReference;
	instanceVariables: #(#filesystem #path );
	package: #'FileSystem-Core'.

FileReference >> = other
= other
	^ self species = other species and: [ self path = other path and: [ self fileSystem = other fileSystem ] ]

FileReference >> absolutePath
absolutePath
	"Return the absolute of the receiver"

	^ self path

FileReference >> asAbsolute
asAbsolute
	"Return the receiver as an absolute file reference."

	^ self isAbsolute
		ifTrue: [ self ]
		ifFalse: [ filesystem referenceTo: (filesystem resolve: path) ]

FileReference >> asFileReference
asFileReference
	^ self

FileReference >> containsReference: aReference
containsReference: aReference
	^ aReference fileSystem = filesystem and: [ path contains: aReference path ]

FileReference >> copyTo: aReference
copyTo: aReference
	self isDirectory
		ifTrue: [ aReference ensureCreateDirectory ]
		ifFalse: [ filesystem = aReference fileSystem
				ifTrue: [ filesystem copy: path to: aReference path ]
				ifFalse: [ filesystem copy: path toReference: aReference ] ]

FileReference >> copyWithPath: newPath
copyWithPath: newPath
	^ filesystem referenceTo: newPath

FileReference >> createDirectory
createDirectory
	"Create a directory if it does not already exist, if this is the case raise the DirectoryExists exception."

	filesystem createDirectory: path

FileReference >> creationTime
creationTime
	^ filesystem creationTime: self path

FileReference >> delete
delete
	filesystem delete: path

FileReference >> deleteIfAbsent: aBlock
deleteIfAbsent: aBlock
	self exists
		ifTrue: [ self delete ]
		ifFalse: aBlock

FileReference >> ensureCreateDirectory
ensureCreateDirectory
	"Create if necessary a directory for the receiver."

	filesystem ensureCreateDirectory: path

FileReference >> entries
entries
	"Return the entries (meta data - file description) of the direct children of the receiver"

	^ self fileSystem entriesAt: self path

FileReference >> entry
entry
	"Return the entry (meta data) describing the receiver."

	^ filesystem entryAt: path

FileReference >> exists
exists
	^ filesystem exists: path

FileReference >> fileSystem
fileSystem
	"Return the filesystem to which the receiver belong."

	^ filesystem

FileReference >> fullName
fullName
	"Return the full path name of the receiver."

	^ filesystem stringFromPath: (filesystem resolve: path)

FileReference >> fullPath
fullPath
	^ self path

FileReference >> hasChildren
hasChildren
	"Return whether the receiver has any children."

	"FileSystem workingDirectory hasChildren"

	^ filesystem hasChildren: path

FileReference >> hasDirectories
hasDirectories
	"Return whether the receiver has children that are directories."

	"FileSystem workingDirectory hasDirectories"

	^ filesystem hasDirectories: path

FileReference >> hasFiles
hasFiles
	"Return whether the receiver has children that are files."

	"FileSystem workingDirectory hasFiles"

	^ filesystem hasFiles: path

FileReference >> hash
hash
	^ path hash bitXor: filesystem hash

FileReference >> isAbsolute
isAbsolute
	^ path isAbsolute

FileReference >> isDirectory
isDirectory
	^ filesystem isDirectory: path

FileReference >> isFile
isFile
	^ filesystem isFile: path

FileReference >> isReadable
isReadable
	^ filesystem isReadable: path

FileReference >> isRelative
isRelative
	^ path isRelative

FileReference >> isRoot
isRoot
	^ path isRoot

FileReference >> isSymlink
isSymlink
	^ filesystem isSymlink: path

FileReference >> isWritable
isWritable
	^ filesystem isWritable: path

FileReference >> macTypeAndCreator
macTypeAndCreator
	| results typeString creatorString |
	"get the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. Does nothing on other platforms (where the underlying primitive is a noop)."
	"FileDirectory default getMacFileNamed: 'foo'"
	self flag: 'TODO'	"	typeString := ByteArray new: 4 withAll: ($? asInteger). #[63 63 63 63]	creatorString := ByteArray new: 4 withAll: ($? asInteger).	[self primGetMacFileNamed: (self fullNameFor: fileName) asVmPathName		type: typeString		creator: creatorString.] ensure: 		[typeString := typeString asString. 		creatorString := creatorString asString].	results := Array with: typeString convertFromSystemString with: creatorString convertFromSystemString.	^results"

FileReference >> mimeTypes
mimeTypes
	"Return the possible mime types for the given path."

	^ filesystem mimeTypesAt: path

FileReference >> modificationTime
modificationTime
	^ filesystem modificationTime: self path

FileReference >> moveTo: aReference
moveTo: aReference
	| result |
	result := self fileSystem rename: self path to: aReference path.
	result ifNotNil: [ self setFileSystem: filesystem path: aReference path ]

FileReference >> nextVersion
nextVersion
	"Assumes a file name includes a version number encoded as '.' followed by digits 
	preceding the file extension.  Increment the version number and answer the new file name.
	If a version number is not found, return just the file"

	| parent version versionNumbers nameWithoutExtension |
	self exists
		ifFalse: [ ^ self ].
	parent := self parent.
	nameWithoutExtension := self basename copyUpTo: $..
	versionNumbers := parent files
		select: [ :f | f basename beginsWith: nameWithoutExtension ]
		thenCollect: [ :f | Number squeezeNumberOutOfString: f basename ifFail: [ 0 ] ].
	versionNumbers ifEmpty: [ ^ self ].
	version := versionNumbers max + 1.
	^ parent / (nameWithoutExtension , '.' , version asString) , self extension

FileReference >> openWritable: aBoolean
openWritable: aBoolean
	^ filesystem open: path writable: aBoolean

FileReference >> path
path
	"Return the path internal representation that denotes the receiver in the context of its filesystem. "

	^ path

FileReference >> pathString
pathString
	"Return the full path name of the receiver."

	^ filesystem stringFromPath: (filesystem resolve: path)

FileReference >> permissions
permissions
	^ filesystem permissions: self path

FileReference >> printOn: aStream
printOn: aStream
	filesystem forReferencePrintOn: aStream.
	filesystem printPath: path on: aStream

FileReference >> readStream
readStream
	^ filesystem readStreamOn: self path

FileReference >> renameTo: newBasename
renameTo: newBasename
	| destinationPath |
	destinationPath := self fileSystem rename: self to: self parent / newBasename.
	destinationPath ifNotNil: [ self setFileSystem: filesystem path: destinationPath ].
	^ self

FileReference >> resolve
resolve
	^ self

FileReference >> resolvePath: anObject
resolvePath: anObject
	^ self withPath: (path resolve: anObject)

FileReference >> resolveReference: aReference
resolveReference: aReference
	^ (filesystem = aReference fileSystem or: [ aReference isRelative ])
		ifTrue: [ filesystem referenceTo: (path resolvePath: aReference path) ]
		ifFalse: [ aReference ]

FileReference >> resolveString: aString
resolveString: aString
	| thePath |
	thePath := filesystem pathFromString: aString.
	^ filesystem referenceTo: (path resolve: thePath)

FileReference >> setFileSystem: aFilesystem path: aPath
setFileSystem: aFilesystem path: aPath
	filesystem := aFilesystem.
	path := aPath

FileReference >> setMacType: aTypeString creator: aCreatorString
setMacType: aTypeString creator: aCreatorString
	self flag: 'TODO'	" 	self primSetMacFileNamed: (self fullNameFor: fileName) asVmPathName		type: typeString convertToSystemString		creator: creatorString convertToSystemString."

FileReference >> size
size
	^ filesystem size: path

FileReference >> writeStream
writeStream
	^ filesystem writeStreamOn: self path

FileReference class >> / aString
/ aString
	"Answer a reference to the argument resolved against the root of the current disk filesystem."

	^ FileSystem disk / aString

FileReference class >> fileSystem: aFilesystem path: aPath
fileSystem: aFilesystem path: aPath
	^ self new setFileSystem: aFilesystem path: aPath

