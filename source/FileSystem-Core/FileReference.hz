FileReference
	superclass: #AbstractFileReference;
	instanceVariables: #(#filesystem #path );
	package: #'FileSystem-Core'.

FileReference >> , extension
[
	^ self withPath: self path , extension
]

FileReference >> = other
[
	^ self species = other species and: [ self path = other path and: [ self fileSystem = other fileSystem ] ]
]

FileReference >> absolutePath
[
	"Return the absolute of the receiver"

	^ self path isRelative
		ifFalse: [ self path ]
		ifTrue: [ filesystem resolve: self path ]
]

FileReference >> asAbsolute
[
	"Return the receiver as an absolute file reference."

	^ self isAbsolute
		ifTrue: [ self ]
		ifFalse: [ filesystem referenceTo: (filesystem resolve: path) ]
]

FileReference >> asFileReference
[
	^ self
]

FileReference >> binaryReadStream
[
	^ filesystem binaryReadStreamOn: self path
]

FileReference >> containsReference: aReference
[
	^ aReference fileSystem = filesystem and: [ path contains: aReference path ]
]

FileReference >> copyTo: aReference
[
	self isDirectory
		ifTrue: [ aReference ensureCreateDirectory ]
		ifFalse: [ filesystem = aReference fileSystem
				ifTrue: [ filesystem copy: path to: aReference resolve path ]
				ifFalse: [ filesystem copy: path toReference: aReference ] ]
]

FileReference >> copyWithPath: newPath
[
	^ filesystem referenceTo: newPath
]

FileReference >> createDirectory
[
	"Create a directory if it does not already exist, if this is the case raise the DirectoryExists exception."

	filesystem createDirectory: path
]

FileReference >> creationTime
[
	^ filesystem creationTime: self path
]

FileReference >> delete
[
	filesystem delete: path
]

FileReference >> deleteIfAbsent: aBlock
[
	self exists
		ifTrue: [ self delete ]
		ifFalse: aBlock
]

FileReference >> ensureCreateDirectory
[
	"Create if necessary a directory for the receiver."

	filesystem ensureCreateDirectory: path
]

FileReference >> entries
[
	"Return the entries (meta data - file description) of the direct children of the receiver"

	^ self fileSystem entriesAt: self path
]

FileReference >> entry
[
	"Return the entry (meta data) describing the receiver."

	^ filesystem entryAt: path
]

FileReference >> exists
[
	^ filesystem exists: path
]

FileReference >> fileSystem
[
	"Return the filesystem to which the receiver belong."

	^ filesystem
]

FileReference >> fullName
[
	"Return the full path name of the receiver."

	^ filesystem stringFromPath: (filesystem resolve: path)
]

FileReference >> fullPath
[
	^ self path
]

FileReference >> hasChildren
[
	"Return whether the receiver has any children."

	"FileSystem workingDirectory hasChildren"

	^ filesystem hasChildren: path
]

FileReference >> hasDirectories
[
	"Return whether the receiver has children that are directories."

	"FileSystem workingDirectory hasDirectories"

	^ filesystem hasDirectories: path
]

FileReference >> hasFiles
[
	"Return whether the receiver has children that are files."

	"FileSystem workingDirectory hasFiles"

	^ filesystem hasFiles: path
]

FileReference >> hash
[
	^ path hash bitXor: filesystem hash
]

FileReference >> isAbsolute
[
	^ path isAbsolute
]

FileReference >> isDirectory
[
	^ filesystem isDirectory: path
]

FileReference >> isFile
[
	^ filesystem isFile: path
]

FileReference >> isReadable
[
	^ filesystem isReadable: path
]

FileReference >> isRelative
[
	^ path isRelative
]

FileReference >> isRoot
[
	^ path isRoot
]

FileReference >> isSymlink
[
	^ filesystem isSymlink: path
]

FileReference >> isWritable
[
	^ filesystem isWritable: path
]

FileReference >> macTypeAndCreator
[
	| results typeString creatorString |
	"get the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. Does nothing on other platforms (where the underlying primitive is a noop)."
	"FileDirectory default getMacFileNamed: 'foo'"
	self flag: 'TODO'	"	typeString := ByteArray new: 4 withAll: ($? asInteger). #[63 63 63 63]	creatorString := ByteArray new: 4 withAll: ($? asInteger).	[self primGetMacFileNamed: (self fullNameFor: fileName) asVmPathName		type: typeString		creator: creatorString.] ensure: 		[typeString := typeString asString. 		creatorString := creatorString asString].	results := Array with: typeString convertFromSystemString with: creatorString convertFromSystemString.	^results"
]

FileReference >> mimeTypes
[
	"Return the possible mime types for the given path."

	^ filesystem mimeTypesAt: path
]

FileReference >> modificationTime
[
	^ filesystem modificationTime: self path
]

FileReference >> moveTo: aReference
[
	| result |
	result := self fileSystem rename: self path to: aReference resolve path.
	result ifNotNil: [ self setFileSystem: filesystem path: aReference path ]
]

FileReference >> nextVersion
[
	"Assumes a file name includes a version number encoded as '.' followed by digits 
	preceding the file extension.  Increment the version number and answer the new file name.
	If a version number is not found, return just the file"

	| parent version versionNumbers nameWithoutExtension |
	self exists
		ifFalse: [ ^ self ].
	parent := self parent.
	nameWithoutExtension := self basename copyUpTo: $..
	versionNumbers := parent files
		select: [ :f | f basename beginsWith: nameWithoutExtension ]
		thenCollect: [ :f | Number squeezeNumberOutOfString: f basename ifFail: [ 0 ] ].
	versionNumbers ifEmpty: [ ^ self ].
	version := versionNumbers max + 1.
	^ parent / (nameWithoutExtension , '.' , version asString) , self extension
]

FileReference >> openWritable: aBoolean
[
	^ filesystem open: path writable: aBoolean
]

FileReference >> path
[
	"Return the path internal representation that denotes the receiver in the context of its filesystem. "

	^ path
]

FileReference >> pathString
[
	"Return the full path name of the receiver."

	^ filesystem stringFromPath: (filesystem resolve: path)
]

FileReference >> permissions
[
	^ filesystem permissions: self path
]

FileReference >> printOn: aStream
[
	filesystem forReferencePrintOn: aStream.
	filesystem printPath: path on: aStream
]

FileReference >> readStream
[
	^ filesystem readStreamOn: self path
]

FileReference >> renameTo: newBasename
[
	| destinationPath |
	destinationPath := self fileSystem rename: self to: self parent / newBasename.
	destinationPath ifNotNil: [ self setFileSystem: filesystem path: destinationPath ].
	^ self
]

FileReference >> resolve
[
	^ self
]

FileReference >> resolvePath: anObject
[
	^ self withPath: (path resolve: anObject)
]

FileReference >> resolveReference: aReference
[
	^ (filesystem = aReference fileSystem or: [ aReference isRelative ])
		ifTrue: [ filesystem referenceTo: (path resolvePath: aReference path) ]
		ifFalse: [ aReference ]
]

FileReference >> resolveString: aString
[
	| thePath |
	thePath := filesystem pathFromString: aString.
	^ filesystem referenceTo: (path resolve: thePath)
]

FileReference >> setFileSystem: aFilesystem path: aPath
[
	filesystem := aFilesystem.
	path := aPath
]

FileReference >> setMacType: aTypeString creator: aCreatorString
[
	self flag: 'TODO'	" 	self primSetMacFileNamed: (self fullNameFor: fileName) asVmPathName		type: typeString convertToSystemString		creator: creatorString convertToSystemString."
]

FileReference >> size
[
	^ filesystem size: path
]

FileReference >> writeStream
[
	^ filesystem writeStreamOn: self path
]

FileReference class >> / aString
[
	"Answer a reference to the argument resolved against the root of the current disk filesystem."

	^ FileSystem disk / aString
]

FileReference class >> fileSystem: aFilesystem path: aPath
[
	^ self new setFileSystem: aFilesystem path: aPath
]

FileReference class >> newTempFilePrefix: prefix suffix: suffix
[
	| tmpDir random fileName |
	tmpDir := FileLocator temp asFileReference.
	[ random := UUIDGenerator default generateRandomBitsOfLength: 100.
	fileName := prefix , random asString , suffix ]
		doWhileTrue: [ (tmpDir / fileName) exists ].
	^ fileName asFileReference
]

