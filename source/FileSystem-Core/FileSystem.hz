FileSystem
	instanceVariables: #(#workingDirectory #store );
	package: #'FileSystem-Core'.

FileSystem >> * anObject
[* anObject
	"Return a relative reference."

	^ self referenceTo: Path * anObject
]

FileSystem >> / anObject
[/ anObject
	"Return the absolute reference obtained by resolving anObject against the
	root of this filesystem."

	^ self root / anObject
]

FileSystem >> = other
[= other
	^ self species = other species and: [ self store = other store ]
]

FileSystem >> changeDirectory: aPath
[changeDirectory: aPath
	self workingDirectoryPath: (self resolve: aPath)
]

FileSystem >> checkName: aString fixErrors: fixErrors
[checkName: aString fixErrors: fixErrors
	^ store checkName: aString fixErrors: fixErrors
]

FileSystem >> childNamesAt: aResolvable
[childNamesAt: aResolvable
	^ Array streamContents: [ :out | self childNamesAt: aResolvable do: [ :path | out nextPut: path ] ]
]

FileSystem >> childNamesAt: aResolvable do: aBlock
[childNamesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		nodesDo: [ :entry | aBlock value: (store basenameFromEntry: entry) ]
]

FileSystem >> childrenAt: aResolvable
[childrenAt: aResolvable
	^ Array streamContents: [ :out | self childrenAt: aResolvable do: [ :path | out nextPut: path ] ]
]

FileSystem >> childrenAt: aResolvable do: aBlock
[childrenAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		nodesDo: [ :entry | aBlock value: path / (store basenameFromEntry: entry) ]
]

FileSystem >> close
[close
	store close
]

FileSystem >> copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock
[copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock
	"Copy the file referenced as sourcePath to the destination referred as destPath. Perform associate actions in case of problems."

	store
		copy: (self resolve: sourcePath)
		ifAbsent: absentBlock
		to: (self resolve: destinationPath)
		ifPresent: presentBlock
		fileSystem: self
]

FileSystem >> copy: sourcePath to: destPath
[copy: sourcePath to: destPath
	"Copy the file referenced as sourcePath to the destination referred as destPath.  
	If there is no file at sourcePath, raise FileDoesNotExist.
	If destPath is a file, raise FileExists."

	self
		copy: sourcePath
		ifAbsent: [ store signalFileDoesNotExist: sourcePath ]
		to: destPath
		ifPresent: [ store signalFileExists: destPath ]
]

FileSystem >> copy: aPath toReference: destRef
[copy: aPath toReference: destRef
	| inputStream path |
	path := self resolve: aPath.
	[ inputStream := self readStreamOn: path.
	inputStream ifNil: [ store signalFileDoesNotExist: path ].
	destRef fileSystem copyFrom: inputStream to: destRef path ]
		ensure: [ inputStream ifNotNil: [ inputStream close ] ]
]

FileSystem >> copyFrom: inputStream to: destPath
[copyFrom: inputStream to: destPath
	| buffer out |
	out := nil.
	(self exists: destPath)
		ifTrue: [ store signalFileExists: destPath ].
	^ [ out := self writeStreamOn: destPath.
	buffer := ByteArray new: 1024.
	[ inputStream atEnd ] whileFalse: [ buffer := inputStream nextInto: buffer.
			out nextPutAll: buffer ] ]
		ensure: [ out ifNotNil: [ out close ] ]
]

FileSystem >> createDirectory: aResolvable
[createDirectory: aResolvable
	"Resolve aResolvable into an absolute path, then as the store to create a directory there. 
	The store is expected to raise an exception if it cannot do so."

	^ store createDirectory: (self resolve: aResolvable)
]

FileSystem >> creationTime: aResolvable
[creationTime: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a directory, false if it refers to a file or doesn't exist."

	^ store creationTime: (self resolve: aResolvable)
]

FileSystem >> delete: aResolvable
[delete: aResolvable
	store delete: (self resolve: aResolvable)
]

FileSystem >> delimiter
[delimiter
	"Return path delimiter used by this filesystem."

	^ store delimiter
]

FileSystem >> directoriesAt: aResolvable
[directoriesAt: aResolvable
	^ Array streamContents: [ :out | self directoriesAt: aResolvable do: [ :path | out nextPut: path ] ]
]

FileSystem >> directoriesAt: aResolvable do: aBlock
[directoriesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		directoryNodesDo: [ :entry | aBlock value: path / (store basenameFromEntry: entry) ]
]

FileSystem >> directoryNamesAt: aResolvable
[directoryNamesAt: aResolvable
	^ Array streamContents: [ :out | self directoryNamesAt: aResolvable do: [ :name | out nextPut: name ] ]
]

FileSystem >> directoryNamesAt: aResolvable do: aBlock
[directoryNamesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		directoryNodesDo: [ :entry | aBlock value: (store basenameFromEntry: entry) ]
]

FileSystem >> ensureCreateDirectory: aResolvable
[ensureCreateDirectory: aResolvable
	"Resolve the argument to an absolute path, then ask the store to make
	sure that all the directories contained in the argument path exist or are created."

	store ensureCreateDirectory: (self resolve: aResolvable)
]

FileSystem >> entriesAt: aResolvable
[entriesAt: aResolvable
	^ Array streamContents: [ :out | self entriesAt: aResolvable do: [ :entry | out nextPut: entry ] ]
]

FileSystem >> entriesAt: aResolvable do: aBlock
[entriesAt: aResolvable do: aBlock
	^ self entriesAt: aResolvable ifAbsent: [ store signalDirectoryDoesNotExist: (self resolve: aResolvable) ] do: aBlock
]

FileSystem >> entriesAt: aResolvable ifAbsent: absentBlock do: aBlock
[entriesAt: aResolvable ifAbsent: absentBlock do: aBlock
	| path entry aFilesystem |
	path := self resolve: aResolvable.
	aFilesystem := self.
	store
		directoryAt: path
		ifAbsent: [ ^ absentBlock value ]
		nodesDo: [ :node | entry := store entryFromNode: node path: path for: aFilesystem.
			aBlock value: entry ]
]

FileSystem >> entryAt: aResolvable
[entryAt: aResolvable
	| path |
	path := self resolve: aResolvable.
	^ store
		nodeAt: path
		ifPresent: [ :node | store entryFromNode: node fileSystem: self path: path ]
		ifAbsent: [ store signalFileDoesNotExist: path ]
]

FileSystem >> exists: aResolvable
[exists: aResolvable
	"Resolve the argument, and answer true if the there is
	a file or directory at that path, false if there is not."

	^ store exists: (self resolve: aResolvable)
]

FileSystem >> extensionDelimiter
[extensionDelimiter
	^ $.
]

FileSystem >> fileNamesAt: aResolvable
[fileNamesAt: aResolvable
	^ Array streamContents: [ :out | self fileNamesAt: aResolvable do: [ :path | out nextPut: path ] ]
]

FileSystem >> fileNamesAt: aResolvable do: aBlock
[fileNamesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		fileNodesDo: [ :entry | aBlock value: (store basenameFromEntry: entry) ]
]

FileSystem >> filesAt: aResolvable
[filesAt: aResolvable
	^ Array streamContents: [ :out | self filesAt: aResolvable do: [ :path | out nextPut: path ] ]
]

FileSystem >> filesAt: aResolvable do: aBlock
[filesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		fileNodesDo: [ :entry | aBlock value: path / (store basenameFromEntry: entry) ]
]

FileSystem >> forReferencePrintOn: aStream
[forReferencePrintOn: aStream
	store forReferencePrintOn: aStream
]

FileSystem >> hasChildren: aResolvable
[hasChildren: aResolvable
	"Returns whether aResolvable has children."

	store directoryAt: (self resolve: aResolvable) ifAbsent: [ ^ false ] nodesDo: [ :node | ^ true ].
	^ false
]

FileSystem >> hasDirectories: aResolvable
[hasDirectories: aResolvable
	self entriesAt: aResolvable ifAbsent: [ ^ false ] do: [ :entry | entry isDirectory
				ifTrue: [ ^ true ] ].
	^ false
]

FileSystem >> hasFiles: aResolvable
[hasFiles: aResolvable
	self entriesAt: aResolvable ifAbsent: [ ^ false ] do: [ :entry | entry isFile
				ifTrue: [ ^ true ] ].
	^ false
]

FileSystem >> hash
[hash
	^ store hash
]

FileSystem >> initializeWithStore: aStore
[initializeWithStore: aStore
	store := aStore.
	workingDirectory := store defaultWorkingDirectory
]

FileSystem >> isCaseSensitive
[isCaseSensitive
	^ self store isCaseSensitive
]

FileSystem >> isDirectory: aResolvable
[isDirectory: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a directory, false if it refers to a file or doesn't exist."

	^ store isDirectory: (self resolve: aResolvable)
]

FileSystem >> isFile: aResolvable
[isFile: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a file, false if it refers to a directory or doesn't exist."

	^ store isFile: (self resolve: aResolvable)
]

FileSystem >> isReadable: aResolvable
[isReadable: aResolvable
	"Resolve the argument, and answer true if the there is
	a file or directory that can be read from."

	^ (self permissions: aResolvable) isReadable
]

FileSystem >> isSymlink: aResolvable
[isSymlink: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a directory, false if it refers to a file or doesn't exist."

	^ store isSymlink: (self resolve: aResolvable)
]

FileSystem >> isWritable: aResolvable
[isWritable: aResolvable
	"Resolve the argument, and answer true if the there is
	a file that can be written to or directory that can be changed."

	^ (self permissions: aResolvable) isWritable
]

FileSystem >> mimeTypesAt: aResolvable
[mimeTypesAt: aResolvable
	"Return the possible mime types for the given path."

	^ store mimeTypesAt: (self resolve: aResolvable)
]

FileSystem >> modificationTime: aResolvable
[modificationTime: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a directory, false if it refers to a file or doesn't exist."

	^ store modificationTime: (self resolve: aResolvable)
]

FileSystem >> open
[open
	"Some kinds of filesystems need to open connections to external resources. Does nothing by default."

	store open
]

FileSystem >> open: aResolvable writable: aBoolean
[open: aResolvable writable: aBoolean
	"Resolve aResolvable into an absolute path, then ask the store to open the file at
	that path using the specified access mode."

	| path |
	path := self resolve: aResolvable.
	^ store handleClass open: (FileReference fileSystem: self path: path) writable: aBoolean
]

FileSystem >> openFileStream: aResolvable writable: aBoolean
[openFileStream: aResolvable writable: aBoolean
	^ store openFileStream: (self resolve: aResolvable) writable: aBoolean
]

FileSystem >> openStreamDescription: aResolvable writable: aBoolean
[openStreamDescription: aResolvable writable: aBoolean
	"I am  a helper method to delegate basicOpen:writable: to the store.
	 I am called from FileSystemHandle implementations."

	| path |
	path := self resolve: aResolvable.
	^ store basicOpen: path writable: aBoolean
]

FileSystem >> pathFromObject: anObject
[pathFromObject: anObject
	^ anObject asPathWith: self
]

FileSystem >> pathFromString: aString
[pathFromString: aString
	^ store pathFromString: aString
]

FileSystem >> permissions: aResolvable
[permissions: aResolvable
	"Resolve the argument and return the Permissions for this file or directory "

	^ store permissions: (self resolve: aResolvable)
]

FileSystem >> printPath: aPath on: aStream
[printPath: aPath on: aStream
	store printPath: aPath on: aStream
]

FileSystem >> readStreamOn: aResolvable
[readStreamOn: aResolvable
	"Resolve the argument into an absolute path and open a file handle on the file
	at that path. Ask the handle to give us a read stream for reading the file."

	^ (self open: aResolvable writable: false) readStream
]

FileSystem >> referenceTo: aResolvable
[referenceTo: aResolvable
	"Answer a reference to the argument from the context of the receiver filesystem.  	
		Example: Filesystem disk referenceTo: 'plonk.taz'"

	^ FileReference fileSystem: self path: (self pathFromObject: aResolvable)
]

FileSystem >> rename: sourcePath ifAbsent: aBlock to: destPath ifPresent: pBlock
[rename: sourcePath ifAbsent: aBlock to: destPath ifPresent: pBlock
	"Rename the file referenced as sourcePath to the destination referred as destPath. 
	Perform associate actions in case of problems."

	| source destination |
	source := self resolve: sourcePath.
	destination := self resolve: destPath.
	store
		rename: source
		ifAbsent: aBlock
		to: destination
		ifPresent: pBlock
		fileSystem: self.
	^ destination
]

FileSystem >> rename: sourcePath to: destName
[rename: sourcePath to: destName
	"Rename the file referenced as sourcePath to destPath.  Raise exceptions 
	FileExists or FileDoesNotExist  if the operation fails"

	^ self
		rename: sourcePath
		ifAbsent: [ store signalFileDoesNotExist: sourcePath ]
		to: destName
		ifPresent: [ store signalFileExists: destName ]
]

FileSystem >> resolve: aResolvable
[resolve: aResolvable
	^ aResolvable asResolvedBy: self
]

FileSystem >> resolvePath: aPath
[resolvePath: aPath
	"Return a path where the argument is resolved in the context of the
	receiver. The behavior is similar to the one of a command line.
		> cd /a/b/c
		> cd b
		The shell will attempt to make /a/b/c/b the current directory. "

	^ workingDirectory resolve: aPath
]

FileSystem >> resolveReference: aReference
[resolveReference: aReference
	^ aReference fileSystem = self
		ifTrue: [ workingDirectory resolvePath: aReference path ]
]

FileSystem >> resolveString: aString
[resolveString: aString
	"Returns the root of the receiver filesystem, i.e. / on unix"

	^ workingDirectory resolvePath: (store pathFromString: aString)
]

FileSystem >> root
[root
	"Returns the root of the receiver filesystem, i.e. / on unix"

	^ self referenceTo: Path root
]

FileSystem >> separator
[separator
	"Return path separator used by this filesystem."

	^ store separator
]

FileSystem >> size: aResolvable
[size: aResolvable
	"Resolve the argument and return the size for this file or directory "

	^ store size: (self resolve: aResolvable)
]

FileSystem >> store
[store
	^ store
]

FileSystem >> stringFromPath: aPath
[stringFromPath: aPath
	^ store stringFromPath: aPath
]

FileSystem >> workingDirectory
[workingDirectory
	"Returns a reference to the directory from where the image was launched"

	^ self referenceTo: self workingDirectoryPath
]

FileSystem >> workingDirectoryPath
[workingDirectoryPath
	^ workingDirectory
]

FileSystem >> workingDirectoryPath: aPath
[workingDirectoryPath: aPath
	aPath isAbsolute
		ifFalse: [ self error: 'Cannot set the working directory to a relative path' ].
	workingDirectory := aPath
]

FileSystem >> writeStreamOn: aResolvable
[writeStreamOn: aResolvable
	"Open a write stream on the file referred by the argument. It can be a string or a path"

	^ (self open: aResolvable writable: true) writeStream
]

FileSystem class >> startUp: aBoolean
[startUp: aBoolean
	"This is only here to deal with migration from older versions of
	FileSystem that wanted to receive startup notifcations."

	Smalltalk removeFromStartUpList: self
]

FileSystem class >> store: aStore
[store: aStore
	^ self basicNew
		initializeWithStore: aStore;
		yourself
]

