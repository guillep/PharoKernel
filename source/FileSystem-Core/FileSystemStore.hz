FileSystemStore
	package: #'FileSystem-Core'.

FileSystemStore >> basenameFromEntry: aNode
basenameFromEntry: aNode
	"Used to extract the basename from the low-level representation (node / entry) from the store."

	self subclassResponsibility

FileSystemStore >> basicCreationTime: aNode
basicCreationTime: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a readable
	file or a directory whose contents can be listed."

	self subclassResponsibility

FileSystemStore >> basicEntry: directoryEntry path: aPath nodesDo: aBlock
basicEntry: directoryEntry path: aPath nodesDo: aBlock
	self subclassResponsibility

FileSystemStore >> basicIsDirectory: aNode
basicIsDirectory: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a directory.
	This private message should only be called form within the store."

	self subclassResponsibility

FileSystemStore >> basicIsFile: aNode
basicIsFile: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a file.
	This private message should only be called form within the store."

	self subclassResponsibility

FileSystemStore >> basicIsSymlink: aNode
basicIsSymlink: aNode
	^ self subclassResponsibility

FileSystemStore >> basicIsWritable: aNode
basicIsWritable: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is 
	a writable file or can be changed."

	self subclassResponsibility

FileSystemStore >> basicModificationTime: aNode
basicModificationTime: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a readable
	file or a directory whose contents can be listed."

	self subclassResponsibility

FileSystemStore >> basicOpen: aPath writable: aBoolean
basicOpen: aPath writable: aBoolean
	"open the file at the given path and return an identifier"

	self subclassResponsibility

FileSystemStore >> basicPosixPermissions: aNode
basicPosixPermissions: aNode
	"Used to get the posix permissions from a low-level filesystem entry / node"

	self subclassResponsibility

FileSystemStore >> basicSize: aNode
basicSize: aNode
	"Used to get the size of the low-level representation (node / entry) "

	self subclassResponsibility

FileSystemStore >> checkName: aString fixErrors: fixErrors
checkName: aString fixErrors: fixErrors
	^ self subclassResponsibility

FileSystemStore >> close
close
	"Some kinds of filesystems need to open connections to external resources"

	

FileSystemStore >> copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: aFilesystem
copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: aFilesystem
	| buffer out in |
	in := nil.
	out := nil.
	buffer := nil.
	[ in := aFilesystem readStreamOn: sourcePath.
	in ifNil: [ ^ absentBlock value ].
	(self exists: destinationPath)
		ifTrue: [ "cannot overwrite destination"
			^ presentBlock value ].
	out := aFilesystem writeStreamOn: destinationPath.
	buffer := ByteArray new: 1024.
	[ in atEnd ] whileFalse: [ buffer := in nextInto: buffer.
			out nextPutAll: buffer ] ]
		ensure: [ in ifNotNil: [ in close ].
			out ifNotNil: [ out close ] ]

FileSystemStore >> createDirectory: aPath
createDirectory: aPath
	self subclassResponsibility

FileSystemStore >> creationTime: aPath
creationTime: aPath
	self nodeAt: aPath ifPresent: [ :entry | ^ self basicCreationTime: entry ] ifAbsent: [ ^ false ]

FileSystemStore >> defaultWorkingDirectory
defaultWorkingDirectory
	^ Path root

FileSystemStore >> delete: aPath
delete: aPath
	self subclassResponsibility

FileSystemStore >> delimiter
delimiter
	^ self class delimiter

FileSystemStore >> directoryAt: aPath ifAbsent: absentBlock directoryNodesDo: aBlock
directoryAt: aPath ifAbsent: absentBlock directoryNodesDo: aBlock
	^ self
		directoryAt: aPath
		ifAbsent: absentBlock
		nodesDo: [ :entry | (self basicIsDirectory: entry)
				ifTrue: [ aBlock value: entry ] ]

FileSystemStore >> directoryAt: aPath ifAbsent: absentBlock fileNodesDo: aBlock
directoryAt: aPath ifAbsent: absentBlock fileNodesDo: aBlock
	^ self
		directoryAt: aPath
		ifAbsent: absentBlock
		nodesDo: [ :entry | (self basicIsDirectory: entry)
				ifFalse: [ aBlock value: entry ] ]

FileSystemStore >> directoryAt: aPath ifAbsent: absentBlock nodesDo: aBlock
directoryAt: aPath ifAbsent: absentBlock nodesDo: aBlock
	^ self
		nodeAt: aPath
		ifPresent: [ :entry | (self basicIsDirectory: entry)
				ifTrue: [ self basicEntry: entry path: aPath nodesDo: aBlock ]
				ifFalse: [ DirectoryDoesNotExist signalWith: aPath ] ]
		ifAbsent: absentBlock

FileSystemStore >> ensureCreateDirectory: aPath
ensureCreateDirectory: aPath
	(self isDirectory: aPath)
		ifTrue: [ ^ self ].
	self ensureCreateDirectory: aPath parent.
	self createDirectory: aPath

FileSystemStore >> entryFromNode: aNode fileSystem: aFilesystem path: aPath
entryFromNode: aNode fileSystem: aFilesystem path: aPath
	^ FileSystemDirectoryEntry
		fileSystem: aFilesystem
		path: aPath
		creation: (self basicCreationTime: aNode)
		modification: (self basicModificationTime: aNode)
		isDir: (self basicIsDirectory: aNode)
		size: (self basicSize: aNode)
		posixPermissions: (self basicPosixPermissions: aNode)
		isSymlink: (self basicIsSymlink: aNode)

FileSystemStore >> entryFromNode: node path: path for: aFileystem
entryFromNode: node path: path for: aFileystem
	| entryPath |
	entryPath := path / (self basenameFromEntry: node).
	^ self entryFromNode: node fileSystem: aFileystem path: entryPath

FileSystemStore >> exists: aPath
exists: aPath
	self nodeAt: aPath ifPresent: [ :entry | ^ true ] ifAbsent: [ ^ false ]

FileSystemStore >> filename: aByteString matches: aByteString2
filename: aByteString matches: aByteString2
	^ aByteString = aByteString2

FileSystemStore >> isCaseSensitive
isCaseSensitive
	^ self class isCaseSensitive

FileSystemStore >> isDirectory: aPath
isDirectory: aPath
	aPath isRoot
		ifTrue: [ ^ true ].
	self nodeAt: aPath ifPresent: [ :entry | ^ self basicIsDirectory: entry ] ifAbsent: [ ^ false ]

FileSystemStore >> isFile: aPath
isFile: aPath
	"slow solution for big directories! "

	^ self nodeAt: aPath ifPresent: [ :entry | ^ self basicIsFile: entry ] ifAbsent: [ ^ false ]

FileSystemStore >> isSymlink: aPath
isSymlink: aPath
	aPath isRoot
		ifTrue: [ ^ true ].
	self nodeAt: aPath ifPresent: [ :entry | ^ self basicIsSymlink: entry ] ifAbsent: [ ^ false ]

FileSystemStore >> isWritable: aPath
isWritable: aPath
	self nodeAt: aPath ifPresent: [ :entry | ^ self basicIsWritable: entry ] ifAbsent: [ ^ false ]

FileSystemStore >> mimeTypesAt: aPath
mimeTypesAt: aPath
	| mimeType |
	mimeType := ZnMimeType forFilenameExtension: aPath extension ifAbsent: [ ^ nil ].
	^ Array with: mimeType

FileSystemStore >> modificationTime: aPath
modificationTime: aPath
	self nodeAt: aPath ifPresent: [ :entry | ^ self basicModificationTime: entry ] ifAbsent: [ ^ false ]

FileSystemStore >> nodeAt: aPath
nodeAt: aPath
	^ self nodeAt: aPath ifPresent: [ :node | node ] ifAbsent: [ NotFound signalFor: aPath in: self ]

FileSystemStore >> nodeAt: aPath ifPresent: presentBlock ifAbsent: absentBlock
nodeAt: aPath ifPresent: presentBlock ifAbsent: absentBlock
	self subclassResponsibility

FileSystemStore >> open
open
	"Some kinds of filesystems need to open connections to external resources"

	

FileSystemStore >> openFileStream: path writable: writable
openFileStream: path writable: writable
	self subclassResponsibility

FileSystemStore >> pathFromString: aString
pathFromString: aString
	"Use the unix convention by default, since many filesystems are based on it."

	^ Path from: aString delimiter: self delimiter

FileSystemStore >> permissions: aPath
permissions: aPath
	self
		nodeAt: aPath
		ifPresent: [ :entry | ^ FileSystemPermission posixPermissions: (self basicPosixPermissions: entry) ]
		ifAbsent: [ ^ FileSystemPermission default ]

FileSystemStore >> printPath: aPath on: out
printPath: aPath on: out
	"Use the unix convention by default, since it's the most common."

	aPath isAbsolute
		ifTrue: [ out nextPut: $/ ].
	^ aPath printOn: out delimiter: self delimiter

FileSystemStore >> rename: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: anFSFilesystem
rename: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: anFSFilesystem
	| result |
	(self exists: destinationPath)
		ifTrue: [ ^ presentBlock value ].
	(self exists: sourcePath)
		ifFalse: [ ^ absentBlock value ].
	result := self rename: sourcePath to: destinationPath.
	result ifNil: [ self primitiveFailed ].
	^ self

FileSystemStore >> rename: sourcePath to: destinationPath
rename: sourcePath to: destinationPath
	self subclassResponsibility

FileSystemStore >> separator
separator
	^ self class separator

FileSystemStore >> signalDirectoryDoesNotExist: aPath
signalDirectoryDoesNotExist: aPath
	^ DirectoryDoesNotExist signalWith: aPath

FileSystemStore >> signalDirectoryExists: aPath
signalDirectoryExists: aPath
	^ DirectoryExists signalWith: aPath

FileSystemStore >> signalFileDoesNotExist: aPath
signalFileDoesNotExist: aPath
	^ FileDoesNotExist signalWith: aPath

FileSystemStore >> signalFileExists: aPath
signalFileExists: aPath
	^ FileExists signalWith: aPath

FileSystemStore >> size: aPath
size: aPath
	^ self nodeAt: aPath ifPresent: [ :entry | ^ self basicSize: entry ] ifAbsent: [ ^ false ]

FileSystemStore >> stringFromPath: aPath
stringFromPath: aPath
	^ String streamContents: [ :out | self printPath: aPath on: out ]

FileSystemStore class >> delimiter
delimiter
	self shouldBeImplemented

FileSystemStore class >> isCaseSensitive
isCaseSensitive
	^ self shouldBeImplemented

FileSystemStore class >> separator
separator
	self shouldBeImplemented

