Class	name: #ThreadSafeTranscript;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#stream #accessSemaphore );	classVariables: #();	package: #Transcript.Class ThreadSafeTranscript >> contents[^ accessSemaphore critical: [ stream contents ]]Class ThreadSafeTranscript >> close[self flush.accessSemaphore critical: [ stream close ]]Class ThreadSafeTranscript >> endEntry[	"Display all the characters since the last endEntry, and reset the  stream "accessSemaphore	critical: [ 		self changed: #appendEntry.		stream resetContents ]]Class ThreadSafeTranscript >> << aString[self show: aString]Class ThreadSafeTranscript >> black[	"copied from Transcripter"Display depth = 1	ifTrue: [ ^ Bitmap with: 16rFFFFFFFF	"Works without color support" ].^ Color black]Class ThreadSafeTranscript >> flush[self endEntry]Class ThreadSafeTranscript >> initialExtent[^ 447 @ 300]Class ThreadSafeTranscript >> cr[accessSemaphore critical: [ stream cr ]]Class ThreadSafeTranscript >> characterLimit[^ 20000]Class ThreadSafeTranscript >> print: anObject[self nextPutAll: anObject asString]Class ThreadSafeTranscript >> space[accessSemaphore critical: [ stream space ]]Class ThreadSafeTranscript >> show: anObject[self	print: anObject;	endEntry]Class ThreadSafeTranscript >> with: aBlock[^ accessSemaphore critical: [ aBlock value: stream ]]Class ThreadSafeTranscript >> nextPutAll: value[accessSemaphore critical: [ stream nextPutAll: value ].^ value]Class ThreadSafeTranscript >> initialize[super initialize.accessSemaphore := Mutex new.stream := String new writeStream]Class ThreadSafeTranscript >> tab[accessSemaphore critical: [ stream tab ]]Class ThreadSafeTranscript >> ensureCr[	"do nothing, its here only for compatibility"]Class ThreadSafeTranscript >> pastEndPut: anObject[	"If the stream reaches its limit, just output the contents and reset."self endEntry.^ self nextPut: anObject]Class ThreadSafeTranscript >> title[^ 'Transcript']Class ThreadSafeTranscript >> crShow: anObject[self	cr;	show: anObject]Class ThreadSafeTranscript >> codePaneMenu: aMenu shifted: shifted[	"Copied from TranscriptStream>>#codePaneMenu:shifted:"^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted]Class ThreadSafeTranscript >> nextPut: value[accessSemaphore critical: [ stream nextPut: value ].^ value]Class ThreadSafeTranscript >> reset[]Class ThreadSafeTranscript >> printOn: aStream[self == Transcript	ifFalse: [ ^ super printOn: aStream ].aStream nextPutAll: 'Transcript']Class ThreadSafeTranscript >> clear[	"Clear all characters and redisplay the view"self changed: #clearText.accessSemaphore critical: [ stream reset ]]Class ThreadSafeTranscript >> white[	"copied from Transcripter"Display depth = 1	ifTrue: [ ^ Bitmap with: 0	"Works without color support" ].^ Color white]Class ThreadSafeTranscript >> isSelfEvaluating[self == Transcript	ifTrue: [ ^ true ].^ super isSelfEvaluating]Metaclass	name: #ThreadSafeTranscript;	instanceVariables: #().Metaclass ThreadSafeTranscript >> installThreadSafeAsTranscript[Smalltalk globals at: #Transcript put: self new	"ThreadSafeTranscript open"]Metaclass ThreadSafeTranscript >> examplesForegroundUpdate[	"self examplesForegroundUpdate"| tt length |Smalltalk globals at: #STranscript ifAbsent: [ self installThreadSafeAsSTranscript ].tt := Smalltalk globals at: #STranscript.tt open.length := 20.tt	cr;	show: 'STARTING----->'.	"Foreground updates"1000 to: 1000 + length do: [ :i | 	tt show: '---' , i printString , '---'.	(Delay forSeconds: 1) wait ]]Metaclass ThreadSafeTranscript >> examplesConcurrent[	"self examplesConcurrent"| tt |Smalltalk globals at: #STranscript ifAbsent: [ self installThreadSafeAsSTranscript ].tt := Smalltalk globals at: #STranscript.tt open.[ 1 to: 10 do: [ :i | 	tt		nextPutAll: i printString;		nextPutAll: '*'.	Processor yield ].tt flush ] fork.[ 100 to: 110 do: [ :i | 	tt		nextPutAll: i printString;		nextPutAll: '-'.	Processor yield ].tt flush ] fork]Metaclass ThreadSafeTranscript >> examplesHighlyConcurrent[	"self examplesHighlyConcurrent"| tt length |Smalltalk globals at: #STranscript ifAbsent: [ self installThreadSafeAsSTranscript ].tt := Smalltalk globals at: #STranscript.tt open.length := 20.tt	cr;	show: 'STARTING----->'.length	timesRepeat: [ 		[ 		"Background updates"		[ 		0 to: 0 + length do: [ :i | 			tt				nextPutAll: '[' , i printString , ']';				nextPutAll: '*';				flush.			Processor yield ] ] fork.	"Background updates"		[ 		500 to: 500 + length do: [ :i | 			tt				nextPutAll: '{' , i printString , '}';				nextPutAll: '-';				flush.			Processor yield ] ] fork ] fork ].	"Display updates"length timesRepeat: [ [ [ length timesRepeat: [ World displayWorldSafely ] fork ] ] fork ].	"Foreground updates"1000 to: 1000 + length do: [ :i | 	tt show: '---' , i printString , '---'.	Processor yield ]]Metaclass ThreadSafeTranscript >> menuCommandOn: aBuilder[	<worldMenu>(aBuilder item: #Transcript)	action: [ Smalltalk tools transcript open ];	parent: #Tools;	help: 'Transcript';	icon: self taskbarIcon]Metaclass ThreadSafeTranscript >> examples[	"self examples"| tt |Smalltalk globals at: #STranscript ifAbsent: [ self installThreadSafeAsSTranscript ].tt := Smalltalk globals at: #STranscript.tt open.tt	nextPutAll: 'Pharo';	flush;	cr;	tab.tt	show: ' is cool';	cr.tt reset.tt clear.tt	nextPutAll: 'Pharo';	flush;	cr;	tab.tt	show: ' is really cool';	cr]Metaclass ThreadSafeTranscript >> install[self installThreadSafeAsTranscript]