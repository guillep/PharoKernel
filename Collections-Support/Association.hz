Class
	name: #Association;
	superclass: #ClassLookupKey;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#value );
	classVariables: #();
	package: #'Collections-Support'.

Class Association >> = anAssociation
[
^ super = anAssociation and: [ value = anAssociation value ]
]

Class Association >> isSelfEvaluating
[
^ self class == Association and: [ self key isSelfEvaluating and: [ self value isSelfEvaluating ] ]
]

Class Association >> key: aKey value: anObject
[
	"Store the arguments as the variables of the receiver."
key := aKey.value := anObject
]

Class Association >> literalEqual: otherLiteral
[
	"Answer true if the receiver and otherLiteral represent the same literal.	Variable bindings are literally equals only if identical.	This is how variable sharing works, by preserving identity and changing only the value."
^ self == otherLiteral
]

Class Association >> printOn: aStream
[
super printOn: aStream.aStream nextPutAll: '->'.value printOn: aStream
]

Class Association >> storeOn: aStream
[
	"Store in the format (key->value)"
aStream nextPut: $(.key storeOn: aStream.aStream nextPutAll: '->'.value storeOn: aStream.aStream nextPut: $)
]

Class Association >> value
[
	"Answer the value of the receiver."
^ value
]

Class Association >> value: anObject
[
	"Store the argument, anObject, as the value of the receiver."
value := anObject
]

Metaclass
	name: #Association;
	instanceVariables: #().

Metaclass Association >> key: newKey value: newValue
[
	"Answer an instance of me with the arguments as the key and value of 	the association."
^ (super key: newKey) value: newValue
]

