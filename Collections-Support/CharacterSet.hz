Class
	name: #CharacterSet;
	superclass: #ClassCollection;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#map );
	classVariables: #(#CrLf );
	package: #'Collections-Support'.

Class CharacterSet >> = anObject
[
^ self species == anObject species and: [ self byteArrayMap = anObject byteArrayMap ]
]

Class CharacterSet >> add: aCharacter
[
	"I automatically become a WideCharacterSet if you add a wide character to myself"
aCharacter asciiValue >= 256	ifTrue: [ 		| wide |		wide := WideCharacterSet new.		wide addAll: self.		wide add: aCharacter.		self becomeForward: wide.		^ aCharacter ].map at: aCharacter asciiValue + 1 put: 1.^ aCharacter
]

Class CharacterSet >> asString
[
	"Convert the receiver into a String"
^ String new: self size streamContents: [ :s | self do: [ :ch | s nextPut: ch ] ]
]

Class CharacterSet >> byteArrayMap
[
	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"
^ map
]

Class CharacterSet >> byteComplement
[
	"return a character set containing precisely the single byte characters the receiver does not"
| set |set := CharacterSet allCharacters.self do: [ :c | set remove: c ].^ set
]

Class CharacterSet >> complement
[
	"return a character set containing precisely the characters the receiver does not"
^ CharacterSetComplement of: self copy
]

Class CharacterSet >> do: aBlock
[
	"evaluate aBlock with each character in the set"
Character allByteCharacters	do: [ :c | 		(self includes: c)			ifTrue: [ aBlock value: c ] ]
]

Class CharacterSet >> findFirstInByteString: aByteString startingAt: startIndex
[
	"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver."
^ ByteString findFirstInString: aByteString inSet: self byteArrayMap startingAt: startIndex
]

Class CharacterSet >> hasWideCharacters
[
^ false
]

Class CharacterSet >> hash
[
^ self byteArrayMap hash
]

Class CharacterSet >> includes: aCharacter
[
aCharacter asciiValue >= 256	ifTrue: [ 		"Guard against wide characters"		^ false ].^ (map at: aCharacter asciiValue + 1) > 0
]

Class CharacterSet >> initialize
[
super initialize.map := ByteArray new: 256 withAll: 0
]

Class CharacterSet >> postCopy
[
super postCopy.map := map copy
]

Class CharacterSet >> remove: aCharacter
[
aCharacter asciiValue >= 256	ifFalse: [ 		"Guard against wide characters"		map at: aCharacter asciiValue + 1 put: 0 ].^ aCharacter
]

Class CharacterSet >> remove: aCharacter ifAbsent: aBlock
[
(self includes: aCharacter)	ifFalse: [ ^ aBlock value ].^ self remove: aCharacter
]

Class CharacterSet >> removeAll
[
map atAllPut: 0
]

Class CharacterSet >> size
[
^ map sum
]

Class CharacterSet >> wideCharacterMap
[
	"used for comparing with WideCharacterSet"
| wide |wide := WideCharacterSet new.wide addAll: self.^ wide wideCharacterMap
]

Metaclass
	name: #CharacterSet;
	instanceVariables: #().

Metaclass CharacterSet >> allCharacters
[
	"return a set containing all characters"
| set |set := self empty.0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].^ set
]

Metaclass CharacterSet >> crlf
[
CrLf ifNil: [ CrLf := self with: Character cr with: Character lf ].^ CrLf
]

Metaclass CharacterSet >> empty
[
	"return an empty set of characters"
^ self new
]

Metaclass CharacterSet >> newFrom: aCollection
[
| newCollection |newCollection := self new.newCollection addAll: aCollection.^ newCollection
]

Metaclass CharacterSet >> nonSeparators
[
	"return a set containing everything but the whitespace characters"
^ self separators complement
]

Metaclass CharacterSet >> separators
[
	"return a set containing just the whitespace characters"
| set |set := self empty.set addAll: Character separators.^ set
]

