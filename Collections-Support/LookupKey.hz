Class
	name: #LookupKey;
	superclass: #ClassMagnitude;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#key );
	classVariables: #();
	package: #'Collections-Support'.

Class LookupKey >> hash
[
	"Hash is reimplemented because = is implemented."
^ key hash
]

Class LookupKey >> isSpecialReadBinding
[
	"Return true if this variable binding is read protected, e.g., should not be accessed primitively but rather by sending #value messages"
^ false
]

Class LookupKey >> printOn: aStream
[
key printOn: aStream
]

Class LookupKey >> isVariableBinding
[
	"Return true if I represent a literal variable binding"
^ true
]

Class LookupKey >> canAssign
[
^ true
]

Class LookupKey >> name
[
^ self key isString	ifTrue: [ self key ]	ifFalse: [ self key printString ]
]

Class LookupKey >> key: anObject
[
	"Store the argument, anObject, as the lookup key of the receiver."
key := anObject
]

Class LookupKey >> = aLookupKey
[
self species = aLookupKey species	ifTrue: [ ^ key = aLookupKey key ]	ifFalse: [ ^ false ]
]

Class LookupKey >> key
[
	"Answer the lookup key of the receiver."
^ key
]

Class LookupKey >> < aLookupKey
[
	"Refer to the comment in Magnitude|<."
^ key < aLookupKey key
]

Metaclass
	name: #LookupKey;
	instanceVariables: #().

Metaclass LookupKey >> key: aKey
[
	"Answer an instance of me with the argument as the lookup up."
^ self basicNew key: aKey
]

