Class	name: #UndefinedObject;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #();	classVariables: #();	package: #'Kernel-Objects'.Class UndefinedObject >> notNil[	"Refer to the comment in Object|notNil."^ false]Class UndefinedObject >> haltIfNil[self halt]Class UndefinedObject >> environment[	"Necessary to support disjoint class hierarchies."^ self class environment]Class UndefinedObject >> ifNotNil: aBlock[	"A convenient test, in conjunction with Object ifNotNil:"^ self]Class UndefinedObject >> ifNil: nilBlock ifNotNilDo: ifNotNilBlock[	"Evaluate the block for nil because I'm == nil"^ nilBlock value]Class UndefinedObject >> deepCopy[	"Only one instance of UndefinedObject should ever be made, so answer 	with self."]Class UndefinedObject >> canHandleSignal: exception[	"When no more handler (on:do:) context left in sender chain this gets called"^ false]Class UndefinedObject >> storeOn: aStream[	"Refer to the comment in Object|storeOn:."aStream nextPutAll: 'nil']Class UndefinedObject >> release[	"Nil release is a no-op"]Class UndefinedObject >> ifNil: nilBlock ifNotNil: ifNotNilBlock[	"Evaluate the block for nil because I'm == nil"^ nilBlock value]Class UndefinedObject >> isEmptyOrNil[	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"^ true]Class UndefinedObject >> subclasses[	"Return all the subclasses of nil"| classList |classList := Array new writeStream.self subclassesDo: [ :class | classList nextPut: class ].^ classList contents]Class UndefinedObject >> ifNotNilDo: aBlock[	"Override to do nothing."^ self]Class UndefinedObject >> ifNotNilDo: ifNotNilBlock ifNil: nilBlock[	"If I got here, I am nil, so evaluate the block nilBlock"^ nilBlock value]Class UndefinedObject >> veryDeepCopyWith: deepCopier[	"Return self.  I can't be copied.  Do not record me."]Class UndefinedObject >> removeObsoleteSubclass: aClass[	"Ignored -- necessary to support disjoint class hierarchies"]Class UndefinedObject >> subclassDefinerClass[	"For disjunct class hierarchies -- how should subclasses of nil be evaluated"^ self class evaluatorClass]Class UndefinedObject >> asSetElement[	"Since nil is a singleton, we need only a single wrapper instance to represent it in set,	created in advance"^ SetElement withNil]Class UndefinedObject >> allSuperclassesDo: aBlockContext[self shouldBeImplemented]Class UndefinedObject >> ifNil: aBlock[	"A convenient test, in conjunction with Object ifNil:"^ aBlock value]Class UndefinedObject >> removeSubclass: aClass[	"Ignored -- necessary to support disjoint class hierarchies"]Class UndefinedObject >> addSubclass: aClass[	"Ignored -- necessary to support disjoint class hierarchies"]Class UndefinedObject >> subclass: nameOfClass instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictnames category: category[	"Calling this method is now considered an accident.  If you really want to create a class with a nil superclass, then create the class and then set the superclass using #superclass:"self	traceCr:		'Attempt to create ' , nameOfClass , ' as a subclass of nil.  Possibly a class is being loaded before its superclass.'.^ ProtoObject	subclass: nameOfClass	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category]Class UndefinedObject >> literalScannedAs: scannedLiteral notifying: requestor[^ scannedLiteral]Class UndefinedObject >> addDependent: ignored[	"Refer to the comment in Object|dependents."self error: 'Nil should not have dependents']Class UndefinedObject >> isLiteral[^ true]Class UndefinedObject >> printOn: aStream[	"Refer to the comment in Object|printOn:."aStream nextPutAll: 'nil']Class UndefinedObject >> subclassesDo: aBlock[	"Evaluate aBlock with all subclasses of nil.  Others are not direct subclasses of Class."^ Class	subclassesDo: [ :cl | 		cl isMeta			ifTrue: [ aBlock value: cl soleInstance ] ]]Class UndefinedObject >> isNil[	"Refer to the comment in Object|isNil."^ true]Class UndefinedObject >> suspend[	"Kills off processes that didn't terminate properly"	"Display reverse; reverse."	"<-- So we can catch the suspend bug"Processor terminateActive]Class UndefinedObject >> typeOfClass[	"Necessary to support disjoint class hierarchies."^ #normal]Class UndefinedObject >> ifNotNil: ifNotNilBlock ifNil: nilBlock[	"If I got here, I am nil, so evaluate the block nilBlock"^ nilBlock value]Class UndefinedObject >> handleSignal: exception[	"When no more handler (on:do:) context left in sender chain this gets called.  Return from signal with default action."^ exception resumeUnchecked: exception defaultAction]Class UndefinedObject >> shallowCopy[	"Only one instance of UndefinedObject should ever be made, so answer 	with self."]Metaclass	name: #UndefinedObject;	instanceVariables: #().Metaclass UndefinedObject >> new[self error: 'You may not create any more undefined objects--use nil']Metaclass UndefinedObject >> allInstances[	"It is well known there is a single instance"^ Array with: nil]Metaclass UndefinedObject >> allInstancesDo: aBlock[	"It is well known there is a single instance"aBlock value: nil]