Class	name: #Behavior;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#superclass #methodDict #format #layout );	classVariables: #(#ObsoleteSubclasses );	package: #'Kernel-Classes'.Class Behavior >> traitComposition: aTraitComposition[self subclassResponsibility]Class Behavior >> classVarNames[	"Answer a collection of the receiver's class variable names."^ #()]Class Behavior >> localSelectors[	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"^ self basicLocalSelectors isNil	ifTrue: [ self selectors asSet ]	ifFalse: [ self basicLocalSelectors ]]Class Behavior >> supermostPrecodeCommentFor: selector[	"Answer a string representing the precode comment in the most distant 	superclass's implementation of the selector. Return nil if none found."| aSuper superComment |(self == Behavior or: [ superclass == nil or: [ (aSuper := superclass whichClassIncludesSelector: selector) == nil ] ])	ifFalse: [ 		"There is a super implementor"		superComment := aSuper supermostPrecodeCommentFor: selector ].^ superComment ifNil: [ self firstPrecodeCommentFor: selector	"ActorState supermostPrecodeCommentFor: #printOn:" ]]Class Behavior >> someInstance[	"Primitive. Answer the first instance in the enumeration of all instances 	of the receiver. Fails if there are none. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 77>^ nil]Class Behavior >> superclass: aClass methodDictionary: mDict format: fmt[	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."superclass := aClass.format := fmt.methodDict := mDict.self traitComposition: nil]Class Behavior >> startUp: resuming[	"This message is sent to registered classes when the system is coming up."^ self startUp]Class Behavior >> allSelectorsAbove[^ self allSelectorsAboveUntil: ProtoObject]Class Behavior >> withAllSubclasses[	"Answer a Set of the receiver, the receiver's descendent's, and the  	receiver's descendent's subclasses."^ self allSubclasses	add: self;	yourself]Class Behavior >> isVariable[	"Answer whether the receiver has indexable variables."^ self instSpec >= 2]Class Behavior >> thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte[	"Answer a set of selectors whose methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "| selectors |selectors := IdentitySet new.self	selectorsAndMethodsDo: [ :sel :method | 		((method refersToLiteral: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ])			ifTrue: [ selectors add: sel ] ].^ selectors]Class Behavior >> cleanUp[	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. Subclasses may override #cleanUp: to provide different levels of cleanliness"]Class Behavior >> canPerform: selector[	"Answer whether the receiver can safely perform to the message whose selector 	is the argument: it is not an abstract or cancelled method"^ self classAndMethodFor: selector do: [ :c :m | m isProvided ] ifAbsent: [ false ]]Class Behavior >> classesComposedWithMe[^ {self}]Class Behavior >> allLocalCallsOn: aSymbol[	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."^ SystemNavigation new allLocalCallsOn: aSymbol ofClass: self theNonMetaClass]Class Behavior >> includesSharedPoolNamed: aSharedPoolString[	"Answer whether the receiver uses the shared pool named aSharedPoolString"^ self sharedPools anySatisfy: [ :each | each name = aSharedPoolString ]]Class Behavior >> includesBehavior: aClass[^ self == aClass or: [ self inheritsFrom: aClass ]]Class Behavior >> instSize[	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver."self flag: #instSizeChange.	"Smalltalk browseAllCallsOn: #instSizeChange"	"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ ((format bitShift: -1) bitAnd: 16rFF) - 1	Note also that every other method in this category will require	2 bits more of right shift after the change."^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1]Class Behavior >> sharedPools[	"Answer an ordered collection of  the shared pools that the receiver shares"^ OrderedCollection new]Class Behavior >> allSelectorsBelow: topClass[| coll |coll := IdentitySet new.self	withAllSuperclassesDo: [ :aClass | 		aClass = topClass			ifTrue: [ ^ coll ]			ifFalse: [ aClass selectorsDo: [ :sel | coll add: sel ] ] ].^ coll]Class Behavior >> compileAllFrom: oldClass[	"Compile all the methods in the receiver's method dictionary.	This validates sourceCode and variable references and forces	all methods to use the current bytecode set"| binding |oldClass selectorsDo: [ :sel | self recompile: sel from: oldClass ].	"Ensure that we share a common binding after recompilation. This is so that ClassBuilder reshapes avoid creating new bindings for every method when recompiling a large class hierarchy."binding := self binding.self	methodsDo: [ :m | 		m methodClassAssociation == binding			ifFalse: [ m methodClassAssociation: binding ] ]]Class Behavior >> withAllSubclassesDo: aBlock[	"Evaluate the argument, aBlock, for the receiver and each of its 	subclasses."aBlock value: self.self allSubclassesDo: aBlock]Class Behavior >> environment[	"Return the environment in which the receiver is visible"^ Smalltalk globals]Class Behavior >> selectSubclasses: aBlock[	"Evaluate the argument, aBlock, with each of the receiver's (next level) 	subclasses as its argument. Collect into a Set only those subclasses for 	which aBlock evaluates to true. In addition, evaluate aBlock for the 	subclasses of each of these successful subclasses and collect into the set 	those for which aBlock evaluates true. Answer the resulting set."| aSet |aSet := Set new.self allSubclasses	do: [ :aSubclass | 		(aBlock value: aSubclass)			ifTrue: [ aSet add: aSubclass ] ].^ aSet]Class Behavior >> shouldNotBeRedefined[	"Return true if the receiver should not be redefined.	The assumption is that compact classes,	classes in Smalltalk specialObjects and 	Behaviors should not be redefined"^ (Smalltalk compactClassesArray includes: self)	or: [ (Smalltalk specialObjectsArray includes: self) or: [ self isKindOf: self ] ]]Class Behavior >> firstPrecodeCommentFor: selector[	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"| parser source tree |(#(#Comment #Definition #Hierarchy) includes: selector)	ifTrue: [ 		"Not really a selector"		^ nil ].source := self sourceCodeAt: selector asSymbol ifAbsent: [ ^ nil ].parser := self parserClass new.tree := parser	parse: source readStream	class: self	noPattern: false	context: nil	notifying: nil	ifFail: [ ^ nil ].^ (tree comment ifNil: [ ^ nil ]) first]Class Behavior >> isFixed[	"Answer whether the receiver does not have a variable (indexable) part."^ self isVariable not]Class Behavior >> bindingOf: varName[	"Answer the binding of some variable resolved in the scope of the receiver"^ superclass bindingOf: varName]Class Behavior >> allSubclassesDo: aBlock[	"Evaluate the argument, aBlock, for each of the receiver's subclasses."self	subclassesDo: [ :cl | 		aBlock value: cl.		cl allSubclassesDo: aBlock ]]Class Behavior >> allowsSubInstVars[	"Classes that allow instances to change classes among its subclasses will want to override this and return false, so inst vars are not accidentally added to its subclasses."^ true]Class Behavior >> printOn: aStream[	"Refer to the comment in Object|printOn:."aStream nextPutAll: 'a descendent of '.superclass printOn: aStream]Class Behavior >> initialize[	"moved here from the class side's #new"super initialize.superclass := Object.	"no longer sending any messages, some of them crash the VM"methodDict := self emptyMethodDictionary.format := Object format]Class Behavior >> allInstances[	"Answer a collection of all current instances of the receiver."| all inst next |all := OrderedCollection new.inst := self someInstance.[ inst == nil ]	whileFalse: [ 		next := inst nextInstance.		inst == all			ifFalse: [ all add: inst ].		inst := next ].^ all asArray]Class Behavior >> typeOfClass[	"Answer a symbol uniquely describing the type of the receiver"self instSpec = CompiledMethod instSpec	ifTrue: [ ^ #compiledMethod ].	"Very special!"self isBytes	ifTrue: [ ^ #bytes ].(self isWords and: [ self isPointers not ])	ifTrue: [ ^ #words ].self isWeak	ifTrue: [ ^ #weak ].self isVariable	ifTrue: [ ^ #variable ].^ #normal]Class Behavior >> withAllSuperclassesDo: aBlock[	"Evaluate the argument, aBlock, for each of the receiver's superclasses."aBlock value: self.superclass == nil	ifFalse: [ superclass withAllSuperclassesDo: aBlock ]]Class Behavior >> removeSelectorSilently: selector[	"Remove selector without sending system change notifications"^ SystemAnnouncer uniqueInstance suspendAllWhile: [ self removeSelector: selector ]]Class Behavior >> allSubInstances[	"Answer a list of all current instances of the receiver and all of its subclasses."| aCollection |aCollection := OrderedCollection new.self	allSubInstancesDo: [ :x | 		x == aCollection			ifFalse: [ aCollection add: x ] ].^ aCollection]Class Behavior >> allMethods[	"Return the collection of compiled method I and my superclasses are defining"	"asArray is used to not bump into a bug when comparing compiled methods."^ self allSelectors asArray collect: [ :s | self lookupSelector: s ]]Class Behavior >> isPointers[	"Answer whether the receiver contains just pointers (not bits)."^ self isBits not]Class Behavior >> commentsAt: selector[	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."^ self commentsIn: (self sourceCodeAt: selector) asString	"Behavior commentsAt: #commentsAt:"]Class Behavior >> becomeCompact[	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Pharo, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."| cct index |self isWeak	ifTrue: [ ^ Halt halt: 'You must not make a weak class compact' ].cct := Smalltalk compactClassesArray.(self isCompact or: [ cct includes: self ])	ifTrue: [ ^ self halt: self name , 'is already compact' ].index := cct indexOf: nil ifAbsent: [ ^ self halt: 'compact class table is full' ].	"Install this class in the compact class table"cct at: index put: self.	"Update instspec so future instances will be compact"format := format + (index bitShift: 11).	"Make up new instances and become old ones into them"self updateInstancesFrom: self.	"Purge any old instances"Smalltalk garbageCollect]Class Behavior >> allSharedPools[	"Answer an ordered collection of the shared pools that the receiver and the receiver's ancestors share."^ superclass allSharedPools]Class Behavior >> copiesMethodsFromSuperclass[	"Checks whether the receiver copied some method from its superclass"self methodDict	valuesDo: [ :method | 		(self copiesFromSuperclass: method)			ifTrue: [ ^ true ] ].^ false]Class Behavior >> classAndMethodFor: aSymbol do: binaryBlock ifAbsent: absentBlock[	"Looks up the selector aSymbol in the class chain. If it is found, binaryBlock is evaluated	with the class that defines the selector and the associated method. Otherwise	absentBlock is evaluated."self	withAllSuperclassesDo: [ :class | 		| method |		method := class compiledMethodAt: aSymbol ifAbsent: [ nil ].		method ifNotNil: [ ^ binaryBlock value: class value: method ] ].^ absentBlock value]Class Behavior >> instancesSizeInMemory[	"Answers the number of bytes consumed by all its instances including their object header"| bytes |bytes := 0.self allInstancesDo: [ :each | bytes := bytes + each sizeInMemory ].^ bytes]Class Behavior >> allSelectorsAboveUntil: aRootClass[| coll |coll := IdentitySet new.(self allSuperclassesIncluding: aRootClass) do: [ :aClass | aClass selectorsDo: [ :sel | coll add: sel ] ].^ coll]Class Behavior >> startUp[	"This message is sent to registered classes when the system is coming up."]Class Behavior >> basicAddSelector: selector withMethod: compiledMethod[	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary.	Do this without sending system change notifications"| oldMethodOrNil |oldMethodOrNil := self lookupSelector: selector.self methodDict at: selector put: compiledMethod.compiledMethod methodClass: self.compiledMethod selector: selector.	"Now flush Pharo's method cache, either by selector or by method"oldMethodOrNil ifNotNil: [ oldMethodOrNil flushCache ].selector flushCache]Class Behavior >> traitComposition[self subclassResponsibility]Class Behavior >> new[	"Answer a new initialized instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."^ self basicNew initialize]Class Behavior >> unreferencedInstanceVariables[	"Return a list of the instance variables defined in the receiver which are not referenced in the receiver or any of its subclasses."^ self instVarNames	reject: [ :ivn | self withAllSubclasses anySatisfy: [ :class | (class whichSelectorsAccess: ivn) notEmpty ] ]]Class Behavior >> numberOfInstanceVariables[^ self instVarNames size]Class Behavior >> basicNew: sizeRequested[	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>self isVariable	ifFalse: [ self error: self printString , ' cannot have variable sized instances' ].(sizeRequested isInteger and: [ sizeRequested >= 0 ])	ifTrue: [ 		"arg okay; space must be low."		OutOfMemory signal.		^ self basicNew: sizeRequested	"retry if user proceeds" ].self primitiveFailed]Class Behavior >> classBindingOf: varName[	"Answer the binding of some variable resolved in the scope of the receiver's class"^ self bindingOf: varName]Class Behavior >> whichSelectorsAccess: instVarName[	"Answer a set of selectors whose methods access the argument, 	instVarName, as a named instance variable."| instVarIndex |instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^ IdentitySet new ].^ self selectors	select: [ :sel | ((self methodDict at: sel) readsField: instVarIndex) or: [ (self methodDict at: sel) writesField: instVarIndex ] ]	"Point whichSelectorsAccess: 'x'."]Class Behavior >> instVarNamesAndOffsetsDo: aBinaryBlock[	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	"Nothing to do here; ClassDescription introduces named instance variables"^ self]Class Behavior >> flushCache[	"Tell the interpreter to remove the contents of its method lookup cache, if it has 	one.  Essential.  See Object documentation whatIsAPrimitive."	<primitive: 89>self primitiveFailed]Class Behavior >> withAllSuperAndSubclassesDo: aBlock[self allSuperclassesDo: aBlock.aBlock value: self.self allSubclassesDo: aBlock]Class Behavior >> printHierarchy[	"Answer a description containing the names and instance variable names 	of all of the subclasses and superclasses of the receiver."| aStream index |index := 0.aStream := (String new: 16) writeStream.self allSuperclasses	reverseDo: [ :aClass | 		aStream crtab: index.		index := index + 1.		aStream nextPutAll: aClass name.		aStream space.		aStream print: aClass instVarNames ].aStream cr.self printSubclassesOn: aStream level: index.^ aStream contents]Class Behavior >> checkCanBeUncompact[	"Certain classes cannot be uncompacted in CogVM.  If you download VMMaker and see the VM code, these are as defined by StackInterpreter>>#checkAssumedCompactClasses and the ones that can't be uncompacted are the following: "({Array.LargeNegativeInteger.LargePositiveInteger.Float.MethodContext} includes: self)	ifTrue: [ self error: 'Class ' , self name , ' cannot be uncompact. ' ]]Class Behavior >> methodDict: aDictionary[methodDict := aDictionary]Class Behavior >> subclasses[	"slow implementation since Behavior does not keep trace of subclasses"^ self class allInstances select: [ :each | each superclass = self ]]Class Behavior >> removeAllObsoleteSubclasses[	"Remove all the obsolete subclasses of the receiver"ObsoleteSubclasses removeKey: self ifAbsent: [  ]]Class Behavior >> isWeak[	"Answer whether the receiver has contains weak references."^ self instSpec = 4]Class Behavior >> removeTraitSelector: aSymbol[[ (self includesLocalSelector: aSymbol) not ] assert.self basicRemoveSelector: aSymbol]Class Behavior >> allInstancesDo: aBlock[	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver.		Because aBlock might change the class of inst (for example, using become:),	it is essential to compute next before aBlock value: inst."| inst next |inst := self someInstance.[ inst == nil ]	whileFalse: [ 		next := inst nextInstance.		aBlock value: inst.		inst := next ]]Class Behavior >> instVarNames[	"Answer an Array of the instance variable names. Behaviors must make 	up fake local instance variable names because Behaviors have instance 	variables for the purpose of compiling methods, but these are not named 	instance variables."| mySize superSize |mySize := self instSize.superSize := superclass == nil	ifTrue: [ 0 ]	ifFalse: [ superclass instSize ].mySize = superSize	ifTrue: [ ^ #() ].^ (superSize + 1 to: mySize) collect: [ :i | 'inst' , i printString ]]Class Behavior >> subclassesDo: aBlock[self subclasses do: aBlock]Class Behavior >> superclass[	"Answer the receiver's superclass, a Class."^ superclass]Class Behavior >> name[	"Answer a String that is the name of the receiver."^ 'a subclass of ' , superclass name]Class Behavior >> flattenDown: aTrait[| selectors |[ self hasTraitComposition and: [ self traitComposition allTraits includes: aTrait ] ] assert.selectors := (self traitComposition transformationOfTrait: aTrait) selectors.self basicLocalSelectors: self basicLocalSelectors , selectors.self removeFromComposition: aTrait]Class Behavior >> sourceMatchesBytecodeAt: selector[	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false	otherwise. Implemented to detect an error where Monticello did not recompile sources when the class	shape changed"	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a	method which turned a selector and class into a CompiledMethod, without  installing it into the 	methodDictionary"| method trailer methodNode |method := self compiledMethodAt: selector.trailer := method trailer.methodNode := self compilerClass new	compile: (self sourceCodeAt: selector)	in: self	notifying: nil	ifFail: [ ^ false ].	"Assume OK after proceed from SyntaxError"selector == methodNode selector	ifFalse: [ self error: 'selector changed!!' ].^ (methodNode generate: trailer) = method]Class Behavior >> allSuperclassesIncluding: aClass[	"Answer an OrderedCollection of the receiver's and the receiver's  ancestor's superclasses	up to aClass included. If aClass is not part of the receiver's superclass, returns up to the root."| temp |self class == ProtoObject class	ifTrue: [ ^ OrderedCollection new ].^ superclass == aClass	ifTrue: [ OrderedCollection with: aClass ]	ifFalse: [ 		temp := superclass allSuperclassesIncluding: aClass.		temp addFirst: superclass.		temp ]]Class Behavior >> whichClassDefinesInstVar: aString[^ self whichSuperclassSatisfies: [ :aClass | aClass instVarNames includes: aString ]]Class Behavior >> setFormat: aFormatInstanceDescription[	"only use this method with extreme care since it modifies the format of the class      ie a description of the number of instance variables and whether the class is     compact, variable sized"format := aFormatInstanceDescription]Class Behavior >> allSelectorsWithout: behaviors[	"Returns all the selectors of the receiver and its superclasses, except the ones define in behaviors"| selectors |selectors := IdentitySet new.self	withAllSuperclassesDo: [ :class | 		(behaviors includes: class)			ifFalse: [ selectors addAll: class selectors ] ].^ selectors asOrderedCollection]Class Behavior >> kindOfSubclass[	"Answer a String that is the keyword that describes the receiver's kind 	of subclass, either a regular subclass, a variableSubclass, a  	variableByteSubclass, a variableWordSubclass, or a weakSubclass."self isWeak	ifTrue: [ ^ ' weakSubclass: ' ].^ self isVariable	ifTrue: [ 		self isBits			ifTrue: [ 				self isBytes					ifTrue: [ ' variableByteSubclass: ' ]					ifFalse: [ ' variableWordSubclass: ' ] ]			ifFalse: [ ' variableSubclass: ' ] ]	ifFalse: [ ' subclass: ' ]]Class Behavior >> setTraitComposition: aTraitComposition[| oldComposition |(self hasTraitComposition not and: [ aTraitComposition isEmpty ])	ifTrue: [ ^ self ].aTraitComposition assertValidUser: self.oldComposition := self traitComposition.self traitComposition: aTraitComposition.self applyChangesOfNewTraitCompositionReplacing: oldComposition.oldComposition traits do: [ :each | each removeUser: self ].aTraitComposition traits do: [ :each | each addUser: self ]]Class Behavior >> whichSuperclassSatisfies: aBlock[(aBlock value: self)	ifTrue: [ ^ self ].^ superclass isNil	ifTrue: [ nil ]	ifFalse: [ superclass whichSuperclassSatisfies: aBlock ]]Class Behavior >> indexIfCompact[	"If these 5 bits are non-zero, then instances of this class	will be compact.  It is crucial that there be an entry in	Smalltalk compactClassesArray for any class so optimized.	See the msgs becomeCompact and becomeUncompact."^ (format bitShift: -11) bitAnd: 16r1F	"Array indexIfCompactVerify if the compactClassesArray and indexIfCompact are coherenSmalltalk compactClassesArray doWithIndex: 	[:c :i | c == nil ifFalse:		[c indexIfCompact = i ifFalse: [self halt]]]"]Class Behavior >> allUnreferencedInstanceVariables[	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"^ self allInstVarNames	reject: [ :ivn | 		| definingClass |		definingClass := self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses anySatisfy: [ :class | (class whichSelectorsAccess: ivn asSymbol) notEmpty ] ]]Class Behavior >> classDepth[superclass ifNil: [ ^ 1 ].^ superclass classDepth + 1]Class Behavior >> new: sizeRequested[	"Answer an initialized instance of this class with the number of indexable	variables specified by the argument, sizeRequested."^ (self basicNew: sizeRequested) initialize]Class Behavior >> copiesFromSuperclass: method[	"Checks whether the receiver copied the argument,  method, from its superclasses"self	allSuperclassesDo: [ :cls | 		(cls includesSelector: method selector)			ifTrue: [ ^ (cls >> method selector) sourceCode = method sourceCode ] ].^ false]Class Behavior >> selectSuperclasses: aBlock[	"Evaluate the argument, aBlock, with the receiver's superclasses as the 	argument. Collect into an OrderedCollection only those superclasses for 	which aBlock evaluates to true. In addition, evaluate aBlock for the 	superclasses of each of these successful superclasses and collect into the 	OrderedCollection ones for which aBlock evaluates to true. Answer the 	resulting OrderedCollection."| aSet |aSet := Set new.self allSuperclasses	do: [ :aSuperclass | 		(aBlock value: aSuperclass)			ifTrue: [ aSet add: aSuperclass ] ].^ aSet]Class Behavior >> printWithClosureAnalysisOn: aStream[	"Refer to the comment in Object|printOn:."aStream nextPutAll: 'a descendent of '.superclass printWithClosureAnalysisOn: aStream]Class Behavior >> basicLocalSelectors: aSetOrNil[self subclassResponsibility]Class Behavior >> isBits[	"Answer whether the receiver contains just bits (not pointers)."^ self instSpec >= 6]Class Behavior >> removeObsoleteSubclass: aClass[	"Remove aClass from the weakly remembered obsolete subclasses"| obs |obs := ObsoleteSubclasses at: self ifAbsent: [ ^ self ].(obs includes: aClass)	ifFalse: [ ^ self ].obs := obs copyWithout: aClass.obs := obs copyWithout: nil.ObsoleteSubclasses at: self put: obs]Class Behavior >> allSubInstancesDo: aBlock[	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver and all its subclasses."self allInstancesDo: aBlock.self allSubclassesDo: [ :sub | sub allInstancesDo: aBlock ]]Class Behavior >> whichSelectorsAssign: instVarName[	"Answer a Set of selectors whose methods store into the argument, 	instVarName, as a named instance variable."^ self whichSelectorsStoreInto: instVarName]Class Behavior >> hasTraitComposition[self subclassResponsibility]Class Behavior >> isCompact[^ self indexIfCompact ~= 0]Class Behavior >> copiedMethodsFromSuperclass[	"Returns the methods that the receiver copied with its ancestors"| methods |methods := OrderedCollection new.self methodDict valuesDo: [ :method | methods addAll: (self copiedFromSuperclass: method) ].^ methods]Class Behavior >> canUnderstand: selector[	"Answer whether the receiver can respond to the message whose selector 	is the argument. The selector can be in the method dictionary of the 	receiver's class or any of its superclasses."(self includesSelector: selector)	ifTrue: [ ^ true ].superclass == nil	ifTrue: [ ^ false ].^ superclass canUnderstand: selector]Class Behavior >> whichSelectorsRead: instVarName[	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."^ self whichSelectorsAccess: instVarName]Class Behavior >> isBytes[	"Answer whether the receiver has 8-bit instance variables."^ self instSpec >= 8]Class Behavior >> addTraitSelector: aSymbol withMethod: aCompiledMethod[	"Add aMethod with selector aSymbol to my	methodDict. aMethod must not be defined locally."| source methodAndNode |[ (self includesLocalSelector: aSymbol) not ] assert.self ensureLocalSelectors.source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.methodAndNode := self	compile: source	classified: aCompiledMethod category	notifying: nil	trailer: self defaultMethodTrailer	ifFail: [ ^ nil ].methodAndNode method	putSource: source	fromParseNode: methodAndNode node	inFile: 2	withPreamble: [ :f | 		f			cr;			nextPut: $!;			nextChunkPut: 'Trait method';			cr ].methodAndNode method properties at: #traitSource put: aCompiledMethod.self basicAddSelector: aSymbol withMethod: methodAndNode method]Class Behavior >> subclassDefinerClass[	"Answer an evaluator class appropriate for evaluating definitions of new 	subclasses of this class."^ Compiler]Class Behavior >> basicNew[	"Primitive. Answer an instance of the receiver (which is a class) with no 	indexable variables. Fail if the class is indexable. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 70>self isVariable	ifTrue: [ ^ self basicNew: 0 ].	"space must be low"OutOfMemory signal.^ self basicNew	"retry if user proceeds"]Class Behavior >> ultimateSourceCodeAt: selector ifAbsent: aBlock[	"Return the source code at selector, deferring to superclass if necessary"^ self	sourceCodeAt: selector	ifAbsent: [ superclass ifNil: [ aBlock value ] ifNotNil: [ superclass ultimateSourceCodeAt: selector ifAbsent: aBlock ] ]]Class Behavior >> isWords[	"Answer true if the receiver is made of 32-bit instance variables."^ self isBytes not]Class Behavior >> becomeCompactSimplyAt: index[	"Make me compact, but don't update the instances.  For importing segments."	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Pharo, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."| cct |self isWeak	ifTrue: [ ^ Halt halt: 'You must not make a weak class compact' ].cct := Smalltalk compactClassesArray.(self isCompact or: [ cct includes: self ])	ifTrue: [ ^ self halt: self name , 'is already compact' ].(cct at: index) ifNotNil: [ ^ self halt: 'compact table slot already in use' ].	"Install this class in the compact class table"cct at: index put: self.	"Update instspec so future instances will be compact"format := format + (index bitShift: 11)	"Caller must convert the instances"]Class Behavior >> isObsolete[	"Return true if the receiver is obsolete."^ self instanceCount = 0]Class Behavior >> lookupSelector: selector[	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."| lookupClass |lookupClass := self.[ lookupClass == nil ]	whileFalse: [ 		(lookupClass includesSelector: selector)			ifTrue: [ ^ lookupClass compiledMethodAt: selector ].		lookupClass := lookupClass superclass ].^ nil]Class Behavior >> isAliasSelector: aSymbol[	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."^ (self includesLocalSelector: aSymbol) not	and: [ self hasTraitComposition and: [ self traitComposition isAliasSelector: aSymbol ] ]]Class Behavior >> allSuperclassesDo: aBlock[	"Evaluate the argument, aBlock, for each of the receiver's superclasses."superclass == nil	ifFalse: [ 		aBlock value: superclass.		superclass allSuperclassesDo: aBlock ]]Class Behavior >> isBehavior[	"Return true if the receiver is a behavior"^ true]Class Behavior >> allClassVarNames[	"Answer a Set of the names of the receiver's and the receiver's ancestor's 	class variables."^ superclass allClassVarNames]Class Behavior >> traitsProvidingSelector: aSymbol[| result |result := OrderedCollection new.self hasTraitComposition	ifFalse: [ ^ result ].(self traitComposition methodDescriptionsForSelector: aSymbol)	do: [ :methodDescription | 		methodDescription selector = aSymbol			ifTrue: [ result addAll: (methodDescription locatedMethods collect: [ :each | each methodClass ]) ] ].^ result]Class Behavior >> whichClassDefinesClassVar: aString[Symbol	hasInterned: aString	ifTrue: [ :aSymbol | ^ self whichSuperclassSatisfies: [ :aClass | aClass classVarNames anySatisfy: [ :each | each = aSymbol ] ] ].^ #()]Class Behavior >> whichClassIncludesSelector: aSymbol[	"Answer the class on the receiver's superclass chain where the 	argument, aSymbol (a message selector), will be found. Answer nil if none found."	"Rectangle whichClassIncludesSelector: #inspect."(self includesSelector: aSymbol)	ifTrue: [ ^ self ].superclass == nil	ifTrue: [ ^ nil ].^ superclass whichClassIncludesSelector: aSymbol]Class Behavior >> copiedFromSuperclass: method[	"Returns the methods that the receiver copied with its ancestors"self	allSuperclassesDo: [ :cls | 		(cls includesSelector: method selector)			ifTrue: [ 				(cls >> method selector) sourceCode = method sourceCode					ifTrue: [ ^ {(cls >> method selector)} ]					ifFalse: [ ^ #() ] ] ].^ #()]Class Behavior >> basicLocalSelectors[	"Direct accessor for the instance variable localSelectors.	Because of hardcoded ivar indexes of Behavior and Class in the VM, Class and	Metaclass declare the needed ivar and override this method as an accessor. 	By returning nil instead of declaring this method as a subclass responsibility,	Behavior can be instantiated for creating anonymous classes."^ nil]Class Behavior >> inheritsFrom: aClass[	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."| aSuperclass |aSuperclass := superclass.[ aSuperclass == nil ]	whileFalse: [ 		aSuperclass == aClass			ifTrue: [ ^ true ].		aSuperclass := aSuperclass superclass ].^ false]Class Behavior >> adoptInstance: anInstance[	"Change the class of anInstance to me.	Primitive (found in Cog and new VMs)  follows the same rules as primitiveChangeClassTo:, but returns the 	class rather than the modified instance"	<primitive: 160 error: #ec>anInstance primitiveChangeClassTo: self basicNew.^ self]Class Behavior >> subclassInstVarNames[	"Answer a Set of the names of the receiver's subclasses' instance 	variables."| vars |vars := Set new.self allSubclasses do: [ :aSubclass | vars addAll: aSubclass instVarNames ].^ vars]Class Behavior >> instSpec[^ (format bitShift: -7) bitAnd: 16rF]Class Behavior >> nonObsoleteClass[	"Attempt to find and return the current version of this obsolete class"| obsName |obsName := self name.[ obsName beginsWith: 'AnObsolete' ] whileTrue: [ obsName := obsName copyFrom: 'AnObsolete' size + 1 to: obsName size ].^ self environment at: obsName asSymbol]Class Behavior >> variablesAndOffsetsDo: aBinaryBlock[	"This is the interface between the compiler and a class's instance or field names.  The	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed	 by the instance variable name strings and their integer offsets (1-relative).  The order is	 important; names evaluated later will override the same names occurring earlier."	"Only need to do instance variables here.  CProtoObject introduces field definitions."self instVarNamesAndOffsetsDo: aBinaryBlock]Class Behavior >> whichSelectorsStoreInto: instVarName[	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."| instVarIndex |instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^ IdentitySet new ].^ self selectors select: [ :sel | (self methodDict at: sel) writesField: instVarIndex ]	"Point whichSelectorsStoreInto: 'x'."]Class Behavior >> zapAllMethods[	"Remove all methods in this class which is assumed to be obsolete"methodDict := self emptyMethodDictionary.self class isMeta	ifTrue: [ self class zapAllMethods ]]Class Behavior >> commentsIn: sourceString[| commentStart nextQuotePos someComments aPos |('*"*' match: sourceString)	ifFalse: [ ^ #() ].someComments := OrderedCollection new.sourceString size = 0	ifTrue: [ ^ someComments ].aPos := 1.nextQuotePos := 0.[ commentStart := sourceString findString: '"' startingAt: aPos.nextQuotePos := self nextQuotePosIn: sourceString startingFrom: commentStart.commentStart ~= 0 and: [ nextQuotePos > commentStart ] ]	whileTrue: [ 		commentStart ~= nextQuotePos			ifTrue: [ someComments add: ((sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"') ].		aPos := nextQuotePos + 1 ].^ someComments]Class Behavior >> basicRemoveSelector: selector[	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."| oldMethod |oldMethod := self methodDict at: selector ifAbsent: [ ^ self ].self methodDict removeKey: selector.	"Now flush Pharo's method cache, either by selector or by method"oldMethod flushCache.selector flushCache]Class Behavior >> shutDown: quitting[	"This message is sent on system shutdown to registered classes"^ self shutDown]Class Behavior >> allSuperclasses[	"Answer an OrderedCollection of the receiver's and the receiver's  	ancestor's superclasses. The first element is the receiver's immediate  	superclass, followed by its superclass; the last element is Object."| temp |^ superclass == nil	ifTrue: [ OrderedCollection new ]	ifFalse: [ 		temp := superclass allSuperclasses.		temp addFirst: superclass.		temp ]]Class Behavior >> superclass: aClass[	"Change the receiver's superclass to be aClass."	"Note: Do not use 'aClass isKindOf: Behavior' here		in case we recompile from Behavior itself."(aClass == nil or: [ aClass isBehavior ])	ifTrue: [ 		superclass := aClass.		Object flushCache ]	ifFalse: [ self error: 'superclass must be a class-describing object' ]]Class Behavior >> allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level[	"Walk the tree of subclasses, giving the class and its level"| subclassNames |classAndLevelBlock value: self value: level.self == Class	ifTrue: [ ^ self ].	"Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"subclassNames := SortedCollection new.self subclassesDo: [ :subC | subclassNames add: subC name ].subclassNames	do: [ :name | (self environment at: name) allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level + 1 ]]Class Behavior >> allSubclasses[	"Answer an orderedCollection of the receiver's and the receiver's descendent's subclasses. "| scan scanTop |scan := OrderedCollection withAll: self subclasses.scanTop := 1.[ scanTop > scan size ]	whileFalse: [ 		scan addAll: (scan at: scanTop) subclasses.		scanTop := scanTop + 1 ].^ scan]Class Behavior >> methodDict[	"The method dictionary of a class can be nil when we want to use the #cannotInterpret: hook. Indeed when a class dictionary is nil, the VM sends the message cannotInterpret: to the receiver but starting the look up in the superclass of the class whose method dictionary was nil.	 Now the system relies that when the message methodDict is sent to a class a method dictionary is returned. In order to prevent the complaints of tools and IDE unaware of this feature, we fool them by providing an empty MethodDictionary. This will hopefully work in most cases, but the tools will loose the ability to modify the behaviour of this behavior. The user of #cannotInterpret: should be aware of this."methodDict == nil	ifTrue: [ ^ MethodDictionary new ].^ methodDict]Class Behavior >> selectorsWithArgs: numberOfArgs[	"Return all selectors defined in this class that take this number of arguments"^ self selectors select: [ :selector | selector numArgs = numberOfArgs ]]Class Behavior >> addObsoleteSubclass: aClass[	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"| obs |obs := ObsoleteSubclasses at: self ifAbsent: [ WeakArray new ].(obs includes: aClass)	ifTrue: [ ^ self ].obs := obs copyWithout: nil.obs := obs copyWith: aClass.ObsoleteSubclasses at: self put: obs]Class Behavior >> nextQuotePosIn: sourceString startingFrom: commentStart[| pos nextQuotePos |pos := commentStart + 1.[ (nextQuotePos := sourceString findString: '"' startingAt: pos) == (sourceString findString: '""' startingAt: pos)	and: [ nextQuotePos ~= 0 ] ] whileTrue: [ pos := nextQuotePos + 2 ].^ nextQuotePos]Class Behavior >> obsoleteSubclasses[	"Return all the weakly remembered obsolete subclasses of the receiver"| obs |obs := ObsoleteSubclasses at: self ifAbsent: [ ^ #() ].^ obs copyWithout: nil]Class Behavior >> allInstVarNames[	"Answer an Array of the names of the receiver's instance variables. The 	Array ordering is the order in which the variables are stored and 	accessed by the interpreter."| vars |superclass == nil	ifTrue: [ vars := self instVarNames copy ]	ifFalse: [ vars := superclass allInstVarNames , self instVarNames ].	"Guarantee a copy is answered."^ vars]Class Behavior >> shutDown[	"This message is sent on system shutdown to registered classes"]Class Behavior >> isMeta[^ false]Class Behavior >> instanceCount[	"Answer the number of instances of the receiver that are currently in 	use."| count |count := 0.self allInstancesDo: [ :x | count := count + 1 ].^ count]Class Behavior >> flattenDownAllTraits[self traitComposition allTraits do: [ :each | self flattenDown: each ].[ self traitComposition isEmpty ] assert.self traitComposition: nil]Class Behavior >> precodeCommentOrInheritedCommentFor: selector[	"Answer a string representing the first comment in the method associated 	with selector, considering however only comments that occur before the 	beginning of the actual code. If the version recorded in the receiver is 	uncommented, look up the inheritance chain. Return nil if none found."| aSuper aComment |^ (aComment := self firstPrecodeCommentFor: selector) isEmptyOrNil	ifTrue: [ 		(self == Behavior or: [ superclass == nil or: [ (aSuper := superclass whichClassIncludesSelector: selector) == nil ] ])			ifFalse: [ aSuper precodeCommentOrInheritedCommentFor: selector ] ]	ifFalse: [ aComment ]]Class Behavior >> cleanUp: aggressive[	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. The argument should be used to indicate how aggressive the cleanup should be. Some subclasses may act differently depending on its value - for example, ChangeSet will only delete all unused and reinitialize the current change set if we're asking it to be aggressive."^ self cleanUp]Class Behavior >> allSelectors[	"Answer all selectors understood by instances of the receiver"^ self allSelectorsBelow: nil]Class Behavior >> withAllSubAndSuperclassesDo: aBlock[self withAllSubclassesDo: aBlock.self allSuperclassesDo: aBlock]Class Behavior >> becomeUncompact[| cct index |cct := Smalltalk compactClassesArray.(index := self indexIfCompact) = 0	ifTrue: [ ^ self ].(cct includes: self)	ifFalse: [ ^ self halt	"inconsistent state" ].self checkCanBeUncompact.	"Update instspec so future instances will not be compact"format := format - (index bitShift: 11).	"Make up new instances and become old ones into them"self updateInstancesFrom: self.	"Make sure there are no compact ones left around"Smalltalk garbageCollect.	"Remove this class from the compact class table"cct at: index put: nil]Class Behavior >> format[	"Answer an Integer that encodes the kinds and numbers of variables of 	instances of the receiver."^ format]Metaclass	name: #Behavior;	instanceVariables: #().Metaclass Behavior >> flushObsoleteSubclasses[	"Behavior flushObsoleteSubclasses"ObsoleteSubclasses finalizeValues]Metaclass Behavior >> initializeObsoleteSubclasses[ObsoleteSubclasses := WeakKeyToCollectionDictionary new]Metaclass Behavior >> cleanUp[	"Flush the obsolete subclasses."self flushObsoleteSubclasses]Metaclass Behavior >> canZapMethodDictionary[	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."^ false]Metaclass Behavior >> initialize[	"Behavior initialize"	"Never called for real"ObsoleteSubclasses	ifNil: [ self initializeObsoleteSubclasses ]	ifNotNil: [ 		| newDict |		newDict := WeakKeyToCollectionDictionary newFrom: ObsoleteSubclasses.		newDict rehash.		ObsoleteSubclasses := newDict ]]