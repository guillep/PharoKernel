Class
	name: #ContextPart;
	superclass: #ClassInstructionStream;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#stackp );
	classVariables: #(#QuickStep #PrimitiveFailToken #SpecialPrimitiveSimulators #TryNamedPrimitiveTemplateMethod );
	package: #'Kernel-Methods'.


Class ContextPart >> isContextPart
[
^true
]

Class ContextPart >> activateMethod: newMethod withArgs: args receiver: rcvr class: class
[
	"Answer a ContextPart initialized with the arguments."
^ MethodContext	sender: self	receiver: rcvr	method: newMethod	arguments: args
]

Class ContextPart >> activateReturn: aContext value: value
[
	"Activate 'aContext return: value' in place of self, so execution will return to aContext's sender"
^ self	activateMethod: ContextPart theReturnMethod	withArgs: {value}	receiver: aContext	class: aContext class
]

Class ContextPart >> arguments
[
	"returns the arguments of a message invocation"
| arguments numargs |numargs := self method numArgs.arguments := Array new: numargs.1 to: numargs do: [ :i | arguments at: i put: (self tempAt: i) ].^ arguments
]

Class ContextPart >> at: index
[
	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not an	 Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."
	<primitive: 210>
index isInteger	ifTrue: [ self errorSubscriptBounds: index ].index isNumber	ifTrue: [ ^ self at: index asInteger ]	ifFalse: [ self errorNonIntegerIndex ]
]

Class ContextPart >> at: index put: value
[
	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not	 an Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."
	<primitive: 211>
index isInteger	ifTrue: [ self errorSubscriptBounds: index ].index isNumber	ifTrue: [ ^ self at: index asInteger put: value ]	ifFalse: [ self errorNonIntegerIndex ]
]

Class ContextPart >> basicAt: index
[
	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not an	 Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."
	<primitive: 210>
index isInteger	ifTrue: [ self errorSubscriptBounds: index ].index isNumber	ifTrue: [ ^ self at: index asInteger ]	ifFalse: [ self errorNonIntegerIndex ]
]

Class ContextPart >> basicAt: index put: value
[
	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not	 an Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."
	<primitive: 211>
index isInteger	ifTrue: [ self errorSubscriptBounds: index ].index isNumber	ifTrue: [ ^ self at: index asInteger put: value ]	ifFalse: [ self errorNonIntegerIndex ]
]

Class ContextPart >> basicSize
[
	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."
	"The number of indexable fields of fixed-length objects is 0"
	<primitive: 212>
^ self primitiveFail
]

Class ContextPart >> bottomContext
[
	"Return the last context (the first context invoked) in my sender chain"
^ self findContextSuchThat: [ :c | c sender isNil ]
]

Class ContextPart >> canHandleSignal: exception
[
	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then return true, otherwise forward this message to the next handler context.  If none left, return false (see nil>>canHandleSignal:)"
^ (((self tempAt: 1) handles: exception) and: [ self tempAt: 3 ])	or: [ self nextHandlerContext canHandleSignal: exception ]
]

Class ContextPart >> cannotReturn: result to: homeContext
[
	"The receiver tried to return result to homeContext that no longer exists."
^ BlockCannotReturn new	result: result;	deadHome: homeContext;	signal
]

Class ContextPart >> client
[
	"Answer the client, that is, the object that sent the message that created this context."
^ sender receiver
]

Class ContextPart >> closureCopy: numArgs copiedValues: anArray
[
	"Distinguish a block of code from its enclosing method by 	creating a BlockClosure for that block. The compiler inserts into all 	methods that contain blocks the bytecodes to send the message 	closureCopy:copiedValues:. Do not use closureCopy:copiedValues: in code that you write! Only the 	compiler can decide to send the message closureCopy:copiedValues:. Fail if numArgs is 	not a SmallInteger. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."
	<primitive: 200>
^ BlockClosure	outerContext: self	startpc: pc + 2	numArgs: numArgs	copiedValues: anArray
]

Class ContextPart >> completeCallee: aContext
[
	"Simulate the execution of bytecodes until a return to the receiver."
| ctxt current ctxt1 |ctxt := aContext.[ ctxt == current or: [ ctxt hasSender: self ] ]	whileTrue: [ 		current := ctxt.		ctxt1 := ctxt quickStep.		ctxt1 ifNil: [ self halt ].		ctxt := ctxt1 ].^ self stepToSendOrReturn
]

Class ContextPart >> contextStack
[
	"Answer an Array of the contexts on the receiver's sender chain."
^ self stackOfSize: 100000
]

Class ContextPart >> copyStack
[
^ self copyTo: nil
]

Class ContextPart >> copyTo: aContext
[
	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home.  It is best to use BlockClosures instead.  They only hold a ContextTag, which will work for all copies of the original home context."
^ self copyTo: aContext blocks: IdentityDictionary new
]

Class ContextPart >> copyTo: aContext blocks: dict
[
	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home."
| copy |self == aContext	ifTrue: [ ^ nil ].copy := self copy.dict at: self ifPresent: [ :blocks | blocks do: [ :b | b privHome: copy ] ].self sender ifNotNil: [ copy privSender: (self sender copyTo: aContext blocks: dict) ].^ copy
]

Class ContextPart >> cut: aContext
[
	"Cut aContext and its senders from my sender chain"
| ctxt callee |ctxt := self.[ ctxt == aContext ]	whileFalse: [ 		callee := ctxt.		ctxt := ctxt sender.		ctxt ifNil: [ aContext ifNotNil: [ self error: 'aContext not a sender' ] ] ].callee privSender: nil
]

Class ContextPart >> debugStack: stackSize on: aStream
[
	"print a condensed version of the stack up to stackSize on aStream"
(self stackOfSize: stackSize)	do: [ :item | 		item printDebugOn: aStream.		aStream cr ]
]

Class ContextPart >> debugStackOn: aStream
[
	"print the top ten contexts on my sender chain."
^ self debugStack: 100 on: aStream
]

Class ContextPart >> depthBelow: aContext
[
	"Answer how many calls there are between this and aContext."
| this depth |this := self.depth := 0.[ this == aContext or: [ this == nil ] ]	whileFalse: [ 		this := this sender.		depth := depth + 1 ].^ depth
]

Class ContextPart >> doDup
[
	"Simulate the action of a 'duplicate top of stack' bytecode."
self push: self top
]

Class ContextPart >> doPop
[
	"Simulate the action of a 'remove top of stack' bytecode."
self pop
]

Class ContextPart >> doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
[
	"Simulate a primitive method whose index is primitiveIndex.  The        simulated receiver and arguments are given as arguments to this message.        Any primitive which provikes execution needs to be intercepted and simulated        to avoid execution running away."
	<primitive: 19>
| value |primitiveIndex = 83	ifTrue: [ 		^ self			send: arguments first			to: receiver			with: arguments allButFirst			super: false ].	"Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	"	(primitiveIndex = 19) ifTrue:		[Smalltalk tools debugger			openContext: self			label:'Code simulation error'			contents: nil]."	"afr 9/11/1998 19:50"	"Object>>perform:[with:...]"primitiveIndex = 84	ifTrue: [ 		^ self			send: arguments first			to: receiver			with: (arguments at: 2)			super: false ].	"afr 9/11/1998 19:50"	"Object>>perform:withArguments:"primitiveIndex = 188	ifTrue: [ 		arguments size = 2			ifTrue: [ 				"eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"				^ MethodContext					sender: self					receiver: receiver					method: (arguments at: 2)					arguments: (arguments at: 1) ].		arguments size = 3			ifTrue: [ 				"CompiledMethod class >> #receiver:withArguments:executeMethod:"				^ MethodContext					sender: self					receiver: (arguments at: 1)					method: (arguments at: 3)					arguments: (arguments at: 2) ] ].primitiveIndex = 189	ifTrue: [ 		"Object >> (#with:)*executeMethod"		^ MethodContext			sender: self			receiver: receiver			method: arguments last			arguments: arguments allButLast ].	"Closure primitives"(primitiveIndex = 200 and: [ receiver == self ])	ifTrue: [ 		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"		^ self			push:				(BlockClosure					outerContext: receiver					startpc: pc + 2					numArgs: arguments first					copiedValues: arguments last) ].((primitiveIndex between: 201 and: 205) or: [ primitiveIndex between: 221 and: 222 ])	ifTrue: [ 		"BlockClosure>>valueNoContextSwitch[:]"		^ receiver simulateValueWithArguments: arguments caller: self ].	"BlockClosure>>value[:value:...]"primitiveIndex = 206	ifTrue: [ 		"BlockClosure>>valueWithArguments:"		^ receiver simulateValueWithArguments: arguments first caller: self ].primitiveIndex = 120	ifTrue: [ 		"FFI method"		value := meth literals first tryInvokeWithArguments: arguments ]	ifFalse: [ 		value := self			simulatePrimitive: primitiveIndex			in: meth			receiver: receiver			arguments: arguments ].^ (self isFailToken: value)	ifTrue: [ value ]	ifFalse: [ self push: value ]
]

Class ContextPart >> errorReportOn: strm
[
	"Write a detailed error report on the stack (above me) on a  	stream.  For both the error file, and emailing a bug report.   	Suppress any errors while getting printStrings.  Limit the length."
| cnt aContext startPos |strm	print: Date today;	space;	print: Time now;	cr.strm cr.strm	nextPutAll: 'VM: ';	nextPutAll: Smalltalk platform platformName asString;	nextPutAll: ' - ';	nextPutAll: Smalltalk platform platformSubtype asString;	nextPutAll: ' - ';	nextPutAll: Smalltalk os version asString;	nextPutAll: ' - ';	nextPutAll: Smalltalk vm version asString;	cr.strm	nextPutAll: 'Image: ';	nextPutAll: SystemVersion current version asString;	nextPutAll: ' [';	nextPutAll: Smalltalk lastUpdateString asString;	nextPutAll: ']';	cr.strm cr.	"Note: The following is an open-coded version of  ContextPart>>stackOfSize: since this method may be called during a  low space condition and we might run out of space for allocating the  full stack."cnt := 0.startPos := strm position.aContext := self.[ aContext notNil and: [ (cnt := cnt + 1) < 40 ] ]	whileTrue: [ 		aContext printDetails: strm.	"variable values"		strm cr.		aContext := aContext sender ].strm	cr;	nextPutAll: '--- The full stack ---';	cr.aContext := self.cnt := 0.[ aContext == nil ]	whileFalse: [ 		cnt := cnt + 1.		cnt = 40			ifTrue: [ 				strm					nextPutAll:							' - - - - - - - - - - - - - - -  			- - - - - - - - - - - - - - - - - -';					cr ].		strm			print: aContext;			cr.	"just class>>selector"		strm position > (startPos + 150000)			ifTrue: [ 				strm nextPutAll: '...etc...'.				^ self ].	"exit early"		cnt > 200			ifTrue: [ 				strm nextPutAll: '-- and more not shown --'.				^ self ].		aContext := aContext sender ]
]

Class ContextPart >> findContextSuchThat: testBlock
[
	"Search self and my sender chain for first one that satisfies testBlock.  Return nil if none satisfy"
| ctxt |ctxt := self.[ ctxt isNil ]	whileFalse: [ 		(testBlock value: ctxt)			ifTrue: [ ^ ctxt ].		ctxt := ctxt sender ].^ nil
]

Class ContextPart >> findNextHandlerContextStarting
[
	"Return the next handler marked context, returning nil if there is none.  Search starts with self and proceeds up to nil."
	<primitive: 197>
| ctx |ctx := self.[ ctx isHandlerContext	ifTrue: [ ^ ctx ].(ctx := ctx sender) == nil ] whileFalse.^ nil
]

Class ContextPart >> findNextUnwindContextUpTo: aContext
[
	"Return the next unwind marked above the receiver, returning nil if there is none.  Search proceeds up to but not including aContext."
	<primitive: 195>
| ctx |ctx := self.[ (ctx := ctx sender) == nil or: [ ctx == aContext ] ]	whileFalse: [ 		ctx isUnwindContext			ifTrue: [ ^ ctx ] ].^ nil
]

Class ContextPart >> findSecondToOldestSimilarSender
[
	"Search the stack for the second-to-oldest occurance of self's method.  Very useful for an infinite recursion.  Gets back to the second call so you can see one complete recursion cycle, and how it was called at the beginning."
| sec ctxt bot |sec := self.ctxt := self.[ bot := ctxt findSimilarSender.bot isNil ]	whileFalse: [ 		sec := ctxt.		ctxt := bot ].^ sec
]

Class ContextPart >> findSimilarSender
[
	"Return the closest sender with the same method, return nil if none found"
| meth |meth := self method.^ self sender findContextSuchThat: [ :c | c method == meth ]
]

Class ContextPart >> handleSignal: exception
[
	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."
| val |(((self tempAt: 1) handles: exception) and: [ self tempAt: 3 ])	ifFalse: [ ^ self nextHandlerContext handleSignal: exception ].exception privHandlerContext: self contextTag.self tempAt: 3 put: false.	"disable self while executing handle block"val := [ (self tempAt: 2) cull: exception ]	ensure: [ self tempAt: 3 put: true ].self return: val	"return from self if not otherwise directed in handle block"
]

Class ContextPart >> hasContext: aContext
[
	"Answer whether aContext is me or one of my senders"
^ (self findContextSuchThat: [ :c | c == aContext ]) notNil
]

Class ContextPart >> hasSender: context
[
	"Answer whether the receiver is strictly above context on the stack."
| s |self == context	ifTrue: [ ^ false ].s := sender.[ s == nil ]	whileFalse: [ 		s == context			ifTrue: [ ^ true ].		s := s sender ].^ false
]

Class ContextPart >> home
[
	"Answer the context in which the receiver was defined."
self subclassResponsibility
]

Class ContextPart >> insertSender: aContext
[
	"Insert aContext and its sender chain between me and my sender.  Return new callee of my original sender."
| ctxt |ctxt := aContext bottomContext.ctxt privSender: self sender.self privSender: aContext.^ ctxt
]

Class ContextPart >> isBottomContext
[
	"Answer if this is the last context (the first context invoked) in my sender chain"
^ sender isNil
]

Class ContextPart >> isContext
[
^ true
]

Class ContextPart >> isDead
[
	"Has self finished"
^ pc isNil
]

Class ContextPart >> isFailToken: anObject
[
^ anObject class == Array and: [ anObject size = 2 and: [ (anObject at: 1) == PrimitiveFailToken ] ]
]

Class ContextPart >> isHandlerContext
[
^ false
]

Class ContextPart >> isUnwindContext
[
^ false
]

Class ContextPart >> jump
[
	"Abandon thisContext and resume self instead (using the same current process).  You may want to save thisContext's sender before calling this so you can jump back to it.	Self MUST BE a top context (ie. a suspended context or a abandoned context that was jumped out of).  A top context already has its return value on its stack (see Interpreter>>primitiveSuspend and other suspending primitives).	thisContext's sender is converted to a top context (by pushing a nil return value on its stack) so it can be jump back to."
| top |"Make abandoned context a top context (has return value (nil)) so it can be jumped back to"thisContext sender push: nil.	"Pop self return value then return it to self (since we jump to self by returning to it)"stackp = 0	ifTrue: [ self stepToSendOrReturn ].stackp = 0	ifTrue: [ self push: nil ].	"must be quick return self/constant"top := self pop.thisContext privSender: self.^ top
]

Class ContextPart >> jump: distance
[
	"Simulate the action of a 'unconditional jump' bytecode whose offset is 	the argument, distance."
pc := pc + distance
]

Class ContextPart >> jump: distance if: condition
[
	"Simulate the action of a 'conditional jump' bytecode whose offset is the 	argument, distance, and whose condition is the argument, condition."
| bool |bool := self pop.(bool == true or: [ bool == false ])	ifFalse: [ 		^ self			send: #mustBeBooleanIn:			to: bool			with: {self}			super: false ].(bool eqv: condition)	ifTrue: [ self jump: distance ]
]

Class ContextPart >> longStack
[
	"Answer a String showing the top 100 contexts on my sender chain."
^ String	streamContents: [ :strm | 		(self stackOfSize: 100)			do: [ :item | 				strm					print: item;					cr ] ]
]

Class ContextPart >> method
[
	"Answer the method of this context."
self subclassResponsibility
]

Class ContextPart >> methodClass
[
	"Answer the class in which the receiver's method was found."
^ self method methodClass ifNil: [ self receiver class ]
]

Class ContextPart >> methodNode
[
^ self method methodNode
]

Class ContextPart >> methodReturnConstant: value
[
	"Simulate the action of a 'return constant' bytecode whose value is the	 argument, value. This corresponds to a source expression like '^0'."
^ self return: value from: self methodReturnContext
]

Class ContextPart >> methodReturnContext
[
	"Answer the context from which an ^-return should return from."
self subclassResponsibility
]

Class ContextPart >> methodReturnReceiver
[
	"Simulate the action of a 'return receiver' bytecode. This corresponds to	 the source expression '^self'."
^ self return: self receiver from: self methodReturnContext
]

Class ContextPart >> methodReturnTop
[
	"Simulate the action of a 'return top of stack' bytecode. This corresponds	 to source expressions like '^something'."
^ self return: self pop from: self methodReturnContext
]

Class ContextPart >> methodSelector
[
^ self method selector
]

Class ContextPart >> namedTempAt: index
[
	"Answer the value of the temp at index in the receiver's sequence of tempNames."
^ self debuggerMap namedTempAt: index in: self
]

Class ContextPart >> namedTempAt: index put: aValue
[
	"Set the value of the temp at index in the receiver's sequence of tempNames.	 (Note that if the value is a copied value it is also set out along the lexical chain,	  but alas not in along the lexical chain.)."
^ self debuggerMap namedTempAt: index put: aValue in: self
]

Class ContextPart >> nextHandlerContext
[
^ self sender findNextHandlerContextStarting
]

Class ContextPart >> objectSize: anObject
[
	"Answer the number of indexable variables in the argument anObject without sending        it a message. This mimics the action of the VM when it fetches an object's variable size.        Used to simulate the execution machinery by, for example, the debugger.        Primitive.  See Object documentation whatIsAPrimitive."
	"The number of indexable fields of fixed-length objects is 0"
	<primitive: 62>
^ 0
]

Class ContextPart >> pop
[
	"Answer the top of the receiver's stack and remove the top of the stack."
| val |val := self at: stackp.self stackp: stackp - 1.^ val
]

Class ContextPart >> popIntoLiteralVariable: value
[
	"Simulate the action of bytecode that removes the top of the stack and 	stores it into a literal variable of my method."
value value: self pop
]

Class ContextPart >> popIntoReceiverVariable: offset
[
	"Simulate the action of bytecode that removes the top of the stack and 	stores it into an instance variable of my receiver."
self receiver instVarAt: offset + 1 put: self pop
]

Class ContextPart >> popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
[
	"Simulate the action of bytecode that removes the top of the stack and  stores	 it into an offset in one of my local variables being used as a remote temp vector."
(self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self pop
]

Class ContextPart >> popIntoTemporaryVariable: offset
[
	"Simulate the action of bytecode that removes the top of the stack and 	stores it into one of my temporary variables."
self at: offset + 1 put: self pop
]

Class ContextPart >> print: anObject on: aStream
[
	"Safely print anObject in the face of direct ProtoObject subclasses"
| title |(anObject class canUnderstand: #printOn:)	ifTrue: [ ^ anObject printOn: aStream ].title := anObject class name.aStream	nextPutAll:			(title first isVowel					ifTrue: [ 'an ' ]					ifFalse: [ 'a ' ]);	nextPutAll: title
]

Class ContextPart >> printDebugOn: aStream
[
	"print a condensed for of the stack.
		For methods simply print Class >> selector
		For blocks only print the first line"
self printOn: aStream
]

Class ContextPart >> printDetails: strm
[
	"Put my class>>selector and arguments and temporaries on the stream.  Protect against errors during printing."
| str |self printOn: strm.strm	cr;	tab;	nextPutAll: 'Arguments and temporary variables: ';	cr.str := [ self tempsAndValuesLimitedTo: 80 indent: 2 ] ifError: [ '<<error during printing>>' ].strm nextPutAll: str.strm peekLast == Character cr	ifFalse: [ strm cr ]
]

Class ContextPart >> printOn: aStream
[
| selector class mclass |self method == nil	ifTrue: [ ^ super printOn: aStream ].class := self receiver class.mclass := self methodClass.selector := self selector ifNil: [ self method defaultSelector ].aStream nextPutAll: class name.mclass == class	ifFalse: [ 		aStream nextPut: $(.		aStream nextPutAll: mclass name.		aStream nextPut: $) ].aStream nextPutAll: '>>'.aStream nextPutAll: selector.selector = #doesNotUnderstand:	ifTrue: [ 		aStream space.		(self tempAt: 1) selector printOn: aStream ]
]

Class ContextPart >> privSender: aContext
[
sender := aContext
]

Class ContextPart >> push: val
[
	"Push val on the receiver's stack."
self stackp: stackp + 1.self at: stackp put: val
]

Class ContextPart >> push: numObjects fromIndexable: anIndexableCollection
[
	"Push the elements of anIndexableCollection onto the receiver's stack.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."
1 to: numObjects do: [ :i | self push: (anIndexableCollection at: i) ]
]

Class ContextPart >> pushActiveContext
[
	"Simulate the action of bytecode that pushes the the active context on the 	top of its own stack."
self push: self
]

Class ContextPart >> pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize
[
	"Simulate the action of a 'closure copy' bytecode whose result is the	 new BlockClosure for the following code"
| copiedValues |numCopied > 0	ifTrue: [ 		copiedValues := Array new: numCopied.		numCopied to: 1 by: -1 do: [ :i | copiedValues at: i put: self pop ] ]	ifFalse: [ copiedValues := nil ].self	push:		(BlockClosure			outerContext: self			startpc: pc			numArgs: numArgs			copiedValues: copiedValues).self jump: blockSize
]

Class ContextPart >> pushConstant: value
[
	"Simulate the action of bytecode that pushes the constant, value, on the 	top of the stack."
self push: value
]

Class ContextPart >> pushLiteralVariable: value
[
	"Simulate the action of bytecode that pushes the contents of the literal 	variable whose index is the argument, index, on the top of the stack."
self push: value value
]

Class ContextPart >> pushNewArrayOfSize: arraySize
[
self push: (Array new: arraySize)
]

Class ContextPart >> pushReceiver
[
	"Simulate the action of bytecode that pushes the active context's receiver 	on the top of the stack."
self push: self receiver
]

Class ContextPart >> pushReceiverVariable: offset
[
	"Simulate the action of bytecode that pushes the contents of the receiver's 	instance variable whose index is the argument, index, on the top of the 	stack."
self push: (self receiver instVarAt: offset + 1)
]

Class ContextPart >> pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
[
	"Simulate the action of bytecode that pushes the value at remoteTempIndex	 in one of my local variables being used as a remote temp vector."
self push: ((self at: tempVectorIndex + 1) at: remoteTempIndex + 1)
]

Class ContextPart >> pushTemporaryVariable: offset
[
	"Simulate the action of bytecode that pushes the contents of the 	temporary variable whose index is the argument, index, on the top of 	the stack."
self push: (self at: offset + 1)
]

Class ContextPart >> quickSend: selector to: receiver with: arguments super: superFlag
[
	"Send the given selector with arguments in an environment which closely resembles the non-simulating environment, with an interjected unwind-protected block to catch nonlocal returns.	Attention: don't get lost!"
| lookupClass contextToReturnTo result |contextToReturnTo := self.lookupClass := superFlag	ifTrue: [ (self method literalAt: self method numLiterals) value superclass ]	ifFalse: [ receiver class ].[ | oldSender |oldSender := thisContext sender swapSender: self.result := receiver perform: selector withArguments: arguments inSuperclass: lookupClass.thisContext sender swapSender: oldSender ]	ifCurtailed: [ 		contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"		contextToReturnTo jump: -1.	"skip to front of return bytecode causing this unwind"		contextToReturnTo nextByte = 16r7C			ifTrue: [ 				"If it was a returnTop, push the value to be returned.			Otherwise the value is implicit in the bytecode"				contextToReturnTo push: (thisContext sender tempAt: 1) ].		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"		contextToReturnTo ].contextToReturnTo push: result.^ contextToReturnTo
]

Class ContextPart >> quickStep
[
	"If the next instruction is a send, just perform it.	Otherwise, do a normal step."
self willSend	ifTrue: [ QuickStep := self ].^ self step
]

Class ContextPart >> receiver
[
	"Answer the receiver of the message that created this context."
self subclassResponsibility
]

Class ContextPart >> release
[
	"Remove information from the receiver and all of the contexts on its 	sender chain in order to break circularities."
self releaseTo: nil
]

Class ContextPart >> releaseTo: caller
[
	"Remove information from the receiver and the contexts on its sender 	chain up to caller in order to break circularities."
| c s |c := self.[ c == nil or: [ c == caller ] ]	whileFalse: [ 		s := c sender.		c singleRelease.		c := s ]
]

Class ContextPart >> restart
[
	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"
| ctxt unwindBlock |self isDead	ifTrue: [ self cannotReturn: nil to: self ].self privRefresh.ctxt := thisContext.[ ctxt := ctxt findNextUnwindContextUpTo: self.ctxt isNil ]	whileFalse: [ 		(ctxt tempAt: 2)			ifNil: [ 				ctxt tempAt: 2 put: true.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value ] ].thisContext terminateTo: self.self jump
]

Class ContextPart >> resume
[
	"Roll back thisContext to self and resume.  Execute unwind blocks when rolling back.  ASSUMES self is a sender of thisContext"
self resume: nil
]

Class ContextPart >> resume: value
[
	"Unwind thisContext to self and resume with value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"
| ctxt unwindBlock |self isDead	ifTrue: [ self cannotReturn: value to: self ].ctxt := thisContext.[ ctxt := ctxt findNextUnwindContextUpTo: self.ctxt isNil ]	whileFalse: [ 		(ctxt tempAt: 2)			ifNil: [ 				ctxt tempAt: 2 put: true.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value ] ].thisContext terminateTo: self.^ value
]

Class ContextPart >> resume: value through: firstUnwindCtxt
[
	"Unwind thisContext to self and resume with value as result of last send.	 Execute any unwind blocks while unwinding.	 ASSUMES self is a sender of thisContext."
| ctxt unwindBlock |self isDead	ifTrue: [ self cannotReturn: value to: self ].ctxt := firstUnwindCtxt.[ ctxt isNil ]	whileFalse: [ 		(ctxt tempAt: 2)			ifNil: [ 				ctxt tempAt: 2 put: true.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value ].		ctxt := ctxt findNextUnwindContextUpTo: self ].thisContext terminateTo: self.^ value
]

Class ContextPart >> return
[
	"Unwind until my sender is on top"
self return: self receiver
]

Class ContextPart >> return: value
[
	"Unwind thisContext to self and return value to self's sender.  Execute any unwind blocks while unwinding.  ASSUMES self is a sender of thisContext"
sender ifNil: [ self cannotReturn: value to: sender ].sender resume: value
]

Class ContextPart >> return: value from: aSender
[
	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"
| newTop ctxt |aSender isDead	ifTrue: [ 		^ self			send: #cannotReturn:			to: self			with: {value}			super: false ].newTop := aSender sender.ctxt := self findNextUnwindContextUpTo: newTop.ctxt	ifNotNil: [ 		^ self			send: #aboutToReturn:through:			to: self			with:				{value.				ctxt}			super: false ].self releaseTo: newTop.newTop ifNotNil: [ newTop push: value ].^ newTop
]

Class ContextPart >> return: value through: firstUnwindContext
[
	"Unwind thisContext to self and return value to self's sender.	 Execute any unwind blocks while unwinding.	 ASSUMES self is a sender of thisContext."
sender ifNil: [ self cannotReturn: value to: sender ].sender resume: value through: firstUnwindContext
]

Class ContextPart >> return: value to: sendr
[
	"Simulate the return of value to sendr."
self releaseTo: sendr.sendr ifNil: [ ^ nil ].^ sendr push: value
]

Class ContextPart >> runSimulated: aBlock contextAtEachStep: block2
[
	"Simulate the execution of the argument, aBlock, until it ends. aBlock 	MUST NOT contain an '^'. Evaluate block2 with the current context 	prior to each instruction executed. Answer the simulated value of aBlock."
| current returnContext exception |aBlock hasMethodReturn	ifTrue: [ self error: 'simulation of blocks with ^ can run loose' ].current := [ aBlock	on: Exception	do: [ :ex | SimulationExceptionWrapper signalForException: ex ] ] asContext.returnContext := MethodContext	sender: nil	receiver: self home receiver	method: self home method	arguments: self home arguments.current pushArgs: Array new from: returnContext.[ current == returnContext ]	whileFalse: [ 		block2 value: current.		current := current step ].exception := returnContext pop.exception class == SimulationExceptionWrapper	ifTrue: [ ^ exception exception signal ].^ exception
]

Class ContextPart >> runUntilErrorOrReturnFrom: aSender
[
	"ASSUMES aSender is a sender of self.  Execute self's stack until aSender returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSender returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."
	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSender that jumps back to thisContext when evaluated.  We also insert an exception handler under aSender that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."
| error ctxt here topContext aSendersSender |here := thisContext.aSendersSender := aSender sender.	"Insert ensure and exception handler contexts under aSender"error := nil.ctxt := aSender	insertSender:		(ContextPart			contextOn: UnhandledError			do: [ :ex | 				error					ifNil: [ 						error := ex exception.						topContext := thisContext.						ex resumeUnchecked: here jump ]					ifNotNil: [ ex pass ] ]).ctxt := ctxt	insertSender:		(ContextPart			contextEnsure: [ 				error					ifNil: [ 						topContext := thisContext.						here jump ] ]).self jump.	"Control jumps to self"	"Control resumes here once above ensure block or exception handler is executed"^ error	ifNil: [ 		"No error was raised, remove ensure context by stepping until popped"		[ ctxt isDead or: [ aSender isDead ] ] whileFalse: [ topContext := topContext stepToCallee ].		^ {(aSender isDead			ifTrue: [ 				| retValue |				retValue := (ctxt method == (BlockClosure >> #ensure:) or: [ ctxt method == (BlockClosure >> #ifCurtailed:) ])					ifTrue: [ ctxt tempAt: 3 ].	"returnValue in ensure: and result in ifCurtailed:"				aSendersSender push: retValue.				aSendersSender ]			ifFalse: [ topContext ]).		nil} ]	ifNotNil: [ 		"Error was raised, remove inserted above contexts then return signaler context"		aSender terminateTo: ctxt sender.	"remove above ensure and handler contexts"		{topContext.		error} ]
]

Class ContextPart >> secondFromBottom
[
	"Return the second from bottom of my sender chain"
self sender ifNil: [ ^ nil ].^ self findContextSuchThat: [ :c | c sender sender isNil ]
]

Class ContextPart >> selector
[
	"Answer the selector of the method that created the receiver."
^ self method selector ifNil: [ self method defaultSelector ]
]

Class ContextPart >> send: selector super: superFlag numArgs: numArgs
[
	"Simulate the action of bytecodes that send a message with selector, 	selector. The argument, superFlag, tells whether the receiver of the 	message was specified with 'super' in the source method. The arguments 	of the message are found in the top numArgs locations on the stack and 	the receiver just below them."
| receiver arguments answer |arguments := Array new: numArgs.numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop ].receiver := self pop.	"	selector == #doPrimitive:method:receiver:args:		ifTrue: [answer := receiver 					doPrimitive: (arguments at: 1)					method: (arguments at: 2)					receiver: (arguments at: 3)					args: (arguments at: 4).				self push: answer.				^self]. "QuickStep == self	ifTrue: [ 		QuickStep := nil.		^ self			quickSend: selector			to: receiver			with: arguments			super: superFlag ].^ self	send: selector	to: receiver	with: arguments	super: superFlag
]

Class ContextPart >> send: selector to: rcvr with: args super: superFlag
[
	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."
| class meth val ctx |class := superFlag	ifTrue: [ (self method literalAt: self method numLiterals) value superclass ]	ifFalse: [ rcvr class ].meth := class lookupSelector: selector.meth == nil	ifTrue: [ 		^ self			send: #doesNotUnderstand:			to: rcvr			with: (Array with: (Message selector: selector arguments: args))			super: superFlag ].val := self tryPrimitiveFor: meth receiver: rcvr args: args.	"primitive runs without failure?"(self isFailToken: val)	ifFalse: [ ^ val ].(selector == #doesNotUnderstand: and: [ (class canUnderstand: #doesNotUnderstand:) not ])	ifTrue: [ ^ self error: 'Simulated message ' , (args at: 1) selector , ' not understood' ].	"failure.. lets activate the method"ctx := self	activateMethod: meth	withArgs: args	receiver: rcvr	class: class.	"check if activated method handles the error code (a first bytecode will be store into temp)"(ctx method at: ctx pc) = 129	ifTrue: [ ctx at: ctx stackPtr put: val last ].	"long store temp"^ ctx
]

Class ContextPart >> sender
[
	"Answer the context that sent the message that created the receiver."
^ sender
]

Class ContextPart >> setNamedPrimitiveInformationFrom: fromMethod toMethod: toMethod
[
	"For named primitives, the first literal contains a special object that has information of the primitive. Example:(StandardFileStream >> #primOpen:writable:) literalAt: 1 ----->>>>   #(#FilePlugin #primitiveFileOpen 0 147).In this method we cope such information from one to another one."
| spec |spec := toMethod literalAt: 1.spec	replaceFrom: 1	to: spec size	with: (fromMethod literalAt: 1)	startingAt: 1
]

Class ContextPart >> setNumArgs: numArgs toMethod: theMethod
[
	"All that line is to change the argument count of a CompiledMethod header. The argument count is 4 bits starting in the 24 and finishign in 27.16r787FFFFF is the hexa representation of a number that is all 1 and only those 4 bits in 0. Hence, when doing (theMethod header bitAnd: 16r787FFFFF) what we do is just to put zeros in those 4 bits.Now with the new argument size, we do bitShift: 24 and we obtain a 32 bits number with all zeros and just our 4 bits with the value we want.Since in the previous step we cleaned those 4 bits doing now a bitOr: with the second step, we have the result."
| xpc |theMethod	objectAt: 1	put:		(((theMethod header bitAnd: 2r01110000000000111111111111111111) bitOr: (numArgs bitShift: 24))			bitOr: (numArgs + 1 bitShift: 18)).xpc := theMethod initialPC.(theMethod at: xpc) = 129	ifTrue: [ 		theMethod at: xpc + 1 put: 16r40 + numArgs.		theMethod at: xpc + 3 put: 16r10 + numArgs ]	"long store temp"
]

Class ContextPart >> shortDebugStack
[
	"Answer a String showing the top ten contexts on my sender chain."
^ String streamContents: [ :stream | self debugStack: 10 on: stream ]
]

Class ContextPart >> shortDebugStackOn: aStream
[
	"print the top ten contexts on my sender chain."
^ self debugStack: 10 on: aStream
]

Class ContextPart >> shortStack
[
	"Answer a String showing the top ten contexts on my sender chain."
^ String	streamContents: [ :strm | 		(self stackOfSize: 10)			do: [ :item | 				strm					print: item;					cr ] ]
]

Class ContextPart >> simulatePrimitive: primitiveIndex in: method receiver: receiver arguments: arguments
[
| key simulator |key := primitiveIndex = 117	ifTrue: [ 		| lit |		lit := method literalAt: 1.		{"prim name, module name "		(lit second).		(lit first)}	"prim name, module name " ]	ifFalse: [ primitiveIndex ].simulator := self class specialPrimitiveSimulators	at: key	ifAbsent: [ 		^ primitiveIndex = 117			ifTrue: [ 				self withoutPrimitiveTryNamedPrimitiveIn: method for: receiver withArgs: arguments	"this using primitive 218, which doesn't works as expected... 					self tryNamedPrimitiveIn: method for: receiver withArgs: arguments " ]			ifFalse: [ receiver tryPrimitive: primitiveIndex withArgs: arguments ]	"named primitives" ].^ simulator	simulatePrimitiveFor: method	receiver: receiver	arguments: arguments	context: self
]

Class ContextPart >> singleRelease
[
	"Remove information from the receiver in order to break circularities."
stackp == nil	ifFalse: [ 1 to: stackp do: [ :i | self at: i put: nil ] ].sender := nil.pc := nil
]

Class ContextPart >> size
[
	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."
	"The number of indexable fields of fixed-length objects is 0"
	<primitive: 212>
^ self primitiveFail
]

Class ContextPart >> sourceCode
[
^ self method sourceCode	"Note: The above is a bit safer than		^ methodClass sourceCodeAt: selector	which may fail if the receiver's method has been changed in	the debugger (e.g., the method is no longer in the methodDict	and thus the above selector is something like #Doit:with:with:with:)	but the source code is still available."
]

Class ContextPart >> stack
[
	"Answer an Array of the contexts on the receiver's sender chain."
^ self stackOfSize: 9999
]

Class ContextPart >> stackOfSize: limit
[
	"Answer an OrderedCollection of the top 'limit' contexts	 on the receiver's sender chain."
| stack ctxt |stack := OrderedCollection new.stack addLast: (ctxt := self).[ (ctxt := ctxt sender) ~~ nil and: [ stack size < limit ] ] whileTrue: [ stack addLast: ctxt ].^ stack
]

Class ContextPart >> stackPtr
[
	"For use only by the SystemTracer and the Debugger, Inspectors etc"
^ stackp
]

Class ContextPart >> stackp: newStackp
[
	"Storing into the stack pointer is a potentially dangerous thing.	This primitive stores nil into any cells that become accessible as a result,	and it performs the entire operation atomically."
	"Once this primitive is implemented, failure code should cause an error"
	<primitive: 76>
self error: 'stackp store failure'	"	stackp == nil ifTrue: [stackp := 0].	newStackp > stackp  'effectively checks that it is a number'		ifTrue: [oldStackp := stackp.				stackp := newStackp.				'Nil any newly accessible cells'				oldStackp + 1 to: stackp do: [:i | self at: i put: nil]]		ifFalse: [stackp := newStackp]"
]

Class ContextPart >> step
[
	"Simulate the execution of the receiver's next bytecode. Answer the 	context that would be the active context after this bytecode."
^ self interpretNextInstructionFor: self
]

Class ContextPart >> stepToCallee
[
	"Step to callee or sender"
| ctxt |ctxt := self.[ (ctxt := ctxt step) == self ] whileTrue.^ ctxt
]

Class ContextPart >> stepToSendOrReturn
[
	"Simulate the execution of bytecodes until either sending a message or 	returning a value to the receiver (that is, until switching contexts)."
| ctxt |[ self willSend | self willReturn | self willStore ]	whileFalse: [ 		ctxt := self step.		ctxt == self			ifFalse: [ 				self halt.	"Caused by mustBeBoolean handling"				^ ctxt ] ]
]

Class ContextPart >> storeIntoLiteralVariable: value
[
	"Simulate the action of bytecode that stores the top of the stack into a 	literal variable of my method."
value value: self top
]

Class ContextPart >> storeIntoReceiverVariable: offset
[
	"Simulate the action of bytecode that stores the top of the stack into an 	instance variable of my receiver."
self receiver instVarAt: offset + 1 put: self top
]

Class ContextPart >> storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex
[
	"Simulate the action of bytecode that stores the top of the stack at	 an offset in one of my local variables being used as a remote temp vector."
(self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self top
]

Class ContextPart >> storeIntoTemporaryVariable: offset
[
	"Simulate the action of bytecode that stores the top of the stack into one 	of my temporary variables."
self at: offset + 1 put: self top
]

Class ContextPart >> swapSender: coroutine
[
	"Replace the receiver's sender with coroutine and answer the receiver's 	previous sender. For use in coroutining."
| oldSender |oldSender := sender.sender := coroutine.^ oldSender
]

Class ContextPart >> tempAt: index
[
	"Answer the value of the temporary variable whose index is the 	argument, index."
self subclassResponsibility
]

Class ContextPart >> tempAt: index put: value
[
	"Store the argument, value, as the temporary variable whose index is the 	argument, index."
self subclassResponsibility
]

Class ContextPart >> tempNamed: aName
[
	"Answer the value of the temporary variable whose name is the 	argument, aName."
self subclassResponsibility
]

Class ContextPart >> tempNamed: aName put: value
[
	"Store the argument, value, as the temporary variable whose name is the 	argument, aName."
self subclassResponsibility
]

Class ContextPart >> tempNames
[
	"Answer a SequenceableCollection of the names of the receiver's temporary 	 variables, which are strings."
^ self debuggerMap tempNamesForContext: self
]

Class ContextPart >> tempScopedNames
[
	"Answer a SequenceableCollection of the names of the receiver's temporary 	 variables, which are strings."
^ self debuggerMap tempNamesScopedForContext: self
]

Class ContextPart >> tempsAndValues
[
	"Return a string of the temporary variabls and their current values"
^ self debuggerMap tempsAndValuesForContext: self
]

Class ContextPart >> tempsAndValuesLimitedTo: sizeLimit indent: indent
[
	"Return a string of the temporary variabls and their current values"
| aStream |aStream := (String new: 100) writeStream.self tempScopedNames	doWithIndex: [ :title :index | 		indent timesRepeat: [ aStream tab ].		aStream			nextPutAll: title;			nextPut: $:;			space;			tab.		aStream nextPutAll: ((self tempAt: index) printStringLimitedTo: (sizeLimit - 3 - title size max: 1)).		aStream cr ].^ aStream contents
]

Class ContextPart >> terminate
[
	"Make myself unresumable."
sender := nil.pc := nil
]

Class ContextPart >> terminateTo: previousContext
[
	"Terminate all the Contexts between me and previousContext, if previousContext is on my Context stack. Make previousContext my sender."
	<primitive: 196>
| currentContext sendingContext |(self hasSender: previousContext)	ifTrue: [ 		currentContext := sender.		[ currentContext == previousContext ]			whileFalse: [ 				sendingContext := currentContext sender.				currentContext terminate.				currentContext := sendingContext ] ].sender := previousContext
]

Class ContextPart >> top
[
	"Answer the top of the receiver's stack."
^ self at: stackp
]

Class ContextPart >> tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
[
	<primitive: 218 error: #ec>
ec	ifNotNil: [ 		"If ec is an integer other than -1 there was a problem with primitive 218,		 not with the external primitive itself.  -1 indicates a generic failure (where		 ec should be nil) but ec = nil means primitive 218 is not implemented.  So		 interpret -1 to mean the external primitive failed with a nil error code."		ec isInteger			ifTrue: [ 				ec = -1					ifTrue: [ ec := nil ]					ifFalse: [ self primitiveFailed ] ].		^ self class primitiveFailTokenFor: ec ].	"Assume a nil error code implies the primitive is not implemented and fall back on the old code."	"The primitive doesn't exist or there was an error. Hence, we follow another solution without the primitive"^ self withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
]

Class ContextPart >> tryPrimitiveFor: method receiver: receiver args: arguments
[
	"If this method has a primitive index, then run the primitive and return its result.	Otherwise (and also if the primitive fails) return PrimitiveFailToken,	as an indication that the method should be activated and run as bytecodes."
| primIndex |(primIndex := method primitive) = 0	ifTrue: [ ^ self class primitiveFailToken ].^ self	doPrimitive: primIndex	method: method	receiver: receiver	args: arguments
]

Class ContextPart >> unwindTo: aContext
[
| ctx unwindBlock |ctx := self.[ (ctx := ctx findNextUnwindContextUpTo: aContext) isNil ]	whileFalse: [ 		(ctx tempAt: 2)			ifNil: [ 				ctx tempAt: 2 put: true.				unwindBlock := ctx tempAt: 1.				unwindBlock value ] ]
]

Class ContextPart >> withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments
[
	"When using the debugger we want to run a method step by step. What what happens when we do a step into a CompiledMethod which has a primitive? If such a method is executed form outside the Debugger (normal scenario) the VM knows that such CompiledMethod has a primitive declaration and hence executes it. If it fails then it continues executing all the bytecode of the method. Otherwise, it just returns. Now, what is the problem with the Debugger? The problem is that if the primitive fail, we don't want that the VM directly executes all the remaining bytecodes of the method. Instead, we would like to go step by step witht he Debugger, just as happens with normal methods. To solve the mentioned problem, we use the following trick: We have the orignal compiled method (the one that has a primitive invokation), the receiver and the arguments. So the idea is to use a template compiled method that ONLY contains the primitive delcaration (it doesn't include all the smalltalk code after the primitive). #tryNamedPrimitiveTemplateMethod answers such a template method which looks like:tryNamedPrimitive	<primitive:'' module:''>	^ ContextPart primitiveFailToken' Since this method does not change its bytecodes for every invokation, we can reuse it for all methods with primitives. There are only 2 things we have to change in the template: the number of arguments and the primitive declaration (to use the correct primitive name and module name).Then what we do is to run that compiled method with the receiver and arguments we have. The result is that we will be invoking almost the same original method but a slighly different version that does not have the smalltalk part after the primitive and that in contrast is sends #primitiveFailToken. If this method invokation does not fail, then the Debugger continues debugging the sender of the primitive method. In this case, the step in is the same as step over. If the primitive fails, then the debugger continues executing the smalltalk part after the primitive method. In this case, step in is a real step in.  "
| theMethod spec |arguments size > 8	ifTrue: [ ^ self class primitiveFailToken ].theMethod := self class tryNamedPrimitiveTemplateMethod.self setNumArgs: arguments size toMethod: theMethod.theMethod == nil	ifTrue: [ ^ self class primitiveFailToken ].self setNamedPrimitiveInformationFrom: aCompiledMethod toMethod: theMethod.theMethod flushCache.^ theMethod valueWithReceiver: aReceiver arguments: arguments	"^ aReceiver withArgs: arguments executeMethod: theMethod	"
]

Metaclass
	name: #ContextPart;
	instanceVariables: #().

Metaclass ContextPart >> basicNew: size
[
self error: 'Contexts must only be created with newForMethod:'
]

Metaclass ContextPart >> carefullyPrint: anObject on: aStream
[
aStream	nextPutAll:		([ anObject printString ]			on: Error			do: [ 'unprintable ' , anObject class name ])
]

Metaclass ContextPart >> contextEnsure: block
[
	"Create an #ensure: context that is ready to return from executing its receiver"
| ctxt chain |ctxt := thisContext.[ chain := thisContext sender cut: ctxt.ctxt jump ]	ensure: block.	"jump above will resume here without unwinding chain"^ chain
]

Metaclass ContextPart >> contextOn: exceptionClass do: block
[
	"Create an #on:do: context that is ready to return from executing its receiver"
| ctxt chain |ctxt := thisContext.[ chain := thisContext sender cut: ctxt.ctxt jump ]	on: exceptionClass	do: block.	"jump above will resume here without unwinding chain"^ chain
]

Metaclass ContextPart >> initialize
[
	"A unique object to be returned when a primitive fails during simulation"
PrimitiveFailToken := Object new.self initializeTryNamedPrimitiveTemplateMethod.SpecialPrimitiveSimulators := nil.QuickStep := nil
]

Metaclass ContextPart >> initializePrimitiveSimulators
[
	"extra primitive simulators can be registered by implementing	#registerPrimitiveSimulators method in class side of your class.	 "
SpecialPrimitiveSimulators := Dictionary new.Class	allSubclassesDo: [ :metaclass | 		(metaclass methodDict includesKey: #registerPrimitiveSimulators)			ifTrue: [ metaclass theNonMetaClass registerPrimitiveSimulators ] ]
]

Metaclass ContextPart >> initializeTryNamedPrimitiveTemplateMethod
[
| methodNode |methodNode := Compiler new	compile:		'tryNamedPrimitive	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ ContextPart primitiveFailTokenFor: errorCode'	in: UndefinedObject	classified: nil	notifying: #()	ifFail: [ self error: 'method source is incorrect' ].TryNamedPrimitiveTemplateMethod := (CompiledMethodWithNode	generateMethodFromNode: methodNode	trailer: CompiledMethodTrailer empty) method
]

Metaclass ContextPart >> isContextClass
[
^ true
]

Metaclass ContextPart >> new
[
self error: 'Contexts must only be created with newForMethod:'
]

Metaclass ContextPart >> new: size
[
self error: 'Contexts must only be created with newForMethod:'
]

Metaclass ContextPart >> newForMethod: aMethod
[
	"This is the only method for creating new contexts, other than primitive cloning.	Any other attempts, such as inherited methods like shallowCopy, should be	avoided or must at least be rewritten to determine the proper size from the	method being activated.  This is because asking a context its size (even basicSize!)	will not return the real object size but only the number of fields currently	accessible, as determined by stackp."
^ super basicNew: aMethod frameSize
]

Metaclass ContextPart >> primitiveFailToken
[
^ self primitiveFailTokenFor: nil
]

Metaclass ContextPart >> primitiveFailTokenFor: errorCode
[
^ {PrimitiveFailToken.errorCode}
]

Metaclass ContextPart >> runSimulated: aBlock
[
	"Simulate the execution of the argument, current. Answer the result it 	returns."
^ thisContext sender runSimulated: aBlock contextAtEachStep: [ :ignored |  ]	"ContextPart runSimulated: [Pen new defaultNib: 5; go: 100]"
]

Metaclass ContextPart >> simulatePrimitive: primName module: moduleName with: simulator
[
^ self specialPrimitiveSimulators	at:		{primName.		moduleName}	put: simulator
]

Metaclass ContextPart >> simulatePrimitiveNumber: num with: simulator
[
^ self specialPrimitiveSimulators at: num put: simulator
]

Metaclass ContextPart >> specialPrimitiveSimulators
[
SpecialPrimitiveSimulators ifNil: [ self initializePrimitiveSimulators ].^ SpecialPrimitiveSimulators
]

Metaclass ContextPart >> tallyInstructions: aBlock
[
	"This method uses the simulator to count the number of occurrences of	each of the Smalltalk instructions executed during evaluation of aBlock.	Results appear in order of the byteCode set."
| tallies |tallies := Bag new.thisContext sender runSimulated: aBlock contextAtEachStep: [ :current | tallies add: current nextByte ].^ tallies sortedElements	"ContextPart tallyInstructions: [3.14159 printString]"
]

Metaclass ContextPart >> tallyMethods: aBlock
[
	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. Results are given in order of decreasing counts."
| prev tallies |tallies := Bag new.prev := aBlock.thisContext sender	runSimulated: aBlock	contextAtEachStep: [ :current | 		current == prev			ifFalse: [ 				"call or return"				prev sender == nil					ifFalse: [ 						"call only"						tallies add: current printString ].				prev := current ] ].^ tallies sortedCounts	"ContextPart tallyMethods: [3.14159 printString]"
]

Metaclass ContextPart >> theReturnMethod
[
| meth |meth := self lookupSelector: #return:.meth isPrimitive	ifTrue: [ ^ self error: 'expected #return: to not be a primitive' ].^ meth
]

Metaclass ContextPart >> trace: aBlock
[
	"ContextPart trace: [3 factorial]"
	"This method uses the simulator to print calls and returned values in the Transcript."
Transcript clear.^ self trace: aBlock on: Transcript
]

Metaclass ContextPart >> trace: aBlock on: aStream
[
	"ContextPart trace: [3 factorial]"
	"This method uses the simulator to print calls to a file."
| prev |prev := aBlock.^ thisContext sender	runSimulated: aBlock	contextAtEachStep: [ :current | 		Sensor anyButtonPressed			ifTrue: [ ^ nil ].		current == prev			ifFalse: [ 				prev sender					ifNil: [ 						"Following does not work anymore due to closures?"						"						aStream space; nextPut: $^.						self carefullyPrint: current top on: aStream						"						 ].				aStream cr.				(current depthBelow: aBlock) timesRepeat: [ aStream space ].				self carefullyPrint: current receiver on: aStream.				aStream					space;					nextPutAll: current selector;					flush.				prev := current ] ]
]

Metaclass ContextPart >> trace: aBlock onFileNamed: fileName
[
	"ContextPart trace: [3 factorial] onFileNamed: 'trace'"
	"This method uses the simulator to print calls to a file."
| aStream |^ [ aStream := FileStream fileNamed: fileName.self trace: aBlock on: aStream ]	ensure: [ aStream close ]
]

Metaclass ContextPart >> tryNamedPrimitiveTemplateMethod
[
^ TryNamedPrimitiveTemplateMethod
]

