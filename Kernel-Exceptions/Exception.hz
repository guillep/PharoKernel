Class	name: #Exception;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#messageText #tag #signaler #signalContext #handlerContext #outerContext );	classVariables: #();	package: #'Kernel-Exceptions'.Class Exception >> searchFrom: aContext[	" Set the context where the handler search will start. "signalContext := aContext contextTag]Class Exception >> resume: resumptionValue[	"Return resumptionValue as the value of the signal message."self isResumable	ifFalse: [ IllegalResumeAttempt signal ].self resumeUnchecked: resumptionValue]Class Exception >> tag: t[	"This message is not specified in the ANSI protocol, but that looks like an oversight because #tag is specified, and the spec states that the signaler may store the tag value."tag := t]Class Exception >> isResumable[	"Determine whether an exception is resumable."^ true]Class Exception >> outer[	"Evaluate the enclosing exception action and return to here instead of signal if it resumes (see #resumeUnchecked:)."| prevOuterContext |self isResumable	ifTrue: [ 		prevOuterContext := outerContext.		outerContext := thisContext contextTag ].self pass]Class Exception >> debug[	"open a debugger on myself"Smalltalk tools debugError: self]Class Exception >> retry[	"Abort an exception handler and re-evaluate its protected block."handlerContext restart]Class Exception >> defaultResumeValue[	"Answer the value that by default should be returned if the exception is resumed"^ nil]Class Exception >> defaultReturnValue[	"Answer the value that by default should be returned if the exception is returned"^ nil]Class Exception >> freezeUpTo: aContext[	"freeze the signal context up to the given context so the exception is usable outside the catch block"signalContext := signalContext copyTo: aContext]Class Exception >> return: returnValue[	"Return the argument as the value of the block protected by the active exception handler."handlerContext return: returnValue]Class Exception >> signalerContext[	"Find the first sender of signal(:)"^ signalContext findContextSuchThat: [ :ctxt | (ctxt receiver == self or: [ ctxt receiver == self class ]) not ]]Class Exception >> retryUsing: alternativeBlock[	"Abort an exception handler and evaluate a new block in place of the handler's protected block."handlerContext restartWithNewReceiver: alternativeBlock]Class Exception >> messageText: signalerText[	"Set an exception's message text."messageText := signalerText]Class Exception >> freeze[	"freeze the context stack to keep the exception usable outside the catch blocks"self freezeUpTo: thisContext]Class Exception >> signal: signalerText[	"Signal the occurrence of an exceptional condition with a specified textual description."self messageText: signalerText.^ self signal]Class Exception >> receiver[^ self signalerContext receiver]Class Exception >> resume[	"Return from the message that signaled the receiver."self resume: self defaultResumeValue]Class Exception >> return[	"Return nil as the value of the block protected by the active exception handler."self return: self defaultReturnValue]Class Exception >> isNested[	"Determine whether the current exception handler is within the scope of another handler for the same exception."^ handlerContext nextHandlerContext canHandleSignal: self]Class Exception >> tag[	"Return an exception's tag value."^ tag == nil	ifTrue: [ self messageText ]	ifFalse: [ tag ]]Class Exception >> messageText[	"Return an exception's message text."^ messageText ifNil: [ String empty ]]Class Exception >> signaler: anObject[	"Set the object that is the subject involving me.	This is set automatically to my #receiver during #signal	but could be overwritten when I am signaled"signaler := anObject]Class Exception >> signal[	"Ask ContextHandlers in the sender chain to handle this signal.  The default is to execute and return my defaultAction."signalContext := thisContext contextTag.signaler ifNil: [ signaler := self receiver ].^ signalContext nextHandlerContext handleSignal: self]Class Exception >> defaultAction[	"The default action taken if the exception is signaled."self subclassResponsibility]Class Exception >> description[	"Return a textual description of the exception."^ String	streamContents: [ :stream | 		| mt |		stream << self class name.		(mt := self messageText) isEmptyOrNil			ifFalse: [ stream << ': ' << mt ] ]]Class Exception >> privHandlerContext: aContextTag[handlerContext := aContextTag]Class Exception >> printOn: stream[stream nextPutAll: self description]Class Exception >> resignalAs: replacementException[	"Signal an alternative exception in place of the receiver."self resumeUnchecked: replacementException signal]Class Exception >> pass[	"Yield control to the enclosing exception action for the receiver."handlerContext nextHandlerContext handleSignal: self]Class Exception >> resumeUnchecked: resumptionValue[	"Return resumptionValue as the value of #signal, unless this was called after an #outer message, then return resumptionValue as the value of #outer."| ctxt |outerContext	ifNil: [ signalContext return: resumptionValue ]	ifNotNil: [ 		ctxt := outerContext.		outerContext := ctxt tempAt: 1.	"prevOuterContext in #outer"		ctxt return: resumptionValue ]]Class Exception >> signaler[	"Return the object that is the subject involving me.	This is set automatically to my #receiver during #signal	but could be overwritten when I am signaled"^ signaler]Metaclass	name: #Exception;	instanceVariables: #().Metaclass Exception >> signal: signalerText[	"Signal the occurrence of an exceptional condition with a specified textual description."^ self new signal: signalerText]Metaclass Exception >> handles: exception[	"Determine whether an exception handler will accept a signaled exception."^ exception isKindOf: self]Metaclass Exception >> , anotherException[	"Create an exception set."^ ExceptionSet new	add: self;	add: anotherException;	yourself]Metaclass Exception >> signal[	"Signal the occurrence of an exceptional condition."^ self new signal]