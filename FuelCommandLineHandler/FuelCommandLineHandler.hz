Class	name: #FuelCommandLineHandler;	superclass: #ClassCommandLineHandler;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#sourceFiles );	classVariables: #();	package: #FuelCommandLineHandler.Class FuelCommandLineHandler >> activate[self loadSourceFiles: (self commandLine allFilesWithExtension: 'fuel').self installSourceFiles.(self commandLine hasOption: 'save')	ifTrue: [ 		ThreadSafeTranscript install.		Smalltalk			addDeferredStartupAction: [ 				Smalltalk snapshot: true andQuit: true.				NonInteractiveTranscript new install ] ].(self commandLine hasOption: 'quit')	ifTrue: [ self exitSucess ]]Class FuelCommandLineHandler >> installSourceFile: aReference[	"Install the previously loaded source file"| timeToMaterialize package timeToLoad bytes |aReference	readStreamDo: [ :stream | 		FileStream stdout			nextPutAll: 'Materializing package from file: ' , aReference fullName;			lf.		timeToMaterialize := [ package := FLPackageLoader new materializeFrom: stream ] timeToRun.		FileStream stdout			nextPutAll:					'Time to materialize: ' , timeToMaterialize asString , ' miliseconds and occupied: ' , stream size asBytesDescription;			lf ].FileStream stdout	nextPutAll: 'Loading and initializing package from file: ' , aReference fullName;	lf.timeToLoad := [ package load ] timeToRun.FileStream stdout	nextPutAll: 'Time to load: ' , timeToLoad asString , 'miliseconds.';	lf]Class FuelCommandLineHandler >> loadSourceFiles: anArray[	"Load all the source files in the given array."sourceFiles := anArray collect: [ :each | (FileSystem disk resolve: each) asFileReference ]]Class FuelCommandLineHandler >> installSourceFiles[	"Install the previously loaded source files"sourceFiles ifNil: [ ^ self ].[ sourceFiles do: [ :reference | self installSourceFile: reference ] ]	ensure: [ sourceFiles := nil ]]Class FuelCommandLineHandler >> handleError: error reference: aReference[	"Print a header before failing on an errro / syntax notification from the the script loaded by the given request"| stderr |"spit out a warning if in headless mode, otherwise a debugger will popup"Smalltalk isHeadless	ifTrue: [ self inform: 'Errors in script loaded from ' , aReference fullName ].(error isKindOf: SyntaxErrorNotification)	ifTrue: [ error defaultAction ]	ifFalse: [ error pass ]	"for syntax errors we can used the default action"	"otherwise resignal it"]Metaclass	name: #FuelCommandLineHandler;	instanceVariables: #().Metaclass FuelCommandLineHandler >> isResponsibleFor: aCommandLine[	"This handler is reponsible only for .fuel files"(aCommandLine hasFileWithExtension: '.fuel')	ifTrue: [ ^ true ].^ super isResponsibleFor: aCommandLine]Metaclass FuelCommandLineHandler >> description[^ 'handles .fuel package files']Metaclass FuelCommandLineHandler >> commandName[^ 'fuel']