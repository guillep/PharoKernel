Class
	name: #Interval;
	superclass: #ClassSequenceableCollection;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#start #stop #step );
	classVariables: #();
	package: #'Collections-Sequenceable'.

Class Interval >> at: anInteger put: anObject
[
	"Storing into an Interval is not allowed."
self error: 'you can not store into an interval'
]

Class Interval >> do: aBlock
[
	"Evaluate aBlock for each value of the interval.	Implementation note: instead of repeatedly incrementing the value		aValue := aValue + step.	until stop is reached,	We prefer to recompute value from start		aValue := start + (index * step).	This is better for floating points accuracy, while not degrading Integer and Fraction speed too much.	Moreover, this is consistent with methods #at: and #size"
| aValue index size |index := 0.size := self size.[ index < size ]	whileTrue: [ 		aValue := start + (index * step).		index := index + 1.		aBlock value: aValue ]
]

Class Interval >> collect: aBlock
[
| nextValue result |result := self species new: self size.nextValue := start.1 to: result size do: [ :i | 	result at: i put: (aBlock value: nextValue).	nextValue := nextValue + step ].^ result
]

Class Interval >> add: newObject
[
	"Adding to an Interval is not allowed."
self shouldNotImplement
]

Class Interval >> reverseDo: aBlock
[
	"Evaluate aBlock for each element of my interval, in reverse order.	Implementation notes: see do: for an explanation on loop detail"
| aValue index |index := self size.[ index > 0 ]	whileTrue: [ 		index := index - 1.		aValue := start + (index * step).		aBlock value: aValue ]
]

Class Interval >> indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock
[
	"startIndex is an positive integer, the collection index where the search is started."
	"during the computation of val , floats are only used when the receiver contains floats"
| index val |(self rangeIncludes: anElement)	ifFalse: [ ^ exceptionBlock value ].val := (anElement - self first) / self increment.val isFloat	ifTrue: [ 		(val - val rounded) abs * 100000000 < 1			ifTrue: [ index := val rounded + 1 ]			ifFalse: [ ^ exceptionBlock value ] ]	ifFalse: [ 		val isInteger			ifTrue: [ index := val + 1 ]			ifFalse: [ ^ exceptionBlock value ] ].	"finally, the value of startIndex comes into play:"^ (index between: startIndex and: self size)	ifTrue: [ index ]	ifFalse: [ exceptionBlock value ]
]

Class Interval >> storeOn: aStream
[
aStream	nextPut: $(;	store: start;	nextPutAll: ' to: ';	store: stop.step ~= 1	ifTrue: [ 		aStream			nextPutAll: ' by: ';			store: step ].aStream nextPut: $)
]

Class Interval >> at: anInteger
[
	"Answer the anInteger'th element."
(anInteger >= 1 and: [ anInteger <= self size ])	ifTrue: [ ^ start + (step * (anInteger - 1)) ]	ifFalse: [ self errorSubscriptBounds: anInteger ]
]

Class Interval >> species
[
^ Array
]

Class Interval >> extent
[
	"Answer the max - min of the receiver interval."
	"(10 to: 50) extent"
^ stop - start
]

Class Interval >> = anObject
[
^ self == anObject	ifTrue: [ true ]	ifFalse: [ 		anObject isInterval			ifTrue: [ start = anObject first and: [ step = anObject increment and: [ self last = anObject last ] ] ]			ifFalse: [ super = anObject ] ]
]

Class Interval >> increment
[
	"Answer the receiver's interval increment."
^ step
]

Class Interval >> hash
[
	"Hash is reimplemented because = is implemented."
^ (((start hash bitShift: 2) bitOr: stop hash) bitShift: 1) bitOr: self size
]

Class Interval >> rangeIncludes: aNumber
[
	"Return true if the number lies in the interval between start and stop."
step >= 0	ifTrue: [ ^ aNumber between: start and: stop ]	ifFalse: [ ^ aNumber between: stop and: start ]
]

Class Interval >> remove: newObject
[
	"Removing from an Interval is not allowed."
self error: 'elements cannot be removed from an Interval'
]

Class Interval >> - number
[
^ start - number to: stop - number by: step
]

Class Interval >> last
[
	"Refer to the comment in SequenceableCollection|last."
^ stop - ((stop - start) \\ step)
]

Class Interval >> + number
[
^ start + number to: stop + number by: step
]

Class Interval >> anyOne
[
	"This message will fail for an empty Interval, super would not.	(2 to: 1) anyOne should fail because empty."
^ self at: 1
]

Class Interval >> isInterval
[
^ true
]

Class Interval >> setFrom: startInteger to: stopInteger by: stepInteger
[
start := startInteger.stop := stopInteger.step := stepInteger
]

Class Interval >> printOn: aStream
[
aStream	nextPut: $(;	print: start;	nextPutAll: ' to: ';	print: stop.step ~= 1	ifTrue: [ 		aStream			nextPutAll: ' by: ';			print: step ].aStream nextPut: $)
]

Class Interval >> permutationsDo: aBlock
[
	"Repeatly value aBlock with a single copy of the receiver. Reorder the copy	so that aBlock is presented all (self size factorial) possible permutations."
	"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]"
self asArray permutationsDo: aBlock
]

Class Interval >> size
[
	"Answer how many elements the receiver contains."
step < 0	ifTrue: [ 		start < stop			ifTrue: [ ^ 0 ]			ifFalse: [ ^ (stop - start) // step + 1 ] ]	ifFalse: [ 		stop < start			ifTrue: [ ^ 0 ]			ifFalse: [ ^ (stop - start) // step + 1 ] ]
]

Class Interval >> isSelfEvaluating
[
^ self class == Interval
]

Class Interval >> first
[
	"Refer to the comment in SequenceableCollection|first."
^ start
]

Metaclass
	name: #Interval;
	instanceVariables: #().

Metaclass Interval >> newFrom: aCollection
[
	"Answer an instance of me containing the same elements as aCollection."
| newInterval n |(n := aCollection size) <= 1	ifTrue: [ 		n = 0			ifTrue: [ ^ self from: 1 to: 0 ].		^ self from: aCollection first to: aCollection last ].newInterval := self from: aCollection first to: aCollection last by: (aCollection last - aCollection first) // (n - 1).aCollection ~= newInterval	ifTrue: [ 		"Give a second chance, because progression might be arithmetic, but = answer false"		(newInterval hasEqualElements: aCollection)			ifFalse: [ self error: 'The argument is not an arithmetic progression' ] ].^ newInterval	"	Interval newFrom: {1. 2. 3}	{33. 5. -23} as: Interval	{33. 5. -22} as: Interval    (an error)	(-4 to: -12 by: -1) as: Interval	#(2 4 6) asByteArray as: Interval."
]

Metaclass Interval >> from: startInteger to: stopInteger by: stepInteger
[
	"Answer an instance of me, starting at startNumber, ending at 	stopNumber, and with an interval increment of stepNumber."
^ self new setFrom: startInteger to: stopInteger by: stepInteger
]

Metaclass Interval >> from: startInteger to: stopInteger
[
	"Answer an instance of me, starting at startNumber, ending at 	stopNumber, and with an interval increment of 1."
^ self new setFrom: startInteger to: stopInteger by: 1
]

Metaclass Interval >> new
[
	"Primitive. Create and answer with a new instance of the receiver	(a class) with no indexable fields. Fail if the class is indexable. Override	SequenceableCollection new. Essential. See Object documentation	whatIsAPrimitive."
	<primitive: 70>
self isVariable	ifTrue: [ ^ self new: 0 ].	"space must be low"OutOfMemory signal.^ self new	"retry if user proceeds"
]

