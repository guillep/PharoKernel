Class
	name: #SharedQueue;
	superclass: #ClassStream;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#monitor #items );
	classVariables: #();
	package: #'Collections-Sequenceable'.

Class SharedQueue >> findFirst: aBlock
[
	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no such object has been queued, answer <nil> and leave me intact."
^ monitor	critical: [ 		| index |		index := items findFirst: aBlock.		index = 0			ifTrue: [ nil ]			ifFalse: [ items removeAt: index ] ]
]

Class SharedQueue >> flush
[
	"Remove from the queue all objects"
monitor critical: [ items := items removeAll ]
]

Class SharedQueue >> flushAllSuchThat: aBlock
[
	"Remove from the queue all objects that satisfy aBlock."
monitor critical: [ items := items reject: aBlock ]
]

Class SharedQueue >> initialize
[
super initialize.monitor := Monitor new.items := OrderedCollection new
]

Class SharedQueue >> isEmpty
[
^ monitor critical: [ items isEmpty ]
]

Class SharedQueue >> next
[
^ monitor	critical: [ 		monitor waitWhile: [ items isEmpty ].		items removeFirst ]
]

Class SharedQueue >> nextOrNil
[
^ monitor	critical: [ 		items isEmpty			ifTrue: [ nil ]			ifFalse: [ items removeFirst ] ]
]

Class SharedQueue >> nextOrNilSuchThat: aBlock
[
	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."
^ monitor	critical: [ 		| index |		index := items findFirst: aBlock.		index = 0			ifTrue: [ nil ]			ifFalse: [ items removeAt: index ] ]
]

Class SharedQueue >> nextPut: anObject
[
monitor	critical: [ 		items addLast: anObject.		monitor signal ].^ anObject
]

Class SharedQueue >> peek
[
	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, return nil"
^ monitor	critical: [ 		items isEmpty			ifTrue: [ nil ]			ifFalse: [ items first ] ]
]

Class SharedQueue >> postCopy
[
super postCopy.monitor	critical: [ 		items := items copy.		monitor := Monitor new ]
]

Class SharedQueue >> printOn: aStream
[
monitor	critical: [ 		aStream			nextPutAll: self class name;			nextPutAll: ' with ';			print: items size;			nextPutAll: ' items' ]
]

Class SharedQueue >> removeAll
[
monitor critical: [ items removeAll ]
]

Class SharedQueue >> size
[
^ monitor critical: [ items size ]
]

Metaclass
	name: #SharedQueue;
	instanceVariables: #().

Metaclass SharedQueue >> new
[
^ self basicNew initialize
]

