Class	name: #FLPluggableSubstitutionMapper;	superclass: #ClassFLMapper;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#condition #substitutionFactory );	classVariables: #();	package: #'Fuel-Mappers'.Class FLPluggableSubstitutionMapper >> initializeWith: aCondition substitutionFactory: aBlock[self initialize.condition := aCondition.substitutionFactory := aBlock]Class FLPluggableSubstitutionMapper >> mapAndTrace: anObject[	"Uses the Chain of Responsibility pattern to answer the cluster which maps with the received object."(condition value: anObject)	ifTrue: [ self mapAndTraceSubstitutionIfNotRecursive: anObject ]	ifFalse: [ next mapAndTrace: anObject ]]Class FLPluggableSubstitutionMapper >> mapAndTraceSubstitutionIfNotRecursive: anObject[| cluster |cluster := self clusterKeyedByClusterName: FLSubstitutionCluster.(cluster isSubstitute: anObject)	ifTrue: [ next mapAndTrace: anObject ]	ifFalse: [ cluster add: anObject substitutedBy: (substitutionFactory value: anObject) traceWith: analysis ]]Metaclass	name: #FLPluggableSubstitutionMapper;	instanceVariables: #().Metaclass FLPluggableSubstitutionMapper >> when: aCondition substituteBy: aFactory[^ self basicNew	initializeWith: aCondition substitutionFactory: aFactory;	yourself]