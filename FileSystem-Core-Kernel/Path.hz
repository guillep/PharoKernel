Class	name: #Path;	superclass: #ClassObject;	instanceSpecification: #(#variable #pointers #words );	instanceVariables: #();	classVariables: #();	package: #'FileSystem-Core-Kernel'.Class Path >> parent[| size parent |self isRoot	ifTrue: [ ^ self ].self isAllParents	ifTrue: [ ^ self / '..' ].size := self size - 1.parent := self class new: size.1 to: size do: [ :i | parent at: i put: (self at: i) ].^ parent]Class Path >> containsPath: aPath[self size < aPath size	ifFalse: [ ^ false ].1 to: self size do: [ :i | 	(self at: i) = (aPath at: i)		ifFalse: [ ^ false ] ].^ true]Class Path >> isEmpty[^ self size = 0]Class Path >> extensions[	"Return the extensions of the receiver in order of appearance"	"(Path from: '/foo/bar.tar.gz') extensions"^ (self extensionDelimiter split: self basename) allButFirst]Class Path >> asUrl[^ FileUrl pathParts: self segments asOrderedCollection isAbsolute: self isAbsolute]Class Path >> extensionDelimiter[^ self class extensionDelimiter]Class Path >> contains: anObject[^ anObject isContainedBy: self]Class Path >> asResolvedBy: anObject[^ anObject resolvePath: self]Class Path >> do: aBlock[1 to: self size do: [ :index | 	| segment |	segment := self at: index.	segment isEmpty		ifFalse: [ aBlock value: segment ] ]]Class Path >> base[	"Returns the base of the basename, i.e. /foo/gloops.taz basename is 'gloops'"^ self basename copyUpTo: self extensionDelimiter]Class Path >> resolve: anObject[	"Return a path in which the argument has been interpreted in the context of the receiver. Different 	argument types have different resolution semantics, so we use double dispatch to resolve them correctly."^ anObject asResolvedBy: self]Class Path >> relativeToReference: aReference[^ self relativeToPath: aReference path]Class Path >> isChildOf: anObject[^ self parent = anObject]Class Path >> resolvePath: aPath[	"Answers an absolute path created by resolving the argument against the receiver.	If the argument is abolute answer the argument itself. Otherwise, concatenate the	two paths, then process all parent references '..', and create a path with the remaining	elements."| elements |aPath isAbsolute	ifTrue: [ ^ aPath ].elements := Array new: self size + aPath size.1 to: self size do: [ :i | elements at: i put: (self at: i) ].1 to: aPath size do: [ :i | elements at: self size + i put: (aPath at: i) ].^ self class withAll: (self class canonicalizeElements: elements)]Class Path >> printWithDelimiter: aCharacter[^ String streamContents: [ :out | self printOn: out delimiter: aCharacter ]]Class Path >> isContainedBy: anObject[^ anObject containsPath: self]Class Path >> relativeTo: anObject[^ anObject makeRelative: self]Class Path >> withExtension: extension[| basename name |basename := self basename.^ (basename endsWith: extension)	ifTrue: [ self ]	ifFalse: [ 		name := basename copyUpToLast: self extensionDelimiter.		self withName: name extension: extension ]]Class Path >> printOn: aStream delimiter: aCharacter[(1 to: self size) do: [ :index | aStream nextPutAll: (self at: index) ] separatedBy: [ aStream nextPut: aCharacter ]]Class Path >> printOn: aStream[self printOn: aStream delimiter: self delimiter]Class Path >> = other[^ self species = other species	and: [ self size = other size and: [ (1 to: self size) allSatisfy: [ :i | (self at: i) = (other at: i) ] ] ]]Class Path >> delimiter[^ $/]Class Path >> asPathWith: anObject[^ self]Class Path >> isRoot[self subclassResponsibility]Class Path >> withName: name extension: extension[| basename |basename := String	streamContents: [ :out | 		out nextPutAll: name.		out nextPut: self extensionDelimiter.		out nextPutAll: extension ].^ self copy	at: self size put: basename;	yourself]Class Path >> withParents[| paths |paths := OrderedCollection new.1 to: self size - 1 do: [ :index | paths add: ((self class new: index) copyFrom: self) ].paths add: self.^ paths]Class Path >> containsReference: aReference[^ false]Class Path >> isRelative[^ self isAbsolute not]Class Path >> , extension[^ self withName: self basename extension: extension]Class Path >> fullName[	"Return the fullName of the receiver."^ self printString]Class Path >> asReference[self deprecated: 'Use #asFileReference instead' on: '12 April 2012' in: 'Pharo 1.4'.^ self asFileReference]Class Path >> resolve[^ self]Class Path >> copyFrom: aPath[| size |size := aPath size min: self size.1 to: size do: [ :i | self at: i put: (aPath at: i) ]]Class Path >> isAllParents[1 to: self size do: [ :i | 	(self at: i) = '..'		ifFalse: [ ^ false ] ].^ true]Class Path >> isAbsolute[self subclassResponsibility]Class Path >> / aString[| path |aString isEmptyOrNil	ifTrue: [ Error signal: 'Path element cannot be empty or nil' ].path := self class new: self size + 1.path copyFrom: self.path at: path size put: aString.^ path]Class Path >> segments[	"return an array with all the path segements separated"| segments index |segments := Array new: self size.index := 1.self	do: [ :part | 		segments at: index put: part.		index := index + 1 ].^ segments]Class Path >> hash[| hash |hash := self class identityHash.1 to: self size do: [ :i | hash := String stringHash: (self at: i) initialHash: hash ].^ hash]Class Path >> basename[	"Returns the base of the basename, 		i.e. 		/foo/gloops.taz basename is 'gloops.taz'		/ basename is '/'"self size == 0	ifTrue: [ ^ '/' ].	"the root node"^ self at: self size]Class Path >> resolveReference: aReference[^ aReference]Class Path >> relativeToPath: aPath[	"Return the receiver as relative to the argument aPath"	"(FSPath / 'griffle' / 'plonk' / 'nurp') 		relativeToPath: (FSPath / 'griffle') 			returns  plonk/nurp"| prefix relative |aPath isRelative	ifTrue: [ ^ aPath ].prefix := self lengthOfStemWith: aPath.relative := RelativePath parents: aPath size - prefix.prefix + 1 to: self size do: [ :i | relative := relative / (self at: i) ].^ relative]Class Path >> extension[	"Return the extension of path basename i.e., /foo/gloops.taz extension is 'taz'"^ self basename copyAfterLast: self extensionDelimiter]Class Path >> resolveString: aString[	"Treat strings as relative paths with a single element."^ self / aString]Class Path >> basenameWithoutExtension[	"Returns the base of the basename but without its extension, 		i.e. 		/foo/gloops.taz basenameWithoutExtension is 'gloops'		/ basenameWithoutExtension is '/'"^ self basename copyUpToLast: self extensionDelimiter]Class Path >> makeRelative: anObject[^ anObject relativeToPath: self]Class Path >> basename: newBasename[	"change the basename"self size == 0	ifTrue: [ ^ Error signal: '0 length Path, cannot change basename' ].	"the root node"self at: self size put: newBasename]Class Path >> asFileReference[^ FileSystem disk referenceTo: self]Class Path >> lengthOfStemWith: aPath[| limit index |limit := self size min: aPath size.index := 1.[ index <= limit and: [ (self at: index) = (aPath at: index) ] ] whileTrue: [ index := index + 1 ].^ index - 1]Class Path >> isWorkingDirectory[^ self size = 0]Metaclass	name: #Path;	instanceVariables: #().Metaclass Path >> from: aString[^ self from: aString delimiter: $/]Metaclass Path >> isAbsoluteWindowsPath: aString[^ aString matchesRegex: '[a-zA-Z]\:\\.*']Metaclass Path >> canonicalizeElements: aCollection[| result |result := OrderedCollection new.aCollection do: [ :element | self addElement: element to: result ].^ result]Metaclass Path >> * aString[	"Answer a relative path with aString as its sole segment. For example,	FSPath * 'griffle' will produce the same result as ./griffle in a unix shell.	The selector #* was chosen for it's visual similarity to $."	"Note: aString is not parsed, so supplying a string like '/griffle/plonk'	will not create an absolute path."^ RelativePath with: aString]Metaclass Path >> with: aString[	"Answer a relative path of the given string. N.B. that the argument is not parsed; 	it is the name of a single path element, and path separators in it do not have 	special meaning."	"(FSPath with: '/parent/child/') isRelative	answers true because this is a relative path to a file or directory named 	'/parent/child/'. In bash: \/parent\/child\/"| inst |inst := self new: 1.inst at: 1 put: aString.^ inst]Metaclass Path >> from: aString delimiter: aDelimiterCharacter[	"Answer a path composed of several elements delimited by aCharacter"| pathCls |aString isEmpty	ifTrue: [ ^ self root ].pathCls := ((self isAbsoluteUnixPath: aString) or: [ self isAbsoluteWindowsPath: aString ])	ifTrue: [ AbsolutePath ]	ifFalse: [ RelativePath ].^ pathCls withAll: (pathCls canonicalizeElements: (aDelimiterCharacter split: aString))]Metaclass Path >> workingDirectory[	"Answer a path that will always resolve to the current working directory."^ RelativePath new]Metaclass Path >> parent[	"Answer a path that resolves to the parent of the current	working directory. This is similar to .. in unix, but doesn't	rely on actual hardlinks being present in the filesystem."^ RelativePath with: '..']Metaclass Path >> addParentElementTo: result[result isEmpty	ifTrue: [ result add: '..' ]	ifFalse: [ result removeLast ]]Metaclass Path >> addElement: element to: result[element = '..'	ifTrue: [ ^ self addParentElementTo: result ].element = ''	ifTrue: [ ^ self addEmptyElementTo: result ].element = '.'	ifFalse: [ result add: element ]]Metaclass Path >> / aString[	"Answer an absolute path with aString as it's sole segment. The selector	was chosen to allow path construction with Smalltalk syntax, which 	neverthelesss resembles paths as they appear in a unix shell. Eg.	FSPath / 'griffle' / 'plonk'."aString isEmptyOrNil	ifTrue: [ Error signal: 'Path element cannot be empty or nil' ].^ AbsolutePath with: aString]Metaclass Path >> extensionDelimiter[	"Return the extension delimiter character."^ $.]Metaclass Path >> root[	"Answer the root path - ie, / on unix"^ AbsolutePath new]Metaclass Path >> isAbsoluteUnixPath: aString[^ aString first = $/]Metaclass Path >> withAll: aCollection[| inst |inst := self new: aCollection size.aCollection withIndexDo: [ :segment :index | inst at: index put: segment ].^ inst]Metaclass Path >> addEmptyElementTo: result[result isEmpty	ifTrue: [ result add: '' ]]Metaclass Path >> parents: anInteger[| path |path := self new: anInteger.1 to: anInteger do: [ :i | path at: i put: '..' ].^ path]