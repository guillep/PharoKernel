Class
	name: #Stream;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #();
	classVariables: #();
	package: #'Collections-Streams'.

Class Stream >> upToEnd
[
	"answer the remaining elements in the string"
| elements |elements := OrderedCollection new.[ self atEnd ] whileFalse: [ elements add: self next ].^ elements
]

Class Stream >> next
[
	"Answer the next object accessible by the receiver."
self subclassResponsibility
]

Class Stream >> do: aBlock
[
	"Evaluate aBlock for each of the objects accessible by receiver."
[ self atEnd ] whileFalse: [ aBlock value: self next ]
]

Class Stream >> close
[
	"Presumably sets the status of the receiver to be closed. This message does 	nothing at this level, but is included for FileStream compatibility."
^ self
]

Class Stream >> contents
[
	"Answer all of the contents of the receiver."
self subclassResponsibility
]

Class Stream >> << items
[
items putOn: self.^ self
]

Class Stream >> binary
[
	"do nothing"
^ self
]

Class Stream >> basicNextPut: anObject
[
^ self nextPut: anObject
]

Class Stream >> flush
[
	"Do nothing by default"

]

Class Stream >> openReadOnly
[
^ self
]

Class Stream >> next: anInteger
[
	"Answer the next anInteger number of objects accessible by the receiver."
| aCollection |aCollection := OrderedCollection new.anInteger timesRepeat: [ aCollection addLast: self next ].^ aCollection
]

Class Stream >> print: anObject
[
	"Have anObject print itself on the receiver."
anObject printOn: self
]

Class Stream >> write: encodedObject
[
^ encodedObject putOn: self
]

Class Stream >> isStream
[
	"Return true if the receiver responds to the stream protocol"
^ true
]

Class Stream >> nextMatchAll: aColl
[
	"Answer true if next N objects are the ones in aColl,     else false.  Advance stream of true, leave as was if false."
| save |save := self position.aColl	do: [ :each | 		self next = each			ifFalse: [ 				self position: save.				^ false ] ].^ true
]

Class Stream >> isBinary
[
^ false
]

Class Stream >> nextMatchFor: anObject
[
	"Gobble the next object and answer whether it is equal to the argument, 	anObject."
^ anObject = self next
]

Class Stream >> nextPutAll: aCollection
[
	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."
aCollection do: [ :v | self nextPut: v ].^ aCollection
]

Class Stream >> next: anInteger put: anObject
[
	"Make anObject be the next anInteger number of objects accessible by the 	receiver. Answer anObject."
anInteger timesRepeat: [ self nextPut: anObject ].^ anObject
]

Class Stream >> basicNextPutAll: aCollection
[
^ self nextPutAll: aCollection
]

Class Stream >> readOnly
[
^ self
]

Class Stream >> nextWordsPutAll: aCollection
[
	"Write the argument a word-like object in big endian format on the receiver.	May be used to write other than plain word-like objects (such as ColorArray)."
aCollection class isPointers | aCollection class isWords not	ifTrue: [ ^ self error: aCollection class name , ' is not word-like' ].1 to: aCollection basicSize do: [ :i | self nextNumber: 4 put: (aCollection basicAt: i) ].^ aCollection
]

Class Stream >> nextPut: anObject
[
	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."
self subclassResponsibility
]

Class Stream >> atEnd
[
	"Answer whether the receiver can access any more objects."
self subclassResponsibility
]

Class Stream >> localName
[
^ 'a stream'
]

Class Stream >> basicNext
[
^ self next
]

Class Stream >> closed
[
^ false
]

Metaclass
	name: #Stream;
	instanceVariables: #().

Metaclass Stream >> new
[
self error: 'Streams are created with on: and with:'
]

