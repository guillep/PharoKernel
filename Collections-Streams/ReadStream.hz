Class
	name: #ReadStream;
	superclass: #ClassPositionableStream;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #();
	classVariables: #();
	package: #'Collections-Streams'.

Class ReadStream >> next: anInteger
[
	"Answer the next anInteger elements of my collection.  overriden for efficiency"
| ans endPosition |endPosition := position + anInteger min: readLimit.ans := collection copyFrom: position + 1 to: endPosition.position := endPosition.^ ans
]

Class ReadStream >> readStream
[
	"polymorphic with SequenceableCollection.  Return self"
^ self
]

Class ReadStream >> nextPut: anObject
[
self shouldNotImplement
]

Class ReadStream >> next
[
	"Primitive. Answer the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."
	<primitive: 65>
position >= readLimit	ifTrue: [ ^ nil ]	ifFalse: [ ^ collection at: (position := position + 1) ]
]

Class ReadStream >> ascii
[

]

Class ReadStream >> upToAnyOf: aCollection do: aBlock
[
	"Overriden for speed"
| end result |end := collection indexOfAnyOf: aCollection startingAt: 1 + position ifAbsent: [ 0 ].(end = 0 or: [ end > readLimit ])	ifTrue: [ ^ self upToEnd ].result := collection copyFrom: 1 + position to: -1 + end.position := end.aBlock value: (collection at: end).^ result
]

Class ReadStream >> upTo: anObject
[
	"fast version using indexOf:"
| start end |start := position + 1.end := collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"(end = 0 or: [ end > readLimit ])	ifTrue: [ ^ self upToEnd ].	"skip to the end and return the data passed over"position := end.^ collection copyFrom: start to: end - 1
]

Class ReadStream >> on: aCollection from: firstIndex to: lastIndex
[
| len |collection := aCollection.readLimit := lastIndex > (len := collection size)	ifTrue: [ len ]	ifFalse: [ lastIndex ].position := firstIndex <= 1	ifTrue: [ 0 ]	ifFalse: [ firstIndex - 1 ]
]

Class ReadStream >> size
[
	"Compatibility with other streams (e.g., FileStream)"
^ readLimit
]

Class ReadStream >> localName
[
^ 'ReadStream'
]

Class ReadStream >> readInto: aCollection startingAt: startIndex count: n
[
	"Read n objects into the given collection. 	Return number of elements that have been read."
| max |max := readLimit - position min: n.aCollection	replaceFrom: startIndex	to: startIndex + max - 1	with: collection	startingAt: position + 1.position := position + max.^ max
]

Class ReadStream >> upToEnd
[
| start |start := 1 + position.position := readLimit.^ collection copyFrom: start to: position
]

Class ReadStream >> next: requestedCount into: aCollection startingAt: startIndex
[
	"Read requestedCount objects into the given collection. 	Return aCollection or a partial copy if less elements have been read."
| readCount |readCount := self readInto: aCollection startingAt: startIndex count: requestedCount.^ readCount = requestedCount	ifTrue: [ ^ aCollection ]	ifFalse: [ ^ aCollection copyFrom: 1 to: startIndex + readCount - 1 ]
]

Metaclass
	name: #ReadStream;
	instanceVariables: #().

Metaclass ReadStream >> on: aCollection from: firstIndex to: lastIndex
[
	"Answer with a new instance streaming over a copy of aCollection from	firstIndex to lastIndex."
^ self basicNew on: aCollection from: firstIndex to: lastIndex
]

