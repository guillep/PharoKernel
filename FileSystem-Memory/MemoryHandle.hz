Class
	name: #MemoryHandle;
	superclass: #ClassFileSystemHandle;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#entry );
	classVariables: #();
	package: #'FileSystem-Memory'.

Class MemoryHandle >> at: index
[
^ entry at: index
]

Class MemoryHandle >> at: index put: anObject
[
^ entry at: index put: anObject
]

Class MemoryHandle >> at: index read: aCollection startingAt: start count: count
[
^ entry	at: index	read: aCollection	startingAt: start	count: count
]

Class MemoryHandle >> at: first write: aCollection startingAt: start count: count
[
writable	ifFalse: [ self primitiveFailed ].entry	at: first	write: aCollection	startingAt: start	count: count
]

Class MemoryHandle >> close
[
self isOpen	ifFalse: [ ^ self ].self truncate.entry := nil
]

Class MemoryHandle >> copyFrom: from to: position
[
^ entry copyFrom: from to: position
]

Class MemoryHandle >> flush
[
self truncate
]

Class MemoryHandle >> grow
[
entry grow
]

Class MemoryHandle >> grownBy: length
[
entry grownBy: length
]

Class MemoryHandle >> isOpen
[
^ entry notNil
]

Class MemoryHandle >> open
[
entry := self basicOpen
]

Class MemoryHandle >> readStream
[
	"Return a readstream on my contents.	Using myself as target collection allows to share the internal bytearray between multiple streams."
^ ReadStream on: self from: 1 to: entry fileSize
]

Class MemoryHandle >> size
[
	"return the size for the interna"
^ entry internalSize
]

Class MemoryHandle >> truncate
[
entry truncate
]

Class MemoryHandle >> truncateTo: anInteger
[
entry truncateTo: anInteger
]

Class MemoryHandle >> writeStream
[
	"Return a writestream on my contents.	Using myself as target collection allows to share the internal bytearray between multiple streams."
^ WriteStream on: self from: 1 to: entry fileSize
]

Metaclass
	name: #MemoryHandle;
	instanceVariables: #().

