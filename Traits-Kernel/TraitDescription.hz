Class	name: #TraitDescription;	superclass: #ClassTraitBehavior;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#organization );	classVariables: #();	package: #'Traits-Kernel'.Class TraitDescription >> notifyUsersOfChangedSelectors: aCollection[self users do: [ :each | each noteChangedSelectors: aCollection ]]Class TraitDescription >> fileOut[	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."| internalStream |internalStream := (String new: 100) writeStream.internalStream	header;	timeStamp.self fileOutOn: internalStream moveSource: false toFile: 0.internalStream trailer.FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true]Class TraitDescription >> allMethodsInCategory: aName[	"Answer a list of all the method categories of the receiver"| aColl |aColl := aName = ClassOrganizer allCategory	ifTrue: [ self organization allMethodSelectors ]	ifFalse: [ self organization listAtCategoryNamed: aName ].^ aColl asSet asArray sort]Class TraitDescription >> noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition[aCollection	do: [ :each | 		| oldCategory newCategory |		oldCategory := self organization categoryOfElement: each.		newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.		self noteRecategorizedSelector: each from: oldCategory to: newCategory ]]Class TraitDescription >> category[self subclassResponsibility]Class TraitDescription >> instanceSide[^ self baseTrait]Class TraitDescription >> putClassCommentToCondensedChangesFile: aFileStream[	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."| header aStamp aCommentRemoteStr |self isMeta	ifTrue: [ ^ self ].	"bulletproofing only"((aCommentRemoteStr := self organization commentRemoteStr) isNil or: [ aCommentRemoteStr sourceFileNumber = 1 ])	ifTrue: [ ^ self ].aFileStream	cr;	nextPut: $!.header := String	streamContents: [ :strm | 		strm			nextPutAll: self name;			nextPutAll: ' commentStamp: '.		(aStamp := self organization commentStamp ifNil: [ '<historical>' ]) storeOn: strm.		strm nextPutAll: ' prior: 0' ].aFileStream nextChunkPut: header.aFileStream cr.self organization	classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream)	stamp: aStamp]Class TraitDescription >> addExclusionOf: aSymbol[^ self - {aSymbol}]Class TraitDescription >> applyChangesOfNewTraitCompositionReplacing: oldComposition[| oldMethodDict changedSelectors |oldMethodDict := self methodDict copy.changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.self noteChangesFrom: oldMethodDict.^ changedSelectors]Class TraitDescription >> fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex[	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."| org |(org := self organization) categories	do: [ :cat | 		| sels |		sels := (org listAtCategoryNamed: cat) select: [ :sel | aSet includes: sel ].		sels			do: [ :sel | 				self					printMethodChunk: sel					withPreamble: true					on: aFileStream					moveSource: moveSource					toFile: fileIndex ] ]]Class TraitDescription >> collectMethodsFor: aSelector into: methodDescription[(self includesSelector: aSelector)	ifTrue: [ methodDescription addLocatedMethod: (self compiledMethodAt: aSelector) ]]Class TraitDescription >> hasClassTrait[self subclassResponsibility]Class TraitDescription >> noteChangesFrom: oldMethodDict[	"create notifications about the changes made to the method dictionary"	"deal with additions"self methodDict	keysAndValuesDo: [ :selector :currentMethod | oldMethodDict at: selector ifAbsent: [ self noteMethodAdded: currentMethod ] ].	" deal with removal / updates"oldMethodDict	keysAndValuesDo: [ :selector :oldMethod | 		self methodDict			at: selector			ifPresent: [ :currentMethod | 				currentMethod = oldMethod					ifFalse: [ self noteMethodChanged: oldMethod to: currentMethod ] ]			ifAbsent: [ self noteMethodRemoved: oldMethod ] ]]Class TraitDescription >> notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory[self users do: [ :each | each noteRecategorizedSelector: element from: oldCategory to: newCategory ]]Class TraitDescription >> obsolete[	"Make the receiver obsolete."self organization: nil.super obsolete]Class TraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource[| methodAndNode |methodAndNode := self	compile: text asString	classified: category	notifying: requestor	trailer: self defaultMethodTrailer	ifFail: [ ^ nil ].logSource	ifTrue: [ 		" replace 'text' with 'methodAndNode node sourceText' "		self			logMethodSource: methodAndNode node sourceText			forMethodWithNode: methodAndNode			inCategory: category			withStamp: changeStamp			notifying: requestor ].self	addAndClassifySelector: methodAndNode selector	withMethod: methodAndNode method	inProtocol: category	notifying: requestor.self instanceSide noteCompilationOf: methodAndNode selector meta: self isClassSide.^ methodAndNode selector]Class TraitDescription >> logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor[aCompiledMethodWithNode method	putSource: aText	fromParseNode: aCompiledMethodWithNode node	class: self	category: category	withStamp: changeStamp	inFile: 2	priorMethod: (self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [  ])]Class TraitDescription >> notifyOfRecategorizedSelector: element from: oldCategory to: newCategory[SystemAnnouncer uniqueInstance	selector: element	recategorizedFrom: oldCategory	to: newCategory	inClass: self.SystemAnnouncer uniqueInstance	suspendAllWhile: [ self notifyUsersOfRecategorizedSelector: element from: oldCategory to: newCategory ]]Class TraitDescription >> theMetaClass[^ self classTrait]Class TraitDescription >> isBaseTrait[self subclassResponsibility]Class TraitDescription >> classSide[^ self classTrait]Class TraitDescription >> theNonMetaClass[^ self baseTrait]Class TraitDescription >> spaceUsed[^ super spaceUsed	+		(self hasClassTrait			ifTrue: [ self classTrait spaceUsed ]			ifFalse: [ 0 ])]Class TraitDescription >> isClassTrait[self subclassResponsibility]Class TraitDescription >> - anArrayOfSelectors[^ TraitExclusion	with: self	exclusions:		(anArrayOfSelectors isSymbol			ifTrue: [ {anArrayOfSelectors} ]			ifFalse: [ anArrayOfSelectors ])]Class TraitDescription >> compile: text classified: category notifying: requestor[| stamp |stamp := self acceptsLoggingOfCompilation	ifTrue: [ Author changeStamp ]	ifFalse: [ nil ].^ self	compile: text	classified: category	withStamp: stamp	notifying: requestor]Class TraitDescription >> classCommentBlank[| existingComment stream |existingComment := self instanceSide organization classComment.existingComment isEmpty	ifFalse: [ ^ existingComment ].stream := (String new: 100) writeStream.stream	nextPutAll: 'A';	nextPutAll:			(self name first isVowel					ifTrue: [ 'n ' ]					ifFalse: [ ' ' ]);	nextPutAll: self name;	nextPutAll: ' is xxxxxxxxx.'.stream cr.^ stream contents]Class TraitDescription >> printCategoryChunk: category on: aFileStream priorMethod: priorMethod[^ self	printCategoryChunk: category	on: aFileStream	withStamp: Author changeStamp	priorMethod: priorMethod]Class TraitDescription >> isTestCase[^ false]Class TraitDescription >> noteMethodRemoved: oldMethod[SystemAnnouncer uniqueInstance methodRemoved: oldMethod]Class TraitDescription >> classTrait[self subclassResponsibility]Class TraitDescription >> linesOfCode[	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."| lines |lines := self localMethods inject: 0 into: [ :sum :each | sum + each linesOfCode ].^ self isMeta	ifTrue: [ lines ]	ifFalse: [ lines + self class linesOfCode ]]Class TraitDescription >> addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor[| priorMethodOrNil oldProtocol newProtocol |priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [  ].	"We categorize first, so the users can use the categorization at the add moment"oldProtocol := self organization categoryOfElement: selector.SystemAnnouncer uniqueInstance suspendAllWhile: [ self organization classify: selector under: category ].self addSelectorSilently: selector withMethod: compiledMethod.newProtocol := self organization categoryOfElement: selector.priorMethodOrNil isNil	ifTrue: [ 		SystemAnnouncer uniqueInstance			methodAdded: compiledMethod			selector: selector			inProtocol: category			class: self			requestor: requestor ]	ifFalse: [ 		SystemAnnouncer uniqueInstance			methodChangedFrom: priorMethodOrNil			to: compiledMethod			selector: selector			inClass: self			oldProtocol: oldProtocol			newProtocol: newProtocol			requestor: requestor ]]Class TraitDescription >> noteMethodAdded: aMethod[SystemAnnouncer uniqueInstance methodAdded: aMethod]Class TraitDescription >> baseTrait[self subclassResponsibility]Class TraitDescription >> organization[	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."organization ifNil: [ self organization: (ClassOrganizer defaultList: self selectors asArray sort) ].	"Making sure that subject is set correctly. It should not be necessary."organization ifNotNil: [ organization setSubject: self ].^ organization]Class TraitDescription >> category: aString[self subclassResponsibility]Class TraitDescription >> variablesAndOffsetsDo: aBlock[^ self]Class TraitDescription >> noteMethodChanged: oldMethod to: newMethod[SystemAnnouncer uniqueInstance methodChangedFrom: oldMethod to: newMethod]Class TraitDescription >> organization: aClassOrg[	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."aClassOrg ifNotNil: [ aClassOrg setSubject: self ].organization := aClassOrg]Class TraitDescription >> traitVersion[	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."^ 0]Class TraitDescription >> copyTraitExpression[	"When recursively copying a trait expression, the primitive traits should NOT be copiedbecause they are globally named 'well-known' objects"^ self]Class TraitDescription >> numberOfMethods[	"cound all methods that are local (not comming from a trait)"| num |num := self localMethods size.self isMeta	ifTrue: [ ^ num ]	ifFalse: [ ^ num + self class numberOfMethods ]]Class TraitDescription >> version[	"Allows polymoprhism with ClassDescription>>version"^ self traitVersion]Class TraitDescription >> compile: text classified: category withStamp: changeStamp notifying: requestor[^ self	compile: text	classified: category	withStamp: changeStamp	notifying: requestor	logSource: self acceptsLoggingOfCompilation]Class TraitDescription >> methodsInCategory: aName[	"Answer a list of the methods of the receiver that are in category named aName"| aColl |aColl := aName = ClassOrganizer allCategory	ifTrue: [ self organization allMethodSelectors ]	ifFalse: [ self organization listAtCategoryNamed: aName ].^ aColl asSet asArray sort]Metaclass	name: #TraitDescription;	instanceVariables: #().