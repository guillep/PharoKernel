Class
	name: #ClassTrait;
	superclass: #ClassTraitDescription;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#baseTrait );
	classVariables: #();
	package: #'Traits-Kernel'.

Class ClassTrait >> uses: aTraitCompositionOrArray
[
| copyOfOldTrait newComposition |copyOfOldTrait := self copy.newComposition := aTraitCompositionOrArray asTraitComposition.self assertConsistantCompositionsForNew: newComposition.self setTraitComposition: newComposition.SystemAnnouncer uniqueInstance traitDefinitionChangedFrom: copyOfOldTrait to: self
]

Class ClassTrait >> classTrait
[
^ self
]

Class ClassTrait >> hasClassTrait
[
^ false
]

Class ClassTrait >> copy
[
	"Make a copy of the receiver. Share the 	reference to the base trait."
^ self class new	baseTrait: self baseTrait;	initializeFrom: self;	yourself
]

Class ClassTrait >> compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
[
| classSideUsersOfBaseTrait message |classSideUsersOfBaseTrait := self baseTrait users select: [ :each | each isClassSide ].classSideUsersOfBaseTrait isEmpty	ifFalse: [ 		message := String			streamContents: [ :stream | 				stream					nextPutAll: 'The instance side of this trait is used on ';					cr.				classSideUsersOfBaseTrait do: [ :each | stream nextPutAll: each name ] separatedBy: [ stream nextPutAll: ', ' ].				stream					cr;					nextPutAll: ' You can not add methods to the class side of this trait!' ].		^ TraitException signal: message ].^ super	compile: text	classified: category	withStamp: changeStamp	notifying: requestor	logSource: logSource
]

Class ClassTrait >> baseTrait
[
^ baseTrait
]

Class ClassTrait >> isClassTrait
[
^ true
]

Class ClassTrait >> baseTrait: aTrait
[
[ aTrait isBaseTrait ] assert.baseTrait := aTrait
]

Class ClassTrait >> initializeFrom: anotherClassTrait
[
traitComposition := self traitComposition copyTraitExpression.methodDict := self methodDict copy.localSelectors := self localSelectors copy.organization := self organization copy
]

Class ClassTrait >> category
[
^ self baseTrait category
]

Class ClassTrait >> name
[
^ self baseTrait name , ' classTrait'
]

Class ClassTrait >> definition
[
^ String	streamContents: [ :stream | 		stream			nextPutAll: self name;			crtab;			nextPutAll: 'uses: ';			nextPutAll: self traitCompositionString ]
]

Class ClassTrait >> classTrait: aClassTrait
[
self error: 'Trait is already a class trait!'
]

Class ClassTrait >> traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
	"Used by copy of Trait"
localSelectors := aSet.methodDict := aMethodDict.traitComposition := aComposition.self organization: aClassOrganization
]

Class ClassTrait >> initializeWithBaseTrait: aTrait
[
self baseTrait: aTrait.self noteNewBaseTraitCompositionApplied: aTrait traitComposition.aTrait users do: [ :each | self addUser: each classSide ]
]

Class ClassTrait >> isSelfEvaluating
[
	"Return true if the receiver printString is evaluating back to self."
^ baseTrait isObsolete not
]

Class ClassTrait >> baseClass: aTrait traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization
[
self baseTrait: aTrait.self	traitComposition: aComposition	methodDict: aMethodDict	localSelectors: aSet	organization: aClassOrganization
]

Class ClassTrait >> isBaseTrait
[
^ false
]

Metaclass
	name: #ClassTrait;
	instanceVariables: #().

Metaclass ClassTrait >> for: aTrait
[
^ self new	initializeWithBaseTrait: aTrait;	yourself
]

