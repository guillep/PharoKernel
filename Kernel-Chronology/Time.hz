Class	name: #Time;	superclass: #ClassMagnitude;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#seconds #nanos );	classVariables: #();	sharedPools: #(#ChronologyConstants );	package: #'Kernel-Chronology'.Class Time >> asMonth[^ self asDateAndTime asMonth]Class Time >> asMilliSeconds[	"Answer the number of milliseconds since midnight"^ self asDuration asMilliSeconds]Class Time >> minute[	"Answer a number that represents the number of complete minutes in the receiver,	after the number of complete hours has been removed."^ (seconds rem: SecondsInHour) quo: SecondsInMinute]Class Time >> asYear[^ self asDateAndTime asYear]Class Time >> intervalString[	"Treat the time as a difference.  Give it in hours and minutes with two digits of accuracy."| d |d := self asDuration.^ String	streamContents: [ :s | 		d hours > 0			ifTrue: [ 				s					print: d hours;					nextPutAll: ' hours' ].		d minutes > 0			ifTrue: [ 				s					space;					print: d minutes;					nextPutAll: ' minutes' ].		d seconds > 0			ifTrue: [ 				s					space;					print: d seconds;					nextPutAll: ' seconds' ] ]]Class Time >> seconds: secondCount[	"Private - only used by Time class."seconds := secondCount.nanos := 0]Class Time >> ticks: anArray[	"ticks is an Array: { days. seconds. nanoSeconds }"seconds := anArray at: 2.nanos := anArray at: 3]Class Time >> asTimeStamp[^ self asDateAndTime asTimeStamp]Class Time >> asSeconds[	"Answer the number of seconds since midnight of the receiver."^ seconds]Class Time >> meridianAbbreviation[^ self hour < 12	ifTrue: [ 'AM' ]	ifFalse: [ 'PM' ]]Class Time >> hour24[	"Answer a number that represents the number of complete hours in the receiver, 	after the number of complete days has been removed."^ (seconds rem: SecondsInDay) quo: SecondsInHour]Class Time >> asNanoSeconds[	"Answer the number of nanoseconds since midnight"^ self asDuration asNanoSeconds]Class Time >> print24: hr24 on: aStream[	"Format is 'hh:mm:ss' or 'h:mm:ss am' "self print24: hr24 showSeconds: true on: aStream]Class Time >> asDuration[	"Answer the duration since midnight"^ Duration seconds: seconds nanoSeconds: nanos]Class Time >> asWeek[^ self asDateAndTime asWeek]Class Time >> minutes[^ self asDuration minutes]Class Time >> ticks[	"Answer an Array: { seconds. nanoSeconds }"^ Array with: 0 with: seconds with: nanos]Class Time >> nanoSecond[^ nanos]Class Time >> < aTime[^ self asDuration < aTime asDuration]Class Time >> addSeconds: nSeconds[	"Answer a Time that is nSeconds after the receiver."^ self class seconds: self asSeconds + nSeconds]Class Time >> storeOn: aStream[aStream	print: self printString;	nextPutAll: ' asTime']Class Time >> hour12[	"Answer an <integer> between 1 and 12, inclusive, representing the hour  	of the day in the 12-hour clock of the local time of the receiver."^ (self hour24 - 1) \\ 12 + 1]Class Time >> = aTime[^ [ self ticks = aTime ticks ]	on: MessageNotUnderstood	do: [ false ]]Class Time >> printOn: aStream[self print24: false showSeconds: (self seconds ~= 0 or: [ self nanoSecond ~= 0 ]) on: aStream]Class Time >> hour[^ self hour24]Class Time >> subtractTime: timeAmount[	"Answer a Time that is timeInterval before the receiver. timeInterval is  	an instance of Date or Time."^ self class seconds: self asSeconds - timeAmount asSeconds]Class Time >> print24[	"Return as 8-digit string 'hh:mm:ss', with leading zeros if needed"^ String new: 8 streamContents: [ :aStream | self print24: true on: aStream ]]Class Time >> to: anEnd[	"Answer a Timespan. anEnd must respond to #asDateAndTime"^ self asDateAndTime to: anEnd]Class Time >> asDate[^ Date today]Class Time >> asDateAndTime[^ DateAndTime today + self]Class Time >> second[	"Answer a number that represents the number of complete seconds in the receiver, 	after the number of complete minutes has been removed."^ seconds rem: SecondsInMinute]Class Time >> print24: hr24 showSeconds: showSeconds on: aStream[	"Format is 'hh:mm:ss' or 'h:mm:ss am'  or, if showSeconds is false, 'hh:mm' or 'h:mm am'"| h m s |h := self hour.m := self minute.s := self second.hr24	ifTrue: [ 		h < 10			ifTrue: [ aStream nextPut: $0 ].		h printOn: aStream ]	ifFalse: [ 		h > 12			ifTrue: [ h - 12 printOn: aStream ]			ifFalse: [ 				h < 1					ifTrue: [ 12 printOn: aStream ]					ifFalse: [ h printOn: aStream ] ] ].aStream	nextPutAll:		(m < 10			ifTrue: [ ':0' ]			ifFalse: [ ':' ]).m printOn: aStream.showSeconds	ifTrue: [ 		aStream			nextPutAll:				(s < 10					ifTrue: [ ':0' ]					ifFalse: [ ':' ]).		s printOn: aStream.		nanos = 0			ifFalse: [ 				| n len |				n := nanos.				len := 9.				[ n \\ 10 = 0 ]					whileTrue: [ 						n := n / 10.						len := len - 1 ].				aStream nextPut: $..				n					printOn: aStream					base: 10					length: len					padded: true ] ].hr24	ifFalse: [ 		aStream			nextPutAll:				(h < 12					ifTrue: [ ' am' ]					ifFalse: [ ' pm' ]) ]]Class Time >> hhmm24[	"Return a string of the form 1123 (for 11:23 am), 2154 (for 9:54 pm), of exactly 4 digits"^ String	new: 4	streamContents: [ :aStream | 		self hour			printOn: aStream			base: 10			length: 2			padded: true.		self minute			printOn: aStream			base: 10			length: 2			padded: true ]]Class Time >> hours[^ self hour]Class Time >> hash[^ self ticks hash]Class Time >> asTime[^ self]Class Time >> seconds[^ self second]Class Time >> printMinutes[	"Return as string 'hh:mm pm'  "^ String new: 8 streamContents: [ :aStream | self print24: false showSeconds: false on: aStream ]]Class Time >> addTime: timeAmount[	"Answer a Time that is timeInterval after the receiver. timeInterval is an  	instance of Date or Time."^ self class seconds: self asSeconds + timeAmount asSeconds]Class Time >> duration[^ Duration zero]Class Time >> seconds: secondCount nanoSeconds: nanoCount[	"Private - only used by Time class."seconds := secondCount.nanos := nanoCount]Metaclass	name: #Time;	instanceVariables: #().Metaclass Time >> current[^ self now]Metaclass Time >> millisecondClockValue[	"Answer the number of milliseconds since the millisecond clock was last reset or rolled over.	Answer 0 if the primitive fails."	<primitive: 135>^ 0]Metaclass Time >> millisecondsSince: lastTime[	"Answer the elapsed time since last recorded in milliseconds. 	Compensate for rollover."^ self milliseconds: self millisecondClockValue since: lastTime]Metaclass Time >> humanWordsForSecondsAgo: secs[| date today |"Return natural language for this date and time in the past."secs <= 1	ifTrue: [ ^ 'a second ago' ].secs < 45	ifTrue: [ ^ secs printString , ' seconds ago' ].secs < 90	ifTrue: [ ^ 'a minute ago' ].secs < 2700	ifTrue: [ ^ (secs // 60) printString , ' minutes ago' ].	"45*60"secs < 5400	ifTrue: [ ^ 'an hour ago' ].	"90*60"secs < 64800	ifTrue: [ ^ (secs // 3600) printString , ' hours ago' ].	"18*60*60"date := Date fromSeconds: self totalSeconds - secs.	"now work with dates"today := Date today.date > (today subtractDays: 2)	ifTrue: [ ^ 'yesterday' ].date > (today subtractDays: 8)	ifTrue: [ ^ 'last ' , date dayOfWeekName ].date > (today subtractDays: 13)	ifTrue: [ ^ 'a week ago' ].date > (today subtractDays: 28)	ifTrue: [ ^ ((today subtractDate: date) // 7) printString , ' weeks ago' ].date > (today subtractDays: 45)	ifTrue: [ ^ 'a month ago' ].date > (today subtractDays: 300)	ifTrue: [ ^ 'last ' , date monthName ].^ date monthName , ', ' , date year printString	"Example#(0.5 30 62 130 4000 10000 60000 90000 345600 864000 1728000 3456000 17280000 34560000 345600000) 		collect: [:ss | Time humanWordsForSecondsAgo: ss]."]Metaclass Time >> seconds: seconds[	"Answer a Time from midnight."^ self basicNew ticks: (Duration seconds: seconds) ticks]Metaclass Time >> hour: hour minute: minute second: second[	"Answer a Time"^ self	hour: hour	minute: minute	second: second	nanoSecond: 0]Metaclass Time >> benchmarkMillisecondClock[	"Time benchmarkMillisecondClock"	"Benchmark the time spent in a call to Time>>millisecondClockValue.	On the VM level this tests the efficiency of calls to ioMSecs()."	"PII/400 Windows 98: 0.725 microseconds per call"| temp1 temp2 temp3 delayTime nLoops time |delayTime := 5000.	"Time to run benchmark is approx. 2*delayTime"	"Don't run the benchmark if we have an active delay since	we will measure the additional penalty in the primitive dispatch	mechanism (see #benchmarkPrimitiveResponseDelay)."Delay anyActive	ifTrue: [ 		^ self			notify:				'Some delay is currently active.Running this benchmark will not give any useful result.' ].	"Flush the cache for this benchmark so we will have	a clear cache hit for each send to #millisecondClockValue below"Object flushCache.temp1 := 0.temp2 := self.	"e.g., temp1 == Time"temp3 := self millisecondClockValue + delayTime.	"Now check how often we can run the following loop in the given time"[ temp2 millisecondClockValue < temp3 ] whileTrue: [ temp1 := temp1 + 1 ].nLoops := temp1.	"Remember the loops we have run during delayTime"	"Setup the second loop"temp1 := 0.temp3 := nLoops.	"Now measure how much time we spend without sending #millisecondClockValue"time := Time millisecondClockValue.[ temp1 < temp3 ] whileTrue: [ temp1 := temp1 + 1 ].time := Time millisecondClockValue - time.	"And compute the number of microseconds spent per call to #millisecondClockValue"^ ((delayTime - time) * 1000.0 / nLoops truncateTo: 0.001) printString	, ' microseconds per call to Time>>millisecondClockValue']Metaclass Time >> millisecondsToRun: timedBlock[	"Answer the number of milliseconds timedBlock takes to return its value."| initialMilliseconds |initialMilliseconds := self millisecondClockValue.timedBlock value.^ self millisecondsSince: initialMilliseconds]Metaclass Time >> primMillisecondClock[	"Primitive. Answer the number of milliseconds since the millisecond clock	 was last reset or rolled over. Answer zero if the primitive fails.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 135>^ 0]Metaclass Time >> fromSeconds: secondCount[	"Answer an instance of me that is secondCount number of seconds since midnight."| integerSeconds nanos |integerSeconds := secondCount truncated.integerSeconds = secondCount	ifTrue: [ nanos := 0 ]	ifFalse: [ nanos := ((secondCount - integerSeconds) * NanosInSecond) asInteger ].^ self seconds: integerSeconds nanoSeconds: nanos]Metaclass Time >> readFrom: aStream[	"Read a Time from the stream in the form:		<hour>:<minute>:<second>.<nseconds> <am/pm>	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"| hour minute second ampm nanos nanosBuffer |hour := Integer readFrom: aStream.minute := 0.second := 0.nanosBuffer := '000000000' copy.nanos := nanosBuffer writeStream.(aStream peekFor: $:)	ifTrue: [ 		minute := Integer readFrom: aStream.		(aStream peekFor: $:)			ifTrue: [ second := Integer readFrom: aStream ].		(aStream peekFor: $.)			ifTrue: [ [ aStream atEnd not and: [ aStream peek isDigit ] ] whileTrue: [ nanos nextPut: aStream next ] ] ].aStream skipSeparators.(aStream atEnd not and: [ aStream peek isLetter ])	ifTrue: [ 		ampm := aStream next asLowercase.		(ampm = $p and: [ hour < 12 ])			ifTrue: [ hour := hour + 12 ].		(ampm = $a and: [ hour = 12 ])			ifTrue: [ hour := 0 ].		(aStream peekFor: $m)			ifFalse: [ aStream peekFor: $M ] ].^ self	hour: hour	minute: minute	second: second	nanoSecond: nanosBuffer asInteger]Metaclass Time >> midnight[^ self seconds: 0]Metaclass Time >> dateAndTimeNow[	"Answer a two-element Array of (Date today, Time now)."^ self dateAndTimeFromSeconds: self totalSeconds]Metaclass Time >> seconds: seconds nanoSeconds: nanoCount[	"Answer a Time from midnight."^ self basicNew ticks: (Duration seconds: seconds nanoSeconds: nanoCount) ticks]Metaclass Time >> noon[^ self seconds: SecondsInDay / 2]Metaclass Time >> condenseBunches: aCollectionOfSeconds[| secArray now out pause prev bunchEnd |"Identify the major intervals in a bunch of numbers.  	Each number is a seconds since 1901 that represents a date and time.	We want the last event in a bunch.  Return array of seconds for:		Every event in the last half hour.		Every bunch separated by 30 min in the last 24 hours.		Every bunch separated by two hours before that.""Time condenseBunches: 		(#(20 400 401  20000 20200 20300 40000 45000  200000 201000 202000) 			collect: [ :tt | self totalSeconds - tt])"secArray := aCollectionOfSeconds asSortedCollection.pause := 1.now := self totalSeconds.out := OrderedCollection new.prev := 0.bunchEnd := nil.secArray	reverseDo: [ :secs | 		| ago |		"descending"		ago := now - secs.		ago > (60 * 30)			ifTrue: [ pause := 1800	"60*30" ].		ago > (60 * 60 * 24)			ifTrue: [ pause := 7200	"60*120" ].		ago - prev >= pause			ifTrue: [ 				out add: bunchEnd.				bunchEnd := secs ].		prev := ago ].out add: bunchEnd.out removeFirst.^ out]Metaclass Time >> primSecondsClock[	"Answer the number of seconds since 00:00 on the morning of	 January 1, 1901 (a 32-bit unsigned number).	 Essential. See Object documentation whatIsAPrimitive. "	<primitive: 137>self primitiveFailed]Metaclass Time >> secondsWhenClockTicks[	"waits for the moment when a new second begins"| lastSecond delay |delay := Delay forMilliseconds: 1.lastSecond := self primSecondsClock.[ lastSecond = self primSecondsClock ] whileTrue: [ delay wait ].^ lastSecond + 1]Metaclass Time >> new[	"Answer a Time representing midnight"^ self midnight]Metaclass Time >> milliseconds: currentTime since: lastTime[	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."| delta |delta := currentTime - lastTime.^ delta < 0	ifTrue: [ SmallInteger maxVal + delta ]	ifFalse: [ delta ]]Metaclass Time >> now[	"Answer a Time representing the time right now - this is a 24 hour clock."| ms |ms := DateAndTime milliSecondsSinceMidnight.^ self seconds: ms // 1000 nanoSeconds: ms \\ 1000 * 1000000]Metaclass Time >> hour: hour minute: minute second: second nanoSecond: nanoCount[	"Answer a Time - only second precision for now"^ self seconds: hour * SecondsInHour + (minute * SecondsInMinute) + second nanoSeconds: nanoCount]Metaclass Time >> fromString: aString[^ self readFrom: aString readStream]Metaclass Time >> namesForTimes: arrayOfSeconds[| simpleEnglish final prev |"Return English descriptions of the times in the array.  They are each seconds since 1901.  If two names are the same, append the date and time to distinguish them."simpleEnglish := arrayOfSeconds collect: [ :secsAgo | self humanWordsForSecondsAgo: self totalSeconds - secsAgo ].prev := ''.final := simpleEnglish copy.simpleEnglish	withIndexDo: [ :eng :ind | 		| myPair prevPair |		eng = prev			ifFalse: [ eng ]			ifTrue: [ 				"both say 'a month ago'"				prevPair := self dateAndTimeFromSeconds: (arrayOfSeconds at: ind - 1).				myPair := self dateAndTimeFromSeconds: (arrayOfSeconds at: ind).				(final at: ind - 1) = prev					ifTrue: [ 						"only has 'a month ago'"						final at: ind - 1 put: (final at: ind - 1) , ', ' , prevPair first mmddyyyy ].				final at: ind put: (final at: ind) , ', ' , myPair first mmddyyyy.				prevPair first = myPair first					ifTrue: [ 						(final at: ind - 1) last == $m							ifFalse: [ 								"date but no time"								final at: ind - 1 put: (final at: ind - 1) , ', ' , prevPair second printMinutes ].						final at: ind put: (final at: ind) , ', ' , myPair second printMinutes ] ].		prev := eng ].^ final]Metaclass Time >> dateAndTimeFromSeconds: secondCount[^ Array with: (Date fromSeconds: secondCount) with: (Time fromSeconds: secondCount \\ 86400)]Metaclass Time >> benchmarkPrimitiveResponseDelay[	"Time benchmarkPrimitiveResponseDelay"	"Benchmark the overhead for primitive dispatches with an active Delay.	On the VM level, this tests the efficiency of ioLowResMSecs."	"PII/400 Windows98: 0.128 microseconds per prim"	"ar 9/6/1999: This value is *extremely* important for stuff like sockets etc.	I had a bad surprise when Michael pointed this particular problem out:	Using the hardcoded clock() call for ioLowResMSecs on Win32 resulted in an overhead	of 157.4 microseconds per primitive call - meaning you can't get no more than	approx. 6000 primitives per second on my 400Mhz PII system with an active delay!	BTW, it finally explains why Squeak seemed soooo slow when running PWS or 	other socket stuff. The new version (not using clock() but some Windows function) 	looks a lot better (see above; approx. 8,000,000 prims per sec with an active delay)."| nLoops bb index baseTime actualTime delayTime |delayTime := 5000.	"Time to run this test is approx. 3*delayTime"Delay anyActive	ifTrue: [ 		^ self			notify:				'Some delay is currently active.Running this benchmark will not give any useful result.' ].bb := Array new: 1.	"The object we send the prim message to"	"Compute the # of loops we'll run in a decent amount of time"[ (Delay forMilliseconds: delayTime) wait ] forkAt: Processor userInterruptPriority.nLoops := 0.[ Delay anyActive ]	whileTrue: [ 		bb			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize.		nLoops := nLoops + 1 ].	"Flush the cache and make sure #basicSize is in there"Object flushCache.bb basicSize.	"Now run the loop without any active delay	for getting an idea about its actual speed."baseTime := self millisecondClockValue.index := nLoops.[ index > 0 ]	whileTrue: [ 		bb			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize.		index := index - 1 ].baseTime := self millisecondClockValue - baseTime.	"Setup the active delay but try to never make it active"[ (Delay forMilliseconds: delayTime + delayTime) wait ] forkAt: Processor userInterruptPriority.	"And run the loop"actualTime := self millisecondClockValue.index := nLoops.[ index > 0 ]	whileTrue: [ 		bb			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize;			basicSize.		index := index - 1 ].actualTime := self millisecondClockValue - actualTime.	"And get us some result"^ ((actualTime - baseTime) * 1000 asFloat / (nLoops * 10) truncateTo: 0.001) printString	, ' microseconds overhead per primitive call']Metaclass Time >> totalSeconds[	"Answer the total seconds since the Squeak epoch: 1 January 1901."^ self primSecondsClock]