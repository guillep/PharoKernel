Class	name: #Duration;	superclass: #ClassMagnitude;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#nanos #seconds );	classVariables: #();	sharedPools: #(#ChronologyConstants );	package: #'Kernel-Chronology'.Class Duration >> asNanoSeconds[^ seconds * NanosInSecond + nanos]Class Duration >> truncateTo: aDuration[	"e.g. if the receiver is 5 minutes, 37 seconds, and aDuration is 2 minutes, answer 4 minutes."^ self class nanoSeconds: (self asNanoSeconds truncateTo: aDuration asNanoSeconds)]Class Duration >> asMinutes[	"Answer the number of minutes in the receiver."^ seconds / 60.0]Class Duration >> ticks[	"Answer an array {days. seconds. nanoSeconds}. Used by DateAndTime and Time."| days |days := self days.^ Array with: days with: seconds - (days * SecondsInDay) with: nanos]Class Duration >> asDelay[^ Delay forDuration: self]Class Duration >> hours[	"Answer a number that represents the number of complete hours in the receiver, after the number of complete days has been removed."^ (seconds rem: SecondsInDay) quo: SecondsInHour]Class Duration >> negative[^ self positive not]Class Duration >> storeOn: aStream[aStream	nextPut: $(;	nextPutAll: self className;	nextPutAll: ' seconds: ';	print: seconds;	nextPutAll: ' nanoSeconds: ';	print: nanos;	nextPut: $)]Class Duration >> roundTo: aDuration[	"e.g. if the receiver is 5 minutes, 37 seconds, and aDuration is 2 minutes, answer 6 minutes."^ self class nanoSeconds: (self asNanoSeconds roundTo: aDuration asNanoSeconds)]Class Duration >> seconds: secondCount nanoSeconds: nanoCount[	"Private - only used by Duration class"seconds := secondCount.nanos := nanoCount rounded.	"normalize if signs do not match"[ nanos < 0 and: [ seconds > 0 ] ]	whileTrue: [ 		seconds := seconds - 1.		nanos := nanos + NanosInSecond ].[ seconds < 0 and: [ nanos > 0 ] ]	whileTrue: [ 		seconds := seconds + 1.		nanos := nanos - NanosInSecond ]]Class Duration >> * operand[	"operand is a Number"^ self class nanoSeconds: (self asNanoSeconds * operand) asInteger]Class Duration >> abs[^ self class seconds: seconds abs nanoSeconds: nanos abs]Class Duration >> asDays[	"Answer the number of days in the receiver."^ self asHours / 24]Class Duration >> = comparand[	"Answer whether the argument is a <Duration> representing the same  	period of time as the receiver."^ self == comparand	ifTrue: [ true ]	ifFalse: [ 		self species = comparand species			ifTrue: [ self asNanoSeconds = comparand asNanoSeconds ]			ifFalse: [ false ] ]]Class Duration >> negated[^ self class seconds: seconds negated nanoSeconds: nanos negated]Class Duration >> / operand[	"operand is a Duration or a Number"^ operand isNumber	ifTrue: [ self class nanoSeconds: (self asNanoSeconds / operand) asInteger ]	ifFalse: [ self asNanoSeconds / operand asDuration asNanoSeconds ]]Class Duration >> hash[^ seconds bitXor: nanos]Class Duration >> asMilliSeconds[^ (seconds * NanosInSecond + nanos) // (10 raisedToInteger: 6)]Class Duration >> initialize[super initialize.self seconds: 0 nanoSeconds: 0]Class Duration >> nanoSeconds[^ nanos]Class Duration >> - operand[	"operand is a Duration"^ self + operand negated]Class Duration >> asHours[	"Answer the number of hours in the receiver."^ self asMinutes / 60.0]Class Duration >> positive[^ seconds = 0	ifTrue: [ nanos positive ]	ifFalse: [ seconds positive ]]Class Duration >> minutes[	"Answer a number that represents the number of complete minutes in the receiver, after the number of complete hours has been removed."^ (seconds rem: SecondsInHour) quo: SecondsInMinute]Class Duration >> asSeconds[	"Answer the number of seconds in the receiver."^ seconds]Class Duration >> + operand[	"operand is a Duration"^ self class nanoSeconds: self asNanoSeconds + operand asNanoSeconds]Class Duration >> days[	"Answer a number that represents the number of complete days in the receiver"^ seconds quo: SecondsInDay]Class Duration >> isZero[^ seconds = 0 and: [ nanos = 0 ]]Class Duration >> printOn: aStream[	"Format as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]"| d h m s n |d := self days abs.h := self hours abs.m := self minutes abs.s := self seconds abs truncated.n := self nanoSeconds abs.self negative	ifTrue: [ aStream nextPut: $- ].d printOn: aStream.aStream nextPut: $:.h < 10	ifTrue: [ aStream nextPut: $0 ].h printOn: aStream.aStream nextPut: $:.m < 10	ifTrue: [ aStream nextPut: $0 ].m printOn: aStream.aStream nextPut: $:.s < 10	ifTrue: [ aStream nextPut: $0 ].s printOn: aStream.n = 0	ifFalse: [ 		| z ps |		aStream nextPut: $..		ps := n printString padLeftTo: 9 with: $0.		z := ps findLast: [ :c | c asciiValue > $0 asciiValue ].		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ]]Class Duration >> asDuration[^ self]Class Duration >> \\ operand[	"modulo. Remainder defined in terms of //. Answer a Duration with the  	same sign as aDuration. operand is a Duration or a Number."^ operand isNumber	ifTrue: [ self class nanoSeconds: self asNanoSeconds \\ operand ]	ifFalse: [ self - (operand * (self // operand)) ]]Class Duration >> // operand[	"operand is a Duration or a Number"^ operand isNumber	ifTrue: [ self class nanoSeconds: (self asNanoSeconds // operand) asInteger ]	ifFalse: [ self asNanoSeconds // operand asDuration asNanoSeconds ]]Class Duration >> < comparand[^ self asNanoSeconds < comparand asNanoSeconds]Class Duration >> seconds[	"Answer a number that represents the number of complete seconds in the receiver, after the number of complete minutes has been removed."^ seconds rem: SecondsInMinute]Metaclass	name: #Duration;	instanceVariables: #().Metaclass Duration >> days: days seconds: seconds[^ self basicNew seconds: days * SecondsInDay + seconds nanoSeconds: 0]Metaclass Duration >> days: days hours: hours minutes: minutes seconds: seconds[^ self	days: days	hours: hours	minutes: minutes	seconds: seconds	nanoSeconds: 0]Metaclass Duration >> nanoSeconds: nanos[	"This method is slow. If you have nanos less than 10^6 you should use #seconds:nanoSeconds: instead."| quo |quo := nanos quo: NanosInSecond.^ self basicNew seconds: quo nanoSeconds: nanos - (quo * NanosInSecond)]Metaclass Duration >> zero[^ self basicNew seconds: 0 nanoSeconds: 0]Metaclass Duration >> month: aMonth[	"aMonth is an Integer or a String"^ (Month month: aMonth year: Year current year) duration]Metaclass Duration >> weeks: aNumber[^ self days: aNumber * 7 seconds: 0]Metaclass Duration >> minutes: aNumber[^ self seconds: aNumber * SecondsInMinute nanoSeconds: 0]Metaclass Duration >> milliSeconds: milliCount[^ self seconds: (milliCount quo: 1000) nanoSeconds: (milliCount rem: 1000) * NanosInMillisecond]Metaclass Duration >> seconds: seconds[^ self seconds: seconds nanoSeconds: 0]Metaclass Duration >> readFrom: aStream[	"Formatted as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]"| sign days hours minutes seconds nanos nanosBuffer |sign := (aStream peekFor: $-)	ifTrue: [ -1 ]	ifFalse: [ 1 ].days := (aStream upTo: $:) asInteger sign: sign.hours := (aStream upTo: $:) asInteger sign: sign.minutes := (aStream upTo: $:) asInteger sign: sign.seconds := (aStream upTo: $.) asInteger sign: sign.nanosBuffer := '000000000' copy.nanos := nanosBuffer writeStream.[ aStream atEnd not and: [ aStream peek isDigit ] ] whileTrue: [ nanos nextPut: aStream next ].^ self	days: days	hours: hours	minutes: minutes	seconds: seconds	nanoSeconds: (nanosBuffer asInteger sign: sign)]Metaclass Duration >> fromString: aString[^ self readFrom: aString readStream]Metaclass Duration >> days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: nanos[^ self seconds: days * SecondsInDay + (hours * SecondsInHour) + (minutes * SecondsInMinute) + seconds nanoSeconds: nanos]Metaclass Duration >> seconds: seconds nanoSeconds: nanos[^ self basicNew seconds: seconds truncated nanoSeconds: seconds fractionPart * NanosInSecond + nanos]Metaclass Duration >> days: aNumber[^ self seconds: aNumber * SecondsInDay nanoSeconds: 0]Metaclass Duration >> hours: aNumber[^ self seconds: aNumber * SecondsInHour nanoSeconds: 0]