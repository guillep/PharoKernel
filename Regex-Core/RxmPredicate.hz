Class	name: #RxmPredicate;	superclass: #ClassRxmLink;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#predicate );	classVariables: #();	package: #'Regex-Core'.Class RxmPredicate >> matchAgainst: aMatcher[	"Match if the predicate block evaluates to true when given the	current stream character as the argument."| original |original := aMatcher currentState.(aMatcher atEnd not and: [ (predicate value: aMatcher next) and: [ next matchAgainst: aMatcher ] ])	ifTrue: [ ^ true ]	ifFalse: [ 		aMatcher restoreState: original.		^ false ]]Class RxmPredicate >> predicate: aBlock[	"This link will match any single character for which <aBlock>	evaluates to true."aBlock numArgs ~= 1	ifTrue: [ self error: 'bad predicate block' ].predicate := aBlock.^ self]Class RxmPredicate >> bePerform: aSelector[	"Match any single character that answers true  to this message."self predicate: [ :char | RxParser doHandlingMessageNotUnderstood: [ char perform: aSelector ] ]]Class RxmPredicate >> bePerformNot: aSelector[	"Match any single character that answers false to this message."self predicate: [ :char | RxParser doHandlingMessageNotUnderstood: [ (char perform: aSelector) not ] ]]Metaclass	name: #RxmPredicate;	instanceVariables: #().Metaclass RxmPredicate >> with: unaryBlock[^ self new predicate: unaryBlock]