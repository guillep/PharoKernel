Class	name: #RxsCharSet;	superclass: #ClassRxsNode;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#negated #elements );	classVariables: #();	package: #'Regex-Core'.Class RxsCharSet >> enumerablePartPredicateIgnoringCase: aBoolean[| enumeration |enumeration := self optimalSetIgnoringCase: aBoolean.^ negated	ifTrue: [ [ :char | (enumeration includes: char) not ] ]	ifFalse: [ [ :char | enumeration includes: char ] ]]Class RxsCharSet >> enumerableSetIgnoringCase: aBoolean[	"Answer a collection of characters that make up the portion of me	that can be enumerated."| set |set := Set new.elements	do: [ :each | 		each isEnumerable			ifTrue: [ each enumerateTo: set ignoringCase: aBoolean ] ].^ set]Class RxsCharSet >> predicateIgnoringCase: aBoolean[| predicate enumerable |enumerable := self enumerablePartPredicateIgnoringCase: aBoolean.^ self hasPredicates	ifFalse: [ enumerable ]	ifTrue: [ 		predicate := self predicatePartPredicate.		negated			ifTrue: [ [ :char | (enumerable value: char) and: [ predicate value: char ] ] ]			ifFalse: [ [ :char | (enumerable value: char) or: [ predicate value: char ] ] ] ]]Class RxsCharSet >> predicatePartPredicate[	"Answer a predicate that tests all of my elements that cannot be	enumerated."| predicates |predicates := elements reject: [ :some | some isEnumerable ].predicates isEmpty	ifTrue: [ ^ [ :char | negated ] ].predicates size = 1	ifTrue: [ 		^ negated			ifTrue: [ predicates first predicateNegation ]			ifFalse: [ predicates first predicate ] ].predicates := predicates collect: [ :each | each predicate ].^ negated	ifFalse: [ [ :char | predicates contains: [ :some | some value: char ] ] ]	ifTrue: [ [ :char | (predicates contains: [ :some | some value: char ]) not ] ]]Class RxsCharSet >> initializeElements: aCollection negated: aBoolean[	"See class comment for instance variables description."elements := aCollection.negated := aBoolean]Class RxsCharSet >> optimalSetIgnoringCase: aBoolean[	"Assuming the client with search the `set' using #includes:,	answer a collection with the contents of `set', of the class	that will provide the fastest lookup. Strings are faster than	Sets for short strings."| set |set := self enumerableSetIgnoringCase: aBoolean.^ set size < 10	ifTrue: [ set asArray ]	ifFalse: [ set ]]Class RxsCharSet >> hasPredicates[^ elements contains: [ :some | some isEnumerable not ]]Class RxsCharSet >> isEnumerable[elements detect: [ :some | some isEnumerable not ] ifNone: [ ^ true ].^ false]Class RxsCharSet >> predicates[^ (elements reject: [ :some | some isEnumerable ]) collect: [ :each | each predicate ]]Class RxsCharSet >> isNegated[^ negated]Class RxsCharSet >> dispatchTo: aMatcher[	"Inform the matcher of the kind of the node, and it	will do whatever it has to."^ aMatcher syntaxCharSet: self]Metaclass	name: #RxsCharSet;	instanceVariables: #().