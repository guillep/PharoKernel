Class	name: #RxMatcher;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#matcher #ignoreCase #startOptimizer #stream #markerPositions #markerCount #lastResult );	classVariables: #(#Cr #Lf );	package: #'Regex-Core'.Class RxMatcher >> syntaxBeginningOfLine[	"Double dispatch from the syntax tree. 	Create a matcher for beginning-of-line condition."^ RxmSpecial new beBeginningOfLine]Class RxMatcher >> next[^ stream next]Class RxMatcher >> matches: aString[	"Match against a string."^ self matchesStream: aString readStream]Class RxMatcher >> position[^ stream position]Class RxMatcher >> syntaxCharacter: charNode[	"Double dispatch from the syntax tree. 	We get here when no merging characters into strings was possible."| wanted |wanted := charNode character.^ RxmPredicate new	predicate:		(ignoreCase			ifTrue: [ [ :char | char sameAs: wanted ] ]			ifFalse: [ [ :char | char = wanted ] ])]Class RxMatcher >> isWordChar: aCharacterOrNil[	"Answer whether the argument is a word constituent character:	alphanumeric or _."^ aCharacterOrNil ~~ nil and: [ aCharacterOrNil isAlphaNumeric ]]Class RxMatcher >> matchesIn: aString do: aBlock[	"Search aString repeatedly for the matches of the receiver.	Evaluate aBlock for each match passing the matched substring	as the argument."self matchesOnStream: aString readStream do: aBlock]Class RxMatcher >> atEndOfLine[^ self atEnd or: [ stream peek = Cr ]]Class RxMatcher >> syntaxMessagePredicate: messagePredicateNode[	"Double dispatch from the syntax tree. 	Special link can handle predicates."^ messagePredicateNode negated	ifTrue: [ RxmPredicate new bePerformNot: messagePredicateNode selector ]	ifFalse: [ RxmPredicate new bePerform: messagePredicateNode selector ]]Class RxMatcher >> copyStream: aStream to: writeStream translatingMatchesUsing: aBlock[	"Copy the contents of <aStream> on the <writeStream>, except for the matches. For each match, evaluate <aBlock> passing the matched substring as the argument.  Expect the block to answer a String, and write the answer to <writeStream> in place of the match."| searchStart matchStart matchEnd match |stream := aStream.markerPositions := nil.[ searchStart := aStream position.self proceedSearchingStream: aStream ]	whileTrue: [ 		matchStart := (self subBeginning: 1) first.		matchEnd := (self subEnd: 1) first.		aStream position: searchStart.		searchStart to: matchStart - 1 do: [ :ignoredPos | writeStream nextPut: aStream next ].		match := (String new: matchEnd - matchStart + 1) writeStream.		matchStart to: matchEnd - 1 do: [ :ignoredPos | match nextPut: aStream next ].		writeStream nextPutAll: (aBlock value: match contents).	"Be extra careful about successful matches which consume no input.		After those, make sure to advance or finish if already at end."		matchEnd = searchStart			ifTrue: [ 				aStream atEnd					ifTrue: [ ^ self	"rest after end of whileTrue: block is a no-op if atEnd" ]					ifFalse: [ writeStream nextPut: aStream next ] ] ].aStream position: searchStart.[ aStream atEnd ] whileFalse: [ writeStream nextPut: aStream next ]]Class RxMatcher >> lastChar[^ stream position = 0	ifFalse: [ 		stream			skip: -1;			next ]]Class RxMatcher >> notAtWordBoundary[^ self atWordBoundary not]Class RxMatcher >> syntaxNonWordBoundary[	"Double dispatch from the syntax tree. 	Create a matcher for the word boundary condition."^ RxmSpecial new beNotWordBoundary]Class RxMatcher >> markerPositionAt: anIndex add: position[	"Remember position of another instance of the given marker."(markerPositions at: anIndex) addFirst: position]Class RxMatcher >> restoreState: aBlock[aBlock value]Class RxMatcher >> currentState[	"Answer an opaque object that can later be used to restore the	matcher's state (for backtracking)."| origPosition origLastChar |origPosition := stream position.^ [ stream position: origPosition ]]Class RxMatcher >> search: aString[	"Search the string for occurrence of something matching myself.	Answer a Boolean indicating success."^ self searchStream: aString readStream]Class RxMatcher >> searchStream: aStream[	"Search the stream for occurrence of something matching myself.	After the search has occurred, stop positioned after the end of the	matched substring. Answer a Boolean indicating success."| position |stream := aStream.position := aStream position.markerPositions := nil.[ aStream atEnd ]	whileFalse: [ 		self tryMatch			ifTrue: [ ^ true ].		aStream			position: position;			next.		position := aStream position ].	"Try match at the very stream end too!"self tryMatch	ifTrue: [ ^ true ].^ false]Class RxMatcher >> matchesStreamPrefix: theStream[	"Match thyself against a positionable stream."stream := theStream.markerPositions := nil.^ self tryMatch]Class RxMatcher >> syntaxEndOfWord[	"Double dispatch from the syntax tree. 	Create a matcher for end-of-word condition."^ RxmSpecial new beEndOfWord]Class RxMatcher >> syntaxRegex: regexNode[	"Double dispatch from the syntax tree. 	Regex node is a chain of branches to be tried. Should compile this 	into a bundle of parallel branches, between two marker nodes."| startIndex endIndex endNode alternatives |startIndex := self allocateMarker.endIndex := self allocateMarker.endNode := RxmMarker new index: endIndex.alternatives := self hookBranchOf: regexNode onto: endNode.^ (RxmMarker new index: startIndex)	pointTailTo: alternatives;	yourself]Class RxMatcher >> makePlus: aMatcher[	"Private - Wrap this matcher so that the result would match 1 and more	occurrences of the matcher."| loopback |loopback := RxmBranch new beLoopback next: aMatcher.aMatcher pointTailTo: loopback.^ aMatcher]Class RxMatcher >> atEnd[^ stream atEnd]Class RxMatcher >> buildFrom: aSyntaxTreeRoot[	"Private - Entry point of matcher build process."markerCount := 0.	"must go before #dispatchTo: !"matcher := aSyntaxTreeRoot dispatchTo: self.matcher terminateWith: RxmTerminator new]Class RxMatcher >> proceedSearchingStream: aStream[| position |position := aStream position.[ aStream atEnd ]	whileFalse: [ 		self tryMatch			ifTrue: [ ^ true ].		aStream			position: position;			next.		position := aStream position ].	"Try match at the very stream end too!"self tryMatch	ifTrue: [ ^ true ].^ false]Class RxMatcher >> matchesOnStream: aStream do: aBlock[	"Be extra careful about successful matches which consume no input.	After those, make sure to advance or finish if already at end."| position |[ position := aStream position.self searchStream: aStream ]	whileTrue: [ 		aBlock value: (self subexpression: 1).		position = aStream position			ifTrue: [ 				aStream atEnd					ifTrue: [ ^ self ]					ifFalse: [ aStream next ] ] ]]Class RxMatcher >> syntaxEndOfLine[	"Double dispatch from the syntax tree. 	Create a matcher for end-of-line condition."^ RxmSpecial new beEndOfLine]Class RxMatcher >> copyStream: aStream to: writeStream replacingMatchesWith: aString[	"Copy the contents of <aStream> on the <writeStream>, except for the matches. Replace each match with <aString>."| searchStart matchStart matchEnd |stream := aStream.markerPositions := nil.[ searchStart := aStream position.self proceedSearchingStream: aStream ]	whileTrue: [ 		matchStart := (self subBeginning: 1) first.		matchEnd := (self subEnd: 1) first.		aStream position: searchStart.		searchStart to: matchStart - 1 do: [ :ignoredPos | writeStream nextPut: aStream next ].		writeStream nextPutAll: aString.		aStream position: matchEnd.	"Be extra careful about successful matches which consume no input.		After those, make sure to advance or finish if already at end."		matchEnd = searchStart			ifTrue: [ 				aStream atEnd					ifTrue: [ ^ self	"rest after end of whileTrue: block is a no-op if atEnd" ]					ifFalse: [ writeStream nextPut: aStream next ] ] ].aStream position: searchStart.[ aStream atEnd ] whileFalse: [ writeStream nextPut: aStream next ]]Class RxMatcher >> atBeginningOfWord[^ (self isWordChar: self lastChar) not and: [ self isWordChar: stream peek ]]Class RxMatcher >> matchesIn: aString collect: aBlock[	"Search aString repeatedly for the matches of the receiver.  Evaluate aBlock for each match passing the matched substring as the argument, collect evaluation results in an OrderedCollection, and return in. The following example shows how to use this message to split a string into words."	"'\w+' asRegex matchesIn: 'Now is the Time' collect: [:each | each asLowercase]"| result |result := OrderedCollection new.self matchesOnStream: aString readStream do: [ :match | result add: (aBlock value: match) ].^ result]Class RxMatcher >> allocateMarker[	"Answer an integer to use as an index of the next marker."markerCount := markerCount + 1.^ markerCount]Class RxMatcher >> makeStar: aMatcher[	"Private - Wrap this matcher so that the result would match 0 and more	occurrences of the matcher."| dummy detour loopback |dummy := RxmLink new.detour := RxmBranch new	next: aMatcher;	alternative: dummy.loopback := RxmBranch new beLoopback	next: aMatcher;	alternative: dummy.aMatcher pointTailTo: loopback.^ detour]Class RxMatcher >> subexpressionCount[^ markerCount // 2]Class RxMatcher >> syntaxPredicate: predicateNode[	"Double dispatch from the syntax tree. 	A character set is a few characters, and we either match any of them,	or match any that is not one of them."^ RxmPredicate with: predicateNode predicate]Class RxMatcher >> syntaxPiece: pieceNode[	"Double dispatch from the syntax tree. 	Piece is an atom repeated a few times. Take care of a special	case when the atom is repeated just once."| atom |atom := pieceNode atom dispatchTo: self.^ pieceNode isSingular	ifTrue: [ atom ]	ifFalse: [ 		pieceNode isStar			ifTrue: [ self makeStar: atom ]			ifFalse: [ 				pieceNode isPlus					ifTrue: [ self makePlus: atom ]					ifFalse: [ 						pieceNode isOptional							ifTrue: [ self makeOptional: atom ]							ifFalse: [ RxParser signalCompilationException: 'repetitions are not supported by RxMatcher' ] ] ] ]]Class RxMatcher >> syntaxEpsilon[	"Double dispatch from the syntax tree. Match empty string. This is unlikely	to happen in sane expressions, so we'll live without special epsilon-nodes."^ RxmSubstring new substring: String new ignoreCase: ignoreCase]Class RxMatcher >> syntaxAny[	"Double dispatch from the syntax tree. 	Create a matcher for any non-null character."^ RxmPredicate new predicate: [ :char | char asInteger ~= 0 ]]Class RxMatcher >> matchesOnStream: aStream collect: aBlock[| result |result := OrderedCollection new.self matchesOnStream: aStream do: [ :match | result add: (aBlock value: match) ].^ result]Class RxMatcher >> atWordBoundary[^ (self isWordChar: self lastChar) xor: (self isWordChar: stream peek)]Class RxMatcher >> makeOptional: aMatcher[	"Private - Wrap this matcher so that the result would match 0 or 1	occurrences of the matcher."| dummy branch |dummy := RxmLink new.branch := RxmBranch new beLoopback	next: aMatcher;	alternative: dummy.aMatcher pointTailTo: dummy.^ branch]Class RxMatcher >> matchingRangesIn: aString[	"Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."| result |result := OrderedCollection new.self matchesIn: aString do: [ :match | result add: (self position - match size + 1 to: self position) ].^ result]Class RxMatcher >> matchesStream: theStream[	"Match thyself against a positionable stream."^ (self matchesStreamPrefix: theStream) and: [ stream atEnd ]]Class RxMatcher >> hookBranchOf: regexNode onto: endMarker[	"Private - Recurse down the chain of regexes starting at	regexNode, compiling their branches and hooking their tails 	to the endMarker node."| rest |rest := regexNode regex isNil	ifTrue: [ nil ]	ifFalse: [ self hookBranchOf: regexNode regex onto: endMarker ].^ RxmBranch new	next:			((regexNode branch dispatchTo: self)					pointTailTo: endMarker;					yourself);	alternative: rest;	yourself]Class RxMatcher >> lastResult[^ lastResult]Class RxMatcher >> syntaxCharSet: charSetNode[	"Double dispatch from the syntax tree. 	A character set is a few characters, and we either match any of them,	or match any that is not one of them."^ RxmPredicate with: (charSetNode predicateIgnoringCase: ignoreCase)]Class RxMatcher >> copy: aString replacingMatchesWith: replacementString[	"Copy <aString>, except for the matches. Replace each match with <aString>."| answer |answer := (String new: 40) writeStream.self copyStream: aString readStream to: answer replacingMatchesWith: replacementString.^ answer contents]Class RxMatcher >> syntaxBranch: branchNode[	"Double dispatch from the syntax tree. 	Branch node is a link in a chain of concatenated pieces.	First build the matcher for the rest of the chain, then make 	it for the current piece and hook the rest to it."| result next rest |branchNode branch isNil	ifTrue: [ ^ branchNode piece dispatchTo: self ].	"Optimization: glue a sequence of individual characters into a single string to match."branchNode piece isAtomic	ifTrue: [ 		result := (String new: 40) writeStream.		next := branchNode tryMergingInto: result.		result := result contents.		result size > 1			ifTrue: [ 				"worth merging"				rest := next notNil					ifTrue: [ next dispatchTo: self ]					ifFalse: [ nil ].				^ (RxmSubstring new substring: result ignoreCase: ignoreCase)					pointTailTo: rest;					yourself ] ].	"No optimization possible or worth it, just concatenate all. "^ (branchNode piece dispatchTo: self)	pointTailTo: (branchNode branch dispatchTo: self);	yourself]Class RxMatcher >> atEndOfWord[^ (self isWordChar: self lastChar) and: [ (self isWordChar: stream peek) not ]]Class RxMatcher >> subexpression: subIndex[	"Answer a string that matched the subexpression at the given index.	If there are multiple matches, answer the last one.	If there are no matches, answer nil. 	(NB: it used to answer an empty string but I think nil makes more sense)."| matches |matches := self subexpressions: subIndex.^ matches isEmpty	ifTrue: [ nil ]	ifFalse: [ matches last ]]Class RxMatcher >> matchesPrefix: aString[	"Match against a string."^ self matchesStreamPrefix: aString readStream]Class RxMatcher >> syntaxBeginningOfWord[	"Double dispatch from the syntax tree. 	Create a matcher for beginning-of-word condition."^ RxmSpecial new beBeginningOfWord]Class RxMatcher >> atBeginningOfLine[^ self position = 0 or: [ self lastChar = Cr ]]Class RxMatcher >> initialize: syntaxTreeRoot ignoreCase: aBoolean[	"Compile thyself for the regex with the specified syntax tree.	See comment and `building' protocol in this class and 	#dispatchTo: methods in syntax tree components for details 	on double-dispatch building. 	The argument is supposedly a RxsRegex."ignoreCase := aBoolean.self buildFrom: syntaxTreeRoot.startOptimizer := RxMatchOptimizer new initialize: syntaxTreeRoot ignoreCase: aBoolean]Class RxMatcher >> matchesOnStream: aStream[| result |result := OrderedCollection new.self matchesOnStream: aStream do: [ :match | result add: match ].^ result]Class RxMatcher >> subEnd: subIndex[^ markerPositions at: subIndex * 2]Class RxMatcher >> subexpressions: subIndex[	"Answer an array of all matches of the subexpression at the given index.	The answer is always an array; it is empty if there are no matches."| originalPosition startPositions stopPositions reply |originalPosition := stream position.startPositions := self subBeginning: subIndex.stopPositions := self subEnd: subIndex.(startPositions isEmpty or: [ stopPositions isEmpty ])	ifTrue: [ ^ Array new ].reply := OrderedCollection new.startPositions	with: stopPositions	do: [ :start :stop | 		stream position: start.		reply add: (stream next: stop - start) ].stream position: originalPosition.^ reply asArray]Class RxMatcher >> supportsSubexpressions[^ true]Class RxMatcher >> matchesIn: aString[	"Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of all matches (substrings)."| result |result := OrderedCollection new.self matchesOnStream: aString readStream do: [ :match | result add: match ].^ result]Class RxMatcher >> tryMatch[	"Match thyself against the current stream."| oldMarkerPositions |oldMarkerPositions := markerPositions.markerPositions := Array new: markerCount.1 to: markerCount do: [ :i | markerPositions at: i put: OrderedCollection new ].lastResult := startOptimizer isNil	ifTrue: [ matcher matchAgainst: self ]	ifFalse: [ (startOptimizer canStartMatch: stream peek in: self) and: [ matcher matchAgainst: self ] ].	"check for duplicates"(lastResult not or: [ oldMarkerPositions isNil or: [ oldMarkerPositions size ~= markerPositions size ] ])	ifTrue: [ ^ lastResult ].oldMarkerPositions	with: markerPositions	do: [ :oldPos :newPos | 		oldPos size = newPos size			ifFalse: [ ^ lastResult ].		oldPos			with: newPos			do: [ :old :new | 				old = new					ifFalse: [ ^ lastResult ] ] ].	"this is a duplicate"^ lastResult := false]Class RxMatcher >> copy: aString translatingMatchesUsing: aBlock[	"Copy <aString>, except for the matches. For each match, evaluate <aBlock> passing the matched substring as the argument.  Expect the block to answer a String, and replace the match with the answer."| answer |answer := (String new: 40) writeStream.self copyStream: aString readStream to: answer translatingMatchesUsing: aBlock.^ answer contents]Class RxMatcher >> subBeginning: subIndex[^ markerPositions at: subIndex * 2 - 1]Class RxMatcher >> split: aString[| result lastPosition |result := OrderedCollection new.stream := aString readStream.lastPosition := stream position.[ self searchStream: stream ]	whileTrue: [ 		result add: (aString copyFrom: lastPosition + 1 to: (self subBeginning: 1) first).		[ lastPosition < stream position ] assertWithDescription: 'Regex cannot match null string'.		lastPosition := stream position ].result add: (aString copyFrom: lastPosition + 1 to: aString size).^ result]Class RxMatcher >> syntaxWordBoundary[	"Double dispatch from the syntax tree. 	Create a matcher for the word boundary condition."^ RxmSpecial new beWordBoundary]Metaclass	name: #RxMatcher;	instanceVariables: #().Metaclass RxMatcher >> for: aRegex[	"Create and answer a matcher that will match a regular expression	specified by the syntax tree of which `aRegex' is a root."^ self for: aRegex ignoreCase: false]Metaclass RxMatcher >> forString: aString[	"Create and answer a matcher that will match the regular expression	`aString'."^ self for: (RxParser new parse: aString)]Metaclass RxMatcher >> forString: aString ignoreCase: aBoolean[	"Create and answer a matcher that will match the regular expression	`aString'."^ self for: (RxParser new parse: aString) ignoreCase: aBoolean]Metaclass RxMatcher >> for: aRegex ignoreCase: aBoolean[	"Create and answer a matcher that will match a regular expression	specified by the syntax tree of which `aRegex' is a root."^ self new initialize: aRegex ignoreCase: aBoolean]Metaclass RxMatcher >> initialize[	"RxMatcher initialize"Cr := Character cr.Lf := Character lf]