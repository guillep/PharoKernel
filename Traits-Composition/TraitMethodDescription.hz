Class
	name: #TraitMethodDescription;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#selector #locatedMethods );
	classVariables: #();
	package: #'Traits-Composition'.

Class TraitMethodDescription >> providedMethod
[
^ self providedLocatedMethod ifNotNil: [ :locatedMethod | locatedMethod method ]
]

Class TraitMethodDescription >> isAliasSelector
[
	"Return true if the selector is an alias (if it is different	from the original selector) or already an aliased method	in the original location (recursively search the compositions).	Return false, if not or if we have a conflict."
| locatedMethod |^ self size = 1	and: [ 		locatedMethod := self locatedMethods anyOne.		locatedMethod selector ~= self selector or: [ locatedMethod methodClass isAliasSelector: self selector ] ]
]

Class TraitMethodDescription >> methodsDo: aBlock
[
self locatedMethods do: [ :each | aBlock value: each ]
]

Class TraitMethodDescription >> effectiveMethod
[
	"Return the effective compiled method of this method description."
| locatedMethod method |method := self providedMethod.method isNil	ifFalse: [ ^ method ].method := self conflictMethod.method isNil	ifFalse: [ ^ method ].^ self requiredMethod
]

Class TraitMethodDescription >> effectiveMethodCategory
[
^ self effectiveMethodCategoryCurrent: nil new: nil
]

Class TraitMethodDescription >> providedLocatedMethod
[
| locatedMethod aLocatedMethod refOrigin |locatedMethod := nil.self locatedMethods ifEmpty: [ ^ nil ].self locatedMethods size > 1	ifTrue: [ 		aLocatedMethod := self locatedMethods anyOne.		refOrigin := (aLocatedMethod methodClass >> aLocatedMethod selector) origin.		(self locatedMethods allSatisfy: [ :each | each origin == refOrigin ])			ifTrue: [ ^ aLocatedMethod ] ].self locatedMethods	do: [ :each | 		each isProvided			ifTrue: [ 				locatedMethod isNil					ifFalse: [ ^ nil ].				locatedMethod := each ] ].^ locatedMethod
]

Class TraitMethodDescription >> selector: aSymbol
[
selector := aSymbol
]

Class TraitMethodDescription >> isProvided
[
^ self providedMethod notNil
]

Class TraitMethodDescription >> requiredMethod
[
| argumentNames numberOfArguments binary |self isRequired	ifFalse: [ ^ nil ].self size = 1	ifTrue: [ ^ self locatedMethods anyOne ].argumentNames := self getArgumentNames.binary := self isBinarySelector.numberOfArguments := binary	ifTrue: [ 1 ]	ifFalse: [ argumentNames size + 2 ].^ self	generateMethod: self selector	withMarker: CompiledMethod implicitRequirementMarker	forArgs: argumentNames size	binary: binary
]

Class TraitMethodDescription >> addLocatedMethod: aLocatedMethod
[
locatedMethods add: aLocatedMethod
]

Class TraitMethodDescription >> conflictMethod
[
| method argumentNames binary numberOfArguments |self isConflict	ifFalse: [ ^ nil ].argumentNames := self getArgumentNames.binary := self isBinarySelector.numberOfArguments := binary	ifTrue: [ 1 ]	ifFalse: [ argumentNames size + 2 ].^ self	generateMethod: self selector	withMarker: CompiledMethod conflictMarker	forArgs: argumentNames size	binary: binary
]

Class TraitMethodDescription >> isEmpty
[
^ self size = 0
]

Class TraitMethodDescription >> isConflict
[
| count originMethodReferenciel |count := 0.self locatedMethods size > 1	ifTrue: [ 		"If they are more than 1 located method, then check whether these methods have the same origin"		originMethodReferenciel := self locatedMethods anyOne origin.		(self locatedMethods allSatisfy: [ :each | each origin == originMethodReferenciel ])			ifTrue: [ ^ false ] ].self	methodsDo: [ :each | 		each isProvided			ifTrue: [ 				count := count + 1.				count > 1					ifTrue: [ ^ true ] ] ].^ false
]

Class TraitMethodDescription >> effectiveMethodCategoryCurrent: currentCategoryOrNil new: newCategoryOrNil
[
| result size isCurrent isConflict |size := self size.size = 0	ifTrue: [ ^ nil ].result := self locatedMethods anyOne category.size = 1	ifTrue: [ ^ result ].isCurrent := currentCategoryOrNil isNil.isConflict := false.self locatedMethods	do: [ :each | 		| cat |		cat := each category.		isCurrent := isCurrent or: [ cat == currentCategoryOrNil ].		isConflict := isConflict or: [ cat ~~ result ] ].isConflict	ifFalse: [ ^ result ].(isCurrent not and: [ newCategoryOrNil notNil ])	ifTrue: [ ^ newCategoryOrNil ].^ ClassOrganizer ambiguous
]

Class TraitMethodDescription >> initialize
[
super initialize.locatedMethods := IdentitySet new
]

Class TraitMethodDescription >> generateMethod: aSelector withMarker: aSymbol forArgs: aNumber binary: aBoolean
[
| source node |source := String	streamContents: [ :stream | 		aNumber < 1			ifTrue: [ stream nextPutAll: 'selector' ]			ifFalse: [ 				aBoolean					ifTrue: [ stream nextPutAll: '* anObject' ]					ifFalse: [ 						1 to: aNumber do: [ :argumentNumber | 							stream								nextPutAll: 'with:';								space;								nextPutAll: 'arg';								nextPutAll: argumentNumber asString;								space ] ] ].		stream			cr;			tab;			nextPutAll: 'self ';			nextPutAll: aSymbol ].node := self class compilerClass new	compile: source	in: self class	notifying: nil	ifFail: [  ].^ node generateWithSource	selector: aSelector;	yourself
]

Class TraitMethodDescription >> getArgumentNames
[
| argumentNamesCollection names defaultName |defaultName := 'arg'.argumentNamesCollection := self locatedMethods collect: [ :each | each argumentNames ].names := Array new: argumentNamesCollection anyOne size.argumentNamesCollection	do: [ :collection | 		1 to: names size do: [ :index | 			(names at: index) isNil				ifTrue: [ names at: index put: (collection at: index) ]				ifFalse: [ 					(names at: index) ~= (collection at: index)						ifTrue: [ names at: index put: defaultName , index asString ] ] ] ].^ names
]

Class TraitMethodDescription >> isRequired
[
self isEmpty	ifTrue: [ ^ false ].^ self locatedMethods allSatisfy: [ :each | each isRequired ]
]

Class TraitMethodDescription >> locatedMethods
[
^ locatedMethods
]

Class TraitMethodDescription >> size
[
^ self locatedMethods size
]

Class TraitMethodDescription >> isBinarySelector
[
^ self locatedMethods anyOne isBinarySelector
]

Class TraitMethodDescription >> selector
[
^ selector
]

Class TraitMethodDescription >> isLocalAliasSelector
[
	"Return true if the selector is an alias (if it is different	from the original selector). Return false, if not or if we	have a conflict."
^ self size = 1 and: [ self locatedMethods anyOne selector ~= self selector ]
]

Metaclass
	name: #TraitMethodDescription;
	instanceVariables: #().

Metaclass TraitMethodDescription >> new
[
^ super new	initialize;	yourself
]

Metaclass TraitMethodDescription >> selector: aSymbol
[
^ self new selector: aSymbol yourself
]

Metaclass TraitMethodDescription >> maxArguments
[
^ 30
]

