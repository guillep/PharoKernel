Class
	name: #FLVariablesMapping;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#mapping #theClass #notIgnoredVariables );
	classVariables: #();
	package: #'Fuel-Clusters'.

Class FLVariablesMapping >> initializeAnalyzing
[
notIgnoredVariables := self instanceVariableNamesToSerialize.mapping := notIgnoredVariables collect: [ :name | theClass instVarIndexFor: name ]
]

Class FLVariablesMapping >> initializeMaterializingFrom: aDecoder
[
notIgnoredVariables := (1 to: aDecoder nextEncodedByte) collect: [ :index | aDecoder nextEncodedString ].mapping := notIgnoredVariables collect: [ :name | theClass instVarIndexFor: name ifAbsent: [ nil ] ]
]

Class FLVariablesMapping >> initializeWith: aClass
[
self initialize.theClass := aClass
]

Class FLVariablesMapping >> instanceVariableNamesToSerialize
[
| ignoredInstanceVariableNames instanceVariableNamesToSerialize |ignoredInstanceVariableNames := theClass fuelIgnoredInstanceVariableNames.instanceVariableNamesToSerialize := OrderedCollection new.theClass	instanceVariableNamesDo: [ :name | 		(ignoredInstanceVariableNames includes: name)			ifFalse: [ instanceVariableNamesToSerialize add: name ] ].^ instanceVariableNamesToSerialize
]

Class FLVariablesMapping >> map: sourceName to: destinationName
[
| indexOfVariableToMap |indexOfVariableToMap := notIgnoredVariables indexOf: sourceName.indexOfVariableToMap > 0	ifTrue: [ 		mapping			at: indexOfVariableToMap			put: (theClass instVarIndexFor: destinationName ifAbsent: [ self error: 'Bad variable destination.' ]) ]
]

Class FLVariablesMapping >> materializeReferencesOf: anObject with: aDecoder
[
mapping	do: [ :index | 		| reference |		reference := aDecoder nextEncodedReference.		index ifNotNil: [ anObject instVarAt: index put: reference ] ]
]

Class FLVariablesMapping >> referencesOf: anObject do: aBlock
[
mapping do: [ :index | aBlock value: (anObject instVarAt: index) ]
]

Class FLVariablesMapping >> serializeOn: anEncoder
[
anEncoder encodeByte: notIgnoredVariables size.notIgnoredVariables do: [ :name | anEncoder encodeString: name ]
]

Class FLVariablesMapping >> serializeReferencesOf: anObject with: anEncoder
[
mapping do: [ :index | anEncoder encodeReferenceTo: (anObject instVarAt: index) ]
]

Metaclass
	name: #FLVariablesMapping;
	instanceVariables: #().

Metaclass FLVariablesMapping >> materializing: aClass from: aDecoder
[
^ self basicNew	initializeWith: aClass;	initializeMaterializingFrom: aDecoder;	yourself
]

Metaclass FLVariablesMapping >> newAnalyzing: aClass
[
^ self basicNew	initializeWith: aClass;	initializeAnalyzing;	yourself
]

