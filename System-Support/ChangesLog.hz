Class	name: #ChangesLog;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#startupStamp );	classVariables: #(#DefaultInstance );	package: #'System-Support'.Class ChangesLog >> logExpressionEvaluated: announcement[self logChange: announcement expressionEvaluated]Class ChangesLog >> logMethodRemoved: announcement[announcement methodClass acceptsLoggingOfCompilation	ifTrue: [ self logChange: announcement methodClass name , ' removeSelector: #' , announcement selector ]]Class ChangesLog >> logChange: aStringOrText[	"Write the argument, aString, onto the changes file."| aString changesFile |(SourceFiles isNil or: [ (SourceFiles at: 2) == nil ])	ifTrue: [ ^ self ].self assureStartupStampLogged.aString := aStringOrText asString.(aString findFirst: [ :char | char isSeparator not ]) = 0	ifTrue: [ ^ self ].	"null doits confuse replay"changesFile := SourceFiles at: 2.changesFile isReadOnly	ifTrue: [ ^ self ].changesFile	setToEnd;	cr;	cr.changesFile nextChunkPut: aString.	"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"self forceChangesToDisk]Class ChangesLog >> logClassRemoved: annoucement[annoucement classRemoved acceptsLoggingOfCompilation	ifTrue: [ self logChange: 'Smalltalk globals removeClassNamed: #' , annoucement classRemoved name ]]Class ChangesLog >> recordStartupStamp[startupStamp := '----STARTUP----' , Time dateAndTimeNow printString , ' as ' , Smalltalk imagePath]Class ChangesLog >> assureStartupStampLogged[	"If there is a startup stamp not yet actually logged to disk, do it now."| changesFile |startupStamp ifNil: [ ^ self ].(SourceFiles isNil or: [ (changesFile := SourceFiles at: 2) == nil ])	ifTrue: [ ^ self ].changesFile isReadOnly	ifTrue: [ ^ self ].changesFile	setToEnd;	cr;	cr.changesFile	nextChunkPut: startupStamp asString;	cr.startupStamp := nil.self forceChangesToDisk]Class ChangesLog >> registerToAnnouncements[SystemAnnouncer uniqueInstance	on: ClassRemoved send: #logClassRemoved: to: self;	on: MethodRemoved send: #logMethodRemoved: to: self;	on: ExpressionEvaluated send: #logExpressionEvaluated: to: self]Class ChangesLog >> forceChangesToDisk[	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."| changesFile |changesFile := SourceFiles at: 2.(changesFile isKindOf: FileStream)	ifTrue: [ 		changesFile flush.		changesFile close.		changesFile open: changesFile name forWrite: true.		changesFile setToEnd ]]Metaclass	name: #ChangesLog;	instanceVariables: #().Metaclass ChangesLog >> reset[SystemAnnouncer uniqueInstance unsubscribe: DefaultInstance.DefaultInstance := nil]Metaclass ChangesLog >> default[^ DefaultInstance	ifNil: [ 		DefaultInstance := self new.		DefaultInstance registerToAnnouncements ]]