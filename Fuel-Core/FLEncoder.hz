Class	name: #FLEncoder;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#stream #objectsIndexes #objectCount #indexStream );	classVariables: #();	package: #'Fuel-Core'.Class FLEncoder >> encodeBytes: aBytesObject[stream nextBytesPutAll: aBytesObject]Class FLEncoder >> encodeUint16: aSmallInteger[	"Append to the receiver an Integer as the next two bytes."stream nextPut: (aSmallInteger bitShift: -8).stream nextPut: (aSmallInteger bitAnd: 255)]Class FLEncoder >> objectCount[^ objectCount]Class FLEncoder >> objectCount: aNumber[objectCount := aNumber.objectsIndexes := FLLargeIdentityDictionary new.indexStream := FLIndexStream on: stream digits: aNumber digitLength]Class FLEncoder >> encodeByte: aSmallInteger[stream nextPut: aSmallInteger]Class FLEncoder >> encodeWeakReferenceTo: anObject[indexStream nextIndexPut: (objectsIndexes at: anObject ifAbsent: [ objectsIndexes at: nil ])]Class FLEncoder >> flush[^ stream flush]Class FLEncoder >> encodeUint8: aSmallInteger[	"Append to the receiver an Integer as the next two bytes."stream nextPut: aSmallInteger]Class FLEncoder >> initializeOn: aStream[self initialize.stream := FLBufferedWriteStream on: aStream]Class FLEncoder >> encodeYourself[self encodePositiveInteger: objectCount.self encodePositiveInteger: Smalltalk isBigEndian asBit]Class FLEncoder >> encodePositiveInteger: anInteger[	"Append to the receiver an Integer as the next 4 bytes."1 to: 4 do: [ :i | stream nextPut: (anInteger digitAt: 4 + 1 - i) ]]Class FLEncoder >> encodeUint24: aSmallInteger[	"Append to the receiver an Integer as the next 3 bytes."stream	nextPut: ((aSmallInteger bitShift: -16) bitAnd: 255);	nextPut: ((aSmallInteger bitShift: -8) bitAnd: 255);	nextPut: (aSmallInteger bitAnd: 255)]Class FLEncoder >> encodeClusterClass: aClusterClass[self encodeString: aClusterClass name]Class FLEncoder >> encodeInt24: aSmallInteger[	"Write a signed integer to the next 4 bytes"| pos |pos := aSmallInteger < 0	ifTrue: [ (0 - aSmallInteger bitXor: 16rFFFFFF) + 1 ]	ifFalse: [ aSmallInteger ].1 to: 3 do: [ :i | stream nextPut: (pos digitAt: 4 - i) ]]Class FLEncoder >> encodeBitmap: aBitmap[	"Append to the receiver an Integer as the next two bytes."aBitmap writeOn: stream]Class FLEncoder >> fuelAccept: aGeneralMapper[^ aGeneralMapper visitSubstitution: self by: nil]Class FLEncoder >> encodeUint32: aSmallInteger[	"Append to the receiver an Integer as the next 4 bytes."stream	nextPut: (aSmallInteger bitShift: -24);	nextPut: ((aSmallInteger bitShift: -16) bitAnd: 255);	nextPut: ((aSmallInteger bitShift: -8) bitAnd: 255);	nextPut: (aSmallInteger bitAnd: 255)]Class FLEncoder >> encodeString: aString[| length |(length := aString size) < 192	ifTrue: [ stream nextPut: length ]	ifFalse: [ 		stream nextPut: (length digitAt: 4) + 192.		stream nextPut: (length digitAt: 3).		stream nextPut: (length digitAt: 2).		stream nextPut: (length digitAt: 1) ].stream nextBytesPutAll: aString]Class FLEncoder >> objectsIndexes[^ objectsIndexes]Class FLEncoder >> encodeInt32: aSmallInteger[	"Write a signed integer to the next 4 bytes"| pos |pos := aSmallInteger < 0	ifTrue: [ (0 - aSmallInteger) bitInvert32 + 1 ]	ifFalse: [ aSmallInteger ].1 to: 4 do: [ :i | stream nextPut: (pos digitAt: 5 - i) ]]Class FLEncoder >> encodeWords: aWordsObject[stream nextWordsPut: aWordsObject]Class FLEncoder >> encodeReferenceTo: anObject[indexStream nextIndexPut: (objectsIndexes at: anObject ifAbsent: [ FLObjectNotFound signalWith: anObject ])]Metaclass	name: #FLEncoder;	instanceVariables: #().Metaclass FLEncoder >> on: aStream[^ self basicNew	initializeOn: aStream;	yourself]Metaclass FLEncoder >> on: aStream do: aBlock[| anEncoder |anEncoder := self on: aStream.^ [ aBlock value: anEncoder ]	ensure: [ anEncoder flush ]]