Class
	name: #HazelnutSeed;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #();
	classVariables: #();
	package: #'Seed-HazelBuilder'.

Class HazelnutSeed >> appySubstitutionsOn: aSubstituteHandler forEnvironment: aBootstrapEnvironment
[
self classRoles	keysAndValuesDo: [ :role :className | aSubstituteHandler substitute: (Smalltalk globals at: role) by: (aBootstrapEnvironment globalNamed: className) ]
]

Class HazelnutSeed >> metaclassRoleClassDefinition
[
^ self classDefinitionPlayingRole: #Metaclass
]

Class HazelnutSeed >> classRoles
[
	"Here you have to explicit a map for all the roles the new seed needs to cover.  An image not fulfilling all the roles may not work.  It's up to you to know if you fulfill all the roles or not"
	"	The left of the map should be filled with roles.  The corresponding value of each role should be the name of the class in the given seed.		#Class -> #Class.	#Metaclass -> #Metaclass.	#Array -> #Array.	#MethodDictionary -> #MethodDictionary. 	#CompiledMethod -> #CompiledMethod.	#Character -> #Character. 	#ByteArray -> #ByteArray.	#Association -> #Association.	#BlockClosure -> #BlockClosure.	#MethodContext -> #MethodContext.	#Point -> #Point.	#Rectangle -> #Rectangle.	#Process -> #Process.	#Semaphore -> #Semaphore.	#ByteString -> #ByteString.	#ByteSymbol -> #ByteSymbol.	#True -> #True.	#False -> #False.	#UndefinedObject -> #UndefinedObject.	#Float -> #Float.	#SmallInteger -> #SmallInteger.	#LargePositiveInteger -> #LargePositiveInteger.	#LargeNegativeInteger -> #LargeNegativeInteger.	#Dictionary -> #Dictionary.									Dictionaries are used to build class variables	#WideString -> #WideString.								The Wide guys right now are needed here because they commonly appear as literals	#WideSymbol -> #WideSymbol.	"
self subclassResponsibility
]

Class HazelnutSeed >> bootstrapMetamodelOn: aBootstrapEnvironment
[
	"This method creates a bootstrap of the Smalltalk-80 meta model"
| classFormat metaclassFormat metaclassClass metaclass |classFormat := self classRoleClassDefinition format.metaclassFormat := self metaclassRoleClassDefinition format.metaclassClass := Metaclass new.metaclassClass superclass: Class class methodDictionary: MethodDictionary new format: classFormat.metaclass := metaclassClass basicNew.metaclass instVarAt: 1 put: Metaclass.metaclass instVarAt: 2 put: MethodDictionary new.metaclass instVarAt: 3 put: metaclassFormat.metaclassClass := metaclass basicNew.metaclassClass instVarAt: 1 put: Metaclass class.metaclassClass instVarAt: 2 put: MethodDictionary new.metaclassClass instVarAt: 3 put: classFormat.metaclassClass adoptInstance: metaclass.aBootstrapEnvironment bootstrapMetaclass: metaclass.aBootstrapEnvironment addBehavior: metaclass named: self metaclassRoleClassDefinition name.aBootstrapEnvironment addGlobal: self metaclassRoleClassDefinition name pointingTo: metaclass.self initializeClass: metaclass named: self metaclassRoleClassDefinition name
]

Class HazelnutSeed >> metaModelDefinitions
[
self subclassResponsibility
]

Class HazelnutSeed >> classRoleClassDefinition
[
^ self classDefinitionPlayingRole: #Class
]

Class HazelnutSeed >> classDefinitionPlayingRole: aRoleName
[
	"all the seeds should answer a class definition for the role"
self subclassResponsibility
]

Metaclass
	name: #HazelnutSeed;
	instanceVariables: #().

