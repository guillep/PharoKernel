Class
	name: #Monitor;
	superclass: #ClassObject;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#mutex #ownerProcess #nestingLevel #defaultQueue #queueDict #queuesMutex );
	classVariables: #();
	package: #'Kernel-Processes'.

Class Monitor >> waitUntil: aBlock maxSeconds: aNumber
[
	"Same as Monitor>>waitUntil:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitUntil: aBlock maxMilliseconds: (aNumber * 1000) asInteger
]

Class Monitor >> queueDict
[
^ queueDict ifNil: [ queueDict := IdentityDictionary new ]
]

Class Monitor >> privateCleanup
[
queuesMutex	critical: [ 		defaultQueue isEmpty			ifTrue: [ defaultQueue := nil ].		queueDict			ifNotNil: [ 				queueDict copy					keysAndValuesDo: [ :id :queue | 						queue isEmpty							ifTrue: [ queueDict removeKey: id ] ].				queueDict isEmpty					ifTrue: [ queueDict := nil ] ] ]
]

Class Monitor >> initialize
[
super initialize.mutex := Semaphore forMutualExclusion.queuesMutex := Semaphore forMutualExclusion.nestingLevel := 0
]

Class Monitor >> waitFor: aSymbolOrNil maxSeconds: aNumber
[
	"Same as Monitor>>waitFor:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitFor: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger
]

Class Monitor >> waitMaxMilliseconds: anIntegerOrNil
[
	"Same as Monitor>>wait, but the process gets automatically woken up when the 	specified time has passed."
^ self waitFor: nil maxMilliseconds: anIntegerOrNil
]

Class Monitor >> waitUntil: aBlock
[
	"Conditional waiting for the default event.	See Monitor>>waitWhile: aBlock."
^ self waitUntil: aBlock for: nil
]

Class Monitor >> waitUntil: aBlock maxMilliseconds: anIntegerOrNil
[
	"Same as Monitor>>waitUntil:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitUntil: aBlock for: nil maxMilliseconds: anIntegerOrNil
]

Class Monitor >> exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil
[
| lock delay |lock := queuesMutex critical: [ anOrderedCollection addLast: Semaphore new ].self exit.anIntegerOrNil isNil	ifTrue: [ lock wait ]	ifFalse: [ 		delay := MonitorDelay			signalLock: lock			afterMSecs: anIntegerOrNil			inMonitor: self			queue: anOrderedCollection.		lock wait.		delay unschedule ].self enter
]

Class Monitor >> waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil
[
	"Same as Monitor>>waitWhile:for:, but the process gets automatically woken up when the 	specified time has passed."
self checkOwnerProcess.self waitWhile: aBlock inQueue: (self queueFor: aSymbolOrNil) maxMilliseconds: anIntegerOrNil
]

Class Monitor >> signalLock: aSemaphore inQueue: anOrderedCollection
[
queuesMutex	critical: [ 		aSemaphore signal.		anOrderedCollection remove: aSemaphore ifAbsent: [  ] ]
]

Class Monitor >> signal: aSymbolOrNil
[
	"One process waiting for the given event is woken up. If there is no process waiting 	for this specific event, a process waiting for the default event gets resumed."
| queue |self checkOwnerProcess.queue := self queueFor: aSymbolOrNil.queue isEmpty	ifTrue: [ queue := self defaultQueue ].self signalQueue: queue
]

Class Monitor >> signalQueue: anOrderedCollection
[
queuesMutex	critical: [ 		anOrderedCollection isEmpty			ifFalse: [ anOrderedCollection removeFirst signal ] ]
]

Class Monitor >> waitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil
[
self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil
]

Class Monitor >> exit
[
nestingLevel := nestingLevel - 1.nestingLevel < 1	ifTrue: [ 		ownerProcess := nil.		mutex signal ]
]

Class Monitor >> waitWhile: aBlock
[
	"Conditional waiting for the default event.	The current process gets blocked and leaves the monitor only if the argument block	evaluates to true. This means that another process can enter the monitor. When the 	default event is signaled, the original process is resumed, which means that the condition	(argument block) is checked again. Only if it evaluates to false, does execution proceed.	Otherwise, the process gets blocked and leaves the monitor again..."
^ self waitWhile: aBlock for: nil
]

Class Monitor >> waitMaxSeconds: aNumber
[
	"Same as Monitor>>wait, but the process gets automatically woken up when the 	specified time has passed."
^ self waitMaxMilliseconds: (aNumber * 1000) asInteger
]

Class Monitor >> wait
[
	"Unconditional waiting for the default event.	The current process gets blocked and leaves the monitor, which means that the monitor	allows another process to execute critical code. When the default event is signaled, the	original process is resumed."
^ self waitMaxMilliseconds: nil
]

Class Monitor >> waitWhile: aBlock for: aSymbolOrNil maxSeconds: aNumber
[
	"Same as Monitor>>waitWhile:for:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger
]

Class Monitor >> defaultQueue
[
defaultQueue ifNil: [ defaultQueue := OrderedCollection new ].^ defaultQueue
]

Class Monitor >> signalAllInQueue: anOrderedCollection
[
queuesMutex	critical: [ 		anOrderedCollection			removeAllSuchThat: [ :each | 				each signal.				true ] ]
]

Class Monitor >> waitFor: aSymbolOrNil maxMilliseconds: anIntegerOrNil
[
	"Same as Monitor>>waitFor:, but the process gets automatically woken up when the 	specified time has passed."
self checkOwnerProcess.self waitInQueue: (self queueFor: aSymbolOrNil) maxMilliseconds: anIntegerOrNil
]

Class Monitor >> waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil
[
	"Same as Monitor>>waitUntil:for:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitWhile: [ aBlock value not ] for: aSymbolOrNil maxMilliseconds: anIntegerOrNil
]

Class Monitor >> signalAll: aSymbolOrNil
[
	"All process waiting for the given event or the default event are woken up."
| queue |self checkOwnerProcess.queue := self queueFor: aSymbolOrNil.self signalAllInQueue: self defaultQueue.queue ~~ self defaultQueue	ifTrue: [ self signalAllInQueue: queue ]
]

Class Monitor >> waitWhile: aBlock maxSeconds: aNumber
[
	"Same as Monitor>>waitWhile:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitWhile: aBlock maxMilliseconds: (aNumber * 1000) asInteger
]

Class Monitor >> signalReallyAll
[
	"All processes waiting for any events (default or specific) are woken up."
self checkOwnerProcess.self signalAll.self queueDict valuesDo: [ :queue | self signalAllInQueue: queue ]
]

Class Monitor >> enter
[
self isOwnerProcess	ifTrue: [ nestingLevel := nestingLevel + 1 ]	ifFalse: [ 		mutex wait.		ownerProcess := Processor activeProcess.		nestingLevel := 1 ]
]

Class Monitor >> waitWhile: aBlock maxMilliseconds: anIntegerOrNil
[
	"Same as Monitor>>waitWhile:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitWhile: aBlock for: nil maxMilliseconds: anIntegerOrNil
]

Class Monitor >> signal
[
	"One process waiting for the default event is woken up."
^ self signal: nil
]

Class Monitor >> waitWhile: aBlock for: aSymbolOrNil
[
	"Confitional waiting for the non-default event represented by the argument symbol.	Same as Monitor>>waitWhile:for:, but the process gets only reactivated by the specific 	event and not the default event."
^ self waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: nil
]

Class Monitor >> checkOwnerProcess
[
self isOwnerProcess	ifFalse: [ self error: 'Monitor access violation' ]
]

Class Monitor >> waitUntil: aBlock for: aSymbolOrNil maxSeconds: aNumber
[
	"Same as Monitor>>waitUntil:for:, but the process gets automatically woken up when the 	specified time has passed."
^ self waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger
]

Class Monitor >> waitUntil: aBlock for: aSymbolOrNil
[
	"Confitional waiting for the non-default event represented by the argument symbol.	See Monitor>>waitWhile:for: aBlock."
^ self waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: nil
]

Class Monitor >> isOwnerProcess
[
^ Processor activeProcess == ownerProcess
]

Class Monitor >> signalAll
[
	"All processes waiting for the default event are woken up."
^ self signalAll: nil
]

Class Monitor >> critical: aBlock
[
	"Critical section.	Executes aBlock as a critical section. At any time, only one process can be executing code 	in a critical section.	NOTE: All the following synchronization operations are only valid inside the critical section 	of the monitor!"
^ [ self enter.aBlock value ]	ensure: [ self exit ]
]

Class Monitor >> cleanup
[
self checkOwnerProcess.self critical: [ self privateCleanup ]
]

Class Monitor >> queueFor: aSymbol
[
aSymbol ifNil: [ ^ self defaultQueue ].^ self queueDict at: aSymbol ifAbsentPut: [ OrderedCollection new ]
]

Class Monitor >> waitWhile: aBlock inQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil
[
[ aBlock value ] whileTrue: [ self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil ]
]

Class Monitor >> waitFor: aSymbolOrNil
[
	"Unconditional waiting for the non-default event represented by the argument symbol.	Same as Monitor>>wait, but the process gets only reactivated by the specific event and 	not the default event."
^ self waitFor: aSymbolOrNil maxMilliseconds: nil
]

Metaclass
	name: #Monitor;
	instanceVariables: #().

