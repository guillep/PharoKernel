Class	name: #AtomicCollection;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #();	classVariables: #();	package: #'Collections-Atomic'.Class AtomicCollection >> signalNoMoreItems[	"Optional, override in subclass(es) to signal that queue is currently empty.	Default implementation does nothing"]Class AtomicCollection >> copy[^ self errorDontCopy]Class AtomicCollection >> signalAddedNewItem[	"Optional, override in subclass(es) to signal that new item available in queue.	Default implementation does nothing"]Class AtomicCollection >> errorDontCopy[	"copying a structure, involved in concurrent operations is a bad idea"^ self error: 'Copying not available']Class AtomicCollection >> interrupt[	"simulate interrupt , for debugging purposes only"Processor yield]Class AtomicCollection >> waitForNewItems[	"Override in subclass. By default, yield current process.	If you run more than one process, which popping items from queue,	then there is no guarantee, that after wait, #next won't block the queue"^ self yield]Class AtomicCollection >> newItem[	"override in subclass, if you need to instantiate queue items of different class or initialize them in some specific way"^ AtomicQueueItem new]Class AtomicCollection >> yield[	"Yield the current process.	Used internally by spin loops, once detected that 	current process can't make any progress	without some external event to happen"Processor yield]Class AtomicCollection >> deepCopy[^ self errorDontCopy]Metaclass	name: #AtomicCollection;	instanceVariables: #().