Class	name: #FileSystem;	superclass: #ClassObject;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#workingDirectory #store );	classVariables: #();	package: #'FileSystem-Core-Public'.Class FileSystem >> entriesAt: aResolvable do: aBlock[^ self entriesAt: aResolvable ifAbsent: [ store signalDirectoryDoesNotExist: (self resolve: aResolvable) ] do: aBlock]Class FileSystem >> openFileStream: aResolvable writable: aBoolean[^ store openFileStream: (self resolve: aResolvable) writable: aBoolean]Class FileSystem >> workingDirectoryPath: aPath[aPath isAbsolute	ifFalse: [ self error: 'Cannot set the working directory to a relative path' ].workingDirectory := aPath]Class FileSystem >> separator[	"Return path separator used by this filesystem."^ store separator]Class FileSystem >> copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock[	"Copy the file referenced as sourcePath to the destination referred as destPath. Perform associate actions in case of problems."store	copy: (self resolve: sourcePath)	ifAbsent: absentBlock	to: (self resolve: destinationPath)	ifPresent: presentBlock	fileSystem: self]Class FileSystem >> filesAt: aResolvable[^ Array streamContents: [ :out | self filesAt: aResolvable do: [ :path | out nextPut: path ] ]]Class FileSystem >> hasChildren: aResolvable[	"Returns whether aResolvable has children."store directoryAt: (self resolve: aResolvable) ifAbsent: [ ^ false ] nodesDo: [ :node | ^ true ].^ false]Class FileSystem >> writeStreamOn: aResolvable[	"Open a write stream on the file referred by the argument. It can be a string or a path"^ (self open: aResolvable writable: true) writeStream]Class FileSystem >> extensionDelimiter[^ $.]Class FileSystem >> entryAt: aResolvable[| path |path := self resolve: aResolvable.^ store	nodeAt: path	ifPresent: [ :node | store entryFromNode: node fileSystem: self path: path ]	ifAbsent: [ store signalFileDoesNotExist: path ]]Class FileSystem >> rename: sourcePath ifAbsent: aBlock to: destPath ifPresent: pBlock[	"Rename the file referenced as sourcePath to the destination referred as destPath. 	Perform associate actions in case of problems."| source destination |source := self resolve: sourcePath.destination := self resolve: destPath.store	rename: source	ifAbsent: aBlock	to: destination	ifPresent: pBlock	fileSystem: self.^ destination]Class FileSystem >> filesAt: aResolvable do: aBlock[| path |path := self resolve: aResolvable.store	directoryAt: path	ifAbsent: [ store signalDirectoryDoesNotExist: path ]	fileNodesDo: [ :entry | aBlock value: path / (store basenameFromEntry: entry) ]]Class FileSystem >> rename: sourcePath to: destName[	"Rename the file referenced as sourcePath to destPath.  Raise exceptions 	FileExists or FileDoesNotExist  if the operation fails"^ self	rename: sourcePath	ifAbsent: [ store signalFileDoesNotExist: sourcePath ]	to: destName	ifPresent: [ self signalFileExists: destName ]]Class FileSystem >> readStreamOn: aResolvable[	"Resolve the argument into an absolute path and open a file handle on the file	at that path. Ask the handle to give us a read stream for reading the file."^ (self open: aResolvable writable: false) readStream]Class FileSystem >> openStreamDescription: aResolvable writable: aBoolean[	"I am  a helper method to delegate basicOpen:writable: to the store.	 I am called from FSHandle implementations."| path |path := self resolve: aResolvable.^ store basicOpen: path writable: aBoolean]Class FileSystem >> changeDirectory: aPath[self workingDirectoryPath: (self resolve: aPath)]Class FileSystem >> resolve: aResolvable[^ aResolvable asResolvedBy: self]Class FileSystem >> isDirectory: aResolvable[	"Resolve the argument, and answer true if the result refers	to a directory, false if it refers to a file or doesn't exist."^ store isDirectory: (self resolve: aResolvable)]Class FileSystem >> isReadable: aResolvable[	"Resolve the argument, and answer true if the there is	a file or directory that can be read from."^ (self permissions: aResolvable) isReadable]Class FileSystem >> mimeTypesAt: aResolvable[	"Return the possible mime types for the given path."^ store mimeTypesAt: (self resolve: aResolvable)]Class FileSystem >> resolvePath: aPath[	"Return a path where the argument is resolved in the context of the	receiver. The behavior is similar to the one of a command line.		> cd /a/b/c		> cd b		The shell will attempt to make /a/b/c/b the current directory. "^ workingDirectory resolve: aPath]Class FileSystem >> directoryNamesAt: aResolvable do: aBlock[| path |path := self resolve: aResolvable.store	directoryAt: path	ifAbsent: [ store signalDirectoryDoesNotExist: path ]	directoryNodesDo: [ :entry | aBlock value: (store basenameFromEntry: entry) ]]Class FileSystem >> permissions: aResolvable[	"Resolve the argument and return the Permissions for this file or directory "^ store permissions: (self resolve: aResolvable)]Class FileSystem >> size: aResolvable[	"Resolve the argument and return the size for this file or directory "^ store size: (self resolve: aResolvable)]Class FileSystem >> childNamesAt: aResolvable do: aBlock[| path |path := self resolve: aResolvable.store	directoryAt: path	ifAbsent: [ store signalDirectoryDoesNotExist: path ]	nodesDo: [ :entry | aBlock value: (store basenameFromEntry: entry) ]]Class FileSystem >> stringFromPath: aPath[^ store stringFromPath: aPath]Class FileSystem >> exists: aResolvable[	"Resolve the argument, and answer true if the there is	a file or directory at that path, false if there is not."^ store exists: (self resolve: aResolvable)]Class FileSystem >> forReferencePrintOn: aStream[store forReferencePrintOn: aStream]Class FileSystem >> delimiter[	"Return path delimiter used by this filesystem."^ store delimiter]Class FileSystem >> * anObject[	"Return a relative reference."^ self referenceTo: Path * anObject]Class FileSystem >> fileNamesAt: aResolvable do: aBlock[| path |path := self resolve: aResolvable.store	directoryAt: path	ifAbsent: [ store signalDirectoryDoesNotExist: path ]	fileNodesDo: [ :entry | aBlock value: (store basenameFromEntry: entry) ]]Class FileSystem >> = other[^ self species = other species and: [ self store = other store ]]Class FileSystem >> checkName: aString fixErrors: fixErrors[^ store checkName: aString fixErrors: fixErrors]Class FileSystem >> root[	"Returns the root of the receiver filesystem, i.e. / on unix"^ self referenceTo: Path root]Class FileSystem >> isFile: aResolvable[	"Resolve the argument, and answer true if the result refers	to a file, false if it refers to a directory or doesn't exist."^ store isFile: (self resolve: aResolvable)]Class FileSystem >> directoriesAt: aResolvable[^ Array streamContents: [ :out | self directoriesAt: aResolvable do: [ :path | out nextPut: path ] ]]Class FileSystem >> initializeWithStore: aStore[store := aStore.workingDirectory := store defaultWorkingDirectory]Class FileSystem >> open[	"Some kinds of filesystems need to open connections to external resources. Does nothing by default."store open]Class FileSystem >> printPath: aPath on: aStream[store printPath: aPath on: aStream]Class FileSystem >> isWritable: aResolvable[	"Resolve the argument, and answer true if the there is	a file that can be written to or directory that can be changed."^ (self permissions: aResolvable) isWritable]Class FileSystem >> fileNamesAt: aResolvable[^ Array streamContents: [ :out | self fileNamesAt: aResolvable do: [ :path | out nextPut: path ] ]]Class FileSystem >> hasFiles: aResolvable[self	entriesAt: aResolvable	ifAbsent: [ ^ false ]	do: [ :entry | 		entry isFile			ifTrue: [ ^ true ] ].^ false]Class FileSystem >> ensureDirectory: aResolvable[	"Resolve the argument to an absolute path, then ask the store to make	sure that all the directories contained in the argument path exist or are created."store ensureDirectory: (self resolve: aResolvable)]Class FileSystem >> copyFrom: inputStream to: destPath[| buffer out |out := nil.(self exists: destPath)	ifTrue: [ store signalFileExists: destPath ].^ [ out := self writeStreamOn: destPath.buffer := ByteArray new: 1024.[ inputStream atEnd ]	whileFalse: [ 		buffer := inputStream nextInto: buffer.		out nextPutAll: buffer ] ]	ensure: [ out ifNotNil: [ out close ] ]]Class FileSystem >> isCaseSensitive[^ self store isCaseSensitive]Class FileSystem >> workingDirectoryPath[^ workingDirectory]Class FileSystem >> createDirectory: aResolvable[	"Resolve aResolvable into an absolute path, then as the store to create a directory there. 	The store is expected to raise an exception if it cannot do so."^ store createDirectory: (self resolve: aResolvable)]Class FileSystem >> referenceTo: aResolvable[	"Answer a reference to the argument from the context of the receiver filesystem.  			Example: FSFilesystem disk referenceTo: 'plonk.taz'"^ FileReference fileSystem: self path: (self pathFromObject: aResolvable)]Class FileSystem >> creationTime: aResolvable[	"Resolve the argument, and answer true if the result refers	to a directory, false if it refers to a file or doesn't exist."^ store creationTime: (self resolve: aResolvable)]Class FileSystem >> / anObject[	"Return the absolute reference obtained by resolving anObject against the	root of this filesystem."^ self root / anObject]Class FileSystem >> delete: aResolvable[store delete: (self resolve: aResolvable)]Class FileSystem >> hash[^ store hash]Class FileSystem >> childrenAt: aResolvable do: aBlock[| path |path := self resolve: aResolvable.store	directoryAt: path	ifAbsent: [ store signalDirectoryDoesNotExist: path ]	nodesDo: [ :entry | aBlock value: path / (store basenameFromEntry: entry) ]]Class FileSystem >> isSymlink: aResolvable[	"Resolve the argument, and answer true if the result refers	to a directory, false if it refers to a file or doesn't exist."^ store isSymlink: (self resolve: aResolvable)]Class FileSystem >> pathFromString: aString[^ store pathFromString: aString]Class FileSystem >> close[store close]Class FileSystem >> resolveReference: aReference[^ aReference fileSystem = self	ifTrue: [ workingDirectory resolvePath: aReference path ]]Class FileSystem >> hasDirectories: aResolvable[self	entriesAt: aResolvable	ifAbsent: [ ^ false ]	do: [ :entry | 		entry isDirectory			ifTrue: [ ^ true ] ].^ false]Class FileSystem >> entriesAt: aResolvable[^ Array streamContents: [ :out | self entriesAt: aResolvable do: [ :entry | out nextPut: entry ] ]]Class FileSystem >> modificationTime: aResolvable[	"Resolve the argument, and answer true if the result refers	to a directory, false if it refers to a file or doesn't exist."^ store modificationTime: (self resolve: aResolvable)]Class FileSystem >> copy: sourcePath to: destPath[	"Copy the file referenced as sourcePath to the destination referred as destPath.  	If there is no file at sourcePath, raise FileDoesNotExist.	If destPath is a file, raise FileExists."self	copy: sourcePath	ifAbsent: [ store signalFileDoesNotExist: sourcePath ]	to: destPath	ifPresent: [ store signalFileExists: destPath ]]Class FileSystem >> childrenAt: aResolvable[^ Array streamContents: [ :out | self childrenAt: aResolvable do: [ :path | out nextPut: path ] ]]Class FileSystem >> workingDirectory[	"Returns a reference to the directory from where the image was launched"^ self referenceTo: self workingDirectoryPath]Class FileSystem >> entriesAt: aResolvable ifAbsent: absentBlock do: aBlock[| path entry aFilesystem |path := self resolve: aResolvable.aFilesystem := self.store	directoryAt: path	ifAbsent: [ ^ absentBlock value ]	nodesDo: [ :node | 		entry := store entryFromNode: node path: path for: aFilesystem.		aBlock value: entry ]]Class FileSystem >> pathFromObject: anObject[^ anObject asPathWith: self]Class FileSystem >> directoriesAt: aResolvable do: aBlock[| path |path := self resolve: aResolvable.store	directoryAt: path	ifAbsent: [ store signalDirectoryDoesNotExist: path ]	directoryNodesDo: [ :entry | aBlock value: path / (store basenameFromEntry: entry) ]]Class FileSystem >> resolveString: aString[	"Returns the root of the receiver filesystem, i.e. / on unix"^ workingDirectory resolvePath: (store pathFromString: aString)]Class FileSystem >> copy: aPath toReference: destRef[| inputStream path |path := self resolve: aPath.[ inputStream := self readStreamOn: path.inputStream ifNil: [ store signalFileDoesNotExist: path ].destRef fileSystem copyFrom: inputStream to: destRef path ]	ensure: [ inputStream ifNotNil: [ inputStream close ] ]]Class FileSystem >> directoryNamesAt: aResolvable[^ Array streamContents: [ :out | self directoryNamesAt: aResolvable do: [ :name | out nextPut: name ] ]]Class FileSystem >> childNamesAt: aResolvable[^ Array streamContents: [ :out | self childNamesAt: aResolvable do: [ :path | out nextPut: path ] ]]Class FileSystem >> open: aResolvable writable: aBoolean[	"Resolve aResolvable into an absolute path, then ask the store to open the file at	that path using the specified access mode."| path |path := self resolve: aResolvable.^ store handleClass open: (FileReference fileSystem: self path: path) writable: aBoolean]Class FileSystem >> store[^ store]Metaclass	name: #FileSystem;	instanceVariables: #().Metaclass FileSystem >> store: aStore[^ self basicNew	initializeWithStore: aStore;	yourself]Metaclass FileSystem >> startUp: aBoolean[	"This is only here to deal with migration from older versions of	FileSystem that wanted to receive startup notifcations."Smalltalk removeFromStartUpList: self]