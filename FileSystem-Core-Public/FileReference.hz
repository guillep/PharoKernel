Class	name: #FileReference;	superclass: #ClassAbstractFileReference;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#filesystem #path );	classVariables: #();	package: #'FileSystem-Core-Public'.Class FileReference >> delete[filesystem delete: path]Class FileReference >> isSymlink[^ filesystem isSymlink: path]Class FileReference >> asAbsolute[	"Return the receiver as an absolute file reference."^ self isAbsolute	ifTrue: [ self ]	ifFalse: [ filesystem referenceTo: (filesystem resolve: path) ]]Class FileReference >> renameTo: newBasename[| destinationPath |destinationPath := self fileSystem rename: self to: self parent / newBasename.destinationPath ifNotNil: [ self setFileSystem: filesystem path: destinationPath ].^ self]Class FileReference >> hasChildren[	"Return whether the receiver has any children."	"FileSystem workingDirectory hasChildren"^ filesystem hasChildren: path]Class FileReference >> hasFiles[	"Return whether the receiver has children that are files."	"FileSystem workingDirectory hasFiles"^ filesystem hasFiles: path]Class FileReference >> contains: anObject[^ anObject isContainedBy: self]Class FileReference >> isReadable[^ filesystem isReadable: path]Class FileReference >> size[^ filesystem size: path]Class FileReference >> resolve: anObject[^ anObject asResolvedBy: self]Class FileReference >> exists[^ filesystem exists: path]Class FileReference >> ensureDirectory[	"Create if necessary a directory for the receiver."filesystem ensureDirectory: path]Class FileReference >> resolvePath: anObject[^ self withPath: (path resolve: anObject)]Class FileReference >> isDirectory[^ filesystem isDirectory: path]Class FileReference >> fileSystem[	"Return the filesystem to which the receiver belong."^ filesystem]Class FileReference >> mimeTypes[	"Return the possible mime types for the given path."^ filesystem mimeTypesAt: path]Class FileReference >> path[	"Return the path internal representation that denotes the receiver in the context of its filesystem. "^ path]Class FileReference >> printOn: aStream[filesystem forReferencePrintOn: aStream.filesystem printPath: path on: aStream]Class FileReference >> = other[^ self species = other species and: [ self path = other path and: [ self fileSystem = other fileSystem ] ]]Class FileReference >> isRoot[^ path isRoot]Class FileReference >> setFileSystem: aFilesystem path: aPath[filesystem := aFilesystem.path := aPath]Class FileReference >> hasDirectories[	"Return whether the receiver has children that are directories."	"FileSystem workingDirectory hasDirectories"^ filesystem hasDirectories: path]Class FileReference >> fullPath[^ self path]Class FileReference >> containsReference: aReference[^ aReference fileSystem = filesystem and: [ path contains: aReference path ]]Class FileReference >> isFile[^ filesystem isFile: path]Class FileReference >> isRelative[^ path isRelative]Class FileReference >> isWritable[^ filesystem isWritable: path]Class FileReference >> fullName[	"Return the full path name of the receiver."^ filesystem stringFromPath: (filesystem resolve: path)]Class FileReference >> resolve[^ self]Class FileReference >> nextVersion[	"Assumes a file name includes a version number encoded as '.' followed by digits 	preceding the file extension.  Increment the version number and answer the new file name.	If a version number is not found, return just the file"| parent version versionNumbers nameWithoutExtension |self exists	ifFalse: [ ^ self ].parent := self parent.nameWithoutExtension := self basename copyUpTo: $..versionNumbers := parent files	select: [ :f | f basename beginsWith: nameWithoutExtension ]	thenCollect: [ :f | Number squeezeNumberOutOfString: f basename ifFail: [ 0 ] ].versionNumbers ifEmpty: [ ^ self ].version := versionNumbers max + 1.^ parent / (nameWithoutExtension , '.' , version asString) , self extension]Class FileReference >> copyTo: aReference[self isDirectory	ifTrue: [ aReference ensureDirectory ]	ifFalse: [ 		filesystem = aReference fileSystem			ifTrue: [ filesystem copy: path to: aReference path ]			ifFalse: [ filesystem copy: path toReference: aReference ] ]]Class FileReference >> moveTo: aReference[| result |result := self fileSystem rename: self path to: aReference path.result ifNotNil: [ self setFileSystem: filesystem path: aReference path ]]Class FileReference >> modificationTime[^ filesystem modificationTime: self path]Class FileReference >> openWritable: aBoolean[^ filesystem open: path writable: aBoolean]Class FileReference >> isAbsolute[^ path isAbsolute]Class FileReference >> hash[^ path hash bitXor: filesystem hash]Class FileReference >> pathString[	"Return the full path name of the receiver."^ filesystem stringFromPath: (filesystem resolve: path)]Class FileReference >> readStream[^ filesystem readStreamOn: self path]Class FileReference >> pathName[self deprecated: 'Use fullName instead' on: 'StephaneDucasse 6/22/2012 19:00' in: #Pharo20.^ self fullName]Class FileReference >> resolveReference: aReference[^ (filesystem = aReference fileSystem or: [ aReference isRelative ])	ifTrue: [ filesystem referenceTo: (path resolvePath: aReference path) ]	ifFalse: [ aReference ]]Class FileReference >> permissions[^ filesystem permissions: self path]Class FileReference >> entries[	"Return the entries (meta data - file description) of the direct children of the receiver"^ self fileSystem entriesAt: self path]Class FileReference >> macTypeAndCreator[| results typeString creatorString |"get the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. Does nothing on other platforms (where the underlying primitive is a noop).""FileDirectory default getMacFileNamed: 'foo'"self flag: 'TODO'	"	typeString := ByteArray new: 4 withAll: ($? asInteger). #[63 63 63 63]	creatorString := ByteArray new: 4 withAll: ($? asInteger).	[self primGetMacFileNamed: (self fullNameFor: fileName) asVmPathName		type: typeString		creator: creatorString.] ensure: 		[typeString := typeString asString. 		creatorString := creatorString asString].	results := Array with: typeString convertFromSystemString with: creatorString convertFromSystemString.	^results"]Class FileReference >> deleteIfAbsent: aBlock[self exists	ifTrue: [ self delete ]	ifFalse: aBlock]Class FileReference >> createDirectory[filesystem createDirectory: path]Class FileReference >> resolveString: aString[| thePath |thePath := filesystem pathFromString: aString.^ filesystem referenceTo: (path resolve: thePath)]Class FileReference >> writeStream[^ filesystem writeStreamOn: self path]Class FileReference >> asFileReference[^ self]Class FileReference >> creationTime[^ filesystem creationTime: self path]Class FileReference >> setMacType: aTypeString creator: aCreatorString[self flag: 'TODO'	" 	self primSetMacFileNamed: (self fullNameFor: fileName) asVmPathName		type: typeString convertToSystemString		creator: creatorString convertToSystemString."]Class FileReference >> copyWithPath: newPath[^ filesystem referenceTo: newPath]Class FileReference >> entry[	"Return the entry (meta data) describing the receiver."^ filesystem entryAt: path]Metaclass	name: #FileReference;	instanceVariables: #().Metaclass FileReference >> fileSystem: aFilesystem path: aPath[^ self new setFileSystem: aFilesystem path: aPath]Metaclass FileReference >> / aString[	"Answer a reference to the argument resolved against the root of the current disk filesystem."^ FileSystem disk / aString]