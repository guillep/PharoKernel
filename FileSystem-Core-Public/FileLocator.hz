Class
	name: #FileLocator;
	superclass: #ClassAbstractFileReference;
	instanceSpecification: #(#pointers #words );
	instanceVariables: #(#origin #path );
	classVariables: #(#Resolver );
	package: #'FileSystem-Core-Public'.

Class FileLocator >> = other
[
^ self species = other species and: [ origin = other origin and: [ path = other path ] ]
]

Class FileLocator >> asAbsolute
[
^ self
]

Class FileLocator >> asFileReference
[
^ self resolve
]

Class FileLocator >> copyWithPath: newPath
[
^ self class origin: origin path: newPath
]

Class FileLocator >> doesNotUnderstand: aMessage
[
	"Redirect message to the resolved version of this FileLocator.	If FileReference won't understand the message send a normal DNU."
| resolved |resolved := self resolve.(resolved respondsTo: aMessage selector)	ifTrue: [ ^ resolved perform: aMessage selector withArguments: aMessage arguments ].^ super doesNotUnderstand: aMessage
]

Class FileLocator >> fullPath
[
^ self resolve path
]

Class FileLocator >> hash
[
^ origin hash bitXor: path hash
]

Class FileLocator >> initializeWithOrigin: aSymbol path: aPath
[
self initialize.origin := aSymbol.path := aPath
]

Class FileLocator >> isAbsolute
[
^ true
]

Class FileLocator >> isRelative
[
^ false
]

Class FileLocator >> origin
[
^ origin
]

Class FileLocator >> path
[
^ path
]

Class FileLocator >> printOn: aStream
[
| fs |aStream	nextPut: ${;	nextPutAll: origin;	nextPut: $}.path isWorkingDirectory	ifTrue: [ ^ self ].fs := self fileSystem.aStream nextPut: fs delimiter.fs printPath: path on: aStream
]

Class FileLocator >> readStream
[
^ self resolve readStream
]

Class FileLocator >> renameTo: newBasename
[
| result |result := self resolve renameTo: newBasename.path size > 0	ifTrue: [ path basename: newBasename ]	ifFalse: [ path := result path ]
]

Class FileLocator >> resolve
[
^ (Resolver resolve: origin) resolve: path
]

Class FileLocator >> resolveString: aString
[
| filesystem thePath |filesystem := (Resolver resolve: origin) fileSystem.thePath := filesystem pathFromString: aString.^ self withPath: (path resolvePath: thePath)
]

Class FileLocator >> writeStream
[
^ self resolve writeStream
]

Metaclass
	name: #FileLocator;
	instanceVariables: #().

Metaclass FileLocator >> A
[
^ self driveNamed: #A
]

Metaclass FileLocator >> B
[
^ self driveNamed: #B
]

Metaclass FileLocator >> C
[
^ self driveNamed: #C
]

Metaclass FileLocator >> D
[
^ self driveNamed: #D
]

Metaclass FileLocator >> E
[
^ self driveNamed: #E
]

Metaclass FileLocator >> F
[
^ self driveNamed: #F
]

Metaclass FileLocator >> G
[
^ self driveNamed: #G
]

Metaclass FileLocator >> H
[
^ self driveNamed: #H
]

Metaclass FileLocator >> I
[
^ self driveNamed: #I
]

Metaclass FileLocator >> J
[
^ self driveNamed: #J
]

Metaclass FileLocator >> K
[
^ self driveNamed: #K
]

Metaclass FileLocator >> L
[
^ self driveNamed: #L
]

Metaclass FileLocator >> M
[
^ self driveNamed: #M
]

Metaclass FileLocator >> N
[
^ self driveNamed: #N
]

Metaclass FileLocator >> O
[
^ self driveNamed: #O
]

Metaclass FileLocator >> P
[
^ self driveNamed: #P
]

Metaclass FileLocator >> Q
[
^ self driveNamed: #Q
]

Metaclass FileLocator >> R
[
^ self driveNamed: #R
]

Metaclass FileLocator >> S
[
^ self driveNamed: #S
]

Metaclass FileLocator >> T
[
^ self driveNamed: #T
]

Metaclass FileLocator >> U
[
^ self driveNamed: #U
]

Metaclass FileLocator >> V
[
^ self driveNamed: #V
]

Metaclass FileLocator >> W
[
^ self driveNamed: #W
]

Metaclass FileLocator >> X
[
^ self driveNamed: #X
]

Metaclass FileLocator >> Y
[
^ self driveNamed: #Y
]

Metaclass FileLocator >> Z
[
^ self driveNamed: #Z
]

Metaclass FileLocator >> addResolver: aResolver
[
Resolver addResolver: aResolver
]

Metaclass FileLocator >> changes
[
^ self origin: #changes
]

Metaclass FileLocator >> cwd
[
^ self workingDirectory
]

Metaclass FileLocator >> desktop
[
^ self origin: #desktop
]

Metaclass FileLocator >> documents
[
^ self origin: #documents
]

Metaclass FileLocator >> driveNamed: driveName
[
^ FileReference fileSystem: FileSystem disk path: Path / (driveName , ':')
]

Metaclass FileLocator >> flushCaches
[
Resolver flushCaches
]

Metaclass FileLocator >> home
[
^ self origin: #home
]

Metaclass FileLocator >> image
[
^ self origin: #image
]

Metaclass FileLocator >> imageDirectory
[
^ self origin: #imageDirectory
]

Metaclass FileLocator >> initialize
[
Smalltalk addToStartUpList: self.self startUp: true
]

Metaclass FileLocator >> origin: aSymbol
[
^ self origin: aSymbol path: Path workingDirectory
]

Metaclass FileLocator >> origin: aSymbol path: aPath
[
^ self basicNew initializeWithOrigin: aSymbol path: aPath
]

Metaclass FileLocator >> preferences
[
^ self origin: #preferences
]

Metaclass FileLocator >> root
[
^ FileSystem disk root
]

Metaclass FileLocator >> startUp: resuming
[
resuming	ifFalse: [ ^ self ].Resolver := InteractiveResolver new.Resolver addResolver: SystemResolver new.Resolver addResolver: PlatformResolver forCurrentPlatform
]

Metaclass FileLocator >> supportedOrigins
[
| origins current |origins := IdentitySet new.current := Resolver.[ current notNil ]	whileTrue: [ 		origins addAll: current supportedOrigins.		current := current next ].^ origins
]

Metaclass FileLocator >> vmBinary
[
^ self origin: #vmBinary
]

Metaclass FileLocator >> vmDirectory
[
^ self origin: #vmDirectory
]

Metaclass FileLocator >> workingDirectory
[
^ FileSystem disk referenceTo: RelativePath new
]

