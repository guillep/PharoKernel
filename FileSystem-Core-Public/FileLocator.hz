Class	name: #FileLocator;	superclass: #ClassAbstractFileReference;	instanceSpecification: #(#pointers #words );	instanceVariables: #(#origin #path );	classVariables: #(#Resolver );	package: #'FileSystem-Core-Public'.Class FileLocator >> renameTo: newBasename[| result |result := self resolve renameTo: newBasename.path size > 0	ifTrue: [ path basename: newBasename ]	ifFalse: [ path := result path ]]Class FileLocator >> asAbsolute[^ self]Class FileLocator >> hash[^ origin hash bitXor: path hash]Class FileLocator >> isAbsolute[^ true]Class FileLocator >> fullPath[^ self resolve path]Class FileLocator >> printOn: aStream[| fs |aStream	nextPut: ${;	nextPutAll: origin;	nextPut: $}.path isWorkingDirectory	ifTrue: [ ^ self ].fs := self fileSystem.aStream nextPut: fs delimiter.fs printPath: path on: aStream]Class FileLocator >> asFileReference[^ self resolve]Class FileLocator >> readStream[^ self resolve readStream]Class FileLocator >> path[^ path]Class FileLocator >> doesNotUnderstand: aMessage[	"Redirect message to the resolved version of this FileLocator.	If FileReference won't understand the message send a normal DNU."| resolved |resolved := self resolve.(resolved respondsTo: aMessage selector)	ifTrue: [ ^ resolved perform: aMessage selector withArguments: aMessage arguments ].^ super doesNotUnderstand: aMessage]Class FileLocator >> resolveString: aString[| filesystem thePath |filesystem := (Resolver resolve: origin) fileSystem.thePath := filesystem pathFromString: aString.^ self withPath: (path resolvePath: thePath)]Class FileLocator >> writeStream[^ self resolve writeStream]Class FileLocator >> resolve[^ (Resolver resolve: origin) resolve: path]Class FileLocator >> = other[^ self species = other species and: [ origin = other origin and: [ path = other path ] ]]Class FileLocator >> copyWithPath: newPath[^ self class origin: origin path: newPath]Class FileLocator >> initializeWithOrigin: aSymbol path: aPath[self initialize.origin := aSymbol.path := aPath]Class FileLocator >> origin[^ origin]Class FileLocator >> isRelative[^ false]Metaclass	name: #FileLocator;	instanceVariables: #().Metaclass FileLocator >> desktop[^ self origin: #desktop]Metaclass FileLocator >> I[^ self driveNamed: #I]Metaclass FileLocator >> initialize[Smalltalk addToStartUpList: self.self startUp: true]Metaclass FileLocator >> preferences[^ self origin: #preferences]Metaclass FileLocator >> J[^ self driveNamed: #J]Metaclass FileLocator >> K[^ self driveNamed: #K]Metaclass FileLocator >> documents[^ self origin: #documents]Metaclass FileLocator >> L[^ self driveNamed: #L]Metaclass FileLocator >> vmDirectory[^ self origin: #vmDirectory]Metaclass FileLocator >> M[^ self driveNamed: #M]Metaclass FileLocator >> startUp: resuming[resuming	ifFalse: [ ^ self ].Resolver := InteractiveResolver new.Resolver addResolver: SystemResolver new.Resolver addResolver: PlatformResolver forCurrentPlatform]Metaclass FileLocator >> origin: aSymbol[^ self origin: aSymbol path: Path workingDirectory]Metaclass FileLocator >> N[^ self driveNamed: #N]Metaclass FileLocator >> O[^ self driveNamed: #O]Metaclass FileLocator >> P[^ self driveNamed: #P]Metaclass FileLocator >> Q[^ self driveNamed: #Q]Metaclass FileLocator >> vmBinary[^ self origin: #vmBinary]Metaclass FileLocator >> R[^ self driveNamed: #R]Metaclass FileLocator >> imageDirectory[^ self origin: #imageDirectory]Metaclass FileLocator >> root[^ FileSystem disk root]Metaclass FileLocator >> S[^ self driveNamed: #S]Metaclass FileLocator >> T[^ self driveNamed: #T]Metaclass FileLocator >> addResolver: aResolver[Resolver addResolver: aResolver]Metaclass FileLocator >> A[^ self driveNamed: #A]Metaclass FileLocator >> cwd[^ self workingDirectory]Metaclass FileLocator >> U[^ self driveNamed: #U]Metaclass FileLocator >> B[^ self driveNamed: #B]Metaclass FileLocator >> origin: aSymbol path: aPath[^ self basicNew initializeWithOrigin: aSymbol path: aPath]Metaclass FileLocator >> V[^ self driveNamed: #V]Metaclass FileLocator >> changes[^ self origin: #changes]Metaclass FileLocator >> supportedOrigins[| origins current |origins := IdentitySet new.current := Resolver.[ current notNil ]	whileTrue: [ 		origins addAll: current supportedOrigins.		current := current next ].^ origins]Metaclass FileLocator >> C[^ self driveNamed: #C]Metaclass FileLocator >> W[^ self driveNamed: #W]Metaclass FileLocator >> home[^ self origin: #home]Metaclass FileLocator >> D[^ self driveNamed: #D]Metaclass FileLocator >> X[^ self driveNamed: #X]Metaclass FileLocator >> E[^ self driveNamed: #E]Metaclass FileLocator >> workingDirectory[^ FileSystem disk referenceTo: RelativePath new]Metaclass FileLocator >> Y[^ self driveNamed: #Y]Metaclass FileLocator >> F[^ self driveNamed: #F]Metaclass FileLocator >> image[^ self origin: #image]Metaclass FileLocator >> flushCaches[Resolver flushCaches]Metaclass FileLocator >> Z[^ self driveNamed: #Z]Metaclass FileLocator >> G[^ self driveNamed: #G]Metaclass FileLocator >> driveNamed: driveName[^ FileReference fileSystem: FileSystem disk path: Path / (driveName , ':')]Metaclass FileLocator >> H[^ self driveNamed: #H]